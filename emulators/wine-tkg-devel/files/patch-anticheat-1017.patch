diff -ruN --show-c-function --no-dereference configure configure
--- configure	2025-09-06 20:10:37.111901118 -0700
+++ configure	2025-09-06 20:33:49.874671852 -0700
@@ -1669,6 +1669,7 @@ enable_po
 enable_arp
 enable_aspnet_regiis
 enable_attrib
+enable_belauncher
 enable_cabarc
 enable_cacls
 enable_certutil
@@ -20999,7 +21000,13 @@ then
 fi
 
 
-WINELOADER_PROGRAMS="wine"
+case "$HOST_ARCH,$PE_ARCHS" in
+  x86_64,i386) wine_binary="wine" ;;
+  x86_64,*) wine_binary="wine64" ;;
+  *) wine_binary="wine" ;;
+esac
+test "$wine_binary" = wine || as_fn_append CONFIGURE_TARGETS " loader/wine"
+WINELOADER_PROGRAMS="$wine_binary"
 
 
 case $host_os in
@@ -21013,7 +21020,8 @@ esac
 
 if test "$wine_use_preloader" = "yes"
 then
-  WINELOADER_PROGRAMS="$WINELOADER_PROGRAMS wine-preloader"
+  test "$wine_binary" = wine || as_fn_append CONFIGURE_TARGETS " loader/wine-preloader"
+  WINELOADER_PROGRAMS="$WINELOADER_PROGRAMS $wine_binary-preloader"
 
 printf "%s\n" "#define HAVE_WINE_PRELOADER 1" >>confdefs.h
 
@@ -23227,6 +23235,7 @@ wine_fn_config_makefile po enable_po
 wine_fn_config_makefile programs/arp enable_arp
 wine_fn_config_makefile programs/aspnet_regiis enable_aspnet_regiis
 wine_fn_config_makefile programs/attrib enable_attrib
+wine_fn_config_makefile programs/belauncher enable_belauncher
 wine_fn_config_makefile programs/cabarc enable_cabarc
 wine_fn_config_makefile programs/cacls enable_cacls
 wine_fn_config_makefile programs/certutil enable_certutil
diff -ruN --show-c-function --no-dereference configure.ac configure.ac
--- configure.ac	2025-09-06 20:10:37.092090901 -0700
+++ configure.ac	2025-09-06 20:33:49.856698274 -0700
@@ -2071,7 +2071,13 @@ fi
 
 dnl **** Platform-specific checks ****
 
-AC_SUBST(WINELOADER_PROGRAMS,"wine")
+case "$HOST_ARCH,$PE_ARCHS" in
+  x86_64,i386) wine_binary="wine" ;;
+  x86_64,*) wine_binary="wine64" ;;
+  *) wine_binary="wine" ;;
+esac
+test "$wine_binary" = wine || WINE_IGNORE_FILE(loader/wine)
+AC_SUBST(WINELOADER_PROGRAMS,"$wine_binary")
 
 case $host_os in
   linux*)
@@ -2084,7 +2090,8 @@ esac
 
 if test "$wine_use_preloader" = "yes"
 then
-  WINELOADER_PROGRAMS="$WINELOADER_PROGRAMS wine-preloader"
+  test "$wine_binary" = wine || WINE_IGNORE_FILE(loader/wine-preloader)
+  WINELOADER_PROGRAMS="$WINELOADER_PROGRAMS $wine_binary-preloader"
   AC_DEFINE(HAVE_WINE_PRELOADER, 1, [Define to 1 if the Wine preloader is being used.])
 fi
 
@@ -3503,6 +3510,7 @@ WINE_CONFIG_MAKEFILE(po)
 WINE_CONFIG_MAKEFILE(programs/arp)
 WINE_CONFIG_MAKEFILE(programs/aspnet_regiis)
 WINE_CONFIG_MAKEFILE(programs/attrib)
+WINE_CONFIG_MAKEFILE(programs/belauncher)
 WINE_CONFIG_MAKEFILE(programs/cabarc)
 WINE_CONFIG_MAKEFILE(programs/cacls)
 WINE_CONFIG_MAKEFILE(programs/certutil)
diff -ruN --show-c-function --no-dereference dlls/kernel32/kernel32.spec dlls/kernel32/kernel32.spec
--- dlls/kernel32/kernel32.spec	2025-09-06 20:10:25.242484784 -0700
+++ dlls/kernel32/kernel32.spec	2025-09-06 20:33:44.137733318 -0700
@@ -622,7 +622,7 @@
 @ stdcall -import GetConsoleProcessList(ptr long)
 @ stdcall -import GetConsoleScreenBufferInfo(long ptr)
 @ stdcall -import GetConsoleScreenBufferInfoEx(long ptr)
-# @ stub GetConsoleSelectionInfo
+@ stdcall -import GetConsoleSelectionInfo(ptr)
 @ stdcall -import GetConsoleTitleA(ptr long)
 @ stdcall -import GetConsoleTitleW(ptr long)
 @ stdcall -import GetConsoleWindow()
diff -ruN --show-c-function --no-dereference dlls/kernelbase/console.c dlls/kernelbase/console.c
--- dlls/kernelbase/console.c	2025-09-06 20:10:25.251669102 -0700
+++ dlls/kernelbase/console.c	2025-09-06 20:33:44.137929181 -0700
@@ -1067,6 +1067,14 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetConsole
 }
 
 
+BOOL WINAPI DECLSPEC_HOTPATCH GetConsoleSelectionInfo(CONSOLE_SELECTION_INFO *info)
+{
+    FIXME("stub (%p)\n", info);
+    info->dwFlags = CONSOLE_NO_SELECTION;
+    return TRUE;
+}
+
+
 /******************************************************************************
  *	GetConsoleTitleA   (kernelbase.@)
  */
diff -ruN --show-c-function --no-dereference dlls/kernelbase/kernelbase.spec dlls/kernelbase/kernelbase.spec
--- dlls/kernelbase/kernelbase.spec	2025-09-06 20:10:25.252485135 -0700
+++ dlls/kernelbase/kernelbase.spec	2025-09-06 20:33:44.138094235 -0700
@@ -476,6 +476,7 @@
 @ stdcall GetConsoleProcessList(ptr long)
 @ stdcall GetConsoleScreenBufferInfo(long ptr)
 @ stdcall GetConsoleScreenBufferInfoEx(long ptr)
+@ stdcall GetConsoleSelectionInfo(ptr)
 @ stdcall GetConsoleTitleA(ptr long)
 @ stdcall GetConsoleTitleW(ptr long)
 @ stdcall GetConsoleWindow()
diff -ruN --show-c-function --no-dereference dlls/kernelbase/process.c dlls/kernelbase/process.c
--- dlls/kernelbase/process.c	2025-09-06 20:10:25.252485135 -0700
+++ dlls/kernelbase/process.c	2025-09-06 20:33:44.151016959 -0700
@@ -26,6 +26,7 @@
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
+#include "winver.h"
 #include "wincontypes.h"
 #include "winternl.h"
 
@@ -502,6 +503,101 @@ done:
     return ret;
 }
 
+/* Returns TRUE if the product name of the app matches the parameter */
+static BOOL product_name_matches(const WCHAR *app_name, const char *match)
+{
+    WCHAR full_path[MAX_PATH];
+    DWORD *translation;
+    char *product_name;
+    char buf[100];
+    void *block;
+    UINT size;
+
+    if (!GetLongPathNameW( app_name, full_path, MAX_PATH )) lstrcpynW( full_path, app_name, MAX_PATH );
+    if (!GetFullPathNameW( full_path, MAX_PATH, full_path, NULL )) lstrcpynW( full_path, app_name, MAX_PATH );
+
+    size = GetFileVersionInfoSizeExW(0, full_path, NULL);
+    if (!size)
+        return FALSE;
+
+    block = HeapAlloc( GetProcessHeap(), 0, size );
+
+    if (!GetFileVersionInfoExW(0, full_path, 0, size, block))
+    {
+        HeapFree( GetProcessHeap(), 0, block );
+        return FALSE;
+    }
+
+    if (!VerQueryValueA(block, "\\VarFileInfo\\Translation", (void **) &translation, &size) || size != 4)
+    {
+        HeapFree( GetProcessHeap(), 0, block );
+        return FALSE;
+    }
+
+    sprintf(buf, "\\StringFileInfo\\%08lx\\ProductName", MAKELONG(HIWORD(*translation), LOWORD(*translation)));
+
+    if (!VerQueryValueA(block, buf, (void **) &product_name, &size))
+    {
+        HeapFree( GetProcessHeap(), 0, block );
+        return FALSE;
+    }
+
+    if (strcmp(product_name, match))
+    {
+        HeapFree( GetProcessHeap(), 0, block);
+        return FALSE;
+    }
+
+    HeapFree( GetProcessHeap(), 0, block );
+    return TRUE;
+}
+
+static int battleye_launcher_redirect_hack(const WCHAR *app_name, WCHAR *new_name, DWORD new_name_len, WCHAR **cmd_line)
+{
+    static const WCHAR belauncherW[] = L"c:\\windows\\system32\\belauncher.exe";
+    WCHAR *new_cmd_line;
+    WCHAR *p;
+
+    /* We detect the BattlEye launcher executable through the product name property, as the executable name varies */
+    if (!product_name_matches(app_name, "BattlEye Launcher"))
+        return 0;
+
+    TRACE("Detected launch of a BattlEye Launcher, redirecting to Proton version.\n");
+
+    if (new_name_len < wcslen(belauncherW) + 1)
+    {
+        WARN("Game executable path doesn't fit in buffer.\n");
+        return 0;
+    }
+
+    wcscpy(new_name, belauncherW);
+
+    /* find and replace executable name in command line, and add BE argument */
+    p = *cmd_line;
+    if (p[0] == '\"')
+        p++;
+
+    if (!wcsncmp(p, app_name, wcslen(app_name)))
+    {
+        new_cmd_line = HeapAlloc( GetProcessHeap(), 0, ( wcslen(*cmd_line) + wcslen(belauncherW) + 1 - wcslen(app_name) ) * sizeof(WCHAR) );
+
+        wcscpy(new_cmd_line, *cmd_line);
+        p = new_cmd_line;
+        if (p[0] == '\"')
+            p++;
+
+        memmove( p + wcslen(belauncherW), p + wcslen(app_name), (wcslen(p) - wcslen(belauncherW)) * sizeof(WCHAR) );
+        memcpy( p, belauncherW, wcslen(belauncherW) * sizeof(WCHAR) );
+
+        TRACE("old command line %s.\n", debugstr_w(*cmd_line));
+        TRACE("new command line %s.\n", debugstr_w(new_cmd_line));
+
+        *cmd_line = new_cmd_line;
+    }
+
+    return 1;
+}
+
 /**********************************************************************
  *           CreateProcessInternalW   (kernelbase.@)
  */
@@ -543,6 +639,14 @@ BOOL WINAPI DECLSPEC_HOTPATCH CreateProc
         app_name = name;
     }
 
+    p = tidy_cmdline;
+    if (battleye_launcher_redirect_hack( app_name, name, ARRAY_SIZE(name), &tidy_cmdline ))
+    {
+        app_name = name;
+        if (p != tidy_cmdline && p != cmd_line)
+            HeapFree( GetProcessHeap(), 0, p );
+    }
+
     /* Warn if unsupported features are used */
 
     if (flags & (IDLE_PRIORITY_CLASS | HIGH_PRIORITY_CLASS | REALTIME_PRIORITY_CLASS |
@@ -568,6 +672,32 @@ BOOL WINAPI DECLSPEC_HOTPATCH CreateProc
         goto done;
     }
 
+    /* Set PROTON_EAC_LAUNCHER_PROCESS when launching the EAC launcher to let ntdll know to load the native EAC client library.
+      - We don't do this check in ntdll itself because it's harder to get the product name there
+      - we don't overwrite WINEDLLOVERRIDES because it's fetched from the unix environment */
+    {
+        UNICODE_STRING is_eac_launcher_us;
+        UNICODE_STRING one_us;
+
+        WCHAR *new_env = RtlAllocateHeap( GetProcessHeap(), 0, params->EnvironmentSize );
+        memcpy(new_env, params->Environment, params->EnvironmentSize);
+
+        RtlDestroyProcessParameters( params );
+
+        RtlInitUnicodeString( &is_eac_launcher_us, L"PROTON_EAC_LAUNCHER_PROCESS" );
+        RtlInitUnicodeString( &one_us, L"1" );
+        RtlSetEnvironmentVariable( &new_env, &is_eac_launcher_us, product_name_matches(app_name, "EasyAntiCheat Launcher") ? &one_us : NULL );
+
+        params = create_process_params( app_name, tidy_cmdline, cur_dir, new_env, flags | CREATE_UNICODE_ENVIRONMENT, startup_info );
+
+        RtlFreeHeap(GetProcessHeap(), 0, new_env);
+        if (!params)
+        {
+            status = STATUS_NO_MEMORY;
+            goto done;
+        }
+    }
+
     if (flags & (DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS))
     {
         if ((status = DbgUiConnectToDbg())) goto done;
diff -ruN --show-c-function --no-dereference dlls/ntdll/ntdll.spec dlls/ntdll/ntdll.spec
--- dlls/ntdll/ntdll.spec	2025-09-06 20:10:25.382489706 -0700
+++ dlls/ntdll/ntdll.spec	2025-09-06 20:33:44.147100054 -0700
@@ -1759,3 +1759,6 @@
 @ cdecl wine_get_version()
 @ cdecl wine_get_build_id()
 @ cdecl wine_get_host_version(ptr ptr)
+
+# Filesystem
+@ stdcall -syscall wine_nt_to_unix_file_name(ptr ptr ptr long)
diff -ruN --show-c-function --no-dereference dlls/ntdll/ntsyscalls.h dlls/ntdll/ntsyscalls.h
--- dlls/ntdll/ntsyscalls.h	2025-10-24 21:13:58.797858000 -0700
+++ dlls/ntdll/ntsyscalls.h	2025-10-24 21:28:51.966005000 -0700
@@ -264,7 +264,8 @@
     SYSCALL_ENTRY( 0x0104, NtWow64QueryInformationProcess64, 20 ) \
     SYSCALL_ENTRY( 0x0105, NtWow64ReadVirtualMemory64, 28 ) \
     SYSCALL_ENTRY( 0x0106, NtWow64WriteVirtualMemory64, 28 ) \
-    SYSCALL_ENTRY( 0x0107, __wine_needs_override_large_address_aware, 0 )
+    SYSCALL_ENTRY( 0x0107, wine_nt_to_unix_file_name, 16 ) \
+    SYSCALL_ENTRY( 0x0108, __wine_needs_override_large_address_aware, 0 )
 #ifdef _WIN64
 #define ALL_SYSCALLS \
     SYSCALL_ENTRY( 0x0000, NtAccessCheck, 64 ) \
@@ -524,7 +525,8 @@
     SYSCALL_ENTRY( 0x00fe, NtWaitForAlertByThreadId, 16 ) \
     SYSCALL_ENTRY( 0x00ff, NtWaitForDebugEvent, 32 ) \
     SYSCALL_ENTRY( 0x0100, NtWaitForKeyedEvent, 32 ) \
-    SYSCALL_ENTRY( 0x0101, __wine_needs_override_large_address_aware, 0 )
+    SYSCALL_ENTRY( 0x0101, wine_nt_to_unix_file_name, 32 ) \
+    SYSCALL_ENTRY( 0x0102, __wine_needs_override_large_address_aware, 0 )
 #else
 #define ALL_SYSCALLS ALL_SYSCALLS32
 #endif
diff -ruN --show-c-function --no-dereference dlls/ntdll/signal_arm64ec.c dlls/ntdll/signal_arm64ec.c
--- dlls/ntdll/signal_arm64ec.c	2025-09-06 20:10:25.384489777 -0700
+++ dlls/ntdll/signal_arm64ec.c	2025-09-06 20:33:44.147426706 -0700
@@ -597,6 +597,7 @@ DEFINE_SYSCALL(NtWriteFileGather, (HANDL
 DEFINE_SYSCALL(NtWriteRequestData, (HANDLE handle, LPC_MESSAGE *request, ULONG id, void *buffer, ULONG len, ULONG *retlen))
 DEFINE_SYSCALL(NtWriteVirtualMemory, (HANDLE process, void *addr, const void *buffer, SIZE_T size, SIZE_T *bytes_written))
 DEFINE_SYSCALL(NtYieldExecution, (void))
+DEFINE_SYSCALL(wine_nt_to_unix_file_name, (const OBJECT_ATTRIBUTES *attr, char *nameA, ULONG *size, UINT disposition))
 
 NTSTATUS SYSCALL_API NtAllocateVirtualMemory( HANDLE process, PVOID *ret, ULONG_PTR zero_bits,
                                               SIZE_T *size_ptr, ULONG type, ULONG protect )
diff -ruN --show-c-function --no-dereference dlls/ntdll/unix/file.c dlls/ntdll/unix/file.c
--- dlls/ntdll/unix/file.c	2025-09-06 20:10:25.390489988 -0700
+++ dlls/ntdll/unix/file.c	2025-09-06 20:33:44.147843820 -0700
@@ -3748,6 +3748,51 @@ static NTSTATUS nt_to_unix_file_name( co
 }
 
 
+/******************************************************************************
+ *           wine_nt_to_unix_file_name
+ *
+ * Convert a file name from NT namespace to Unix namespace.
+ *
+ * If disposition is not FILE_OPEN or FILE_OVERWRITE, the last path
+ * element doesn't have to exist; in that case STATUS_NO_SUCH_FILE is
+ * returned, but the unix name is still filled in properly.
+ */
+NTSTATUS WINAPI wine_nt_to_unix_file_name( const OBJECT_ATTRIBUTES *attr, char *nameA, ULONG *size,
+                                          UINT disposition )
+{
+    char *buffer = NULL;
+    NTSTATUS status;
+    UNICODE_STRING nt_name;
+    OBJECT_ATTRIBUTES new_attr = *attr;
+
+    status = get_nt_and_unix_names( &new_attr, &nt_name, &buffer, disposition );
+    if (!status || status == STATUS_NO_SUCH_FILE)
+    {
+        struct stat st1, st2;
+        char *name = buffer;
+
+        /* remove dosdevices prefix for z: drive if it points to the Unix root */
+        if (!strncmp( buffer, config_dir, strlen(config_dir) ) &&
+            !strncmp( buffer + strlen(config_dir), "/dosdevices/z:/", 15 ))
+        {
+            char *p = buffer + strlen(config_dir) + 14;
+            *p = 0;
+            if (!stat( buffer, &st1 ) && !stat( "/", &st2 ) &&
+                st1.st_dev == st2.st_dev && st1.st_ino == st2.st_ino)
+                name = p;
+            *p = '/';
+        }
+
+        if (*size > strlen(name)) strcpy( nameA, name );
+        else status = STATUS_BUFFER_TOO_SMALL;
+        *size = strlen(name) + 1;
+    }
+    free( buffer );
+    free( nt_name.Buffer );
+    return status;
+}
+
+
 /******************************************************************
  *		collapse_path
  *
diff -ruN --show-c-function --no-dereference dlls/ntdll/unix/loader.c dlls/ntdll/unix/loader.c
--- dlls/ntdll/unix/loader.c	2025-09-06 20:10:25.390489988 -0700
+++ dlls/ntdll/unix/loader.c	2025-09-06 20:33:44.173080007 -0700
@@ -383,11 +383,17 @@ static WORD get_alt_machine( WORD machin
 
 static void set_dll_path(void)
 {
-    char *p, *path = getenv( "WINEDLLPATH" );
+    char *p, *path = getenv( "WINEDLLPATH" ), *be_runtime = getenv( "PROTON_BATTLEYE_RUNTIME" ), *eac_runtime = getenv( "PROTON_EAC_RUNTIME" );
     int i, count = 0;
 
     if (path) for (p = path, count = 1; *p; p++) if (*p == ':') count++;
 
+    if (be_runtime)
+        count += 2;
+
+    if (eac_runtime)
+        count += 2;
+
     dll_paths = malloc( (count + 2) * sizeof(*dll_paths) );
     count = 0;
 
@@ -400,6 +406,42 @@ static void set_dll_path(void)
         free( path );
     }
 
+    if (be_runtime)
+    {
+        const char lib32[] = "/v1/lib/wine/";
+        const char lib64[] = "/v1/lib64/wine/";
+
+        p = malloc( strlen(be_runtime) + strlen(lib32) + 1 );
+        strcpy(p, be_runtime);
+        strcat(p, lib32);
+
+        dll_paths[count++] = p;
+
+        p = malloc( strlen(be_runtime) + strlen(lib64) + 1 );
+        strcpy(p, be_runtime);
+        strcat(p, lib64);
+
+        dll_paths[count++] = p;
+    }
+
+    if (eac_runtime)
+    {
+        const char lib32[] = "/v2/lib32/";
+        const char lib64[] = "/v2/lib64/";
+
+        p = malloc( strlen(eac_runtime) + strlen(lib32) + 1 );
+        strcpy(p, eac_runtime);
+        strcat(p, lib32);
+
+        dll_paths[count++] = p;
+
+        p = malloc( strlen(eac_runtime) + strlen(lib64) + 1 );
+        strcpy(p, eac_runtime);
+        strcat(p, lib64);
+
+        dll_paths[count++] = p;
+    }
+
     for (i = 0; i < count; i++) dll_path_maxlen = max( dll_path_maxlen, strlen(dll_paths[i]) );
     dll_paths[count] = NULL;
 }
@@ -478,7 +520,11 @@ static void init_paths(void)
 
     if ((build_dir = remove_tail( ntdll_dir, "/dlls/ntdll" )))
     {
+#ifdef _WIN64
+        wineloader = build_path( build_dir, "loader/wine64" );
+#else
         wineloader = build_path( build_dir, "loader/wine" );
+#endif
         alt_build_dir = realpath_dirname( build_path( build_dir, "loader-wow64" ));
     }
     else
@@ -486,7 +532,11 @@ static void init_paths(void)
         if (!(dll_dir = remove_tail( ntdll_dir, get_so_dir(current_machine) ))) dll_dir = ntdll_dir;
         bin_dir = build_relative_path( dll_dir, LIBDIR "/wine", BINDIR );
         data_dir = build_relative_path( dll_dir, LIBDIR "/wine", DATADIR "/wine" );
+#ifdef _WIN64
+        wineloader = build_path( ntdll_dir, "wine64" );
+#else
         wineloader = build_path( ntdll_dir, "wine" );
+#endif
     }
 
     set_dll_path();
@@ -516,10 +566,17 @@ char *get_alternate_wineloader( WORD mac
         machine = get_alt_machine( current_machine );
     }
 
+#ifdef _WIN64
     if (!build_dir)
         asprintf( &ret, "%s%s/wine", dll_dir, get_so_dir( machine ));
     else if (alt_build_dir)
         asprintf( &ret, "%s/loader/wine", alt_build_dir );
+#else
+    if (!build_dir)
+        asprintf( &ret, "%s%s/wine64", dll_dir, get_so_dir( machine ));
+    else if (alt_build_dir)
+        asprintf( &ret, "%s/loader/wine64", alt_build_dir );
+#endif
 
     return ret;
 }
diff -ruN --show-c-function --no-dereference dlls/ntdll/unix/loadorder.c dlls/ntdll/unix/loadorder.c
--- dlls/ntdll/unix/loadorder.c	2025-09-06 20:10:25.390489988 -0700
+++ dlls/ntdll/unix/loadorder.c	2025-09-06 20:33:44.151488185 -0700
@@ -59,6 +59,7 @@ static HANDLE std_key;
 static HANDLE app_key;
 static BOOL init_done;
 static BOOL main_exe_loaded;
+static BOOL eac_launcher_process;
 
 
 /***************************************************************************
@@ -362,11 +363,24 @@ static enum loadorder get_load_order_val
  */
 void set_load_order_app_name( const WCHAR *app_name )
 {
+    static const WCHAR eac_launcherW[] = {'P','R','O','T','O','N','_','E','A','C','_','L','A','U','N','C','H','E','R','_','P','R','O','C','E','S','S',0};
     const WCHAR *p;
 
     if ((p = wcsrchr( app_name, '\\' ))) app_name = p + 1;
     app_key = open_app_key( app_name );
     main_exe_loaded = TRUE;
+
+    p = NtCurrentTeb()->Peb->ProcessParameters->Environment;
+    while(*p)
+    {
+        if (!wcsncmp( p, eac_launcherW, ARRAY_SIZE(eac_launcherW) - 1 ))
+        {
+            eac_launcher_process = TRUE;
+            break;
+        }
+
+        p += wcslen(p) + 1;
+    }
 }
 
 
@@ -378,6 +392,11 @@ void set_load_order_app_name( const WCHA
  */
 enum loadorder get_load_order( const UNICODE_STRING *nt_name )
 {
+    static const WCHAR easyanticheat_x86W[] = {'e','a','s','y','a','n','t','i','c','h','e','a','t','_','x','8','6','.','d','l','l',0};
+    static const WCHAR easyanticheat_x64W[] = {'e','a','s','y','a','n','t','i','c','h','e','a','t','_','x','6','4','.','d','l','l',0};
+    static const WCHAR easyanticheatW[] = {'e','a','s','y','a','n','t','i','c','h','e','a','t','.','d','l','l',0};
+    static const WCHAR soW[] = {'s','o',0};
+
     static const WCHAR prefixW[] = {'\\','?','?','\\'};
     enum loadorder ret = LO_INVALID;
     const WCHAR *path = nt_name->Buffer;
@@ -391,6 +410,50 @@ enum loadorder get_load_order( const UNI
 
     TRACE("looking for %s\n", debugstr_w(path));
 
+    /* HACK: special logic for easyanticheat bridge: only load the bridge (builtin) if there exists a native version of the library next to the windows version */
+    basename = get_basename((WCHAR *)path);
+    if (!wcsicmp(basename, easyanticheat_x86W) || !wcsicmp(basename, easyanticheat_x64W) || !wcsicmp(basename, easyanticheatW))
+    {
+        UNICODE_STRING eac_unix_name;
+        OBJECT_ATTRIBUTES attr;
+        NTSTATUS status;
+        ULONG size = 256;
+        char *buffer;
+
+        if (eac_launcher_process)
+        {
+            ret = LO_NATIVE;
+            TRACE("got hardcoded %s for %s, as this is the EAC launcher process\n", debugstr_loadorder(ret), debugstr_w(path) );
+            return ret;
+        }
+
+        len = wcslen(nt_name->Buffer);
+        eac_unix_name.Buffer = malloc( (len + 5) * sizeof(WCHAR) );
+        wcscpy(eac_unix_name.Buffer, nt_name->Buffer);
+
+        basename = get_basename(eac_unix_name.Buffer);
+        if (!wcsicmp(basename, easyanticheatW))
+            wcscpy(basename, easyanticheat_x64W);
+        wcscpy(&basename[18], soW);
+        eac_unix_name.Length = eac_unix_name.MaximumLength = wcslen(eac_unix_name.Buffer) * sizeof(WCHAR);
+
+        if (!(status = wine_nt_to_unix_file_name(&attr, buffer, &size, FILE_OPEN)))
+        {
+            free(buffer);
+            free(eac_unix_name.Buffer);
+            ret = LO_BUILTIN;
+            TRACE( "got hardcoded %s for %s, as the eac unix library is present\n", debugstr_loadorder(ret), debugstr_w(path) );
+            return ret;
+        }
+        else
+        {
+            ret = LO_NATIVE;
+            TRACE( "got hardcoded %s for %s, as the eac unix library (%s) is not present. status %x\n", debugstr_loadorder(ret), debugstr_w(path), debugstr_w(eac_unix_name.Buffer), (int)status );
+            free(eac_unix_name.Buffer);
+            return ret;
+        }
+    }
+
     /* Strip path information if the module resides in the system directory
      */
     if (!wcsnicmp( system_dir + 4, path, wcslen(system_dir) - 4 ))
diff -ruN --show-c-function --no-dereference dlls/sechost/service.c dlls/sechost/service.c
--- dlls/sechost/service.c	2025-09-06 20:10:25.445491922 -0700
+++ dlls/sechost/service.c	2025-09-06 20:33:44.141211548 -0700
@@ -312,6 +312,8 @@ SC_HANDLE WINAPI DECLSPEC_HOTPATCH OpenS
     SC_RPC_HANDLE handle = NULL;
     DWORD err;
 
+    char str[64];
+
     TRACE( "%p %s %#lx\n", manager, debugstr_w(name), access );
 
     if (!manager)
@@ -320,6 +322,14 @@ SC_HANDLE WINAPI DECLSPEC_HOTPATCH OpenS
         return NULL;
     }
 
+    /* HACK for ARK: Survivial Evolved checking the status of BEService to determine whether BE is enabled. */
+    if(GetEnvironmentVariableA("SteamGameId", str, sizeof(str)) && !strcmp(str, "346110") &&
+        !wcscmp(name, L"BEService"))
+    {
+        WARN("HACK: returning fake service handle for BEService.\n");
+        return (void *)0xdeadbeef;
+    }
+
     __TRY
     {
         err = svcctl_OpenServiceW( manager, name, access, &handle );
@@ -1107,6 +1117,8 @@ BOOL WINAPI DECLSPEC_HOTPATCH QueryServi
 {
     DWORD err;
 
+    char str[64];
+
     TRACE( "%p %d %p %ld %p\n", service, level, buffer, size, ret_size );
 
     if (level != SC_STATUS_PROCESS_INFO) return set_error( ERROR_INVALID_LEVEL );
@@ -1117,6 +1129,24 @@ BOOL WINAPI DECLSPEC_HOTPATCH QueryServi
         return set_error( ERROR_INSUFFICIENT_BUFFER );
     }
 
+    /* HACK for ARK: Survivial Evolved checking the status of BEService to determine whether BE is enabled. */
+    if(GetEnvironmentVariableA("SteamGameId", str, sizeof(str)) && !strcmp(str, "346110") &&
+        service == (void *)0xdeadbeef)
+    {
+        SERVICE_STATUS_PROCESS *status = (SERVICE_STATUS_PROCESS *)buffer;
+        WARN("HACK: returning fake data for BEService.\n");
+        status->dwServiceType = SERVICE_WIN32_OWN_PROCESS;
+        status->dwCurrentState = SERVICE_RUNNING;
+        status->dwControlsAccepted = SERVICE_ACCEPT_SHUTDOWN | SERVICE_ACCEPT_STOP;
+        status->dwWin32ExitCode = NO_ERROR;
+        status->dwServiceSpecificExitCode = 0;
+        status->dwCheckPoint = 0;
+        status->dwWaitHint = 0;
+        status->dwProcessId = 0xdeadbee0;
+        status->dwServiceFlags = 0;
+        return TRUE;
+    }
+
     __TRY
     {
         err = svcctl_QueryServiceStatusEx( service, level, buffer, size, ret_size );
diff -ruN --show-c-function --no-dereference dlls/wow64/file.c dlls/wow64/file.c
--- dlls/wow64/file.c	2025-09-06 20:10:25.576710873 -0700
+++ dlls/wow64/file.c	2025-09-06 20:33:44.148229003 -0700
@@ -955,3 +955,19 @@ NTSTATUS WINAPI wow64_NtWriteFileGather(
     put_iosb( io32, &io );
     return status;
 }
+
+
+/**********************************************************************
+ *           wow64_wine_nt_to_unix_file_name
+ */
+NTSTATUS WINAPI wow64_wine_nt_to_unix_file_name( UINT *args )
+{
+    OBJECT_ATTRIBUTES32 *attr32 = get_ptr( &args );
+    char *nameA = get_ptr( &args );
+    ULONG *size = get_ptr( &args );
+    UINT disposition = get_ulong( &args );
+
+    struct object_attr64 attr;
+
+    return wine_nt_to_unix_file_name( objattr_32to64_redirect( &attr, attr32 ), nameA, size, disposition );
+}
diff -ruN --show-c-function --no-dereference include/winternl.h include/winternl.h
--- include/winternl.h	2025-09-06 20:10:25.649499095 -0700
+++ include/winternl.h	2025-09-06 20:33:44.148514156 -0700
@@ -5214,6 +5214,11 @@ NTSYSAPI LONGLONG  WINAPI RtlLargeIntege
 NTSYSAPI NTSTATUS  WINAPI RtlLargeIntegerToChar(const ULONGLONG *,ULONG,ULONG,PCHAR);
 #endif
 
+/* Wine internal functions */
+
+NTSYSAPI NTSTATUS WINAPI wine_nt_to_unix_file_name( const OBJECT_ATTRIBUTES *attr, char *nameA, ULONG *size,
+                                                    UINT disposition );
+
 
 /***********************************************************************
  * Inline functions
diff -ruN --show-c-function --no-dereference loader/Makefile.in loader/Makefile.in
--- loader/Makefile.in	2025-09-06 20:10:25.740502295 -0700
+++ loader/Makefile.in	2025-09-06 20:33:44.173222158 -0700
@@ -19,3 +19,11 @@ wine_LDFLAGS = $(WINELOADER_LDFLAGS) $(L
 wine_preloader_OBJS = preloader.o preloader_mac.o
 wine_preloader_DEPS = $(WINELOADER_DEPENDS)
 wine_preloader_LDFLAGS = $(WINEPRELOADER_LDFLAGS)
+
+wine64_OBJS = main.o
+wine64_DEPS = $(WINELOADER_DEPENDS)
+wine64_LDFLAGS = $(WINELOADER_LDFLAGS) $(LDEXECFLAGS) $(PTHREAD_LIBS)
+
+wine64_preloader_OBJS = preloader.o preloader_mac.o
+wine64_preloader_DEPS = $(WINELOADER_DEPENDS)
+wine64_preloader_LDFLAGS = $(WINEPRELOADER_LDFLAGS)
diff -ruN --show-c-function --no-dereference programs/belauncher/main.c programs/belauncher/main.c
--- programs/belauncher/main.c	1969-12-31 16:00:00.000000000 -0800
+++ programs/belauncher/main.c	2025-09-06 20:33:44.141104093 -0700
@@ -0,0 +1,182 @@
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include <io.h>
+#include <shlwapi.h>
+#include <shellapi.h>
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(belauncher);
+
+int WINAPI wWinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPWSTR cmdline, int cmdshow)
+{
+    char *configs, *config, *arch_32_exe = NULL, *arch_64_exe = NULL, *game_exe = NULL, *be_arg = NULL;
+    WCHAR path[MAX_PATH], *p, config_path[MAX_PATH], game_exeW[MAX_PATH], **argvW;
+    LARGE_INTEGER launcher_cfg_size;
+    unsigned char battleye_status;
+    int game_exe_len, arg_len, path_len;
+    PROCESS_INFORMATION pi;
+    HANDLE launcher_cfg;
+    LPWSTR launch_cmd;
+    STARTUPINFOW si = {0};
+    int i, argc;
+    DWORD size;
+    BOOL wow64;
+
+    battleye_status = 0x3; /* Starting */
+    _write(1, &battleye_status, 1);
+
+    *path = 0;
+    if ((size = GetEnvironmentVariableW(L"PROTON_ORIG_LAUNCHER_NAME", path, ARRAY_SIZE(path))) && size <= ARRAY_SIZE(path))
+    {
+        WINE_TRACE("PROTON_ORIG_LAUNCHER_NAME %s.\n", wine_dbgstr_w(path));
+
+        for (p = path + wcslen(path); p != path; --p)
+            if (*p == '\\') break;
+        if (*p == '\\')
+            ++p;
+        *p = 0;
+    }
+
+    wcscpy(config_path, path);
+    wcscat(config_path, L"Battleye\\BELauncher.ini");
+    launcher_cfg = CreateFileW(config_path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+    if (launcher_cfg == INVALID_HANDLE_VALUE)
+    {
+        *path = 0;
+        launcher_cfg = CreateFileW(L"Battleye\\BELauncher.ini", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+    }
+    if (launcher_cfg == INVALID_HANDLE_VALUE)
+    {
+        WINE_ERR("BELauncher.ini not found.\n");
+        goto start_failed;
+    }
+
+    if(!GetFileSizeEx(launcher_cfg, &launcher_cfg_size) || launcher_cfg_size.u.HighPart)
+    {
+        CloseHandle(launcher_cfg);
+        goto start_failed;
+    }
+
+    configs = HeapAlloc( GetProcessHeap(), 0, launcher_cfg_size.u.LowPart);
+
+    if (!ReadFile(launcher_cfg, configs, launcher_cfg_size.u.LowPart, &size, NULL) || size != launcher_cfg_size.u.LowPart)
+    {
+        CloseHandle(launcher_cfg);
+        HeapFree( GetProcessHeap(), 0, configs );
+        goto start_failed;
+    }
+
+    CloseHandle(launcher_cfg);
+
+    config = configs;
+    do
+    {
+        if (!strncmp(config, "32BitExe=", 9))
+            arch_32_exe = config + 9;
+
+        if (!strncmp(config, "64BitExe=", 9))
+            arch_64_exe = config + 9;
+
+        if (!strncmp(config, "BEArg=", 6))
+            be_arg = config + 6;
+    }
+    while ((config = strchr(config, '\n')) && *(config++));
+
+    *game_exeW = 0;
+    game_exe_len = 0;
+
+    if ((argvW = CommandLineToArgvW(cmdline, &argc)))
+    {
+        for (i = 0; i < argc; ++i)
+        {
+            if (!wcscmp(argvW[i], L"-exe") && i < argc - 1)
+            {
+                wcscpy(game_exeW, argvW[i + 1]);
+                game_exe_len = wcslen(game_exeW);
+                break;
+            }
+        }
+    }
+
+    if (!*game_exeW)
+    {
+        if (arch_64_exe && (sizeof(void *) == 8 || (IsWow64Process(GetCurrentProcess(), &wow64) && wow64)))
+            game_exe = arch_64_exe;
+        else if (arch_32_exe)
+            game_exe = arch_32_exe;
+        else
+        {
+            HeapFree( GetProcessHeap(), 0, configs );
+            WINE_ERR("Failed to find game executable name from BattlEye config.\n");
+            goto start_failed;
+        }
+
+        if (strchr(game_exe, '\r'))
+            *(strchr(game_exe, '\r')) = 0;
+        if (strchr(game_exe, '\n'))
+            *(strchr(game_exe, '\n')) = 0;
+        game_exe_len = MultiByteToWideChar(CP_ACP, 0, game_exe, -1, game_exeW, ARRAY_SIZE(game_exeW));
+        if (!game_exe_len)
+        {
+            WINE_ERR("Failed to convert game_exe %s.\n", wine_dbgstr_a(game_exe));
+            goto start_failed;
+        }
+        --game_exe_len;
+    }
+
+    if (!be_arg) arg_len = 0;
+    else
+    {
+        if (strchr(be_arg, '\r'))
+            *(strchr(be_arg, '\r')) = 0;
+        if (strchr(be_arg, '\n'))
+            *(strchr(be_arg, '\n')) = 0;
+        arg_len = MultiByteToWideChar(CP_ACP, 0, be_arg, -1, NULL, 0) - 1;
+    }
+
+    WINE_TRACE("Launching game executable %s for BattlEye.\n", game_exe);
+    battleye_status = 0x9; /* Launching Game */
+    _write(1, &battleye_status, 1);
+
+    if (PathIsRelativeW(game_exeW))
+        path_len = wcslen(path);
+    else
+        path_len = 0;
+
+    launch_cmd = HeapAlloc(GetProcessHeap(), 0, (path_len + game_exe_len + 1 + wcslen(cmdline) + 1 + arg_len + 1) * sizeof(WCHAR));
+
+    memcpy(launch_cmd, path, path_len * sizeof(*path));
+
+    memcpy(launch_cmd + path_len, game_exeW, game_exe_len * sizeof(*launch_cmd));
+    launch_cmd[path_len + game_exe_len] = ' ';
+
+    wcscpy(launch_cmd + path_len + game_exe_len + 1, cmdline);
+    launch_cmd[path_len + game_exe_len + 1 + wcslen(cmdline)] = ' ';
+
+    if (!MultiByteToWideChar(CP_ACP, 0, be_arg, -1, launch_cmd + path_len + game_exe_len + 1 + wcslen(cmdline) + 1, arg_len + 1))
+        launch_cmd[path_len + game_exe_len + 1 + wcslen(cmdline)] = 0;
+
+    WINE_TRACE("game_exe %s, cmdline %s.\n", wine_dbgstr_w(game_exeW), wine_dbgstr_w(cmdline));
+    WINE_TRACE("path %s, be_arg %s.\n", wine_dbgstr_w(path), wine_dbgstr_a(be_arg));
+    WINE_TRACE("launch_cmd %s.\n", wine_dbgstr_w(launch_cmd));
+
+    if (!CreateProcessW(NULL, launch_cmd, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi))
+    {
+        WINE_ERR("CreateProcessW failed.\n");
+        battleye_status = 0xA; /* Launch Failed */
+        _write(1, &battleye_status, 1);
+        return GetLastError();
+    }
+    HeapFree( GetProcessHeap(), 0, launch_cmd );
+
+    WaitForSingleObject(pi.hProcess, INFINITE);
+    CloseHandle(pi.hProcess);
+    return 0;
+
+start_failed:
+    WINE_ERR("Failed.\n");
+    battleye_status = 0x4; /* Start Failed */
+    _write(1, &battleye_status, 1);
+    return 0;
+}
diff -ruN --show-c-function --no-dereference programs/belauncher/Makefile.in programs/belauncher/Makefile.in
--- programs/belauncher/Makefile.in	1969-12-31 16:00:00.000000000 -0800
+++ programs/belauncher/Makefile.in	2025-09-06 20:33:44.592299418 -0700
@@ -0,0 +1,7 @@
+MODULE    = belauncher.exe
+IMPORTS   = shlwapi shcore
+
+EXTRADLLFLAGS = -mwindows -municode
+
+SOURCES = \
+	main.c

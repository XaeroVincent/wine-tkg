diff -ruN --show-c-function dlls/dinput/dinput_main.c dlls/dinput/dinput_main.c
--- dlls/dinput/dinput_main.c	2025-10-10 10:17:47.161834662 -0700
+++ dlls/dinput/dinput_main.c	2025-10-10 12:03:54.180232112 -0700
@@ -509,6 +509,8 @@ void check_dinput_events(void)
     MsgWaitForMultipleObjectsEx(0, NULL, 0, QS_ALLINPUT, 0);
 }
 
+HANDLE steam_overlay_event;
+
 BOOL WINAPI DllMain( HINSTANCE inst, DWORD reason, void *reserved )
 {
     TRACE( "inst %p, reason %lu, reserved %p.\n", inst, reason, reserved );
@@ -517,12 +519,14 @@ BOOL WINAPI DllMain( HINSTANCE inst, DWO
     {
       case DLL_PROCESS_ATTACH:
         DisableThreadLibraryCalls(inst);
+        steam_overlay_event = CreateEventA(NULL, TRUE, FALSE, "__wine_steamclient_GameOverlayActivated");
         DINPUT_instance = inst;
         register_di_em_win_class();
         break;
       case DLL_PROCESS_DETACH:
         if (reserved) break;
         unregister_di_em_win_class();
+        CloseHandle(steam_overlay_event);
         break;
     }
     return TRUE;
diff -ruN --show-c-function dlls/dinput/dinput_main.c.orig dlls/dinput/dinput_main.c.orig
--- dlls/dinput/dinput_main.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ dlls/dinput/dinput_main.c.orig	2025-10-10 12:03:47.945351847 -0700
@@ -0,0 +1,529 @@
+/*		DirectInput
+ *
+ * Copyright 1998 Marcus Meissner
+ * Copyright 1998,1999 Lionel Ulmer
+ * Copyright 2000-2002 TransGaming Technologies Inc.
+ * Copyright 2007 Vitaliy Margolen
+ *
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <assert.h>
+#include <stdarg.h>
+#include <string.h>
+
+#define COBJMACROS
+#include "windef.h"
+#include "winbase.h"
+#include "winuser.h"
+#include "winerror.h"
+#include "objbase.h"
+#include "rpcproxy.h"
+#include "devguid.h"
+#include "hidusage.h"
+#include "initguid.h"
+#include "dinputd.h"
+
+#include "dinput_private.h"
+#include "device_private.h"
+
+#include "wine/asm.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(dinput);
+
+#define INPUT_THREAD_NOTIFY     (WM_USER + 0x10)
+#define NOTIFY_THREAD_STOP      0
+#define NOTIFY_REFRESH_DEVICES  1
+
+struct input_thread_state
+{
+    BOOL running;
+    UINT events_count;
+    UINT devices_count;
+    UINT devices_capacity;
+    HHOOK mouse_ll_hook;
+    HHOOK keyboard_ll_hook;
+    RAWINPUTDEVICE rawinput_devices[2];
+    struct dinput_device **devices;
+    HANDLE *events;
+};
+
+static inline struct dinput_device *impl_from_IDirectInputDevice8W( IDirectInputDevice8W *iface )
+{
+    return CONTAINING_RECORD( iface, struct dinput_device, IDirectInputDevice8W_iface );
+}
+
+HINSTANCE DINPUT_instance;
+
+static HWND di_em_win;
+static HANDLE dinput_thread;
+static UINT input_thread_user_count;
+static struct input_thread_state *input_thread_state;
+
+static CRITICAL_SECTION dinput_hook_crit;
+static CRITICAL_SECTION_DEBUG dinput_critsect_debug =
+{
+    0, 0, &dinput_hook_crit,
+    { &dinput_critsect_debug.ProcessLocksList, &dinput_critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": dinput_hook_crit") }
+};
+static CRITICAL_SECTION dinput_hook_crit = { &dinput_critsect_debug, -1, 0, 0, 0, 0 };
+
+static struct list acquired_device_list = LIST_INIT( acquired_device_list );
+
+static void unhook_device_window_foreground_changes( struct dinput_device *device )
+{
+    if (!device->cbt_hook) return;
+    UnhookWindowsHookEx( device->cbt_hook );
+    device->cbt_hook = NULL;
+}
+
+static void dinput_device_internal_unacquire( IDirectInputDevice8W *iface, DWORD status )
+{
+    struct dinput_device *impl = impl_from_IDirectInputDevice8W( iface );
+
+    TRACE( "iface %p.\n", iface );
+
+    unhook_device_window_foreground_changes( impl );
+
+    EnterCriticalSection( &impl->crit );
+    if (impl->status == STATUS_ACQUIRED)
+    {
+        impl->vtbl->unacquire( iface );
+        impl->status = status;
+        list_remove( &impl->entry );
+    }
+    LeaveCriticalSection( &impl->crit );
+}
+
+static LRESULT CALLBACK input_thread_ll_hook_proc( int code, WPARAM wparam, LPARAM lparam )
+{
+    struct input_thread_state *state = input_thread_state;
+    int i, skip = 0;
+
+    if (code != HC_ACTION) return CallNextHookEx( 0, code, wparam, lparam );
+
+    for (i = state->events_count; i < state->devices_count; ++i)
+    {
+        struct dinput_device *device = state->devices[i];
+        if (device->use_raw_input) continue;
+        if (device->instance.dwDevType & DIDEVTYPE_HID) continue;
+        switch (GET_DIDEVICE_TYPE( device->instance.dwDevType ))
+        {
+        case DIDEVTYPE_MOUSE:
+        case DI8DEVTYPE_MOUSE:
+            TRACE( "calling dinput_mouse_hook (%p %Ix %Ix)\n", device, wparam, lparam );
+            skip |= dinput_mouse_hook( &device->IDirectInputDevice8W_iface, wparam, lparam );
+            break;
+        case DIDEVTYPE_KEYBOARD:
+        case DI8DEVTYPE_KEYBOARD:
+            TRACE( "calling dinput_keyboard_hook (%p %Ix %Ix)\n", device, wparam, lparam );
+            skip |= dinput_keyboard_hook( &device->IDirectInputDevice8W_iface, wparam, lparam );
+            break;
+        }
+    }
+
+    return skip ? 1 : CallNextHookEx( 0, code, wparam, lparam );
+}
+
+static void handle_foreground_lost( HWND window )
+{
+    struct dinput_device *impl, *next;
+
+    EnterCriticalSection( &dinput_hook_crit );
+
+    LIST_FOR_EACH_ENTRY_SAFE( impl, next, &acquired_device_list, struct dinput_device, entry )
+    {
+        if (!(impl->dwCoopLevel & DISCL_FOREGROUND) || window != impl->win) continue;
+        TRACE( "%p window is not foreground - unacquiring %p\n", impl->win, impl );
+        dinput_device_internal_unacquire( &impl->IDirectInputDevice8W_iface, STATUS_UNACQUIRED );
+    }
+
+    LeaveCriticalSection( &dinput_hook_crit );
+}
+
+static void dinput_unacquire_devices(void)
+{
+    struct dinput_device *impl, *next;
+
+    EnterCriticalSection( &dinput_hook_crit );
+
+    LIST_FOR_EACH_ENTRY_SAFE( impl, next, &acquired_device_list, struct dinput_device, entry )
+        dinput_device_internal_unacquire( &impl->IDirectInputDevice8W_iface, STATUS_UNACQUIRED );
+
+    LeaveCriticalSection( &dinput_hook_crit );
+}
+
+static LRESULT CALLBACK cbt_hook_proc( int code, WPARAM wparam, LPARAM lparam )
+{
+    if (code == HCBT_ACTIVATE && di_em_win)
+    {
+        CBTACTIVATESTRUCT *data = (CBTACTIVATESTRUCT *)lparam;
+        handle_foreground_lost( data->hWndActive );
+        SendMessageW( di_em_win, INPUT_THREAD_NOTIFY, NOTIFY_REFRESH_DEVICES, 0 );
+    }
+
+    return CallNextHookEx( 0, code, wparam, lparam );
+}
+
+static void hook_device_window_foreground_changes( struct dinput_device *device )
+{
+    DWORD tid, pid;
+    if (!(tid = GetWindowThreadProcessId( device->win, &pid ))) return;
+    device->cbt_hook = SetWindowsHookExW( WH_CBT, cbt_hook_proc, DINPUT_instance, tid );
+}
+
+static void input_thread_update_device_list( struct input_thread_state *state )
+{
+    RAWINPUTDEVICE rawinput_keyboard = {.usUsagePage = HID_USAGE_PAGE_GENERIC, .usUsage = HID_USAGE_GENERIC_KEYBOARD, .dwFlags = RIDEV_REMOVE};
+    RAWINPUTDEVICE rawinput_mouse = {.usUsagePage = HID_USAGE_PAGE_GENERIC, .usUsage = HID_USAGE_GENERIC_MOUSE, .dwFlags = RIDEV_REMOVE};
+    UINT count = 0, keyboard_ll_count = 0, mouse_ll_count = 0, capacity;
+    struct dinput_device *device;
+
+    EnterCriticalSection( &dinput_hook_crit );
+
+    if ((capacity = list_count( &acquired_device_list )) && capacity > state->devices_capacity)
+    {
+        struct dinput_device **devices;
+        HANDLE *events;
+
+        if (!state->devices_capacity) capacity = max( capacity, 128 );
+        else capacity = max( capacity, state->devices_capacity * 3 / 2 );
+
+        if ((events = realloc( state->events, capacity * sizeof(*events) ))) state->events = events;
+        if ((devices = realloc( state->devices, capacity * sizeof(*devices) ))) state->devices = devices;
+        if (events && devices) state->devices_capacity = capacity;
+    }
+
+    LIST_FOR_EACH_ENTRY( device, &acquired_device_list, struct dinput_device, entry )
+    {
+        unhook_device_window_foreground_changes( device );
+        if (device->dwCoopLevel & DISCL_FOREGROUND) hook_device_window_foreground_changes( device );
+
+        if (!device->read_event || !device->vtbl->read) continue;
+        state->events[count] = device->read_event;
+        dinput_device_internal_addref( (state->devices[count] = device) );
+        if (++count >= state->devices_capacity) break;
+    }
+    state->events_count = count;
+
+    LIST_FOR_EACH_ENTRY( device, &acquired_device_list, struct dinput_device, entry )
+    {
+        RAWINPUTDEVICE *rawinput_device = NULL;
+
+        if (device->read_event && device->vtbl->read) continue;
+        switch (GET_DIDEVICE_TYPE( device->instance.dwDevType ))
+        {
+        case DIDEVTYPE_MOUSE:
+        case DI8DEVTYPE_MOUSE:
+            if (device->dwCoopLevel & DISCL_EXCLUSIVE) rawinput_mouse.dwFlags |= RIDEV_CAPTUREMOUSE;
+            if (!device->use_raw_input) mouse_ll_count++;
+            else rawinput_device = &rawinput_mouse;
+            break;
+        case DIDEVTYPE_KEYBOARD:
+        case DI8DEVTYPE_KEYBOARD:
+            if (device->dwCoopLevel & DISCL_EXCLUSIVE) rawinput_keyboard.dwFlags |= RIDEV_NOHOTKEYS;
+            if (!device->use_raw_input) keyboard_ll_count++;
+            else rawinput_device = &rawinput_keyboard;
+            break;
+        }
+
+        if (rawinput_device)
+        {
+            if (device->dwCoopLevel & DISCL_BACKGROUND) rawinput_device->dwFlags |= RIDEV_INPUTSINK;
+            if (device->dwCoopLevel & DISCL_EXCLUSIVE) rawinput_device->dwFlags |= RIDEV_NOLEGACY;
+            rawinput_device->dwFlags &= ~RIDEV_REMOVE;
+            rawinput_device->hwndTarget = di_em_win;
+        }
+
+        dinput_device_internal_addref( (state->devices[count] = device) );
+        if (++count >= state->devices_capacity) break;
+    }
+    state->devices_count = count;
+    LeaveCriticalSection( &dinput_hook_crit );
+
+    if (keyboard_ll_count && !state->keyboard_ll_hook)
+        state->keyboard_ll_hook = SetWindowsHookExW( WH_KEYBOARD_LL, input_thread_ll_hook_proc, DINPUT_instance, 0 );
+    else if (!keyboard_ll_count && state->keyboard_ll_hook)
+    {
+        UnhookWindowsHookEx( state->keyboard_ll_hook );
+        state->keyboard_ll_hook = NULL;
+    }
+
+    if (mouse_ll_count && !state->mouse_ll_hook)
+        state->mouse_ll_hook = SetWindowsHookExW( WH_MOUSE_LL, input_thread_ll_hook_proc, DINPUT_instance, 0 );
+    else if (!mouse_ll_count && state->mouse_ll_hook)
+    {
+        UnhookWindowsHookEx( state->mouse_ll_hook );
+        state->mouse_ll_hook = NULL;
+    }
+
+    if (!rawinput_mouse.hwndTarget != !state->rawinput_devices[0].hwndTarget &&
+        !RegisterRawInputDevices( &rawinput_mouse, 1, sizeof(RAWINPUTDEVICE) ))
+        WARN( "Failed to (un)register rawinput mouse device.\n" );
+    if (!rawinput_keyboard.hwndTarget != !state->rawinput_devices[1].hwndTarget &&
+        !RegisterRawInputDevices( &rawinput_keyboard, 1, sizeof(RAWINPUTDEVICE) ))
+        WARN( "Failed to (un)register rawinput mouse device.\n" );
+
+    state->rawinput_devices[0] = rawinput_mouse;
+    state->rawinput_devices[1] = rawinput_keyboard;
+}
+
+static LRESULT WINAPI di_em_win_wndproc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
+{
+    struct input_thread_state *state = input_thread_state;
+    int rim = GET_RAWINPUT_CODE_WPARAM( wparam );
+    UINT i, size = sizeof(RAWINPUT);
+    RAWINPUT ri;
+
+    TRACE( "%p %d %Ix %Ix\n", hwnd, msg, wparam, lparam );
+
+    if (msg == WM_INPUT && (rim == RIM_INPUT || rim == RIM_INPUTSINK))
+    {
+        size = GetRawInputData( (HRAWINPUT)lparam, RID_INPUT, &ri, &size, sizeof(RAWINPUTHEADER) );
+        if (size == (UINT)-1 || size < sizeof(RAWINPUTHEADER))
+            WARN( "Unable to read raw input data\n" );
+        else if (ri.header.dwType == RIM_TYPEHID)
+            WARN( "Unexpected HID rawinput message\n" );
+        else
+        {
+            for (i = state->events_count; i < state->devices_count; ++i)
+            {
+                struct dinput_device *device = state->devices[i];
+                if (!device->use_raw_input) continue;
+                if (device->instance.dwDevType & DIDEVTYPE_HID) continue;
+                switch (GET_DIDEVICE_TYPE( device->instance.dwDevType ))
+                {
+                case DIDEVTYPE_MOUSE:
+                case DI8DEVTYPE_MOUSE:
+                    if (ri.header.dwType != RIM_TYPEMOUSE) break;
+                    dinput_mouse_rawinput_hook( &device->IDirectInputDevice8W_iface, wparam, lparam, &ri );
+                    break;
+                case DIDEVTYPE_KEYBOARD:
+                case DI8DEVTYPE_KEYBOARD:
+                    if (ri.header.dwType != RIM_TYPEKEYBOARD) break;
+                    dinput_keyboard_rawinput_hook( &device->IDirectInputDevice8W_iface, wparam, lparam, &ri );
+                    break;
+                default: break;
+                }
+            }
+        }
+    }
+
+    if (msg == INPUT_THREAD_NOTIFY)
+    {
+        TRACE( "Processing hook change notification wparam %#Ix, lparam %#Ix.\n", wparam, lparam );
+
+        switch (wparam)
+        {
+        case NOTIFY_THREAD_STOP:
+            state->running = FALSE;
+            break;
+        case NOTIFY_REFRESH_DEVICES:
+            while (state->devices_count--) dinput_device_internal_release( state->devices[state->devices_count] );
+            input_thread_update_device_list( state );
+            break;
+        }
+
+        return 0;
+    }
+
+    return DefWindowProcW( hwnd, msg, wparam, lparam );
+}
+
+static void register_di_em_win_class(void)
+{
+    WNDCLASSEXW class;
+
+    memset(&class, 0, sizeof(class));
+    class.cbSize = sizeof(class);
+    class.lpfnWndProc = di_em_win_wndproc;
+    class.hInstance = DINPUT_instance;
+    class.lpszClassName = L"DIEmWin";
+
+    if (!RegisterClassExW( &class ) && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
+        WARN( "Unable to register message window class\n" );
+}
+
+static void unregister_di_em_win_class(void)
+{
+    if (!UnregisterClassW( L"DIEmWin", NULL ) && GetLastError() != ERROR_CLASS_DOES_NOT_EXIST)
+        WARN( "Unable to unregister message window class\n" );
+}
+
+static DWORD WINAPI dinput_thread_proc( void *params )
+{
+    struct input_thread_state state = {.running = TRUE};
+    struct dinput_device *device;
+    HANDLE start_event = params;
+    HMODULE this_module = NULL;
+    DWORD ret;
+    MSG msg;
+
+    SetThreadDescription( GetCurrentThread(), L"wine_dinput_worker" );
+    SetThreadDpiAwarenessContext( DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE );
+
+    di_em_win = CreateWindowW( L"DIEmWin", L"DIEmWin", 0, 0, 0, 0, 0, HWND_MESSAGE, 0, DINPUT_instance, NULL );
+    input_thread_state = &state;
+
+    if (!GetModuleHandleExA( GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, (void *)dinput_thread_proc, &this_module ))
+        ERR( "Failed to get a handle of dinput to keep it alive: %lu", GetLastError() );
+
+    SetEvent( start_event );
+
+    while (state.running && (ret = MsgWaitForMultipleObjectsEx( state.events_count, state.events, INFINITE, QS_ALLINPUT, 0 )) <= state.events_count)
+    {
+        if (ret < state.events_count)
+        {
+            if ((device = state.devices[ret]) && FAILED( device->vtbl->read( &device->IDirectInputDevice8W_iface ) ))
+            {
+                EnterCriticalSection( &dinput_hook_crit );
+                dinput_device_internal_unacquire( &device->IDirectInputDevice8W_iface, STATUS_UNPLUGGED );
+                LeaveCriticalSection( &dinput_hook_crit );
+
+                state.events[ret] = state.events[--state.events_count];
+                state.devices[ret] = state.devices[state.events_count];
+                state.devices[state.events_count] = state.devices[--state.devices_count];
+                dinput_device_internal_release( device );
+            }
+        }
+
+        while (PeekMessageW( &msg, 0, 0, 0, PM_REMOVE ))
+        {
+            TranslateMessage(&msg);
+            DispatchMessageW(&msg);
+        }
+    }
+
+    if (state.running)
+    {
+        ERR( "Unexpected termination, ret %#lx\n", ret );
+        dinput_unacquire_devices();
+    }
+
+    while (state.devices_count--) dinput_device_internal_release( state.devices[state.devices_count] );
+    if (state.keyboard_ll_hook) UnhookWindowsHookEx( state.keyboard_ll_hook );
+    if (state.mouse_ll_hook) UnhookWindowsHookEx( state.mouse_ll_hook );
+    free( state.devices );
+    free( state.events );
+
+    DestroyWindow( di_em_win );
+    di_em_win = NULL;
+
+    if (this_module != NULL) FreeLibraryAndExitThread( this_module, 0 );
+    return 0;
+}
+
+void input_thread_start(void)
+{
+    HANDLE start_event;
+
+    TRACE( "Starting input thread.\n" );
+
+    if (!(start_event = CreateEventW( NULL, FALSE, FALSE, NULL )))
+        ERR( "Failed to create start event, error %lu\n", GetLastError() );
+    else if (!(dinput_thread = CreateThread( NULL, 0, dinput_thread_proc, start_event, 0, NULL )))
+        ERR( "Failed to create internal thread, error %lu\n", GetLastError() );
+    else
+        WaitForSingleObject( start_event, INFINITE );
+
+    CloseHandle( start_event );
+}
+
+void dinput_hooks_acquire_device( IDirectInputDevice8W *iface )
+{
+    struct dinput_device *impl = impl_from_IDirectInputDevice8W( iface );
+
+    EnterCriticalSection( &dinput_hook_crit );
+    /* start the input thread now if it wasn't started already */
+    if (!dinput_thread) input_thread_start();
+    list_add_tail( &acquired_device_list, &impl->entry );
+    LeaveCriticalSection( &dinput_hook_crit );
+
+    SendMessageW( di_em_win, INPUT_THREAD_NOTIFY, NOTIFY_REFRESH_DEVICES, 0 );
+}
+
+void dinput_hooks_unacquire_device( IDirectInputDevice8W *iface )
+{
+    struct dinput_device *impl = impl_from_IDirectInputDevice8W( iface );
+
+    EnterCriticalSection( &dinput_hook_crit );
+    list_remove( &impl->entry );
+    LeaveCriticalSection( &dinput_hook_crit );
+
+    SendMessageW( di_em_win, INPUT_THREAD_NOTIFY, NOTIFY_REFRESH_DEVICES, 0 );
+}
+
+void input_thread_add_user(void)
+{
+    /* we cannot start the input thread here because some games create dinput objects from their DllMain, and
+     * starting the thread will wait for it to initialize, which requires the loader lock to be released.
+     */
+    EnterCriticalSection( &dinput_hook_crit );
+    input_thread_user_count++;
+    LeaveCriticalSection( &dinput_hook_crit );
+}
+
+void input_thread_remove_user(void)
+{
+    EnterCriticalSection( &dinput_hook_crit );
+    if (!--input_thread_user_count && dinput_thread)
+    {
+        TRACE( "Stopping input thread.\n" );
+
+        SendMessageW( di_em_win, INPUT_THREAD_NOTIFY, NOTIFY_THREAD_STOP, 0 );
+        WaitForSingleObject( dinput_thread, INFINITE );
+        CloseHandle( dinput_thread );
+        dinput_thread = NULL;
+    }
+    LeaveCriticalSection( &dinput_hook_crit );
+}
+
+void check_dinput_events(void)
+{
+    /* Windows does not do that, but our current implementation of winex11
+     * requires periodic event polling to forward events to the wineserver.
+     *
+     * We have to call this function from multiple places, because:
+     * - some games do not explicitly poll for mouse events
+     *   (for example Culpa Innata)
+     * - some games only poll the device, and neither keyboard nor mouse
+     *   (for example Civilization: Call to Power 2)
+     * - some games do not explicitly poll for keyboard events
+     *   (for example Morrowind in its key binding page)
+     */
+    MsgWaitForMultipleObjectsEx(0, NULL, 0, QS_ALLINPUT, 0);
+}
+
+BOOL WINAPI DllMain( HINSTANCE inst, DWORD reason, void *reserved )
+{
+    TRACE( "inst %p, reason %lu, reserved %p.\n", inst, reason, reserved );
+
+    switch(reason)
+    {
+      case DLL_PROCESS_ATTACH:
+        DisableThreadLibraryCalls(inst);
+        DINPUT_instance = inst;
+        register_di_em_win_class();
+        break;
+      case DLL_PROCESS_DETACH:
+        if (reserved) break;
+        unregister_di_em_win_class();
+        break;
+    }
+    return TRUE;
+}
diff -ruN --show-c-function dlls/dinput/dinput_private.h dlls/dinput/dinput_private.h
--- dlls/dinput/dinput_private.h	2025-10-10 10:17:47.161834662 -0700
+++ dlls/dinput/dinput_private.h	2025-10-10 12:03:54.180335209 -0700
@@ -46,6 +46,7 @@ struct dinput
 
 extern const IDirectInput7AVtbl dinput7_a_vtbl;
 extern const IDirectInput8AVtbl dinput8_a_vtbl;
+extern HANDLE steam_overlay_event;
 
 extern void dinput_internal_addref( struct dinput *dinput );
 extern void dinput_internal_release( struct dinput *dinput );
diff -ruN --show-c-function dlls/dinput/joystick_hid.c dlls/dinput/joystick_hid.c
--- dlls/dinput/joystick_hid.c	2025-10-10 10:17:47.161834662 -0700
+++ dlls/dinput/joystick_hid.c	2025-10-10 12:03:54.189406407 -0700
@@ -47,6 +47,9 @@
 #include "wine/debug.h"
 #include "wine/hid.h"
 
+#define VID_LOGITECH 0x046D
+#define PID_LOGITECH_G920 0xC262
+
 WINE_DEFAULT_DEBUG_CHANNEL(dinput);
 
 DEFINE_GUID( GUID_DEVINTERFACE_WINEXINPUT,0x6c53d5fd,0x6480,0x440f,0xb6,0x18,0x47,0x67,0x50,0xc5,0xe1,0xa6 );
@@ -172,6 +175,7 @@ struct pid_effect_state
 struct hid_joystick
 {
     struct dinput_device base;
+    BOOL wgi_device;
 
     HANDLE device;
     OVERLAPPED read_ovl;
@@ -239,6 +243,51 @@ struct hid_joystick_effect
     char *set_envelope_buf;
 };
 
+struct joystick_device
+{
+    WCHAR device_path[MAX_PATH];
+};
+
+static CRITICAL_SECTION joystick_devices_crit;
+static CRITICAL_SECTION_DEBUG joystick_devices_crit_debug =
+{
+    0, 0, &joystick_devices_crit,
+    { &joystick_devices_crit_debug.ProcessLocksList, &joystick_devices_crit_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": joystick_devices_crit") }
+};
+static CRITICAL_SECTION joystick_devices_crit = { &joystick_devices_crit_debug, -1, 0, 0, 0, 0 };
+
+static struct joystick_device *joystick_devices;
+static unsigned int joystick_device_count;
+
+static unsigned int get_joystick_index( const WCHAR *device_path )
+{
+    unsigned int i;
+
+    EnterCriticalSection( &joystick_devices_crit );
+    for (i = 0; i < joystick_device_count; ++i)
+        if (!wcsicmp( joystick_devices[i].device_path, device_path )) break;
+
+    if (i == joystick_device_count)
+    {
+        ++joystick_device_count;
+        joystick_devices = realloc( joystick_devices, sizeof(*joystick_devices) * joystick_device_count );
+        wcscpy( joystick_devices[i].device_path, device_path );
+    }
+    LeaveCriticalSection( &joystick_devices_crit );
+    return i;
+}
+
+static BOOL get_default_joystick_device_path( WCHAR *device_path )
+{
+    BOOL ret;
+
+    EnterCriticalSection( &joystick_devices_crit );
+    if ((ret = !!joystick_device_count)) wcscpy( device_path, joystick_devices[0].device_path );
+    LeaveCriticalSection( &joystick_devices_crit );
+    return ret;
+}
+
 static inline struct hid_joystick_effect *impl_from_IDirectInputEffect( IDirectInputEffect *iface )
 {
     return CONTAINING_RECORD( iface, struct hid_joystick_effect, IDirectInputEffect_iface );
@@ -543,6 +592,8 @@ static BOOL enum_objects( struct hid_joy
     struct hid_collection_node *node, *node_end;
     WORD version = impl->base.dinput->dwVersion;
     BOOL ret, seen_axis[6] = {0};
+    const GUID *hack_guid;
+    const WCHAR *hack_name;
     const WCHAR *tmp;
 
     button_ofs += impl->caps.NumberInputValueCaps * sizeof(LONG);
@@ -562,6 +613,8 @@ static BOOL enum_objects( struct hid_joy
             value_ofs += (caps->usage_max - caps->usage_min + 1) * sizeof(LONG);
         else for (j = caps->usage_min; j <= caps->usage_max; ++j)
         {
+            hack_name = NULL;
+            hack_guid = NULL;
             instance.dwOfs = value_ofs;
             switch (MAKELONG(j, caps->usage_page))
             {
@@ -571,7 +624,38 @@ static BOOL enum_objects( struct hid_joy
             case MAKELONG(HID_USAGE_GENERIC_RX, HID_USAGE_PAGE_GENERIC):
             case MAKELONG(HID_USAGE_GENERIC_RY, HID_USAGE_PAGE_GENERIC):
             case MAKELONG(HID_USAGE_GENERIC_RZ, HID_USAGE_PAGE_GENERIC):
-                set_axis_type( &instance, seen_axis, j - HID_USAGE_GENERIC_X, &axis );
+                if (!impl->wgi_device && impl->attrs.VendorID == VID_LOGITECH && impl->attrs.ProductID == PID_LOGITECH_G920)
+                {
+                    if (j == HID_USAGE_GENERIC_X)
+                    {
+                        set_axis_type( &instance, seen_axis, 0, &axis );
+                        hack_guid = &GUID_XAxis;
+                        hack_name = L"Wheel axis";
+                    }
+                    else if (j == HID_USAGE_GENERIC_Y)
+                    {
+                        set_axis_type( &instance, seen_axis, 2, &axis );
+                        hack_guid = &GUID_YAxis;
+                        hack_name = L"Accelerator";
+                    }
+                    else if (j == HID_USAGE_GENERIC_Z)
+                    {
+                        set_axis_type( &instance, seen_axis, 5, &axis );
+                        hack_guid = &GUID_RzAxis;
+                        hack_name = L"Brake";
+                    }
+                    else if (j == HID_USAGE_GENERIC_RZ)
+                    {
+                        instance.dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 6 + axis++ );
+                        hack_guid = &GUID_Slider;
+                        hack_name = L"Clutch";
+                    }
+                    else WARN("unknown axis usage page %x usage %lx for Logitech G920\n", caps->usage_page, j);
+                }
+                else
+                {
+                    set_axis_type( &instance, seen_axis, j - HID_USAGE_GENERIC_X, &axis );
+                }
                 instance.dwFlags = DIDOI_ASPECTPOSITION;
                 break;
             case MAKELONG(HID_USAGE_SIMULATION_STEERING, HID_USAGE_PAGE_SIMULATION):
@@ -608,12 +692,16 @@ static BOOL enum_objects( struct hid_joy
             }
             instance.wUsagePage = caps->usage_page;
             instance.wUsage = j;
-            instance.guidType = *object_usage_to_guid( instance.wUsagePage, instance.wUsage );
+            if (hack_guid)
+                instance.guidType = *hack_guid;
+            else
+                instance.guidType = *object_usage_to_guid( instance.wUsagePage, instance.wUsage );
             instance.wReportId = caps->report_id;
             instance.wCollectionNumber = caps->link_collection;
             instance.dwDimension = caps->units;
             instance.wExponent = caps->units_exp;
-            if ((tmp = object_usage_to_string( &instance ))) lstrcpynW( instance.tszName, tmp, MAX_PATH );
+            if (hack_name) lstrcpynW( instance.tszName, hack_name, MAX_PATH );
+            else if ((tmp = object_usage_to_string( &instance ))) lstrcpynW( instance.tszName, tmp, MAX_PATH );
             else swprintf( instance.tszName, MAX_PATH, L"Unknown %u", DIDFT_GETINSTANCE( instance.dwType ) );
             check_pid_effect_axis_caps( impl, &instance );
             ret = enum_object( impl, filter, flags, callback, object, caps, &instance, data );
@@ -805,13 +893,23 @@ static HRESULT hid_joystick_get_property
     case (DWORD_PTR)DIPROP_JOYSTICKID:
     {
         DIPROPDWORD *value = (DIPROPDWORD *)header;
-        value->dwData = impl->base.instance.guidInstance.Data3;
+        value->dwData = get_joystick_index( impl->device_path );
         return DI_OK;
     }
     case (DWORD_PTR)DIPROP_GUIDANDPATH:
     {
         DIPROPGUIDANDPATH *value = (DIPROPGUIDANDPATH *)header;
         value->guidClass = GUID_DEVCLASS_HIDCLASS;
+
+        /* CW-Bug-Id: #23185 Emulate Steam Input native hooks for native SDL */
+        if (impl->attrs.VendorID == 0x28de && impl->attrs.ProductID == 0x11ff)
+        {
+            const WCHAR *tmp;
+            if ((tmp = wcschr( impl->device_path, '#' ))) tmp = wcschr( tmp + 1, '#' );
+            lstrcpynW( value->wszPath, impl->device_path, tmp - impl->device_path + 1 );
+            return DI_OK;
+        }
+
         lstrcpynW( value->wszPath, impl->device_path, MAX_PATH );
         return DI_OK;
     }
@@ -1125,6 +1223,7 @@ struct parse_device_state_params
 {
     BYTE old_state[DEVICE_STATE_MAX_SIZE];
     BYTE buttons[128];
+    BOOL reset_state;
     DWORD time;
     DWORD seq;
 };
@@ -1140,6 +1239,8 @@ static BOOL check_device_state_button( s
 
     value = params->buttons[instance->wUsage - 1];
     old_value = params->old_state[instance->dwOfs];
+    if (params->reset_state) value = 0;
+
     device->device_state[instance->dwOfs] = value;
     if (old_value != value) queue_event( iface, index, value, params->time, params->seq );
 
@@ -1225,6 +1326,16 @@ static BOOL read_device_state_value( str
     if (instance->dwType & DIDFT_AXIS) value = scale_axis_value( logical_value, properties );
     else value = scale_value( logical_value, properties );
 
+    if (params->reset_state)
+    {
+        if (instance->dwType & DIDFT_POV) value = -1;
+        else if (instance->dwType & DIDFT_AXIS)
+        {
+            if (!properties->range_min) value = properties->range_max / 2;
+            else value = round( (properties->range_min + properties->range_max) / 2.0 );
+        }
+    }
+
     old_value = *(LONG *)(params->old_state + instance->dwOfs);
     *(LONG *)(impl->base.device_state + instance->dwOfs) = value;
     if (old_value != value) queue_event( iface, index, value, params->time, params->seq );
@@ -1254,6 +1365,11 @@ static HRESULT hid_joystick_read( IDirec
 
     ret = GetOverlappedResult( impl->device, &impl->read_ovl, &count, FALSE );
 
+    if (WaitForSingleObject(steam_overlay_event, 0) == WAIT_OBJECT_0) /* steam overlay is enabled */
+        params.reset_state = TRUE;
+    else
+        params.reset_state = FALSE;
+
     EnterCriticalSection( &impl->base.crit );
     while (ret)
     {
@@ -1465,6 +1581,14 @@ static HRESULT hid_joystick_device_try_o
     instance->wUsagePage = caps->UsagePage;
     instance->wUsage = caps->Usage;
 
+    /* CW-Bug-Id: #23185 Emulate Steam Input native hooks for native SDL */
+    if (attrs->VendorID == 0x28de && attrs->ProductID == 0x11ff)
+    {
+        instance->guidProduct.Data2 = 0x28de;
+        instance->guidInstance = instance->guidProduct;
+        instance->guidInstance.Data3 = 1;
+    }
+
     node_count = ARRAY_SIZE(nodes);
     status = HidP_GetLinkCollectionNodes( nodes, &node_count, preparsed_data );
     if (status != HIDP_STATUS_SUCCESS) node_count = 0;
@@ -1560,6 +1684,9 @@ static HRESULT hid_joystick_device_try_o
         break;
     }
 
+    if (attrs->VendorID == VID_LOGITECH && attrs->ProductID == PID_LOGITECH_G920)
+        type = DI8DEVTYPE_DRIVING | (DI8DEVTYPEDRIVING_DUALPEDALS << 8);
+
     instance->dwDevType = device_type_for_version( type, version ) | DIDEVTYPE_HID;
     TRACE("detected device type %#lx\n", instance->dwDevType);
 
@@ -1626,6 +1753,8 @@ static HRESULT hid_joystick_device_open(
                                                      attrs, caps, instance, version )))
                 continue;
         }
+        /* Assign joystick index if the device path is first seen. */
+        get_joystick_index( detail->DevicePath );
 
         /* enumerate device by GUID */
         if (IsEqualGUID( guid, &instance->guidProduct ) || IsEqualGUID( guid, &instance->guidInstance )) break;
@@ -2042,10 +2171,18 @@ HRESULT hid_joystick_create_device( stru
     impl->base.read_event = CreateEventW( NULL, TRUE, FALSE, NULL );
 
     if (memcmp( device_path_guid.Data4, guid->Data4, sizeof(device_path_guid.Data4) ))
+    {
+        /* Let hid_joystick_device_open() populate joystick devices before checking for default joystick GUID. */
         hr = hid_joystick_device_open( -1, guid, &impl->base.instance, impl->device_path, &impl->device, &impl->preparsed,
                                        &attrs, &impl->caps, dinput->dwVersion );
+        if (hr == DIERR_DEVICENOTREG && IsEqualGUID( guid, &GUID_Joystick )
+            && get_default_joystick_device_path( impl->device_path ))
+            hr = hid_joystick_device_try_open( impl->device_path, &impl->device, &impl->preparsed, &attrs,
+                                               &impl->caps, &impl->base.instance, dinput->dwVersion );
+    }
     else
     {
+        impl->wgi_device = TRUE;
         wcscpy( impl->device_path, *(const WCHAR **)guid );
         hr = hid_joystick_device_try_open( impl->device_path, &impl->device, &impl->preparsed, &attrs,
                                            &impl->caps, &impl->base.instance, dinput->dwVersion );
diff -ruN --show-c-function dlls/dinput/joystick_hid.c.orig dlls/dinput/joystick_hid.c.orig
--- dlls/dinput/joystick_hid.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ dlls/dinput/joystick_hid.c.orig	2025-10-10 12:03:47.945351847 -0700
@@ -0,0 +1,3199 @@
+/*  DirectInput HID Joystick device
+ *
+ * Copyright 2021 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <assert.h>
+#include <stdarg.h>
+#include <string.h>
+#include <math.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winbase.h"
+#include "winternl.h"
+#include "winuser.h"
+#include "winerror.h"
+#include "winreg.h"
+#include "winioctl.h"
+
+#include "ddk/hidclass.h"
+#include "ddk/hidsdi.h"
+#include "setupapi.h"
+#include "devguid.h"
+#include "dinput.h"
+#include "setupapi.h"
+
+#include "dinput_private.h"
+#include "device_private.h"
+
+#include "initguid.h"
+
+#include "wine/debug.h"
+#include "wine/hid.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(dinput);
+
+DEFINE_GUID( GUID_DEVINTERFACE_WINEXINPUT,0x6c53d5fd,0x6480,0x440f,0xb6,0x18,0x47,0x67,0x50,0xc5,0xe1,0xa6 );
+DEFINE_GUID( hid_joystick_guid, 0x9e573edb, 0x7734, 0x11d2, 0x8d, 0x4a, 0x23, 0x90, 0x3f, 0xb6, 0xbd, 0xf7 );
+DEFINE_GUID( device_path_guid, 0x00000000, 0x0000, 0x0000, 0x8d, 0x4a, 0x23, 0x90, 0x3f, 0xb6, 0xbd, 0xf8 );
+
+struct pid_control_report
+{
+    BYTE id;
+    UINT collection;
+    UINT control_coll;
+};
+
+struct pid_effect_update
+{
+    BYTE id;
+    UINT collection;
+    UINT type_coll;
+    UINT axes_coll;
+    UINT axis_count;
+    UINT direction_coll;
+    UINT direction_count;
+    struct hid_value_caps *axis_caps[MAX_PID_AXES];
+    struct hid_value_caps *direction_caps[MAX_PID_AXES];
+    struct hid_value_caps *duration_caps;
+    struct hid_value_caps *gain_caps;
+    struct hid_value_caps *sample_period_caps;
+    struct hid_value_caps *start_delay_caps;
+    struct hid_value_caps *trigger_button_caps;
+    struct hid_value_caps *trigger_repeat_interval_caps;
+};
+
+struct pid_set_periodic
+{
+    BYTE id;
+    UINT collection;
+    struct hid_value_caps *magnitude_caps;
+    struct hid_value_caps *period_caps;
+    struct hid_value_caps *phase_caps;
+    struct hid_value_caps *offset_caps;
+};
+
+struct pid_set_envelope
+{
+    BYTE id;
+    UINT collection;
+    struct hid_value_caps *attack_level_caps;
+    struct hid_value_caps *attack_time_caps;
+    struct hid_value_caps *fade_level_caps;
+    struct hid_value_caps *fade_time_caps;
+};
+
+struct pid_set_condition
+{
+    BYTE id;
+    UINT collection;
+    struct hid_value_caps *center_point_offset_caps;
+    struct hid_value_caps *positive_coefficient_caps;
+    struct hid_value_caps *negative_coefficient_caps;
+    struct hid_value_caps *positive_saturation_caps;
+    struct hid_value_caps *negative_saturation_caps;
+    struct hid_value_caps *dead_band_caps;
+};
+
+struct pid_set_constant_force
+{
+    BYTE id;
+    UINT collection;
+    struct hid_value_caps *magnitude_caps;
+};
+
+struct pid_set_ramp_force
+{
+    BYTE id;
+    UINT collection;
+    struct hid_value_caps *start_caps;
+    struct hid_value_caps *end_caps;
+};
+
+struct pid_device_gain
+{
+    BYTE id;
+    UINT collection;
+    struct hid_value_caps *device_gain_caps;
+};
+
+struct pid_device_pool
+{
+    BYTE id;
+    UINT collection;
+    struct hid_value_caps *device_managed_caps;
+};
+
+struct pid_block_free
+{
+    BYTE id;
+    UINT collection;
+};
+
+struct pid_block_load
+{
+    BYTE id;
+    UINT collection;
+    UINT status_coll;
+};
+
+struct pid_new_effect
+{
+    BYTE id;
+    UINT collection;
+    UINT type_coll;
+};
+
+struct pid_effect_state
+{
+    BYTE id;
+    UINT collection;
+    struct hid_value_caps *safety_switch_caps;
+    struct hid_value_caps *actuator_power_caps;
+    struct hid_value_caps *actuator_override_switch_caps;
+};
+
+struct hid_joystick
+{
+    struct dinput_device base;
+
+    HANDLE device;
+    OVERLAPPED read_ovl;
+    PHIDP_PREPARSED_DATA preparsed;
+
+    WCHAR device_path[MAX_PATH];
+    HIDD_ATTRIBUTES attrs;
+    HIDP_CAPS caps;
+
+    char *input_report_buf;
+    char *output_report_buf;
+    char *feature_report_buf;
+    USAGE_AND_PAGE *usages_buf;
+    UINT usages_count;
+
+    BYTE effect_inuse[255];
+    struct list effect_list;
+    struct pid_control_report pid_device_control;
+    struct pid_control_report pid_effect_control;
+    struct pid_effect_update pid_effect_update;
+    struct pid_set_periodic pid_set_periodic;
+    struct pid_set_envelope pid_set_envelope;
+    struct pid_set_condition pid_set_condition;
+    struct pid_set_constant_force pid_set_constant_force;
+    struct pid_set_ramp_force pid_set_ramp_force;
+    struct pid_device_gain pid_device_gain;
+    struct pid_device_pool pid_device_pool;
+    struct pid_block_free pid_block_free;
+    struct pid_block_load pid_block_load;
+    struct pid_new_effect pid_new_effect;
+    struct pid_effect_state pid_effect_state;
+};
+
+static inline struct hid_joystick *impl_from_IDirectInputDevice8W( IDirectInputDevice8W *iface )
+{
+    return CONTAINING_RECORD( CONTAINING_RECORD( iface, struct dinput_device, IDirectInputDevice8W_iface ),
+                              struct hid_joystick, base );
+}
+
+struct hid_joystick_effect
+{
+    IDirectInputEffect IDirectInputEffect_iface;
+    LONG ref;
+    USAGE type;
+    ULONG index;
+
+    struct list entry;
+    struct hid_joystick *joystick;
+
+    DWORD axes[MAX_PID_AXES];
+    LONG directions[MAX_PID_AXES];
+    DICONSTANTFORCE constant_force;
+    DIRAMPFORCE ramp_force;
+    DICONDITION condition[MAX_PID_AXES];
+    DIENVELOPE envelope;
+    DIPERIODIC periodic;
+    DIEFFECT params;
+    DWORD modified;
+    DWORD flags;
+    DWORD status;
+
+    char *effect_control_buf;
+    char *effect_update_buf;
+    char *type_specific_buf;
+    char *set_envelope_buf;
+};
+
+static inline struct hid_joystick_effect *impl_from_IDirectInputEffect( IDirectInputEffect *iface )
+{
+    return CONTAINING_RECORD( iface, struct hid_joystick_effect, IDirectInputEffect_iface );
+}
+
+static inline BOOL is_exclusively_acquired( struct hid_joystick *joystick )
+{
+    return joystick->base.status == STATUS_ACQUIRED && (joystick->base.dwCoopLevel & DISCL_EXCLUSIVE);
+}
+
+static const GUID *object_usage_to_guid( USAGE usage_page, USAGE usage )
+{
+    switch (usage_page)
+    {
+    case HID_USAGE_PAGE_BUTTON: return &GUID_Button;
+    case HID_USAGE_PAGE_SIMULATION:
+        switch (usage)
+        {
+        case HID_USAGE_SIMULATION_STEERING: return &GUID_XAxis;
+        case HID_USAGE_SIMULATION_ACCELERATOR: return &GUID_YAxis;
+        case HID_USAGE_SIMULATION_BRAKE: return &GUID_RzAxis;
+        case HID_USAGE_SIMULATION_RUDDER: return &GUID_RzAxis;
+        case HID_USAGE_SIMULATION_THROTTLE: return &GUID_Slider;
+        }
+        break;
+    case HID_USAGE_PAGE_GENERIC:
+        switch (usage)
+        {
+        case HID_USAGE_GENERIC_X: return &GUID_XAxis;
+        case HID_USAGE_GENERIC_Y: return &GUID_YAxis;
+        case HID_USAGE_GENERIC_Z: return &GUID_ZAxis;
+        case HID_USAGE_GENERIC_WHEEL: return &GUID_ZAxis;
+        case HID_USAGE_GENERIC_RX: return &GUID_RxAxis;
+        case HID_USAGE_GENERIC_RY: return &GUID_RyAxis;
+        case HID_USAGE_GENERIC_RZ: return &GUID_RzAxis;
+        case HID_USAGE_GENERIC_SLIDER: return &GUID_Slider;
+        case HID_USAGE_GENERIC_DIAL: return &GUID_Slider;
+        case HID_USAGE_GENERIC_HATSWITCH: return &GUID_POV;
+        }
+        break;
+    }
+
+    return &GUID_Unknown;
+}
+
+static inline USAGE effect_guid_to_usage( const GUID *guid )
+{
+    if (IsEqualGUID( guid, &GUID_CustomForce )) return PID_USAGE_ET_CUSTOM_FORCE_DATA;
+    if (IsEqualGUID( guid, &GUID_ConstantForce )) return PID_USAGE_ET_CONSTANT_FORCE;
+    if (IsEqualGUID( guid, &GUID_RampForce )) return PID_USAGE_ET_RAMP;
+    if (IsEqualGUID( guid, &GUID_Square )) return PID_USAGE_ET_SQUARE;
+    if (IsEqualGUID( guid, &GUID_Sine )) return PID_USAGE_ET_SINE;
+    if (IsEqualGUID( guid, &GUID_Triangle )) return PID_USAGE_ET_TRIANGLE;
+    if (IsEqualGUID( guid, &GUID_SawtoothUp )) return PID_USAGE_ET_SAWTOOTH_UP;
+    if (IsEqualGUID( guid, &GUID_SawtoothDown )) return PID_USAGE_ET_SAWTOOTH_DOWN;
+    if (IsEqualGUID( guid, &GUID_Spring )) return PID_USAGE_ET_SPRING;
+    if (IsEqualGUID( guid, &GUID_Damper )) return PID_USAGE_ET_DAMPER;
+    if (IsEqualGUID( guid, &GUID_Inertia )) return PID_USAGE_ET_INERTIA;
+    if (IsEqualGUID( guid, &GUID_Friction )) return PID_USAGE_ET_FRICTION;
+    return 0;
+}
+
+static inline const GUID *effect_usage_to_guid( USAGE usage )
+{
+    switch (usage)
+    {
+    case PID_USAGE_ET_CUSTOM_FORCE_DATA: return &GUID_CustomForce;
+    case PID_USAGE_ET_CONSTANT_FORCE: return &GUID_ConstantForce;
+    case PID_USAGE_ET_RAMP: return &GUID_RampForce;
+    case PID_USAGE_ET_SQUARE: return &GUID_Square;
+    case PID_USAGE_ET_SINE: return &GUID_Sine;
+    case PID_USAGE_ET_TRIANGLE: return &GUID_Triangle;
+    case PID_USAGE_ET_SAWTOOTH_UP: return &GUID_SawtoothUp;
+    case PID_USAGE_ET_SAWTOOTH_DOWN: return &GUID_SawtoothDown;
+    case PID_USAGE_ET_SPRING: return &GUID_Spring;
+    case PID_USAGE_ET_DAMPER: return &GUID_Damper;
+    case PID_USAGE_ET_INERTIA: return &GUID_Inertia;
+    case PID_USAGE_ET_FRICTION: return &GUID_Friction;
+    }
+    return &GUID_Unknown;
+}
+
+static const WCHAR *effect_guid_to_string( const GUID *guid )
+{
+    if (IsEqualGUID( guid, &GUID_CustomForce )) return L"GUID_CustomForce";
+    if (IsEqualGUID( guid, &GUID_ConstantForce )) return L"GUID_ConstantForce";
+    if (IsEqualGUID( guid, &GUID_RampForce )) return L"GUID_RampForce";
+    if (IsEqualGUID( guid, &GUID_Square )) return L"GUID_Square";
+    if (IsEqualGUID( guid, &GUID_Sine )) return L"GUID_Sine";
+    if (IsEqualGUID( guid, &GUID_Triangle )) return L"GUID_Triangle";
+    if (IsEqualGUID( guid, &GUID_SawtoothUp )) return L"GUID_SawtoothUp";
+    if (IsEqualGUID( guid, &GUID_SawtoothDown )) return L"GUID_SawtoothDown";
+    if (IsEqualGUID( guid, &GUID_Spring )) return L"GUID_Spring";
+    if (IsEqualGUID( guid, &GUID_Damper )) return L"GUID_Damper";
+    if (IsEqualGUID( guid, &GUID_Inertia )) return L"GUID_Inertia";
+    if (IsEqualGUID( guid, &GUID_Friction )) return L"GUID_Friction";
+    return L"GUID_Unknown";
+}
+
+static const WCHAR *object_usage_to_string( DIDEVICEOBJECTINSTANCEW *instance )
+{
+    switch (MAKELONG(instance->wUsage, instance->wUsagePage))
+    {
+    case MAKELONG(HID_USAGE_DIGITIZER_TIP_PRESSURE, HID_USAGE_PAGE_DIGITIZER): return L"Tip Pressure";
+    case MAKELONG(HID_USAGE_CONSUMER_VOLUME, HID_USAGE_PAGE_CONSUMER): return L"Volume";
+
+    case MAKELONG(HID_USAGE_GENERIC_HATSWITCH, HID_USAGE_PAGE_GENERIC): return L"Hat Switch";
+    case MAKELONG(HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC): return L"Joystick";
+    case MAKELONG(HID_USAGE_GENERIC_RX, HID_USAGE_PAGE_GENERIC): return L"X Rotation";
+    case MAKELONG(HID_USAGE_GENERIC_RY, HID_USAGE_PAGE_GENERIC): return L"Y Rotation";
+    case MAKELONG(HID_USAGE_GENERIC_RZ, HID_USAGE_PAGE_GENERIC): return L"Z Rotation";
+    case MAKELONG(HID_USAGE_GENERIC_WHEEL, HID_USAGE_PAGE_GENERIC): return L"Wheel";
+    case MAKELONG(HID_USAGE_GENERIC_X, HID_USAGE_PAGE_GENERIC): return L"X Axis";
+    case MAKELONG(HID_USAGE_GENERIC_Y, HID_USAGE_PAGE_GENERIC): return L"Y Axis";
+    case MAKELONG(HID_USAGE_GENERIC_Z, HID_USAGE_PAGE_GENERIC): return L"Z Axis";
+    case MAKELONG(HID_USAGE_GENERIC_SLIDER, HID_USAGE_PAGE_GENERIC): return L"Slider";
+    case MAKELONG(HID_USAGE_GENERIC_DIAL, HID_USAGE_PAGE_GENERIC): return L"Dial";
+
+    case MAKELONG(PID_USAGE_ATTACK_LEVEL, HID_USAGE_PAGE_PID): return L"Attack Level";
+    case MAKELONG(PID_USAGE_ATTACK_TIME, HID_USAGE_PAGE_PID): return L"Attack Time";
+    case MAKELONG(PID_USAGE_AXES_ENABLE, HID_USAGE_PAGE_PID): return L"Axes Enable";
+
+    case MAKELONG(PID_USAGE_DC_DEVICE_CONTINUE, HID_USAGE_PAGE_PID): return L"DC Device Continue";
+    case MAKELONG(PID_USAGE_DC_DEVICE_PAUSE, HID_USAGE_PAGE_PID): return L"DC Device Pause";
+    case MAKELONG(PID_USAGE_DC_DEVICE_RESET, HID_USAGE_PAGE_PID): return L"DC Device Reset";
+    case MAKELONG(PID_USAGE_DC_DISABLE_ACTUATORS, HID_USAGE_PAGE_PID): return L"DC Disable Actuators";
+    case MAKELONG(PID_USAGE_DC_ENABLE_ACTUATORS, HID_USAGE_PAGE_PID): return L"DC Enable Actuators";
+    case MAKELONG(PID_USAGE_DC_STOP_ALL_EFFECTS, HID_USAGE_PAGE_PID): return L"DC Stop All Effects";
+
+    case MAKELONG(PID_USAGE_DEVICE_GAIN, HID_USAGE_PAGE_PID): return L"Device Gain";
+    case MAKELONG(PID_USAGE_DEVICE_GAIN_REPORT, HID_USAGE_PAGE_PID): return L"Device Gain Report";
+    case MAKELONG(PID_USAGE_CP_OFFSET, HID_USAGE_PAGE_PID): return L"CP Offset";
+    case MAKELONG(PID_USAGE_DEAD_BAND, HID_USAGE_PAGE_PID): return L"Dead Band";
+    case MAKELONG(PID_USAGE_DEVICE_CONTROL, HID_USAGE_PAGE_PID): return L"PID Device Control";
+    case MAKELONG(PID_USAGE_DEVICE_CONTROL_REPORT, HID_USAGE_PAGE_PID): return L"PID Device Control Report";
+    case MAKELONG(PID_USAGE_DIRECTION, HID_USAGE_PAGE_PID): return L"Direction";
+    case MAKELONG(PID_USAGE_DIRECTION_ENABLE, HID_USAGE_PAGE_PID): return L"Direction Enable";
+    case MAKELONG(PID_USAGE_DURATION, HID_USAGE_PAGE_PID): return L"Duration";
+    case MAKELONG(PID_USAGE_EFFECT_BLOCK_INDEX, HID_USAGE_PAGE_PID): return L"Effect Block Index";
+    case MAKELONG(PID_USAGE_EFFECT_OPERATION, HID_USAGE_PAGE_PID): return L"Effect Operation";
+    case MAKELONG(PID_USAGE_EFFECT_OPERATION_REPORT, HID_USAGE_PAGE_PID): return L"Effect Operation Report";
+    case MAKELONG(PID_USAGE_EFFECT_TYPE, HID_USAGE_PAGE_PID): return L"Effect Type";
+
+    case MAKELONG(PID_USAGE_ET_CONSTANT_FORCE, HID_USAGE_PAGE_PID): return L"ET Constant Force";
+    case MAKELONG(PID_USAGE_ET_CUSTOM_FORCE_DATA, HID_USAGE_PAGE_PID): return L"ET Custom Force Data";
+    case MAKELONG(PID_USAGE_ET_DAMPER, HID_USAGE_PAGE_PID): return L"ET Damper";
+    case MAKELONG(PID_USAGE_ET_FRICTION, HID_USAGE_PAGE_PID): return L"ET Friction";
+    case MAKELONG(PID_USAGE_ET_INERTIA, HID_USAGE_PAGE_PID): return L"ET Inertia";
+    case MAKELONG(PID_USAGE_ET_RAMP, HID_USAGE_PAGE_PID): return L"ET Ramp";
+    case MAKELONG(PID_USAGE_ET_SAWTOOTH_DOWN, HID_USAGE_PAGE_PID): return L"ET Sawtooth Down";
+    case MAKELONG(PID_USAGE_ET_SAWTOOTH_UP, HID_USAGE_PAGE_PID): return L"ET Sawtooth Up";
+    case MAKELONG(PID_USAGE_ET_SINE, HID_USAGE_PAGE_PID): return L"ET Sine";
+    case MAKELONG(PID_USAGE_ET_SPRING, HID_USAGE_PAGE_PID): return L"ET Spring";
+    case MAKELONG(PID_USAGE_ET_SQUARE, HID_USAGE_PAGE_PID): return L"ET Square";
+    case MAKELONG(PID_USAGE_ET_TRIANGLE, HID_USAGE_PAGE_PID): return L"ET Triangle";
+
+    case MAKELONG(PID_USAGE_NEGATIVE_COEFFICIENT, HID_USAGE_PAGE_PID): return L"Negative Coefficient";
+    case MAKELONG(PID_USAGE_NEGATIVE_SATURATION, HID_USAGE_PAGE_PID): return L"Negative Saturation";
+    case MAKELONG(PID_USAGE_POSITIVE_COEFFICIENT, HID_USAGE_PAGE_PID): return L"Positive Coefficient";
+    case MAKELONG(PID_USAGE_POSITIVE_SATURATION, HID_USAGE_PAGE_PID): return L"Positive Saturation";
+    case MAKELONG(PID_USAGE_SET_CONDITION_REPORT, HID_USAGE_PAGE_PID): return L"Set Condition Report";
+    case MAKELONG(PID_USAGE_TYPE_SPECIFIC_BLOCK_OFFSET, HID_USAGE_PAGE_PID): return L"Type Specific Block Offset";
+
+    case MAKELONG(PID_USAGE_FADE_LEVEL, HID_USAGE_PAGE_PID): return L"Fade Level";
+    case MAKELONG(PID_USAGE_FADE_TIME, HID_USAGE_PAGE_PID): return L"Fade Time";
+    case MAKELONG(PID_USAGE_LOOP_COUNT, HID_USAGE_PAGE_PID): return L"Loop Count";
+    case MAKELONG(PID_USAGE_MAGNITUDE, HID_USAGE_PAGE_PID): return L"Magnitude";
+    case MAKELONG(PID_USAGE_OP_EFFECT_START, HID_USAGE_PAGE_PID): return L"Op Effect Start";
+    case MAKELONG(PID_USAGE_OP_EFFECT_START_SOLO, HID_USAGE_PAGE_PID): return L"Op Effect Start Solo";
+    case MAKELONG(PID_USAGE_OP_EFFECT_STOP, HID_USAGE_PAGE_PID): return L"Op Effect Stop";
+    case MAKELONG(PID_USAGE_SET_EFFECT_REPORT, HID_USAGE_PAGE_PID): return L"Set Effect Report";
+    case MAKELONG(PID_USAGE_SET_ENVELOPE_REPORT, HID_USAGE_PAGE_PID): return L"Set Envelope Report";
+    case MAKELONG(PID_USAGE_SET_PERIODIC_REPORT, HID_USAGE_PAGE_PID): return L"Set Periodic Report";
+    case MAKELONG(PID_USAGE_START_DELAY, HID_USAGE_PAGE_PID): return L"Start Delay";
+    case MAKELONG(PID_USAGE_STATE_REPORT, HID_USAGE_PAGE_PID): return L"PID State Report";
+    case MAKELONG(PID_USAGE_TRIGGER_BUTTON, HID_USAGE_PAGE_PID): return L"Trigger Button";
+
+    case MAKELONG(PID_USAGE_SET_CONSTANT_FORCE_REPORT, HID_USAGE_PAGE_PID): return L"Set Constant Force Report";
+    case MAKELONG(PID_USAGE_SET_RAMP_FORCE_REPORT, HID_USAGE_PAGE_PID): return L"Set Ramp Force Report";
+
+    case MAKELONG(HID_USAGE_SIMULATION_RUDDER, HID_USAGE_PAGE_SIMULATION): return L"Rudder";
+    case MAKELONG(HID_USAGE_SIMULATION_THROTTLE, HID_USAGE_PAGE_SIMULATION): return L"Throttle";
+    case MAKELONG(HID_USAGE_SIMULATION_ACCELERATOR, HID_USAGE_PAGE_SIMULATION): return L"Accelerator";
+    case MAKELONG(HID_USAGE_SIMULATION_BRAKE, HID_USAGE_PAGE_SIMULATION): return L"Brake";
+    case MAKELONG(HID_USAGE_SIMULATION_CLUTCH, HID_USAGE_PAGE_SIMULATION): return L"Clutch";
+    case MAKELONG(HID_USAGE_SIMULATION_STEERING, HID_USAGE_PAGE_SIMULATION): return L"Steering";
+    default: return NULL;
+    }
+}
+
+static HRESULT find_next_effect_id( struct hid_joystick *impl, ULONG *index, USAGE type )
+{
+    struct pid_device_pool *device_pool = &impl->pid_device_pool;
+    struct pid_new_effect *new_effect = &impl->pid_new_effect;
+    struct pid_block_load *block_load = &impl->pid_block_load;
+    ULONG i, count, report_len = impl->caps.FeatureReportByteLength;
+    NTSTATUS status;
+    USAGE usage;
+
+    if (!device_pool->device_managed_caps)
+    {
+        for (i = 0; i < ARRAY_SIZE(impl->effect_inuse); ++i)
+            if (!impl->effect_inuse[i]) break;
+        if (i == ARRAY_SIZE(impl->effect_inuse)) return DIERR_DEVICEFULL;
+        impl->effect_inuse[i] = TRUE;
+        *index = i + 1;
+    }
+    else
+    {
+        status = HidP_InitializeReportForID( HidP_Feature, new_effect->id, impl->preparsed,
+                                             impl->feature_report_buf, report_len );
+        if (status != HIDP_STATUS_SUCCESS) return status;
+
+        count = 1;
+        status = HidP_SetUsages( HidP_Feature, HID_USAGE_PAGE_PID, new_effect->type_coll,
+                                 &type, &count, impl->preparsed, impl->feature_report_buf, report_len );
+        if (status != HIDP_STATUS_SUCCESS) return status;
+
+        if (!HidD_SetFeature( impl->device, impl->feature_report_buf, report_len )) return DIERR_INPUTLOST;
+
+        status = HidP_InitializeReportForID( HidP_Feature, block_load->id, impl->preparsed,
+                                             impl->feature_report_buf, report_len );
+        if (status != HIDP_STATUS_SUCCESS) return status;
+
+        if (!HidD_GetFeature( impl->device, impl->feature_report_buf, report_len )) return DIERR_INPUTLOST;
+
+        count = 1;
+        status = HidP_GetUsages( HidP_Feature, HID_USAGE_PAGE_PID, block_load->status_coll,
+                                 &usage, &count, impl->preparsed, impl->feature_report_buf, report_len );
+        if (status != HIDP_STATUS_SUCCESS) return status;
+
+        if (count != 1 || usage == PID_USAGE_BLOCK_LOAD_ERROR) return DIERR_INPUTLOST;
+        if (usage == PID_USAGE_BLOCK_LOAD_FULL) return DIERR_DEVICEFULL;
+
+        status = HidP_GetUsageValue( HidP_Feature, HID_USAGE_PAGE_PID, 0, PID_USAGE_EFFECT_BLOCK_INDEX,
+                                     index, impl->preparsed, impl->feature_report_buf, report_len );
+        if (status != HIDP_STATUS_SUCCESS) return status;
+    }
+
+    return DI_OK;
+}
+
+static BOOL enum_object( struct hid_joystick *impl, const DIPROPHEADER *filter, DWORD flags,
+                         enum_object_callback callback, UINT index, struct hid_value_caps *caps,
+                         DIDEVICEOBJECTINSTANCEW *instance, void *data )
+{
+    if (flags != DIDFT_ALL && !(flags & DIDFT_GETTYPE( instance->dwType ))) return DIENUM_CONTINUE;
+
+    switch (filter->dwHow)
+    {
+    case DIPH_DEVICE:
+        return callback( &impl->base, index, caps, instance, data );
+    case DIPH_BYOFFSET:
+        if (filter->dwObj != instance->dwOfs) return DIENUM_CONTINUE;
+        return callback( &impl->base, index, caps, instance, data );
+    case DIPH_BYID:
+        if ((filter->dwObj & 0x00ffffff) != (instance->dwType & 0x00ffffff)) return DIENUM_CONTINUE;
+        return callback( &impl->base, index, caps, instance, data );
+    case DIPH_BYUSAGE:
+        if (HIWORD( filter->dwObj ) != instance->wUsagePage) return DIENUM_CONTINUE;
+        if (LOWORD( filter->dwObj ) != instance->wUsage) return DIENUM_CONTINUE;
+        return callback( &impl->base, index, caps, instance, data );
+    default:
+        FIXME( "unimplemented filter dwHow %#lx dwObj %#lx\n", filter->dwHow, filter->dwObj );
+        break;
+    }
+
+    return DIENUM_CONTINUE;
+}
+
+static void check_pid_effect_axis_caps( struct hid_joystick *impl, DIDEVICEOBJECTINSTANCEW *instance )
+{
+    struct pid_effect_update *effect_update = &impl->pid_effect_update;
+    ULONG i;
+
+    for (i = 0; i < effect_update->axis_count; ++i)
+    {
+        if (effect_update->axis_caps[i]->usage_page != instance->wUsagePage) continue;
+        if (effect_update->axis_caps[i]->usage_min > instance->wUsage) continue;
+        if (effect_update->axis_caps[i]->usage_max >= instance->wUsage) break;
+    }
+
+    if (i == effect_update->axis_count) return;
+    instance->dwType |= DIDFT_FFACTUATOR;
+    instance->dwFlags |= DIDOI_FFACTUATOR;
+}
+
+static void set_axis_type( DIDEVICEOBJECTINSTANCEW *instance, BOOL *seen, DWORD i, DWORD *count )
+{
+    if (!seen[i]) instance->dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( i );
+    else instance->dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 6 + (*count)++ );
+    seen[i] = TRUE;
+}
+
+static BOOL enum_objects( struct hid_joystick *impl, const DIPROPHEADER *filter, DWORD flags,
+                          enum_object_callback callback, void *data )
+{
+    DWORD collection = 0, object = 0, axis = 0, button = 0, pov = 0, value_ofs = 0, button_ofs = 0, j, count, len;
+    struct hid_preparsed_data *preparsed = (struct hid_preparsed_data *)impl->preparsed;
+    DIDEVICEOBJECTINSTANCEW instance = {.dwSize = sizeof(DIDEVICEOBJECTINSTANCEW)};
+    struct hid_value_caps *caps, *caps_end, *nary, *nary_end, *effect_caps;
+    struct hid_collection_node *node, *node_end;
+    WORD version = impl->base.dinput->dwVersion;
+    BOOL ret, seen_axis[6] = {0};
+    const WCHAR *tmp;
+
+    button_ofs += impl->caps.NumberInputValueCaps * sizeof(LONG);
+    if (version >= 0x800)
+    {
+        button_ofs += impl->caps.NumberOutputValueCaps * sizeof(LONG);
+        button_ofs += impl->caps.NumberFeatureValueCaps * sizeof(LONG);
+    }
+
+    for (caps = HID_INPUT_VALUE_CAPS( preparsed ), caps_end = caps + preparsed->input_caps_count;
+         caps != caps_end; ++caps)
+    {
+        if (!caps->usage_page) continue;
+        if (caps->flags & HID_VALUE_CAPS_IS_BUTTON) continue;
+
+        if (caps->usage_page >= HID_USAGE_PAGE_VENDOR_DEFINED_BEGIN)
+            value_ofs += (caps->usage_max - caps->usage_min + 1) * sizeof(LONG);
+        else for (j = caps->usage_min; j <= caps->usage_max; ++j)
+        {
+            instance.dwOfs = value_ofs;
+            switch (MAKELONG(j, caps->usage_page))
+            {
+            case MAKELONG(HID_USAGE_GENERIC_X, HID_USAGE_PAGE_GENERIC):
+            case MAKELONG(HID_USAGE_GENERIC_Y, HID_USAGE_PAGE_GENERIC):
+            case MAKELONG(HID_USAGE_GENERIC_Z, HID_USAGE_PAGE_GENERIC):
+            case MAKELONG(HID_USAGE_GENERIC_RX, HID_USAGE_PAGE_GENERIC):
+            case MAKELONG(HID_USAGE_GENERIC_RY, HID_USAGE_PAGE_GENERIC):
+            case MAKELONG(HID_USAGE_GENERIC_RZ, HID_USAGE_PAGE_GENERIC):
+                set_axis_type( &instance, seen_axis, j - HID_USAGE_GENERIC_X, &axis );
+                instance.dwFlags = DIDOI_ASPECTPOSITION;
+                break;
+            case MAKELONG(HID_USAGE_SIMULATION_STEERING, HID_USAGE_PAGE_SIMULATION):
+                set_axis_type( &instance, seen_axis, 0, &axis );
+                instance.dwFlags = DIDOI_ASPECTPOSITION;
+                break;
+            case MAKELONG(HID_USAGE_SIMULATION_ACCELERATOR, HID_USAGE_PAGE_SIMULATION):
+                set_axis_type( &instance, seen_axis, 1, &axis );
+                instance.dwFlags = DIDOI_ASPECTPOSITION;
+                break;
+            case MAKELONG(HID_USAGE_GENERIC_WHEEL, HID_USAGE_PAGE_GENERIC):
+            case MAKELONG(HID_USAGE_SIMULATION_THROTTLE, HID_USAGE_PAGE_SIMULATION):
+                set_axis_type( &instance, seen_axis, 2, &axis );
+                instance.dwFlags = DIDOI_ASPECTPOSITION;
+                break;
+            case MAKELONG(HID_USAGE_SIMULATION_RUDDER, HID_USAGE_PAGE_SIMULATION):
+            case MAKELONG(HID_USAGE_SIMULATION_BRAKE, HID_USAGE_PAGE_SIMULATION):
+                set_axis_type( &instance, seen_axis, 5, &axis );
+                instance.dwFlags = DIDOI_ASPECTPOSITION;
+                break;
+            case MAKELONG(HID_USAGE_GENERIC_HATSWITCH, HID_USAGE_PAGE_GENERIC):
+                instance.dwType = DIDFT_POV | DIDFT_MAKEINSTANCE( pov++ );
+                instance.dwFlags = 0;
+                break;
+            case MAKELONG(HID_USAGE_GENERIC_SLIDER, HID_USAGE_PAGE_GENERIC):
+            case MAKELONG(HID_USAGE_GENERIC_DIAL, HID_USAGE_PAGE_GENERIC):
+                instance.dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 6 + axis++ );
+                instance.dwFlags = DIDOI_ASPECTPOSITION;
+                break;
+            default:
+                instance.dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 6 + axis++ );
+                instance.dwFlags = 0;
+                break;
+            }
+            instance.wUsagePage = caps->usage_page;
+            instance.wUsage = j;
+            instance.guidType = *object_usage_to_guid( instance.wUsagePage, instance.wUsage );
+            instance.wReportId = caps->report_id;
+            instance.wCollectionNumber = caps->link_collection;
+            instance.dwDimension = caps->units;
+            instance.wExponent = caps->units_exp;
+            if ((tmp = object_usage_to_string( &instance ))) lstrcpynW( instance.tszName, tmp, MAX_PATH );
+            else swprintf( instance.tszName, MAX_PATH, L"Unknown %u", DIDFT_GETINSTANCE( instance.dwType ) );
+            check_pid_effect_axis_caps( impl, &instance );
+            ret = enum_object( impl, filter, flags, callback, object, caps, &instance, data );
+            if (ret != DIENUM_CONTINUE) return ret;
+            value_ofs += sizeof(LONG);
+            object++;
+        }
+    }
+
+    effect_caps = impl->pid_effect_update.trigger_button_caps;
+
+    for (caps = HID_INPUT_VALUE_CAPS( preparsed ), caps_end = caps + preparsed->input_caps_count;
+         caps != caps_end; ++caps)
+    {
+        if (!caps->usage_page) continue;
+        if (!(caps->flags & HID_VALUE_CAPS_IS_BUTTON)) continue;
+
+        if (caps->usage_page >= HID_USAGE_PAGE_VENDOR_DEFINED_BEGIN)
+            button_ofs += caps->usage_max - caps->usage_min + 1;
+        else for (j = caps->usage_min; j <= caps->usage_max; ++j)
+        {
+            instance.dwOfs = button_ofs;
+            instance.dwType = DIDFT_PSHBUTTON | DIDFT_MAKEINSTANCE( button++ );
+            instance.dwFlags = 0;
+            if (effect_caps && effect_caps->logical_min <= j && effect_caps->logical_max >= j)
+            {
+                instance.dwType |= DIDFT_FFEFFECTTRIGGER;
+                instance.dwFlags |= DIDOI_FFEFFECTTRIGGER;
+            }
+            instance.wUsagePage = caps->usage_page;
+            instance.wUsage = j;
+            instance.guidType = *object_usage_to_guid( instance.wUsagePage, instance.wUsage );
+            instance.wReportId = caps->report_id;
+            instance.wCollectionNumber = caps->link_collection;
+            instance.dwDimension = caps->units;
+            instance.wExponent = caps->units_exp;
+            swprintf( instance.tszName, MAX_PATH, L"Button %u", DIDFT_GETINSTANCE( instance.dwType ) );
+            ret = enum_object( impl, filter, flags, callback, object, caps, &instance, data );
+            if (ret != DIENUM_CONTINUE) return ret;
+            button_ofs++;
+            object++;
+        }
+    }
+
+    count = preparsed->output_caps_count + preparsed->feature_caps_count;
+    for (caps = HID_OUTPUT_VALUE_CAPS( preparsed ), caps_end = caps + count;
+         caps != caps_end; ++caps)
+    {
+        if (!caps->usage_page) continue;
+
+        if (caps->usage_page >= HID_USAGE_PAGE_VENDOR_DEFINED_BEGIN)
+        {
+            if (caps->flags & HID_VALUE_CAPS_IS_BUTTON) button_ofs += caps->usage_max - caps->usage_min + 1;
+            else value_ofs += (caps->usage_max - caps->usage_min + 1) * sizeof(LONG);
+        }
+        else if (caps->flags & HID_VALUE_CAPS_ARRAY_HAS_MORE)
+        {
+            for (nary_end = caps - 1; caps != caps_end; caps++)
+                if (!(caps->flags & HID_VALUE_CAPS_ARRAY_HAS_MORE)) break;
+
+            for (nary = caps; nary != nary_end; nary--)
+            {
+                if (version < 0x800) instance.dwOfs = 0;
+                else instance.dwOfs = button_ofs;
+
+                instance.dwType = DIDFT_NODATA | DIDFT_MAKEINSTANCE( object++ ) | DIDFT_OUTPUT;
+                instance.dwFlags = 0x80008000;
+                instance.wUsagePage = nary->usage_page;
+                instance.wUsage = nary->usage_min;
+                instance.guidType = GUID_Unknown;
+                instance.wReportId = nary->report_id;
+                instance.wCollectionNumber = nary->link_collection;
+                instance.dwDimension = caps->units;
+                instance.wExponent = caps->units_exp;
+                if ((tmp = object_usage_to_string( &instance ))) lstrcpynW( instance.tszName, tmp, MAX_PATH );
+                else swprintf( instance.tszName, MAX_PATH, L"Unknown %u", DIDFT_GETINSTANCE( instance.dwType ) );
+                ret = enum_object( impl, filter, flags, callback, -1, nary, &instance, data );
+                if (ret != DIENUM_CONTINUE) return ret;
+                button_ofs++;
+            }
+        }
+        else for (j = caps->usage_min; j <= caps->usage_max; ++j)
+        {
+            if (version < 0x800) instance.dwOfs = 0;
+            else if (caps->flags & HID_VALUE_CAPS_IS_BUTTON) instance.dwOfs = button_ofs;
+            else instance.dwOfs = value_ofs;
+
+            instance.dwType = DIDFT_NODATA | DIDFT_MAKEINSTANCE( object++ ) | DIDFT_OUTPUT;
+            instance.dwFlags = 0x80008000;
+            instance.wUsagePage = caps->usage_page;
+            instance.wUsage = j;
+            instance.guidType = GUID_Unknown;
+            instance.wReportId = caps->report_id;
+            instance.wCollectionNumber = caps->link_collection;
+            instance.dwDimension = caps->units;
+            instance.wExponent = caps->units_exp;
+            if ((tmp = object_usage_to_string( &instance ))) lstrcpynW( instance.tszName, tmp, MAX_PATH );
+            else swprintf( instance.tszName, MAX_PATH, L"Unknown %u", DIDFT_GETINSTANCE( instance.dwType ) );
+            ret = enum_object( impl, filter, flags, callback, -1, caps, &instance, data );
+            if (ret != DIENUM_CONTINUE) return ret;
+
+            if (caps->flags & HID_VALUE_CAPS_IS_BUTTON) button_ofs++;
+            else value_ofs += sizeof(LONG);
+        }
+    }
+
+    for (node = HID_COLLECTION_NODES( preparsed ), node_end = node + preparsed->number_link_collection_nodes;
+         node != node_end; ++node)
+    {
+        if (!node->usage_page) continue;
+        if (node->usage_page < HID_USAGE_PAGE_VENDOR_DEFINED_BEGIN)
+        {
+            instance.dwOfs = 0;
+            instance.dwType = DIDFT_COLLECTION | DIDFT_MAKEINSTANCE( collection++ ) | DIDFT_NODATA;
+            instance.dwFlags = 0;
+            instance.wUsagePage = node->usage_page;
+            instance.wUsage = node->usage;
+            instance.guidType = GUID_Unknown;
+            instance.wReportId = 0;
+            instance.wCollectionNumber = node->parent;
+            instance.dwDimension = 0;
+            instance.wExponent = 0;
+            len = swprintf( instance.tszName, MAX_PATH, L"Collection %u - ", DIDFT_GETINSTANCE( instance.dwType ) );
+            if ((tmp = object_usage_to_string( &instance ))) lstrcpynW( instance.tszName + len, tmp, MAX_PATH - len );
+            else swprintf( instance.tszName + len, MAX_PATH - len, L"Unknown %u", DIDFT_GETINSTANCE( instance.dwType ) );
+            ret = enum_object( impl, filter, flags, callback, -1, NULL, &instance, data );
+            if (ret != DIENUM_CONTINUE) return ret;
+        }
+    }
+
+    return DIENUM_CONTINUE;
+}
+
+static void set_report_value( struct hid_joystick *impl, char *report_buf,
+                              struct hid_value_caps *caps, LONG value )
+{
+    ULONG report_len = impl->caps.OutputReportByteLength;
+    PHIDP_PREPARSED_DATA preparsed = impl->preparsed;
+    NTSTATUS status;
+
+    if (!caps) return;
+
+    status = HidP_SetUsageValue( HidP_Output, caps->usage_page, caps->link_collection,
+                                 caps->usage_min, value, preparsed, report_buf, report_len );
+    if (status != HIDP_STATUS_SUCCESS) WARN( "HidP_SetUsageValue %04x:%04x returned %#lx\n",
+                                             caps->usage_page, caps->usage_min, status );
+}
+
+static void hid_joystick_destroy( IDirectInputDevice8W *iface )
+{
+    struct hid_joystick *impl = impl_from_IDirectInputDevice8W( iface );
+    TRACE( "iface %p.\n", iface );
+
+    free( impl->usages_buf );
+    free( impl->feature_report_buf );
+    free( impl->output_report_buf );
+    free( impl->input_report_buf );
+    HidD_FreePreparsedData( impl->preparsed );
+    CloseHandle( impl->base.read_event );
+    CloseHandle( impl->device );
+}
+
+static HRESULT hid_joystick_get_property( IDirectInputDevice8W *iface, DWORD property,
+                                          DIPROPHEADER *header, const DIDEVICEOBJECTINSTANCEW *instance )
+{
+    struct hid_joystick *impl = impl_from_IDirectInputDevice8W( iface );
+
+    switch (property)
+    {
+    case (DWORD_PTR)DIPROP_PRODUCTNAME:
+    {
+        DIPROPSTRING *value = (DIPROPSTRING *)header;
+        lstrcpynW( value->wsz, impl->base.instance.tszProductName, MAX_PATH );
+        return DI_OK;
+    }
+    case (DWORD_PTR)DIPROP_INSTANCENAME:
+    {
+        DIPROPSTRING *value = (DIPROPSTRING *)header;
+        lstrcpynW( value->wsz, impl->base.instance.tszInstanceName, MAX_PATH );
+        return DI_OK;
+    }
+    case (DWORD_PTR)DIPROP_VIDPID:
+    {
+        DIPROPDWORD *value = (DIPROPDWORD *)header;
+        if (!impl->attrs.VendorID || !impl->attrs.ProductID) return DIERR_UNSUPPORTED;
+        value->dwData = MAKELONG( impl->attrs.VendorID, impl->attrs.ProductID );
+        return DI_OK;
+    }
+    case (DWORD_PTR)DIPROP_JOYSTICKID:
+    {
+        DIPROPDWORD *value = (DIPROPDWORD *)header;
+        value->dwData = impl->base.instance.guidInstance.Data3;
+        return DI_OK;
+    }
+    case (DWORD_PTR)DIPROP_GUIDANDPATH:
+    {
+        DIPROPGUIDANDPATH *value = (DIPROPGUIDANDPATH *)header;
+        value->guidClass = GUID_DEVCLASS_HIDCLASS;
+        lstrcpynW( value->wszPath, impl->device_path, MAX_PATH );
+        return DI_OK;
+    }
+    case (DWORD_PTR)DIPROP_FFLOAD:
+    {
+        DIPROPDWORD *value = (DIPROPDWORD *)header;
+        if (!(impl->base.caps.dwFlags & DIDC_FORCEFEEDBACK)) return DIERR_UNSUPPORTED;
+        if (!is_exclusively_acquired( impl )) return DIERR_NOTEXCLUSIVEACQUIRED;
+        value->dwData = 0;
+        return DI_OK;
+    }
+    }
+
+    return DIERR_UNSUPPORTED;
+}
+
+static LONG scale_to_logical_value( LONG value, struct hid_value_caps *caps )
+{
+    LONG log_min, log_max, phy_min, phy_max;
+
+    if (!caps) return value;
+
+    log_min = caps->logical_min;
+    log_max = caps->logical_max;
+    phy_min = caps->physical_min;
+    phy_max = caps->physical_max;
+
+    if (phy_max || phy_min)
+    {
+        if (value > phy_max || value < phy_min) value = -1;
+        else value = log_min + (value - phy_min) * (log_max - log_min) / (phy_max - phy_min);
+    }
+
+    return value;
+}
+
+static LONG clamp_to_physical_value( LONG value, struct hid_value_caps *caps )
+{
+    LONG phy_min, phy_max;
+
+    if (!caps) return value;
+
+    phy_min = caps->physical_min;
+    phy_max = caps->physical_max;
+    return max( min( value, phy_max ), phy_min );
+}
+
+static HRESULT hid_joystick_send_device_gain( IDirectInputDevice8W *iface, LONG device_gain )
+{
+    struct hid_joystick *impl = impl_from_IDirectInputDevice8W( iface );
+    struct pid_device_gain *report = &impl->pid_device_gain;
+    ULONG report_len = impl->caps.OutputReportByteLength;
+    char *report_buf = impl->output_report_buf;
+    NTSTATUS status;
+
+    TRACE( "iface %p.\n", iface );
+
+    if (!report->id || !report->device_gain_caps) return DI_OK;
+
+    status = HidP_InitializeReportForID( HidP_Output, report->id, impl->preparsed, report_buf, report_len );
+    if (status != HIDP_STATUS_SUCCESS) return status;
+
+    device_gain = clamp_to_physical_value( device_gain, report->device_gain_caps );
+    device_gain = scale_to_logical_value( device_gain, report->device_gain_caps );
+    set_report_value( impl, report_buf, report->device_gain_caps, device_gain );
+
+    if (!WriteFile( impl->device, report_buf, report_len, NULL, NULL )) return DIERR_INPUTLOST;
+    return DI_OK;
+}
+
+static HRESULT hid_joystick_acquire( IDirectInputDevice8W *iface )
+{
+    struct hid_joystick *impl = impl_from_IDirectInputDevice8W( iface );
+    ULONG report_len = impl->caps.InputReportByteLength;
+    BOOL ret;
+
+    if (impl->device == INVALID_HANDLE_VALUE)
+    {
+        impl->device = CreateFileW( impl->device_path, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
+                                    NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, 0 );
+        if (impl->device == INVALID_HANDLE_VALUE) return DIERR_UNPLUGGED;
+    }
+
+    memset( &impl->read_ovl, 0, sizeof(impl->read_ovl) );
+    impl->read_ovl.hEvent = impl->base.read_event;
+    ret = ReadFile( impl->device, impl->input_report_buf, report_len, NULL, &impl->read_ovl );
+    if (!ret && GetLastError() != ERROR_IO_PENDING)
+    {
+        CloseHandle( impl->device );
+        impl->device = INVALID_HANDLE_VALUE;
+        return DIERR_UNPLUGGED;
+    }
+
+    IDirectInputDevice8_SendForceFeedbackCommand( iface, DISFFC_RESET );
+    return DI_OK;
+}
+
+static HRESULT hid_joystick_send_force_feedback_command( IDirectInputDevice8W *iface, DWORD command, BOOL unacquire );
+
+static HRESULT hid_joystick_unacquire( IDirectInputDevice8W *iface )
+{
+    struct hid_joystick *impl = impl_from_IDirectInputDevice8W( iface );
+    BOOL ret;
+
+    if (impl->device == INVALID_HANDLE_VALUE) return DI_NOEFFECT;
+
+    ret = CancelIoEx( impl->device, &impl->read_ovl );
+    if (!ret) WARN( "CancelIoEx failed, last error %lu\n", GetLastError() );
+    else WaitForSingleObject( impl->base.read_event, INFINITE );
+
+    if (!(impl->base.caps.dwFlags & DIDC_FORCEFEEDBACK)) return DI_OK;
+    if (!is_exclusively_acquired( impl )) return DI_OK;
+    hid_joystick_send_force_feedback_command( iface, DISFFC_RESET, TRUE );
+    return DI_OK;
+}
+
+static HRESULT hid_joystick_create_effect( IDirectInputDevice8W *iface, IDirectInputEffect **out );
+
+static HRESULT hid_joystick_get_effect_info( IDirectInputDevice8W *iface, DIEFFECTINFOW *info, const GUID *guid )
+{
+    struct hid_joystick *impl = impl_from_IDirectInputDevice8W( iface );
+    struct pid_effect_update *effect_update = &impl->pid_effect_update;
+    struct pid_set_condition *set_condition = &impl->pid_set_condition;
+    struct pid_set_periodic *set_periodic = &impl->pid_set_periodic;
+    struct pid_set_envelope *set_envelope = &impl->pid_set_envelope;
+    PHIDP_PREPARSED_DATA preparsed = impl->preparsed;
+    HIDP_BUTTON_CAPS button;
+    ULONG type, collection;
+    NTSTATUS status;
+    USAGE usage = 0;
+    USHORT count;
+
+    switch ((usage = effect_guid_to_usage( guid )))
+    {
+    case PID_USAGE_ET_SQUARE:
+    case PID_USAGE_ET_SINE:
+    case PID_USAGE_ET_TRIANGLE:
+    case PID_USAGE_ET_SAWTOOTH_UP:
+    case PID_USAGE_ET_SAWTOOTH_DOWN:
+        type = DIEFT_PERIODIC;
+        break;
+    case PID_USAGE_ET_SPRING:
+    case PID_USAGE_ET_DAMPER:
+    case PID_USAGE_ET_INERTIA:
+    case PID_USAGE_ET_FRICTION:
+        type = DIEFT_CONDITION;
+        break;
+    case PID_USAGE_ET_CONSTANT_FORCE:
+        type = DIEFT_CONSTANTFORCE;
+        break;
+    case PID_USAGE_ET_RAMP:
+        type = DIEFT_RAMPFORCE;
+        break;
+    case PID_USAGE_ET_CUSTOM_FORCE_DATA:
+        type = DIEFT_CUSTOMFORCE;
+        break;
+    default:
+        return DIERR_DEVICENOTREG;
+    }
+
+    if (!(collection = effect_update->collection)) return DIERR_DEVICENOTREG;
+
+    info->dwDynamicParams = DIEP_TYPESPECIFICPARAMS;
+    if (effect_update->axis_count) info->dwDynamicParams |= DIEP_AXES;
+    if (effect_update->duration_caps) info->dwDynamicParams |= DIEP_DURATION;
+    if (effect_update->gain_caps) info->dwDynamicParams |= DIEP_GAIN;
+    if (effect_update->sample_period_caps) info->dwDynamicParams |= DIEP_SAMPLEPERIOD;
+    if (effect_update->start_delay_caps)
+    {
+        type |= DIEFT_STARTDELAY;
+        info->dwDynamicParams |= DIEP_STARTDELAY;
+    }
+    if (effect_update->direction_coll) info->dwDynamicParams |= DIEP_DIRECTION;
+    if (effect_update->axes_coll) info->dwDynamicParams |= DIEP_AXES;
+
+    if (!(collection = effect_update->type_coll)) return DIERR_DEVICENOTREG;
+    else
+    {
+        count = 1;
+        status = HidP_GetSpecificButtonCaps( HidP_Output, HID_USAGE_PAGE_PID, collection,
+                                             usage, &button, &count, preparsed );
+        if (status != HIDP_STATUS_SUCCESS)
+        {
+            WARN( "HidP_GetSpecificButtonCaps %#x returned %#lx\n", usage, status );
+            return DIERR_DEVICENOTREG;
+        }
+        else if (!count)
+        {
+            WARN( "effect usage %#x not found\n", usage );
+            return DIERR_DEVICENOTREG;
+        }
+    }
+
+    if ((DIEFT_GETTYPE(type) == DIEFT_PERIODIC) && (collection = set_periodic->collection))
+    {
+        if (set_periodic->magnitude_caps) info->dwDynamicParams |= DIEP_TYPESPECIFICPARAMS;
+        if (set_periodic->offset_caps) info->dwDynamicParams |= DIEP_TYPESPECIFICPARAMS;
+        if (set_periodic->period_caps) info->dwDynamicParams |= DIEP_TYPESPECIFICPARAMS;
+        if (set_periodic->phase_caps) info->dwDynamicParams |= DIEP_TYPESPECIFICPARAMS;
+    }
+
+    if ((DIEFT_GETTYPE(type) == DIEFT_PERIODIC ||
+         DIEFT_GETTYPE(type) == DIEFT_RAMPFORCE ||
+         DIEFT_GETTYPE(type) == DIEFT_CONSTANTFORCE) &&
+        (collection = set_envelope->collection))
+    {
+        info->dwDynamicParams |= DIEP_ENVELOPE;
+        if (set_envelope->attack_level_caps) type |= DIEFT_FFATTACK;
+        if (set_envelope->attack_time_caps) type |= DIEFT_FFATTACK;
+        if (set_envelope->fade_level_caps) type |= DIEFT_FFFADE;
+        if (set_envelope->fade_time_caps) type |= DIEFT_FFFADE;
+        if (effect_update->trigger_button_caps) info->dwDynamicParams |= DIEP_TRIGGERBUTTON;
+        if (effect_update->trigger_repeat_interval_caps) info->dwDynamicParams |= DIEP_TRIGGERREPEATINTERVAL;
+    }
+
+    if (DIEFT_GETTYPE(type) == DIEFT_CONDITION && (collection = set_condition->collection))
+    {
+        if (set_condition->center_point_offset_caps)
+            info->dwDynamicParams |= DIEP_TYPESPECIFICPARAMS;
+        if (set_condition->positive_coefficient_caps || set_condition->negative_coefficient_caps)
+            info->dwDynamicParams |= DIEP_TYPESPECIFICPARAMS;
+        if (set_condition->positive_saturation_caps || set_condition->negative_saturation_caps)
+        {
+            info->dwDynamicParams |= DIEP_TYPESPECIFICPARAMS;
+            type |= DIEFT_SATURATION;
+        }
+        if (set_condition->dead_band_caps)
+        {
+            info->dwDynamicParams |= DIEP_TYPESPECIFICPARAMS;
+            type |= DIEFT_DEADBAND;
+        }
+    }
+
+    info->guid = *guid;
+    info->dwEffType = type;
+    info->dwStaticParams = info->dwDynamicParams;
+    lstrcpynW( info->tszName, effect_guid_to_string( guid ), MAX_PATH );
+
+    return DI_OK;
+}
+
+static BOOL CALLBACK unload_effect_object( IDirectInputEffect *effect, void *context )
+{
+    IDirectInputEffect_Unload( effect );
+    return DIENUM_CONTINUE;
+}
+
+static HRESULT hid_joystick_send_force_feedback_command( IDirectInputDevice8W *iface, DWORD command, BOOL unacquire )
+{
+    struct hid_joystick *impl = impl_from_IDirectInputDevice8W( iface );
+    struct pid_control_report *report = &impl->pid_device_control;
+    ULONG report_len = impl->caps.OutputReportByteLength;
+    char *report_buf = impl->output_report_buf;
+    NTSTATUS status;
+    USAGE usage;
+    ULONG count;
+
+    TRACE( "iface %p, command %#lx.\n", iface, command );
+
+    switch (command)
+    {
+    case DISFFC_RESET: usage = PID_USAGE_DC_DEVICE_RESET; break;
+    case DISFFC_STOPALL: usage = PID_USAGE_DC_STOP_ALL_EFFECTS; break;
+    case DISFFC_PAUSE: usage = PID_USAGE_DC_DEVICE_PAUSE; break;
+    case DISFFC_CONTINUE: usage = PID_USAGE_DC_DEVICE_CONTINUE; break;
+    case DISFFC_SETACTUATORSON: usage = PID_USAGE_DC_ENABLE_ACTUATORS; break;
+    case DISFFC_SETACTUATORSOFF: usage = PID_USAGE_DC_DISABLE_ACTUATORS; break;
+    }
+
+    if (command == DISFFC_RESET)
+    {
+        IDirectInputDevice8_EnumCreatedEffectObjects( iface, unload_effect_object, NULL, 0 );
+        impl->base.force_feedback_state = DIGFFS_STOPPED | DIGFFS_EMPTY;
+    }
+
+    count = 1;
+    status = HidP_InitializeReportForID( HidP_Output, report->id, impl->preparsed, report_buf, report_len );
+    if (status != HIDP_STATUS_SUCCESS) return status;
+
+    status = HidP_SetUsages( HidP_Output, HID_USAGE_PAGE_PID, report->control_coll, &usage,
+                             &count, impl->preparsed, report_buf, report_len );
+    if (status != HIDP_STATUS_SUCCESS) return status;
+
+    if (!WriteFile( impl->device, report_buf, report_len, NULL, NULL )) return DIERR_INPUTLOST;
+    if (!unacquire && command == DISFFC_RESET)
+    {
+        if (impl->base.autocenter == DIPROPAUTOCENTER_OFF)
+            hid_joystick_send_force_feedback_command( iface, DISFFC_STOPALL, FALSE );
+        hid_joystick_send_device_gain( iface, impl->base.device_gain );
+    }
+
+    return DI_OK;
+}
+
+static HRESULT hid_joystick_enum_created_effect_objects( IDirectInputDevice8W *iface,
+                                                         LPDIENUMCREATEDEFFECTOBJECTSCALLBACK callback,
+                                                         void *context, DWORD flags )
+{
+    struct hid_joystick *impl = impl_from_IDirectInputDevice8W( iface );
+    struct hid_joystick_effect *effect, *next;
+
+    TRACE( "iface %p, callback %p, context %p, flags %#lx.\n", iface, callback, context, flags );
+
+    LIST_FOR_EACH_ENTRY_SAFE(effect, next, &impl->effect_list, struct hid_joystick_effect, entry)
+        if (callback( &effect->IDirectInputEffect_iface, context ) != DIENUM_CONTINUE) break;
+
+    return DI_OK;
+}
+
+struct parse_device_state_params
+{
+    BYTE old_state[DEVICE_STATE_MAX_SIZE];
+    BYTE buttons[128];
+    DWORD time;
+    DWORD seq;
+};
+
+static BOOL check_device_state_button( struct dinput_device *device, UINT index, struct hid_value_caps *caps,
+                                       const DIDEVICEOBJECTINSTANCEW *instance, void *data )
+{
+    IDirectInputDevice8W *iface = &device->IDirectInputDevice8W_iface;
+    struct parse_device_state_params *params = data;
+    BYTE old_value, value;
+
+    if (instance->wReportId != device->device_state_report_id) return DIENUM_CONTINUE;
+
+    value = params->buttons[instance->wUsage - 1];
+    old_value = params->old_state[instance->dwOfs];
+    device->device_state[instance->dwOfs] = value;
+    if (old_value != value) queue_event( iface, index, value, params->time, params->seq );
+
+    return DIENUM_CONTINUE;
+}
+
+static LONG sign_extend( ULONG value, struct object_properties *properties )
+{
+    UINT sign = 1 << (properties->bit_size - 1);
+    if (sign <= 1 || properties->logical_min >= 0) return value;
+    return value - ((value & sign) << 1);
+}
+
+static LONG scale_value( ULONG value, struct object_properties *properties )
+{
+    LONG tmp = sign_extend( value, properties ), log_min, log_max, phy_min, phy_max;
+    log_min = properties->logical_min;
+    log_max = properties->logical_max;
+    phy_min = properties->range_min;
+    phy_max = properties->range_max;
+
+    if (log_min > tmp || log_max < tmp) return -1; /* invalid / null value */
+    return phy_min + MulDiv( tmp - log_min, phy_max - phy_min, log_max - log_min );
+}
+
+static LONG scale_axis_value( ULONG value, struct object_properties *properties )
+{
+    LONG tmp = sign_extend( value, properties ), log_ctr, log_min, log_max, phy_ctr, phy_min, phy_max;
+    ULONG bit_max = (1 << properties->bit_size) - 1;
+
+    log_min = properties->logical_min;
+    log_max = properties->logical_max;
+    phy_min = properties->range_min;
+    phy_max = properties->range_max;
+    /* xinput HID gamepad have bogus logical value range, let's use the bit range instead */
+    if (log_min == 0 && log_max == -1) log_max = bit_max;
+
+    if (phy_min == 0) phy_ctr = phy_max >> 1;
+    else phy_ctr = round( (phy_min + phy_max) / 2.0 );
+    if (log_min == 0) log_ctr = log_max >> 1;
+    else log_ctr = round( (log_min + log_max) / 2.0 );
+
+    tmp -= log_ctr;
+    if (tmp <= 0)
+    {
+        log_max = MulDiv( log_min - log_ctr, properties->deadzone, 10000 );
+        log_min = MulDiv( log_min - log_ctr, properties->saturation, 10000 );
+        phy_max = phy_ctr;
+    }
+    else
+    {
+        log_min = MulDiv( log_max - log_ctr, properties->deadzone, 10000 );
+        log_max = MulDiv( log_max - log_ctr, properties->saturation, 10000 );
+        phy_min = phy_ctr;
+    }
+
+    if (tmp <= log_min) return phy_min;
+    if (tmp >= log_max) return phy_max;
+    return phy_min + MulDiv( tmp - log_min, phy_max - phy_min, log_max - log_min );
+}
+
+static BOOL read_device_state_value( struct dinput_device *device, UINT index, struct hid_value_caps *caps,
+                                     const DIDEVICEOBJECTINSTANCEW *instance, void *data )
+{
+    struct hid_joystick *impl = CONTAINING_RECORD( device, struct hid_joystick, base );
+    IDirectInputDevice8W *iface = &impl->base.IDirectInputDevice8W_iface;
+    ULONG logical_value, report_len = impl->caps.InputReportByteLength;
+    struct parse_device_state_params *params = data;
+    char *report_buf = impl->input_report_buf;
+    struct object_properties *properties;
+    LONG old_value, value;
+    NTSTATUS status;
+
+    if (index == -1) return DIENUM_STOP;
+    properties = device->object_properties + index;
+
+    if (instance->wReportId != impl->base.device_state_report_id) return DIENUM_CONTINUE;
+
+    status = HidP_GetUsageValue( HidP_Input, instance->wUsagePage, 0, instance->wUsage,
+                                 &logical_value, impl->preparsed, report_buf, report_len );
+    if (status != HIDP_STATUS_SUCCESS) WARN( "HidP_GetUsageValue %04x:%04x returned %#lx\n",
+                                             instance->wUsagePage, instance->wUsage, status );
+    if (instance->dwType & DIDFT_AXIS) value = scale_axis_value( logical_value, properties );
+    else value = scale_value( logical_value, properties );
+
+    old_value = *(LONG *)(params->old_state + instance->dwOfs);
+    *(LONG *)(impl->base.device_state + instance->dwOfs) = value;
+    if (old_value != value) queue_event( iface, index, value, params->time, params->seq );
+
+    return DIENUM_CONTINUE;
+}
+
+static HRESULT hid_joystick_read( IDirectInputDevice8W *iface )
+{
+    static const DIPROPHEADER filter =
+    {
+        .dwSize = sizeof(filter),
+        .dwHeaderSize = sizeof(filter),
+        .dwHow = DIPH_DEVICE,
+    };
+    struct hid_joystick *impl = impl_from_IDirectInputDevice8W( iface );
+    ULONG i, index, count, report_len = impl->caps.InputReportByteLength;
+    DIDATAFORMAT *format = &impl->base.device_format;
+    char *report_buf = impl->input_report_buf;
+    struct parse_device_state_params params;
+    struct hid_joystick_effect *effect;
+    UINT device_state, effect_state;
+    USAGE_AND_PAGE *usages;
+    NTSTATUS status;
+    HRESULT hr;
+    BOOL ret;
+
+    ret = GetOverlappedResult( impl->device, &impl->read_ovl, &count, FALSE );
+
+    EnterCriticalSection( &impl->base.crit );
+    while (ret)
+    {
+        if (TRACE_ON(dinput))
+        {
+            TRACE( "iface %p, size %lu, report:\n", iface, count );
+            for (i = 0; i < count;)
+            {
+                char buffer[256], *buf = buffer;
+                buf += sprintf(buf, "%08lx ", i);
+                do { buf += sprintf(buf, " %02x", (BYTE)report_buf[i] ); }
+                while (++i % 16 && i < count);
+                TRACE("%s\n", buffer);
+            }
+        }
+
+        count = impl->usages_count;
+        memset( impl->usages_buf, 0, count * sizeof(*impl->usages_buf) );
+        status = HidP_GetUsagesEx( HidP_Input, 0, impl->usages_buf, &count,
+                                   impl->preparsed, report_buf, report_len );
+        if (status != HIDP_STATUS_SUCCESS) WARN( "HidP_GetUsagesEx returned %#lx\n", status );
+
+        if (report_buf[0] == impl->base.device_state_report_id)
+        {
+            params.time = GetCurrentTime();
+            params.seq = impl->base.dinput->evsequence++;
+            memcpy( params.old_state, impl->base.device_state, format->dwDataSize );
+            memset( params.buttons, 0, sizeof(params.buttons) );
+            memset( impl->base.device_state, 0, format->dwDataSize );
+
+            while (count--)
+            {
+                usages = impl->usages_buf + count;
+                if (usages->UsagePage != HID_USAGE_PAGE_BUTTON)
+                    WARN( "unimplemented usage page %x.\n", usages->UsagePage );
+                else if (usages->Usage >= 128)
+                    FIXME( "ignoring extraneous button %d.\n", usages->Usage );
+                else
+                    params.buttons[usages->Usage - 1] = 0x80;
+            }
+
+            enum_objects( impl, &filter, DIDFT_AXIS | DIDFT_POV, read_device_state_value, &params );
+            enum_objects( impl, &filter, DIDFT_BUTTON, check_device_state_button, &params );
+            if (impl->base.hEvent && memcmp( &params.old_state, impl->base.device_state, format->dwDataSize ))
+                SetEvent( impl->base.hEvent );
+        }
+        else if (report_buf[0] == impl->pid_effect_state.id && is_exclusively_acquired( impl ))
+        {
+            status = HidP_GetUsageValue( HidP_Input, HID_USAGE_PAGE_PID, 0, PID_USAGE_EFFECT_BLOCK_INDEX,
+                                         &index, impl->preparsed, report_buf, report_len );
+            if (status != HIDP_STATUS_SUCCESS) WARN( "HidP_GetUsageValue EFFECT_BLOCK_INDEX returned %#lx\n", status );
+
+            effect_state = 0;
+            device_state = impl->base.force_feedback_state & DIGFFS_EMPTY;
+            while (count--)
+            {
+                USAGE_AND_PAGE *button = impl->usages_buf + count;
+                if (button->UsagePage != HID_USAGE_PAGE_PID)
+                    FIXME( "unimplemented usage page %#04x.\n", button->UsagePage );
+                else switch (button->Usage)
+                {
+                case PID_USAGE_DEVICE_PAUSED: device_state |= DIGFFS_PAUSED; break;
+                case PID_USAGE_ACTUATORS_ENABLED: device_state |= DIGFFS_ACTUATORSON; break;
+                case PID_USAGE_SAFETY_SWITCH: device_state |= DIGFFS_SAFETYSWITCHON; break;
+                case PID_USAGE_ACTUATOR_OVERRIDE_SWITCH: device_state |= DIGFFS_USERFFSWITCHON; break;
+                case PID_USAGE_ACTUATOR_POWER: device_state |= DIGFFS_POWERON; break;
+                case PID_USAGE_EFFECT_PLAYING: effect_state = DIEGES_PLAYING; break;
+                default: FIXME( "unimplemented usage %#04x\n", button->Usage ); break;
+                }
+            }
+            if (!(device_state & DIGFFS_ACTUATORSON)) device_state |= DIGFFS_ACTUATORSOFF;
+            if (!(device_state & DIGFFS_SAFETYSWITCHON) && impl->pid_effect_state.safety_switch_caps)
+                device_state |= DIGFFS_SAFETYSWITCHOFF;
+            if (!(device_state & DIGFFS_USERFFSWITCHON) && impl->pid_effect_state.actuator_override_switch_caps)
+                device_state |= DIGFFS_USERFFSWITCHOFF;
+            if (!(device_state & DIGFFS_POWERON) && impl->pid_effect_state.actuator_power_caps)
+                device_state |= DIGFFS_POWEROFF;
+
+            TRACE( "effect %lu state %#x, device state %#x\n", index, effect_state, device_state );
+
+            LIST_FOR_EACH_ENTRY( effect, &impl->effect_list, struct hid_joystick_effect, entry )
+                if (effect->index == index) effect->status = effect_state;
+            impl->base.force_feedback_state = device_state;
+        }
+
+        memset( &impl->read_ovl, 0, sizeof(impl->read_ovl) );
+        impl->read_ovl.hEvent = impl->base.read_event;
+        ret = ReadFile( impl->device, report_buf, report_len, &count, &impl->read_ovl );
+    }
+
+    if (GetLastError() == ERROR_IO_PENDING || GetLastError() == ERROR_OPERATION_ABORTED) hr = DI_OK;
+    else
+    {
+        WARN( "GetOverlappedResult/ReadFile failed, error %lu\n", GetLastError() );
+        CloseHandle(impl->device);
+        impl->device = INVALID_HANDLE_VALUE;
+        hr = DIERR_INPUTLOST;
+    }
+    LeaveCriticalSection( &impl->base.crit );
+
+    return hr;
+}
+
+static HRESULT hid_joystick_enum_objects( IDirectInputDevice8W *iface, const DIPROPHEADER *filter,
+                                          DWORD flags, enum_object_callback callback, void *context )
+{
+    struct hid_joystick *impl = impl_from_IDirectInputDevice8W( iface );
+    return enum_objects( impl, filter, flags, callback, context );
+}
+
+static const struct dinput_device_vtbl hid_joystick_vtbl =
+{
+    hid_joystick_destroy,
+    NULL,
+    hid_joystick_read,
+    hid_joystick_acquire,
+    hid_joystick_unacquire,
+    hid_joystick_enum_objects,
+    hid_joystick_get_property,
+    hid_joystick_get_effect_info,
+    hid_joystick_create_effect,
+    hid_joystick_send_force_feedback_command,
+    hid_joystick_send_device_gain,
+    hid_joystick_enum_created_effect_objects,
+};
+
+static DWORD device_type_for_version( DWORD type, DWORD version )
+{
+    if (version >= 0x0800) return type;
+
+    switch (GET_DIDEVICE_TYPE( type ))
+    {
+    case DI8DEVTYPE_JOYSTICK:
+        if (GET_DIDEVICE_SUBTYPE( type ) == DI8DEVTYPEJOYSTICK_LIMITED)
+            return DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_UNKNOWN << 8) | DIDEVTYPE_HID;
+        return DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_TRADITIONAL << 8) | DIDEVTYPE_HID;
+
+    case DI8DEVTYPE_GAMEPAD:
+        return DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_GAMEPAD << 8) | DIDEVTYPE_HID;
+
+    case DI8DEVTYPE_DRIVING:
+        return DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_WHEEL << 8) | DIDEVTYPE_HID;
+
+    case DI8DEVTYPE_FLIGHT:
+        return DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_FLIGHTSTICK << 8) | DIDEVTYPE_HID;
+
+    case DI8DEVTYPE_SUPPLEMENTAL:
+        if (GET_DIDEVICE_SUBTYPE( type ) == DI8DEVTYPESUPPLEMENTAL_HEADTRACKER)
+            return DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_HEADTRACKER << 8) | DIDEVTYPE_HID;
+        if (GET_DIDEVICE_SUBTYPE( type ) == DI8DEVTYPESUPPLEMENTAL_RUDDERPEDALS)
+            return DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_RUDDER << 8) | DIDEVTYPE_HID;
+        return DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_UNKNOWN << 8) | DIDEVTYPE_HID;
+
+    case DI8DEVTYPE_1STPERSON:
+        return DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_UNKNOWN << 8) | DIDEVTYPE_HID;
+
+    default:
+        return DIDEVTYPE_DEVICE | DIDEVTYPE_HID;
+    }
+}
+
+static HRESULT hid_joystick_device_try_open( const WCHAR *path, HANDLE *device, PHIDP_PREPARSED_DATA *preparsed,
+                                             HIDD_ATTRIBUTES *attrs, HIDP_CAPS *caps, DIDEVICEINSTANCEW *instance,
+                                             DWORD version )
+{
+    BOOL has_accelerator, has_brake, has_clutch, has_z, has_pov;
+    PHIDP_PREPARSED_DATA preparsed_data = NULL;
+    HIDP_LINK_COLLECTION_NODE nodes[256];
+    DWORD type, size, button_count = 0;
+    HIDP_BUTTON_CAPS buttons[10];
+    HIDP_VALUE_CAPS value;
+    HANDLE device_file;
+    ULONG node_count;
+    NTSTATUS status;
+    UINT32 handle;
+    USHORT count;
+
+    device_file = CreateFileW( path, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
+                               NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, 0 );
+    if (device_file == INVALID_HANDLE_VALUE) return DIERR_DEVICENOTREG;
+
+    if (!HidD_GetPreparsedData( device_file, &preparsed_data )) goto failed;
+    if (!HidD_GetAttributes( device_file, attrs )) goto failed;
+    if (HidP_GetCaps( preparsed_data, caps ) != HIDP_STATUS_SUCCESS) goto failed;
+
+    switch (MAKELONG( caps->Usage, caps->UsagePage ))
+    {
+    case MAKELONG( HID_USAGE_GENERIC_MOUSE, HID_USAGE_PAGE_GENERIC ):  goto failed;
+    case MAKELONG( HID_USAGE_GENERIC_KEYBOARD, HID_USAGE_PAGE_GENERIC ):  goto failed;
+    case MAKELONG( HID_USAGE_GENERIC_GAMEPAD, HID_USAGE_PAGE_GENERIC ): type = DI8DEVTYPE_GAMEPAD; break;
+    case MAKELONG( HID_USAGE_GENERIC_JOYSTICK, HID_USAGE_PAGE_GENERIC ): type = DI8DEVTYPE_JOYSTICK; break;
+    default: FIXME( "device usage %04x:%04x not implemented!\n", caps->UsagePage, caps->Usage); goto failed;
+    }
+
+    if (!HidD_GetProductString( device_file, instance->tszInstanceName, MAX_PATH * sizeof(WCHAR) )) goto failed;
+    if (!HidD_GetProductString( device_file, instance->tszProductName, MAX_PATH * sizeof(WCHAR) )) goto failed;
+
+    if (!DeviceIoControl( device_file, IOCTL_HID_GET_WINE_RAWINPUT_HANDLE, NULL, 0, &handle, sizeof(handle), &size, NULL ))
+    {
+        ERR( "failed to get raw input handle, error %lu\n", GetLastError() );
+        goto failed;
+    }
+
+    instance->guidInstance = hid_joystick_guid;
+    instance->guidInstance.Data1 ^= handle;
+    instance->guidProduct = dinput_pidvid_guid;
+    instance->guidProduct.Data1 = MAKELONG( attrs->VendorID, attrs->ProductID );
+    instance->guidFFDriver = GUID_NULL;
+    instance->wUsagePage = caps->UsagePage;
+    instance->wUsage = caps->Usage;
+
+    node_count = ARRAY_SIZE(nodes);
+    status = HidP_GetLinkCollectionNodes( nodes, &node_count, preparsed_data );
+    if (status != HIDP_STATUS_SUCCESS) node_count = 0;
+    while (node_count--)
+    {
+        if (nodes[node_count].LinkUsagePage != HID_USAGE_PAGE_SIMULATION) continue;
+        if (nodes[node_count].LinkUsage == HID_USAGE_SIMULATION_AUTOMOBILE_SIMULATION_DEVICE) type = DI8DEVTYPE_DRIVING;
+        if (nodes[node_count].LinkUsage == HID_USAGE_SIMULATION_FLIGHT_SIMULATION_DEVICE) type = DI8DEVTYPE_FLIGHT;
+    }
+
+    count = ARRAY_SIZE(buttons);
+    status = HidP_GetSpecificButtonCaps( HidP_Output, HID_USAGE_PAGE_PID, 0,
+                                         PID_USAGE_DC_DEVICE_RESET, buttons, &count, preparsed_data );
+    if (status == HIDP_STATUS_SUCCESS && count > 0)
+        instance->guidFFDriver = IID_IDirectInputPIDDriver;
+
+    count = ARRAY_SIZE(buttons);
+    status = HidP_GetSpecificButtonCaps( HidP_Input, HID_USAGE_PAGE_BUTTON, 0, 0, buttons, &count, preparsed_data );
+    if (status != HIDP_STATUS_SUCCESS) count = button_count = 0;
+    while (count--)
+    {
+        if (!buttons[count].IsRange) button_count += 1;
+        else button_count += buttons[count].Range.UsageMax - buttons[count].Range.UsageMin + 1;
+    }
+
+    count = 1;
+    status = HidP_GetSpecificValueCaps( HidP_Input, HID_USAGE_PAGE_GENERIC, 0, HID_USAGE_GENERIC_X,
+                                        &value, &count, preparsed_data );
+    if (status != HIDP_STATUS_SUCCESS || !count) type = DI8DEVTYPE_SUPPLEMENTAL;
+
+    count = 1;
+    status = HidP_GetSpecificValueCaps( HidP_Input, HID_USAGE_PAGE_GENERIC, 0, HID_USAGE_GENERIC_Y,
+                                        &value, &count, preparsed_data );
+    if (status != HIDP_STATUS_SUCCESS || !count) type = DI8DEVTYPE_SUPPLEMENTAL;
+
+    count = 1;
+    status = HidP_GetSpecificValueCaps( HidP_Input, HID_USAGE_PAGE_SIMULATION, 0, HID_USAGE_SIMULATION_STEERING,
+                                        &value, &count, preparsed_data );
+    if (status == HIDP_STATUS_SUCCESS && count) type = DI8DEVTYPE_DRIVING;
+
+    switch (GET_DIDEVICE_TYPE(type))
+    {
+    case DI8DEVTYPE_SUPPLEMENTAL:
+        type |= (DI8DEVTYPESUPPLEMENTAL_UNKNOWN << 8);
+        break;
+    case DI8DEVTYPE_GAMEPAD:
+        if (button_count < 6) type |= (DI8DEVTYPEGAMEPAD_LIMITED << 8);
+        else type |= (DI8DEVTYPEGAMEPAD_STANDARD << 8);
+        break;
+    case DI8DEVTYPE_JOYSTICK:
+        count = 1;
+        status = HidP_GetSpecificValueCaps( HidP_Input, HID_USAGE_PAGE_GENERIC, 0,
+                                            HID_USAGE_GENERIC_Z, &value, &count, preparsed_data );
+        has_z = (status == HIDP_STATUS_SUCCESS && count);
+
+        count = 1;
+        status = HidP_GetSpecificValueCaps( HidP_Input, HID_USAGE_PAGE_GENERIC, 0,
+                                            HID_USAGE_GENERIC_HATSWITCH, &value, &count, preparsed_data );
+        has_pov = (status == HIDP_STATUS_SUCCESS && count);
+
+        if (button_count < 5 || !has_z || !has_pov)
+            type |= (DI8DEVTYPEJOYSTICK_LIMITED << 8);
+        else
+            type |= (DI8DEVTYPEJOYSTICK_STANDARD << 8);
+        break;
+    case DI8DEVTYPE_DRIVING:
+        count = 1;
+        status = HidP_GetSpecificValueCaps( HidP_Input, HID_USAGE_PAGE_SIMULATION, 0, HID_USAGE_SIMULATION_ACCELERATOR,
+                                            &value, &count, preparsed_data );
+        has_accelerator = (status == HIDP_STATUS_SUCCESS && count);
+
+        count = 1;
+        status = HidP_GetSpecificValueCaps( HidP_Input, HID_USAGE_PAGE_SIMULATION, 0, HID_USAGE_SIMULATION_BRAKE,
+                                            &value, &count, preparsed_data );
+        has_brake = (status == HIDP_STATUS_SUCCESS && count);
+
+        count = 1;
+        status = HidP_GetSpecificValueCaps( HidP_Input, HID_USAGE_PAGE_SIMULATION, 0, HID_USAGE_SIMULATION_CLUTCH,
+                                            &value, &count, preparsed_data );
+        has_clutch = (status == HIDP_STATUS_SUCCESS && count);
+
+        if (button_count < 4)
+            type |= (DI8DEVTYPEDRIVING_LIMITED << 8);
+        else if (has_accelerator && has_brake && has_clutch)
+            type |= (DI8DEVTYPEDRIVING_THREEPEDALS << 8);
+        else if (has_accelerator && has_brake)
+            type |= (DI8DEVTYPEDRIVING_DUALPEDALS << 8);
+        else
+            type |= (DI8DEVTYPEDRIVING_LIMITED << 8);
+        break;
+    case DI8DEVTYPE_FLIGHT:
+        type |= (DI8DEVTYPEFLIGHT_STICK << 8);
+        break;
+    }
+
+    instance->dwDevType = device_type_for_version( type, version ) | DIDEVTYPE_HID;
+    TRACE("detected device type %#lx\n", instance->dwDevType);
+
+    *device = device_file;
+    *preparsed = preparsed_data;
+    return DI_OK;
+
+failed:
+    CloseHandle( device_file );
+    HidD_FreePreparsedData( preparsed_data );
+    return DIERR_DEVICENOTREG;
+}
+
+static HRESULT hid_joystick_device_open( int index, const GUID *guid, DIDEVICEINSTANCEW *instance,
+                                         WCHAR *device_path, HANDLE *device, PHIDP_PREPARSED_DATA *preparsed,
+                                         HIDD_ATTRIBUTES *attrs, HIDP_CAPS *caps, DWORD version )
+{
+    char buffer[sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_W) + MAX_PATH * sizeof(WCHAR)];
+    SP_DEVICE_INTERFACE_DETAIL_DATA_W *detail = (void *)buffer;
+    SP_DEVICE_INTERFACE_DATA iface = {.cbSize = sizeof(iface)};
+    SP_DEVINFO_DATA devinfo = {.cbSize = sizeof(devinfo)};
+    WCHAR device_id[MAX_PATH], *tmp;
+    HDEVINFO set, xi_set;
+    BOOL override;
+    UINT32 i = 0;
+    GUID hid;
+
+    TRACE( "index %d, guid %s\n", index, debugstr_guid( guid ) );
+
+    HidD_GetHidGuid( &hid );
+
+    set = SetupDiGetClassDevsW( &hid, NULL, NULL, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT );
+    if (set == INVALID_HANDLE_VALUE) return DIERR_DEVICENOTREG;
+    xi_set = SetupDiGetClassDevsW( &GUID_DEVINTERFACE_WINEXINPUT, NULL, NULL, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT );
+
+    *device = NULL;
+    *preparsed = NULL;
+    while (SetupDiEnumDeviceInterfaces( set, NULL, &hid, i++, &iface ))
+    {
+        detail->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_W);
+        if (!SetupDiGetDeviceInterfaceDetailW( set, &iface, detail, sizeof(buffer), NULL, &devinfo ))
+            continue;
+        if (FAILED(hid_joystick_device_try_open( detail->DevicePath, device, preparsed,
+                                                 attrs, caps, instance, version )))
+            continue;
+
+        if (device_instance_is_disabled( instance, &override ))
+            goto next;
+
+        if (override && SetupDiGetDeviceInstanceIdW( set, &devinfo, device_id, MAX_PATH, NULL ) &&
+            (tmp = wcsstr( device_id, L"&IG_" )))
+        {
+            memcpy( tmp, L"&XI_", sizeof(L"&XI_") - sizeof(WCHAR) );
+            if (!SetupDiOpenDeviceInfoW( xi_set, device_id, NULL, 0, &devinfo ))
+                goto next;
+            if (!SetupDiEnumDeviceInterfaces( xi_set, &devinfo, &GUID_DEVINTERFACE_WINEXINPUT, 0, &iface ))
+                goto next;
+            if (!SetupDiGetDeviceInterfaceDetailW( xi_set, &iface, detail, sizeof(buffer), NULL, &devinfo ))
+                goto next;
+
+            CloseHandle( *device );
+            HidD_FreePreparsedData( *preparsed );
+            if (FAILED(hid_joystick_device_try_open( detail->DevicePath, device, preparsed,
+                                                     attrs, caps, instance, version )))
+                continue;
+        }
+
+        /* enumerate device by GUID */
+        if (IsEqualGUID( guid, &instance->guidProduct ) || IsEqualGUID( guid, &instance->guidInstance )) break;
+
+        /* enumerate all devices */
+        if (index >= 0 && !index--) break;
+
+    next:
+        CloseHandle( *device );
+        HidD_FreePreparsedData( *preparsed );
+        *device = NULL;
+        *preparsed = NULL;
+    }
+
+    if (xi_set != INVALID_HANDLE_VALUE) SetupDiDestroyDeviceInfoList( xi_set );
+    SetupDiDestroyDeviceInfoList( set );
+    if (!*device || !*preparsed) return DIERR_DEVICENOTREG;
+
+    lstrcpynW( device_path, detail->DevicePath, MAX_PATH );
+    return DI_OK;
+}
+
+HRESULT hid_joystick_enum_device( DWORD type, DWORD flags, DIDEVICEINSTANCEW *instance, DWORD version, int index )
+{
+    HIDD_ATTRIBUTES attrs = {.Size = sizeof(attrs)};
+    PHIDP_PREPARSED_DATA preparsed;
+    WCHAR device_path[MAX_PATH];
+    GUID guid = GUID_NULL;
+    HIDP_CAPS caps;
+    HANDLE device;
+    HRESULT hr;
+
+    TRACE( "type %#lx, flags %#lx, instance %p, version %#lx, index %d\n", type, flags, instance, version, index );
+
+    hr = hid_joystick_device_open( index, &guid, instance, device_path, &device, &preparsed,
+                                   &attrs, &caps, version );
+    if (hr != DI_OK) return hr;
+
+    HidD_FreePreparsedData( preparsed );
+    CloseHandle( device );
+
+    TRACE( "found device %s, usage %04x:%04x, product %s, instance %s, name %s\n", debugstr_w(device_path),
+           instance->wUsagePage, instance->wUsage, debugstr_guid( &instance->guidProduct ),
+           debugstr_guid( &instance->guidInstance ), debugstr_w(instance->tszInstanceName) );
+
+    return DI_OK;
+}
+
+static BOOL init_object_properties( struct dinput_device *device, UINT index, struct hid_value_caps *caps,
+                                    const DIDEVICEOBJECTINSTANCEW *instance, void *data )
+{
+    struct object_properties *properties;
+    LONG tmp;
+
+    if (index == -1) return DIENUM_STOP;
+    properties = device->object_properties + index;
+
+    properties->bit_size = caps->bit_size;
+    properties->physical_min = caps->physical_min;
+    properties->physical_max = caps->physical_max;
+    properties->logical_min = caps->logical_min;
+    properties->logical_max = caps->logical_max;
+    properties->range_min = 0;
+    properties->range_max = 0;
+
+    if (instance->dwType & DIDFT_AXIS) properties->range_max = 65535;
+    else
+    {
+        properties->range_max = 36000;
+        tmp = caps->logical_max - caps->logical_min;
+        if (tmp > 0) properties->range_max -= 36000 / (tmp + 1);
+    }
+
+    properties->saturation = 10000;
+    properties->granularity = 1;
+    return DIENUM_CONTINUE;
+}
+
+static BOOL init_pid_reports( struct dinput_device *device, UINT index, struct hid_value_caps *caps,
+                              const DIDEVICEOBJECTINSTANCEW *instance, void *data )
+{
+    struct hid_joystick *impl = CONTAINING_RECORD( device, struct hid_joystick, base );
+    struct pid_set_constant_force *set_constant_force = &impl->pid_set_constant_force;
+    struct pid_set_ramp_force *set_ramp_force = &impl->pid_set_ramp_force;
+    struct pid_control_report *device_control = &impl->pid_device_control;
+    struct pid_control_report *effect_control = &impl->pid_effect_control;
+    struct pid_effect_update *effect_update = &impl->pid_effect_update;
+    struct pid_set_condition *set_condition = &impl->pid_set_condition;
+    struct pid_set_periodic *set_periodic = &impl->pid_set_periodic;
+    struct pid_set_envelope *set_envelope = &impl->pid_set_envelope;
+    struct pid_device_gain *device_gain = &impl->pid_device_gain;
+    struct pid_device_pool *device_pool = &impl->pid_device_pool;
+    struct pid_block_free *block_free = &impl->pid_block_free;
+    struct pid_block_load *block_load = &impl->pid_block_load;
+    struct pid_new_effect *new_effect = &impl->pid_new_effect;
+    struct pid_effect_state *effect_state = &impl->pid_effect_state;
+
+#define SET_COLLECTION( rep )                                          \
+    do                                                                 \
+    {                                                                  \
+        if (rep->collection) FIXME( "duplicate " #rep " report!\n" );  \
+        else rep->collection = DIDFT_GETINSTANCE( instance->dwType );  \
+    } while (0)
+
+#define SET_SUB_COLLECTION( rep, sub )                                 \
+    do {                                                               \
+        if (instance->wCollectionNumber != rep->collection)            \
+            FIXME( "unexpected " #rep "." #sub " parent!\n" );         \
+        else if (rep->sub)                                             \
+            FIXME( "duplicate " #rep "." #sub " collection!\n" );      \
+        else                                                           \
+            rep->sub = DIDFT_GETINSTANCE( instance->dwType );          \
+    } while (0)
+
+    if (instance->wUsagePage == HID_USAGE_PAGE_PID)
+    {
+        switch (instance->wUsage)
+        {
+        case PID_USAGE_DEVICE_CONTROL_REPORT: SET_COLLECTION( device_control ); break;
+        case PID_USAGE_EFFECT_OPERATION_REPORT: SET_COLLECTION( effect_control ); break;
+        case PID_USAGE_SET_EFFECT_REPORT: SET_COLLECTION( effect_update ); break;
+        case PID_USAGE_SET_PERIODIC_REPORT: SET_COLLECTION( set_periodic ); break;
+        case PID_USAGE_SET_ENVELOPE_REPORT: SET_COLLECTION( set_envelope ); break;
+        case PID_USAGE_SET_CONDITION_REPORT: SET_COLLECTION( set_condition ); break;
+        case PID_USAGE_SET_CONSTANT_FORCE_REPORT: SET_COLLECTION( set_constant_force ); break;
+        case PID_USAGE_SET_RAMP_FORCE_REPORT: SET_COLLECTION( set_ramp_force ); break;
+        case PID_USAGE_DEVICE_GAIN_REPORT: SET_COLLECTION( device_gain ); break;
+        case PID_USAGE_POOL_REPORT: SET_COLLECTION( device_pool ); break;
+        case PID_USAGE_BLOCK_FREE_REPORT: SET_COLLECTION( block_free ); break;
+        case PID_USAGE_BLOCK_LOAD_REPORT: SET_COLLECTION( block_load ); break;
+        case PID_USAGE_CREATE_NEW_EFFECT_REPORT: SET_COLLECTION( new_effect ); break;
+        case PID_USAGE_STATE_REPORT: SET_COLLECTION( effect_state ); break;
+
+        case PID_USAGE_DEVICE_CONTROL: SET_SUB_COLLECTION( device_control, control_coll ); break;
+        case PID_USAGE_EFFECT_OPERATION: SET_SUB_COLLECTION( effect_control, control_coll ); break;
+        case PID_USAGE_EFFECT_TYPE:
+            if (instance->wCollectionNumber == effect_update->collection)
+                SET_SUB_COLLECTION( effect_update, type_coll );
+            else if (instance->wCollectionNumber == new_effect->collection)
+                SET_SUB_COLLECTION( new_effect, type_coll );
+            break;
+        case PID_USAGE_AXES_ENABLE: SET_SUB_COLLECTION( effect_update, axes_coll ); break;
+        case PID_USAGE_DIRECTION: SET_SUB_COLLECTION( effect_update, direction_coll ); break;
+        case PID_USAGE_BLOCK_LOAD_STATUS: SET_SUB_COLLECTION( block_load, status_coll ); break;
+        }
+    }
+
+#undef SET_SUB_COLLECTION
+#undef SET_COLLECTION
+
+    return DIENUM_CONTINUE;
+}
+
+static BOOL init_pid_caps( struct dinput_device *device, UINT index, struct hid_value_caps *caps,
+                           const DIDEVICEOBJECTINSTANCEW *instance, void *data )
+{
+    struct hid_joystick *impl = CONTAINING_RECORD( device, struct hid_joystick, base );
+    struct pid_set_constant_force *set_constant_force = &impl->pid_set_constant_force;
+    struct pid_set_ramp_force *set_ramp_force = &impl->pid_set_ramp_force;
+    struct pid_control_report *device_control = &impl->pid_device_control;
+    struct pid_control_report *effect_control = &impl->pid_effect_control;
+    struct pid_effect_update *effect_update = &impl->pid_effect_update;
+    struct pid_set_condition *set_condition = &impl->pid_set_condition;
+    struct pid_set_periodic *set_periodic = &impl->pid_set_periodic;
+    struct pid_set_envelope *set_envelope = &impl->pid_set_envelope;
+    struct pid_device_gain *device_gain = &impl->pid_device_gain;
+    struct pid_device_pool *device_pool = &impl->pid_device_pool;
+    struct pid_block_free *block_free = &impl->pid_block_free;
+    struct pid_block_load *block_load = &impl->pid_block_load;
+    struct pid_new_effect *new_effect = &impl->pid_new_effect;
+    struct pid_effect_state *effect_state = &impl->pid_effect_state;
+
+#define SET_REPORT_ID( rep )                                           \
+    do                                                                 \
+    {                                                                  \
+        if (!rep->id)                                                  \
+            rep->id = instance->wReportId;                             \
+        else if (rep->id != instance->wReportId)                       \
+            FIXME( "multiple " #rep " report ids!\n" );                \
+    } while (0)
+
+    if (!instance->wCollectionNumber)
+        return DIENUM_CONTINUE;
+
+    if (instance->wCollectionNumber == effect_state->collection)
+    {
+        SET_REPORT_ID( effect_state );
+        if (instance->wUsage == PID_USAGE_SAFETY_SWITCH)
+            effect_state->safety_switch_caps = caps;
+        if (instance->wUsage == PID_USAGE_ACTUATOR_POWER)
+            effect_state->actuator_power_caps = caps;
+        if (instance->wUsage == PID_USAGE_ACTUATOR_OVERRIDE_SWITCH)
+            effect_state->actuator_override_switch_caps = caps;
+    }
+
+    if (!(instance->dwType & DIDFT_OUTPUT)) return DIENUM_CONTINUE;
+
+    if (instance->wCollectionNumber == device_control->control_coll)
+        SET_REPORT_ID( device_control );
+    if (instance->wCollectionNumber == effect_control->control_coll)
+        SET_REPORT_ID( effect_control );
+    if (instance->wCollectionNumber == effect_update->type_coll)
+        SET_REPORT_ID( effect_update );
+    if (instance->wCollectionNumber == effect_update->collection)
+    {
+        SET_REPORT_ID( effect_update );
+        if (instance->wUsage == PID_USAGE_DURATION)
+            effect_update->duration_caps = caps;
+        if (instance->wUsage == PID_USAGE_GAIN)
+        {
+            caps->physical_min = 0;
+            caps->physical_max = 10000;
+            effect_update->gain_caps = caps;
+        }
+        if (instance->wUsage == PID_USAGE_SAMPLE_PERIOD)
+            effect_update->sample_period_caps = caps;
+        if (instance->wUsage == PID_USAGE_START_DELAY)
+            effect_update->start_delay_caps = caps;
+        if (instance->wUsage == PID_USAGE_TRIGGER_BUTTON)
+            effect_update->trigger_button_caps = caps;
+        if (instance->wUsage == PID_USAGE_TRIGGER_REPEAT_INTERVAL)
+            effect_update->trigger_repeat_interval_caps = caps;
+    }
+    if (instance->wCollectionNumber == effect_update->axes_coll)
+    {
+        SET_REPORT_ID( effect_update );
+        if (effect_update->axis_count >= MAX_PID_AXES) FIXME( "more than %d PID axes detected\n", MAX_PID_AXES );
+        else effect_update->axis_caps[effect_update->axis_count] = caps;
+        effect_update->axis_count++;
+    }
+    if (instance->wCollectionNumber == effect_update->direction_coll)
+    {
+        SET_REPORT_ID( effect_update );
+        caps->physical_min = 0;
+        caps->physical_max = 35900;
+        if (effect_update->direction_count >= MAX_PID_AXES) FIXME( "more than %d PID directions detected\n", MAX_PID_AXES );
+        else effect_update->direction_caps[effect_update->direction_count] = caps;
+        effect_update->direction_count++;
+    }
+    if (instance->wCollectionNumber == set_periodic->collection)
+    {
+        SET_REPORT_ID( set_periodic );
+        if (instance->wUsage == PID_USAGE_MAGNITUDE)
+        {
+            caps->physical_min = 0;
+            caps->physical_max = 10000;
+            set_periodic->magnitude_caps = caps;
+        }
+        if (instance->wUsage == PID_USAGE_PERIOD)
+            set_periodic->period_caps = caps;
+        if (instance->wUsage == PID_USAGE_PHASE)
+        {
+            caps->physical_min = 0;
+            caps->physical_max = 35900;
+            set_periodic->phase_caps = caps;
+        }
+        if (instance->wUsage == PID_USAGE_OFFSET)
+        {
+            caps->physical_min = -10000;
+            caps->physical_max = 10000;
+            set_periodic->offset_caps = caps;
+        }
+    }
+    if (instance->wCollectionNumber == set_envelope->collection)
+    {
+        SET_REPORT_ID( set_envelope );
+        if (instance->wUsage == PID_USAGE_ATTACK_LEVEL)
+        {
+            caps->physical_min = 0;
+            caps->physical_max = 10000;
+            set_envelope->attack_level_caps = caps;
+        }
+        if (instance->wUsage == PID_USAGE_ATTACK_TIME)
+            set_envelope->attack_time_caps = caps;
+        if (instance->wUsage == PID_USAGE_FADE_LEVEL)
+        {
+            caps->physical_min = 0;
+            caps->physical_max = 10000;
+            set_envelope->fade_level_caps = caps;
+        }
+        if (instance->wUsage == PID_USAGE_FADE_TIME)
+            set_envelope->fade_time_caps = caps;
+    }
+    if (instance->wCollectionNumber == set_condition->collection)
+    {
+        SET_REPORT_ID( set_condition );
+        if (instance->wUsage == PID_USAGE_CP_OFFSET)
+        {
+            caps->physical_min = -10000;
+            caps->physical_max = 10000;
+            set_condition->center_point_offset_caps = caps;
+        }
+        if (instance->wUsage == PID_USAGE_POSITIVE_COEFFICIENT)
+        {
+            caps->physical_min = -10000;
+            caps->physical_max = 10000;
+            set_condition->positive_coefficient_caps = caps;
+        }
+        if (instance->wUsage == PID_USAGE_NEGATIVE_COEFFICIENT)
+        {
+            caps->physical_min = -10000;
+            caps->physical_max = 10000;
+            set_condition->negative_coefficient_caps = caps;
+        }
+        if (instance->wUsage == PID_USAGE_POSITIVE_SATURATION)
+        {
+            caps->physical_min = 0;
+            caps->physical_max = 10000;
+            set_condition->positive_saturation_caps = caps;
+        }
+        if (instance->wUsage == PID_USAGE_NEGATIVE_SATURATION)
+        {
+            caps->physical_min = 0;
+            caps->physical_max = 10000;
+            set_condition->negative_saturation_caps = caps;
+        }
+        if (instance->wUsage == PID_USAGE_DEAD_BAND)
+        {
+            caps->physical_min = 0;
+            caps->physical_max = 10000;
+            set_condition->dead_band_caps = caps;
+        }
+    }
+    if (instance->wCollectionNumber == set_constant_force->collection)
+    {
+        SET_REPORT_ID( set_constant_force );
+        if (instance->wUsage == PID_USAGE_MAGNITUDE)
+        {
+            caps->physical_min = -10000;
+            caps->physical_max = 10000;
+            set_constant_force->magnitude_caps = caps;
+        }
+    }
+    if (instance->wCollectionNumber == set_ramp_force->collection)
+    {
+        SET_REPORT_ID( set_ramp_force );
+        if (instance->wUsage == PID_USAGE_RAMP_START)
+        {
+            caps->physical_min = -10000;
+            caps->physical_max = 10000;
+            set_ramp_force->start_caps = caps;
+        }
+        if (instance->wUsage == PID_USAGE_RAMP_END)
+        {
+            caps->physical_min = -10000;
+            caps->physical_max = 10000;
+            set_ramp_force->end_caps = caps;
+        }
+    }
+    if (instance->wCollectionNumber == device_gain->collection)
+    {
+        SET_REPORT_ID( device_gain );
+        if (instance->wUsage == PID_USAGE_DEVICE_GAIN)
+        {
+            caps->physical_min = 0;
+            caps->physical_max = 10000;
+            device_gain->device_gain_caps = caps;
+        }
+    }
+    if (instance->wCollectionNumber == device_pool->collection)
+    {
+        SET_REPORT_ID( device_pool );
+        if (instance->wUsage == PID_USAGE_DEVICE_MANAGED_POOL)
+            device_pool->device_managed_caps = caps;
+    }
+    if (instance->wCollectionNumber == block_free->collection)
+        SET_REPORT_ID( block_free );
+    if (instance->wCollectionNumber == block_load->collection)
+        SET_REPORT_ID( block_load );
+    if (instance->wCollectionNumber == block_load->status_coll)
+        SET_REPORT_ID( block_load );
+    if (instance->wCollectionNumber == new_effect->collection)
+        SET_REPORT_ID( new_effect );
+    if (instance->wCollectionNumber == new_effect->type_coll)
+        SET_REPORT_ID( new_effect );
+
+#undef SET_REPORT_ID
+
+    return DIENUM_CONTINUE;
+}
+
+HRESULT hid_joystick_create_device( struct dinput *dinput, const GUID *guid, IDirectInputDevice8W **out )
+{
+    static const DIPROPHEADER filter =
+    {
+        .dwSize = sizeof(filter),
+        .dwHeaderSize = sizeof(filter),
+        .dwHow = DIPH_DEVICE,
+    };
+    DIPROPRANGE range =
+    {
+        .diph =
+        {
+            .dwSize = sizeof(range),
+            .dwHeaderSize = sizeof(DIPROPHEADER),
+            .dwHow = DIPH_DEVICE,
+        },
+    };
+    HIDD_ATTRIBUTES attrs = {.Size = sizeof(attrs)};
+    struct hid_joystick *impl = NULL;
+    USAGE_AND_PAGE *usages;
+    char *buffer;
+    HRESULT hr;
+    DWORD size;
+
+    TRACE( "dinput %p, guid %s, out %p\n", dinput, debugstr_guid( guid ), out );
+
+    *out = NULL;
+
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return E_OUTOFMEMORY;
+    dinput_device_init( &impl->base, &hid_joystick_vtbl, guid, dinput );
+    impl->base.crit.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": hid_joystick.base.crit");
+    impl->base.dwCoopLevel = DISCL_NONEXCLUSIVE | DISCL_BACKGROUND;
+    impl->base.read_event = CreateEventW( NULL, TRUE, FALSE, NULL );
+
+    if (memcmp( device_path_guid.Data4, guid->Data4, sizeof(device_path_guid.Data4) ))
+        hr = hid_joystick_device_open( -1, guid, &impl->base.instance, impl->device_path, &impl->device, &impl->preparsed,
+                                       &attrs, &impl->caps, dinput->dwVersion );
+    else
+    {
+        wcscpy( impl->device_path, *(const WCHAR **)guid );
+        hr = hid_joystick_device_try_open( impl->device_path, &impl->device, &impl->preparsed, &attrs,
+                                           &impl->caps, &impl->base.instance, dinput->dwVersion );
+    }
+    if (hr != DI_OK) goto failed;
+
+    impl->base.caps.dwDevType = impl->base.instance.dwDevType;
+    impl->attrs = attrs;
+    list_init( &impl->effect_list );
+
+    hr = E_OUTOFMEMORY;
+    size = impl->caps.InputReportByteLength;
+    if (!(buffer = malloc( size ))) goto failed;
+    impl->input_report_buf = buffer;
+    size = impl->caps.OutputReportByteLength;
+    if (!(buffer = malloc( size ))) goto failed;
+    impl->output_report_buf = buffer;
+    size = impl->caps.FeatureReportByteLength;
+    if (!(buffer = malloc( size ))) goto failed;
+    impl->feature_report_buf = buffer;
+    impl->usages_count = HidP_MaxUsageListLength( HidP_Input, 0, impl->preparsed );
+    size = impl->usages_count * sizeof(USAGE_AND_PAGE);
+    if (!(usages = malloc( size ))) goto failed;
+    impl->usages_buf = usages;
+
+    enum_objects( impl, &filter, DIDFT_COLLECTION, init_pid_reports, NULL );
+    enum_objects( impl, &filter, DIDFT_NODATA | DIDFT_BUTTON | DIDFT_AXIS, init_pid_caps, NULL );
+
+    TRACE( "device control id %u, coll %u, control coll %u\n", impl->pid_device_control.id,
+           impl->pid_device_control.collection, impl->pid_device_control.control_coll );
+    TRACE( "effect control id %u, coll %u\n", impl->pid_effect_control.id, impl->pid_effect_control.collection );
+    TRACE( "effect update id %u, coll %u, type_coll %u\n", impl->pid_effect_update.id,
+           impl->pid_effect_update.collection, impl->pid_effect_update.type_coll );
+    TRACE( "set periodic id %u, coll %u\n", impl->pid_set_periodic.id, impl->pid_set_periodic.collection );
+    TRACE( "set envelope id %u, coll %u\n", impl->pid_set_envelope.id, impl->pid_set_envelope.collection );
+    TRACE( "set condition id %u, coll %u\n", impl->pid_set_condition.id, impl->pid_set_condition.collection );
+    TRACE( "set constant force id %u, coll %u\n", impl->pid_set_constant_force.id,
+           impl->pid_set_constant_force.collection );
+    TRACE( "set ramp force id %u, coll %u\n", impl->pid_set_ramp_force.id, impl->pid_set_ramp_force.collection );
+    TRACE( "device gain id %u, coll %u\n", impl->pid_device_gain.id, impl->pid_device_gain.collection );
+    TRACE( "device pool id %u, coll %u\n", impl->pid_device_pool.id, impl->pid_device_pool.collection );
+    TRACE( "block free id %u, coll %u\n", impl->pid_block_free.id, impl->pid_block_free.collection );
+    TRACE( "block load id %u, coll %u, status_coll %u\n", impl->pid_block_load.id,
+           impl->pid_block_load.collection, impl->pid_block_load.status_coll );
+    TRACE( "create new effect id %u, coll %u, type_coll %u\n", impl->pid_new_effect.id,
+           impl->pid_new_effect.collection, impl->pid_new_effect.type_coll );
+    TRACE( "effect state id %u, coll %u\n", impl->pid_effect_state.id, impl->pid_effect_state.collection );
+
+    if (impl->pid_device_control.id)
+    {
+        impl->base.caps.dwFlags |= DIDC_FORCEFEEDBACK;
+        if (impl->pid_effect_update.start_delay_caps)
+            impl->base.caps.dwFlags |= DIDC_STARTDELAY;
+        if (impl->pid_set_envelope.attack_level_caps ||
+            impl->pid_set_envelope.attack_time_caps)
+            impl->base.caps.dwFlags |= DIDC_FFATTACK;
+        if (impl->pid_set_envelope.fade_level_caps ||
+            impl->pid_set_envelope.fade_time_caps)
+            impl->base.caps.dwFlags |= DIDC_FFFADE;
+        if (impl->pid_set_condition.positive_saturation_caps ||
+            impl->pid_set_condition.negative_saturation_caps)
+            impl->base.caps.dwFlags |= DIDC_SATURATION;
+        if (impl->pid_set_condition.dead_band_caps)
+            impl->base.caps.dwFlags |= DIDC_DEADBAND;
+        impl->base.caps.dwFFSamplePeriod = 1000000;
+        impl->base.caps.dwFFMinTimeResolution = 1000000;
+        impl->base.caps.dwHardwareRevision = 1;
+        impl->base.caps.dwFFDriverVersion = 1;
+    }
+
+    if (FAILED(hr = dinput_device_init_device_format( &impl->base.IDirectInputDevice8W_iface ))) goto failed;
+    enum_objects( impl, &filter, DIDFT_AXIS | DIDFT_POV, init_object_properties, NULL );
+
+    *out = &impl->base.IDirectInputDevice8W_iface;
+    return DI_OK;
+
+failed:
+    IDirectInputDevice_Release( &impl->base.IDirectInputDevice8W_iface );
+    return hr;
+}
+
+static HRESULT WINAPI hid_joystick_effect_QueryInterface( IDirectInputEffect *iface, REFIID iid, void **out )
+{
+    TRACE( "iface %p, iid %s, out %p\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IDirectInputEffect ))
+    {
+        IDirectInputEffect_AddRef( iface );
+        *out = iface;
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI hid_joystick_effect_AddRef( IDirectInputEffect *iface )
+{
+    struct hid_joystick_effect *impl = impl_from_IDirectInputEffect( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p, ref %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI hid_joystick_effect_Release( IDirectInputEffect *iface )
+{
+    struct hid_joystick_effect *impl = impl_from_IDirectInputEffect( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p, ref %lu.\n", iface, ref );
+    if (!ref)
+    {
+        IDirectInputEffect_Unload( iface );
+        EnterCriticalSection( &impl->joystick->base.crit );
+        list_remove( &impl->entry );
+        LeaveCriticalSection( &impl->joystick->base.crit );
+        dinput_device_internal_release( &impl->joystick->base );
+        free( impl->set_envelope_buf );
+        free( impl->type_specific_buf );
+        free( impl->effect_update_buf );
+        free( impl->effect_control_buf );
+        free( impl );
+    }
+    return ref;
+}
+
+static HRESULT WINAPI hid_joystick_effect_Initialize( IDirectInputEffect *iface, HINSTANCE inst,
+                                                      DWORD version, REFGUID guid )
+{
+    struct hid_joystick_effect *impl = impl_from_IDirectInputEffect( iface );
+    struct hid_joystick *joystick = impl->joystick;
+    ULONG count, report_len = joystick->caps.OutputReportByteLength;
+    NTSTATUS status;
+    USAGE type;
+
+    TRACE( "iface %p, inst %p, version %#lx, guid %s\n", iface, inst, version, debugstr_guid( guid ) );
+
+    if (!inst) return DIERR_INVALIDPARAM;
+    if (!guid) return E_POINTER;
+    if (!(type = effect_guid_to_usage( guid ))) return DIERR_DEVICENOTREG;
+
+    status = HidP_InitializeReportForID( HidP_Output, joystick->pid_effect_update.id,
+                                         joystick->preparsed, impl->effect_update_buf, report_len );
+    if (status != HIDP_STATUS_SUCCESS) return DIERR_DEVICENOTREG;
+
+    impl->type_specific_buf[0] = 0;
+    impl->set_envelope_buf[0] = 0;
+
+    switch (type)
+    {
+    case PID_USAGE_ET_SQUARE:
+    case PID_USAGE_ET_SINE:
+    case PID_USAGE_ET_TRIANGLE:
+    case PID_USAGE_ET_SAWTOOTH_UP:
+    case PID_USAGE_ET_SAWTOOTH_DOWN:
+        status = HidP_InitializeReportForID( HidP_Output, joystick->pid_set_periodic.id,
+                                             joystick->preparsed, impl->type_specific_buf, report_len );
+        if (status != HIDP_STATUS_SUCCESS) return DIERR_DEVICENOTREG;
+        impl->params.lpvTypeSpecificParams = &impl->periodic;
+        break;
+    case PID_USAGE_ET_SPRING:
+    case PID_USAGE_ET_DAMPER:
+    case PID_USAGE_ET_INERTIA:
+    case PID_USAGE_ET_FRICTION:
+        status = HidP_InitializeReportForID( HidP_Output, joystick->pid_set_condition.id, joystick->preparsed,
+                                             impl->type_specific_buf, report_len );
+        if (status != HIDP_STATUS_SUCCESS) return DIERR_DEVICENOTREG;
+        impl->params.lpvTypeSpecificParams = &impl->condition;
+        break;
+    case PID_USAGE_ET_CONSTANT_FORCE:
+        status = HidP_InitializeReportForID( HidP_Output, joystick->pid_set_constant_force.id, joystick->preparsed,
+                                             impl->type_specific_buf, report_len );
+        if (status != HIDP_STATUS_SUCCESS) return DIERR_DEVICENOTREG;
+        impl->params.lpvTypeSpecificParams = &impl->constant_force;
+        break;
+    case PID_USAGE_ET_RAMP:
+        status = HidP_InitializeReportForID( HidP_Output, joystick->pid_set_ramp_force.id, joystick->preparsed,
+                                             impl->type_specific_buf, report_len );
+        if (status != HIDP_STATUS_SUCCESS) return DIERR_DEVICENOTREG;
+        impl->params.lpvTypeSpecificParams = &impl->ramp_force;
+        break;
+    case PID_USAGE_ET_CUSTOM_FORCE_DATA:
+        FIXME( "effect type %#x not implemented!\n", type );
+        break;
+    }
+
+    switch (type)
+    {
+    case PID_USAGE_ET_SQUARE:
+    case PID_USAGE_ET_SINE:
+    case PID_USAGE_ET_TRIANGLE:
+    case PID_USAGE_ET_SAWTOOTH_UP:
+    case PID_USAGE_ET_SAWTOOTH_DOWN:
+    case PID_USAGE_ET_CONSTANT_FORCE:
+    case PID_USAGE_ET_RAMP:
+        status = HidP_InitializeReportForID( HidP_Output, joystick->pid_set_envelope.id, joystick->preparsed,
+                                             impl->set_envelope_buf, report_len );
+        if (status != HIDP_STATUS_SUCCESS) return DIERR_DEVICENOTREG;
+        break;
+    }
+
+    count = 1;
+    status = HidP_SetUsages( HidP_Output, HID_USAGE_PAGE_PID, joystick->pid_effect_update.type_coll,
+                             &type, &count, joystick->preparsed, impl->effect_update_buf, report_len );
+    if (status != HIDP_STATUS_SUCCESS) return DIERR_DEVICENOTREG;
+
+    impl->type = type;
+    return DI_OK;
+}
+
+static HRESULT WINAPI hid_joystick_effect_GetEffectGuid( IDirectInputEffect *iface, GUID *guid )
+{
+    struct hid_joystick_effect *impl = impl_from_IDirectInputEffect( iface );
+
+    TRACE( "iface %p, guid %p.\n", iface, guid );
+
+    if (!guid) return E_POINTER;
+    *guid = *effect_usage_to_guid( impl->type );
+
+    return DI_OK;
+}
+
+static BOOL get_parameters_object_id( struct dinput_device *device, UINT index, struct hid_value_caps *caps,
+                                      const DIDEVICEOBJECTINSTANCEW *instance, void *data )
+{
+    *(DWORD *)data = instance->dwType;
+    return DIENUM_STOP;
+}
+
+static BOOL get_parameters_object_ofs( struct dinput_device *device, UINT index, struct hid_value_caps *caps,
+                                       const DIDEVICEOBJECTINSTANCEW *instance, void *data )
+{
+    DIDATAFORMAT *device_format = &device->device_format, *user_format = &device->user_format;
+    DIOBJECTDATAFORMAT *device_obj, *user_obj;
+
+    if (!user_format->rgodf) return DIENUM_CONTINUE;
+
+    user_obj = user_format->rgodf + device_format->dwNumObjs;
+    device_obj = device_format->rgodf + device_format->dwNumObjs;
+    while (user_obj-- > user_format->rgodf && device_obj-- > device_format->rgodf)
+    {
+        if (!user_obj->dwType) continue;
+        if (device_obj->dwType == instance->dwType) break;
+    }
+    if (user_obj < user_format->rgodf) return DIENUM_CONTINUE;
+
+    *(DWORD *)data = user_obj->dwOfs;
+    return DIENUM_STOP;
+}
+
+static void convert_directions_to_spherical( const DIEFFECT *in, DIEFFECT *out )
+{
+    DWORD i, j, direction_flags = DIEFF_CARTESIAN | DIEFF_POLAR | DIEFF_SPHERICAL;
+    double tmp;
+
+    switch (in->dwFlags & direction_flags)
+    {
+    case DIEFF_CARTESIAN:
+        for (i = 1; i < in->cAxes; ++i)
+        {
+            tmp = in->rglDirection[0];
+            for (j = 1; j < i; ++j) tmp = sqrt( tmp * tmp + in->rglDirection[j] * in->rglDirection[j] );
+            tmp = atan2( in->rglDirection[i], tmp );
+            out->rglDirection[i - 1] = tmp * 18000 / M_PI;
+            if (out->rglDirection[i - 1] < 0) out->rglDirection[i - 1] += 36000;
+        }
+        if (in->cAxes) out->rglDirection[in->cAxes - 1] = 0;
+        out->cAxes = in->cAxes;
+        break;
+    case DIEFF_POLAR:
+        out->rglDirection[0] = (in->rglDirection[0] % 36000) - 9000;
+        if (out->rglDirection[0] < 0) out->rglDirection[0] += 36000;
+        for (i = 1; i < in->cAxes; ++i) out->rglDirection[i] = 0;
+        out->cAxes = in->cAxes;
+        break;
+    case DIEFF_SPHERICAL:
+        if (!in->cAxes) i = 0;
+        else for (i = 0; i < in->cAxes - 1; ++i)
+        {
+            out->rglDirection[i] = in->rglDirection[i] % 36000;
+            if (out->rglDirection[i] < 0) out->rglDirection[i] += 36000;
+        }
+        out->rglDirection[i] = 0;
+        out->cAxes = in->cAxes;
+        break;
+    }
+}
+
+static void convert_directions_from_spherical( const DIEFFECT *in, DIEFFECT *out )
+{
+    DWORD i, j, direction_flags = DIEFF_CARTESIAN | DIEFF_POLAR | DIEFF_SPHERICAL;
+    LONG tmp;
+
+    switch (out->dwFlags & direction_flags)
+    {
+    case DIEFF_CARTESIAN:
+        out->rglDirection[0] = 10000;
+        for (i = 1; i <= in->cAxes; ++i)
+        {
+            tmp = cos( in->rglDirection[i - 1] * M_PI / 18000 ) * 10000;
+            for (j = 0; j < i; ++j)
+                out->rglDirection[j] = round( out->rglDirection[j] * tmp / 10000.0 );
+            if (i < in->cAxes)
+                out->rglDirection[i] = sin( in->rglDirection[i - 1] * M_PI / 18000 ) * 10000;
+        }
+        out->cAxes = in->cAxes;
+        break;
+    case DIEFF_POLAR:
+        out->rglDirection[0] = (in->rglDirection[0] + 9000) % 36000;
+        if (out->rglDirection[0] < 0) out->rglDirection[0] += 36000;
+        out->rglDirection[1] = 0;
+        out->cAxes = 2;
+        break;
+    case DIEFF_SPHERICAL:
+        for (i = 0; i < in->cAxes; ++i)
+        {
+            out->rglDirection[i] = in->rglDirection[i] % 36000;
+            if (out->rglDirection[i] < 0) out->rglDirection[i] += 36000;
+        }
+        out->cAxes = in->cAxes;
+        break;
+    }
+}
+
+static void convert_directions( const DIEFFECT *in, DIEFFECT *out )
+{
+    DWORD direction_flags = DIEFF_CARTESIAN | DIEFF_POLAR | DIEFF_SPHERICAL;
+    LONG directions[MAX_PID_AXES] = {0};
+    DIEFFECT spherical = {.rglDirection = directions};
+
+    switch (in->dwFlags & direction_flags)
+    {
+    case DIEFF_CARTESIAN:
+        switch (out->dwFlags & direction_flags)
+        {
+        case DIEFF_CARTESIAN:
+            memcpy( out->rglDirection, in->rglDirection, in->cAxes * sizeof(LONG) );
+            out->cAxes = in->cAxes;
+            break;
+        case DIEFF_POLAR:
+            convert_directions_to_spherical( in, &spherical );
+            convert_directions_from_spherical( &spherical, out );
+            break;
+        case DIEFF_SPHERICAL:
+            convert_directions_to_spherical( in, out );
+            break;
+        }
+        break;
+
+    case DIEFF_POLAR:
+        switch (out->dwFlags & direction_flags)
+        {
+        case DIEFF_POLAR:
+            memcpy( out->rglDirection, in->rglDirection, in->cAxes * sizeof(LONG) );
+            out->cAxes = in->cAxes;
+            break;
+        case DIEFF_CARTESIAN:
+            convert_directions_to_spherical( in, &spherical );
+            convert_directions_from_spherical( &spherical, out );
+            break;
+        case DIEFF_SPHERICAL:
+            convert_directions_to_spherical( in, out );
+            break;
+        }
+        break;
+
+    case DIEFF_SPHERICAL:
+        switch (out->dwFlags & direction_flags)
+        {
+        case DIEFF_POLAR:
+        case DIEFF_CARTESIAN:
+            convert_directions_from_spherical( in, out );
+            break;
+        case DIEFF_SPHERICAL:
+            convert_directions_to_spherical( in, out );
+            break;
+        }
+        break;
+    }
+}
+
+static HRESULT WINAPI hid_joystick_effect_GetParameters( IDirectInputEffect *iface, DIEFFECT *params, DWORD flags )
+{
+    DIPROPHEADER filter =
+    {
+        .dwSize = sizeof(DIPROPHEADER),
+        .dwHeaderSize = sizeof(DIPROPHEADER),
+        .dwHow = DIPH_BYUSAGE,
+    };
+    struct hid_joystick_effect *impl = impl_from_IDirectInputEffect( iface );
+    ULONG i, count, capacity, object_flags, direction_flags;
+    BOOL ret;
+
+    TRACE( "iface %p, params %p, flags %#lx.\n", iface, params, flags );
+
+    if (!params) return DI_OK;
+    if (params->dwSize != sizeof(DIEFFECT_DX6) && params->dwSize != sizeof(DIEFFECT_DX5)) return DIERR_INVALIDPARAM;
+    capacity = params->cAxes;
+    object_flags = params->dwFlags & (DIEFF_OBJECTIDS | DIEFF_OBJECTOFFSETS);
+    direction_flags = params->dwFlags & (DIEFF_CARTESIAN | DIEFF_POLAR | DIEFF_SPHERICAL);
+
+    if (flags & DIEP_AXES)
+    {
+        if (!object_flags) return DIERR_INVALIDPARAM;
+        params->cAxes = impl->params.cAxes;
+        if (capacity < impl->params.cAxes) return DIERR_MOREDATA;
+
+        for (i = 0; i < impl->params.cAxes; ++i)
+        {
+            if (!params->rgdwAxes) return DIERR_INVALIDPARAM;
+            filter.dwObj = impl->params.rgdwAxes[i];
+            if (object_flags & DIEFF_OBJECTIDS)
+                ret = enum_objects( impl->joystick, &filter, DIDFT_AXIS, get_parameters_object_id,
+                                    &params->rgdwAxes[i] );
+            else
+                ret = enum_objects( impl->joystick, &filter, DIDFT_AXIS, get_parameters_object_ofs,
+                                    &params->rgdwAxes[i] );
+            if (ret != DIENUM_STOP) params->rgdwAxes[i] = 0;
+        }
+    }
+
+    if (flags & DIEP_DIRECTION)
+    {
+        if (!direction_flags) return DIERR_INVALIDPARAM;
+
+        count = params->cAxes = impl->params.cAxes;
+        if (!count) params->dwFlags &= ~(DIEFF_CARTESIAN | DIEFF_POLAR | DIEFF_SPHERICAL);
+        if ((direction_flags & DIEFF_POLAR) && count != 2) return DIERR_INVALIDPARAM;
+        if (capacity < params->cAxes) return DIERR_MOREDATA;
+
+        if (!count) params->rglDirection = NULL;
+        else if (!params->rglDirection) return DIERR_INVALIDPARAM;
+        else convert_directions( &impl->params, params );
+    }
+
+    if (flags & DIEP_TYPESPECIFICPARAMS)
+    {
+        capacity = params->cbTypeSpecificParams;
+        params->cbTypeSpecificParams = impl->params.cbTypeSpecificParams;
+        if (capacity < impl->params.cbTypeSpecificParams) return DIERR_MOREDATA;
+        if (impl->params.lpvTypeSpecificParams)
+        {
+            if (!params->lpvTypeSpecificParams) return E_POINTER;
+            memcpy( params->lpvTypeSpecificParams, impl->params.lpvTypeSpecificParams,
+                    impl->params.cbTypeSpecificParams );
+        }
+    }
+
+    if (flags & DIEP_ENVELOPE)
+    {
+        if (!params->lpEnvelope) return E_POINTER;
+        if (params->lpEnvelope->dwSize != sizeof(DIENVELOPE)) return DIERR_INVALIDPARAM;
+        if (!impl->params.lpEnvelope) params->lpEnvelope = NULL;
+        else memcpy( params->lpEnvelope, impl->params.lpEnvelope, sizeof(DIENVELOPE) );
+    }
+
+    if (flags & DIEP_DURATION) params->dwDuration = impl->params.dwDuration;
+    if (flags & DIEP_GAIN) params->dwGain = impl->params.dwGain;
+    if (flags & DIEP_SAMPLEPERIOD) params->dwSamplePeriod = impl->params.dwSamplePeriod;
+    if (flags & DIEP_STARTDELAY)
+    {
+        if (params->dwSize != sizeof(DIEFFECT_DX6)) return DIERR_INVALIDPARAM;
+        params->dwStartDelay = impl->params.dwStartDelay;
+    }
+    if (flags & DIEP_TRIGGERREPEATINTERVAL) params->dwTriggerRepeatInterval = impl->params.dwTriggerRepeatInterval;
+
+    if (flags & DIEP_TRIGGERBUTTON)
+    {
+        if (!object_flags) return DIERR_INVALIDPARAM;
+
+        filter.dwObj = impl->params.dwTriggerButton;
+        if (object_flags & DIEFF_OBJECTIDS)
+            ret = enum_objects( impl->joystick, &filter, DIDFT_BUTTON, get_parameters_object_id,
+                                &params->dwTriggerButton );
+        else
+            ret = enum_objects( impl->joystick, &filter, DIDFT_BUTTON, get_parameters_object_ofs,
+                                &params->dwTriggerButton );
+        if (ret != DIENUM_STOP) params->dwTriggerButton = -1;
+    }
+
+    return DI_OK;
+}
+
+static BOOL set_parameters_object( struct dinput_device *device, UINT index, struct hid_value_caps *caps,
+                                   const DIDEVICEOBJECTINSTANCEW *instance, void *data )
+{
+    DWORD usages = MAKELONG( instance->wUsage, instance->wUsagePage );
+    *(DWORD *)data = usages;
+    return DIENUM_STOP;
+}
+
+static HRESULT WINAPI hid_joystick_effect_SetParameters( IDirectInputEffect *iface,
+                                                         const DIEFFECT *params, DWORD flags )
+{
+    DIPROPHEADER filter =
+    {
+        .dwSize = sizeof(DIPROPHEADER),
+        .dwHeaderSize = sizeof(DIPROPHEADER),
+        .dwHow = DIPH_BYUSAGE,
+    };
+    struct hid_joystick_effect *impl = impl_from_IDirectInputEffect( iface );
+    ULONG i, count, old_value, object_flags, direction_flags;
+    HRESULT hr;
+    BOOL ret;
+
+    TRACE( "iface %p, params %p, flags %#lx.\n", iface, params, flags );
+
+    if (!params) return E_POINTER;
+    if (params->dwSize != sizeof(DIEFFECT_DX6) && params->dwSize != sizeof(DIEFFECT_DX5)) return DIERR_INVALIDPARAM;
+    object_flags = params->dwFlags & (DIEFF_OBJECTIDS | DIEFF_OBJECTOFFSETS);
+    direction_flags = params->dwFlags & (DIEFF_CARTESIAN | DIEFF_POLAR | DIEFF_SPHERICAL);
+
+    if (object_flags & DIEFF_OBJECTIDS) filter.dwHow = DIPH_BYID;
+    else filter.dwHow = DIPH_BYOFFSET;
+
+    if (flags & DIEP_AXES)
+    {
+        if (!object_flags) return DIERR_INVALIDPARAM;
+        if (!params->rgdwAxes) return DIERR_INVALIDPARAM;
+        if (impl->params.cAxes) return DIERR_ALREADYINITIALIZED;
+        count = impl->joystick->pid_effect_update.axis_count;
+        if (params->cAxes > count) return DIERR_INVALIDPARAM;
+
+        impl->params.cAxes = params->cAxes;
+        for (i = 0; i < params->cAxes; ++i)
+        {
+            filter.dwObj = params->rgdwAxes[i];
+            ret = enum_objects( impl->joystick, &filter, DIDFT_AXIS, set_parameters_object,
+                                &impl->params.rgdwAxes[i] );
+            if (ret != DIENUM_STOP) impl->params.rgdwAxes[i] = 0;
+        }
+
+        impl->modified |= DIEP_AXES;
+    }
+
+    if (flags & DIEP_DIRECTION)
+    {
+        if (!direction_flags) return DIERR_INVALIDPARAM;
+        if (!params->rglDirection) return DIERR_INVALIDPARAM;
+
+        count = impl->params.cAxes;
+        if (params->cAxes < count) return DIERR_INVALIDPARAM;
+        if ((direction_flags & DIEFF_POLAR) && count != 2) return DIERR_INVALIDPARAM;
+        if ((direction_flags & DIEFF_CARTESIAN) && params->cAxes != count) return DIERR_INVALIDPARAM;
+
+        impl->params.dwFlags &= ~(DIEFF_CARTESIAN | DIEFF_POLAR | DIEFF_SPHERICAL);
+        impl->params.dwFlags |= direction_flags;
+        if (memcmp( impl->params.rglDirection, params->rglDirection, count * sizeof(LONG) ))
+            impl->modified |= DIEP_DIRECTION;
+        memcpy( impl->params.rglDirection, params->rglDirection, count * sizeof(LONG) );
+    }
+
+    if (flags & DIEP_TYPESPECIFICPARAMS)
+    {
+        if (!params->lpvTypeSpecificParams) return E_POINTER;
+        switch (impl->type)
+        {
+        case PID_USAGE_ET_SQUARE:
+        case PID_USAGE_ET_SINE:
+        case PID_USAGE_ET_TRIANGLE:
+        case PID_USAGE_ET_SAWTOOTH_UP:
+        case PID_USAGE_ET_SAWTOOTH_DOWN:
+            if (params->cbTypeSpecificParams != sizeof(DIPERIODIC))
+                return DIERR_INVALIDPARAM;
+            break;
+        case PID_USAGE_ET_SPRING:
+        case PID_USAGE_ET_DAMPER:
+        case PID_USAGE_ET_INERTIA:
+        case PID_USAGE_ET_FRICTION:
+            if (params->cbTypeSpecificParams != sizeof(DICONDITION) && impl->params.cAxes &&
+                params->cbTypeSpecificParams != impl->params.cAxes * sizeof(DICONDITION))
+                return DIERR_INVALIDPARAM;
+            break;
+        case PID_USAGE_ET_CONSTANT_FORCE:
+            if (params->cbTypeSpecificParams != sizeof(DICONSTANTFORCE))
+                return DIERR_INVALIDPARAM;
+            break;
+        case PID_USAGE_ET_RAMP:
+            if (params->cbTypeSpecificParams != sizeof(DIRAMPFORCE))
+                return DIERR_INVALIDPARAM;
+            break;
+        case PID_USAGE_ET_CUSTOM_FORCE_DATA:
+            FIXME( "custom force data not implemented!\n" );
+            return DIERR_UNSUPPORTED;
+        }
+
+        if (memcmp( impl->params.lpvTypeSpecificParams, params->lpvTypeSpecificParams,
+                    params->cbTypeSpecificParams ))
+            impl->modified |= DIEP_TYPESPECIFICPARAMS;
+        memcpy( impl->params.lpvTypeSpecificParams, params->lpvTypeSpecificParams,
+                params->cbTypeSpecificParams );
+        impl->params.cbTypeSpecificParams = params->cbTypeSpecificParams;
+    }
+
+    if (!(flags & DIEP_ENVELOPE))
+        TRACE( "Keeping previous effect envelope\n" );
+    else if (params->lpEnvelope)
+    {
+        if (params->lpEnvelope->dwSize != sizeof(DIENVELOPE)) return DIERR_INVALIDPARAM;
+        impl->params.lpEnvelope = &impl->envelope;
+        if (memcmp( impl->params.lpEnvelope, params->lpEnvelope, sizeof(DIENVELOPE) ))
+            impl->modified |= DIEP_ENVELOPE;
+        memcpy( impl->params.lpEnvelope, params->lpEnvelope, sizeof(DIENVELOPE) );
+    }
+    else
+    {
+        flags &= ~DIEP_ENVELOPE;
+        impl->flags &= ~DIEP_ENVELOPE;
+        impl->modified &= ~DIEP_ENVELOPE;
+        impl->params.lpEnvelope = NULL;
+    }
+
+    if (flags & DIEP_DURATION)
+    {
+        impl->modified |= DIEP_DURATION;
+        impl->params.dwDuration = params->dwDuration;
+    }
+    if (flags & DIEP_GAIN)
+    {
+        if (impl->params.dwGain != params->dwGain) impl->modified |= DIEP_GAIN;
+        impl->params.dwGain = params->dwGain;
+    }
+    if (flags & DIEP_SAMPLEPERIOD)
+    {
+        if (impl->params.dwSamplePeriod != params->dwSamplePeriod) impl->modified |= DIEP_SAMPLEPERIOD;
+        impl->params.dwSamplePeriod = params->dwSamplePeriod;
+    }
+    if (flags & DIEP_STARTDELAY)
+    {
+        if (params->dwSize != sizeof(DIEFFECT_DX6)) return DIERR_INVALIDPARAM;
+        if (impl->params.dwStartDelay != params->dwStartDelay) impl->modified |= DIEP_STARTDELAY;
+        impl->params.dwStartDelay = params->dwStartDelay;
+    }
+    if (flags & DIEP_TRIGGERREPEATINTERVAL)
+    {
+        if (impl->params.dwTriggerRepeatInterval != params->dwTriggerRepeatInterval)
+            impl->modified |= DIEP_TRIGGERREPEATINTERVAL;
+        impl->params.dwTriggerRepeatInterval = params->dwTriggerRepeatInterval;
+    }
+
+    if (flags & DIEP_TRIGGERBUTTON)
+    {
+        if (!object_flags) return DIERR_INVALIDPARAM;
+
+        filter.dwObj = params->dwTriggerButton;
+        old_value = impl->params.dwTriggerButton;
+        ret = enum_objects( impl->joystick, &filter, DIDFT_BUTTON, set_parameters_object,
+                            &impl->params.dwTriggerButton );
+        if (ret != DIENUM_STOP) impl->params.dwTriggerButton = -1;
+        if (impl->params.dwTriggerButton != old_value) impl->modified |= DIEP_TRIGGERBUTTON;
+    }
+
+    impl->flags |= flags;
+
+    if (flags & DIEP_NODOWNLOAD) return DI_DOWNLOADSKIPPED;
+    if (flags & DIEP_START) hr = IDirectInputEffect_Start( iface, 1, 0 );
+    else hr = IDirectInputEffect_Download( iface );
+    if (hr == DIERR_NOTEXCLUSIVEACQUIRED) return DI_DOWNLOADSKIPPED;
+    if (FAILED(hr)) return hr;
+    return DI_OK;
+}
+
+static HRESULT WINAPI hid_joystick_effect_Start( IDirectInputEffect *iface, DWORD iterations, DWORD flags )
+{
+    struct hid_joystick_effect *impl = impl_from_IDirectInputEffect( iface );
+    struct pid_control_report *effect_control = &impl->joystick->pid_effect_control;
+    ULONG count, report_len = impl->joystick->caps.OutputReportByteLength;
+    PHIDP_PREPARSED_DATA preparsed = impl->joystick->preparsed;
+    HANDLE device = impl->joystick->device;
+    NTSTATUS status;
+    USAGE control;
+    HRESULT hr;
+
+    TRACE( "iface %p, iterations %lu, flags %#lx.\n", iface, iterations, flags );
+
+    if ((flags & ~(DIES_NODOWNLOAD|DIES_SOLO))) return DIERR_INVALIDPARAM;
+    if (flags & DIES_SOLO) control = PID_USAGE_OP_EFFECT_START_SOLO;
+    else control = PID_USAGE_OP_EFFECT_START;
+
+    EnterCriticalSection( &impl->joystick->base.crit );
+    if (!is_exclusively_acquired( impl->joystick ))
+        hr = DIERR_NOTEXCLUSIVEACQUIRED;
+    else if ((flags & DIES_NODOWNLOAD) && !impl->index)
+        hr = DIERR_NOTDOWNLOADED;
+    else if ((flags & DIES_NODOWNLOAD) || SUCCEEDED(hr = IDirectInputEffect_Download( iface )))
+    {
+        count = 1;
+        status = HidP_InitializeReportForID( HidP_Output, effect_control->id, preparsed,
+                                             impl->effect_control_buf, report_len );
+
+        if (status != HIDP_STATUS_SUCCESS) hr = status;
+        else status = HidP_SetUsageValue( HidP_Output, HID_USAGE_PAGE_PID, 0, PID_USAGE_EFFECT_BLOCK_INDEX,
+                                          impl->index, preparsed, impl->effect_control_buf, report_len );
+
+        if (status != HIDP_STATUS_SUCCESS) hr = status;
+        else status = HidP_SetUsages( HidP_Output, HID_USAGE_PAGE_PID, effect_control->control_coll,
+                                      &control, &count, preparsed, impl->effect_control_buf, report_len );
+
+        if (status != HIDP_STATUS_SUCCESS) hr = status;
+        else status = HidP_SetUsageValue( HidP_Output, HID_USAGE_PAGE_PID, 0, PID_USAGE_LOOP_COUNT,
+                                          iterations, preparsed, impl->effect_control_buf, report_len );
+
+        if (status != HIDP_STATUS_SUCCESS) hr = status;
+        else if (WriteFile( device, impl->effect_control_buf, report_len, NULL, NULL )) hr = DI_OK;
+        else hr = DIERR_INPUTLOST;
+
+        if (SUCCEEDED(hr)) impl->status |= DIEGES_PLAYING;
+        else impl->status &= ~DIEGES_PLAYING;
+    }
+    LeaveCriticalSection( &impl->joystick->base.crit );
+
+    return hr;
+}
+
+static HRESULT WINAPI hid_joystick_effect_Stop( IDirectInputEffect *iface )
+{
+    struct hid_joystick_effect *impl = impl_from_IDirectInputEffect( iface );
+    struct pid_control_report *effect_control = &impl->joystick->pid_effect_control;
+    ULONG count, report_len = impl->joystick->caps.OutputReportByteLength;
+    PHIDP_PREPARSED_DATA preparsed = impl->joystick->preparsed;
+    HANDLE device = impl->joystick->device;
+    NTSTATUS status;
+    USAGE control;
+    HRESULT hr;
+
+    TRACE( "iface %p.\n", iface );
+
+    EnterCriticalSection( &impl->joystick->base.crit );
+    if (!is_exclusively_acquired( impl->joystick ))
+        hr = DIERR_NOTEXCLUSIVEACQUIRED;
+    else if (!impl->index)
+        hr = DIERR_NOTDOWNLOADED;
+    else
+    {
+        count = 1;
+        control = PID_USAGE_OP_EFFECT_STOP;
+        status = HidP_InitializeReportForID( HidP_Output, effect_control->id, preparsed,
+                                             impl->effect_control_buf, report_len );
+
+        if (status != HIDP_STATUS_SUCCESS) hr = status;
+        else status = HidP_SetUsageValue( HidP_Output, HID_USAGE_PAGE_PID, 0, PID_USAGE_EFFECT_BLOCK_INDEX,
+                                          impl->index, preparsed, impl->effect_control_buf, report_len );
+
+        if (status != HIDP_STATUS_SUCCESS) hr = status;
+        else status = HidP_SetUsages( HidP_Output, HID_USAGE_PAGE_PID, effect_control->control_coll,
+                                      &control, &count, preparsed, impl->effect_control_buf, report_len );
+
+        if (status != HIDP_STATUS_SUCCESS) hr = status;
+        else status = HidP_SetUsageValue( HidP_Output, HID_USAGE_PAGE_PID, 0, PID_USAGE_LOOP_COUNT,
+                                          0, preparsed, impl->effect_control_buf, report_len );
+
+        if (status != HIDP_STATUS_SUCCESS) hr = status;
+        else if (WriteFile( device, impl->effect_control_buf, report_len, NULL, NULL )) hr = DI_OK;
+        else hr = DIERR_INPUTLOST;
+
+        impl->status &= ~DIEGES_PLAYING;
+    }
+    LeaveCriticalSection( &impl->joystick->base.crit );
+
+    return hr;
+}
+
+static HRESULT WINAPI hid_joystick_effect_GetEffectStatus( IDirectInputEffect *iface, DWORD *status )
+{
+    struct hid_joystick_effect *impl = impl_from_IDirectInputEffect( iface );
+    HRESULT hr = DI_OK;
+
+    TRACE( "iface %p, status %p.\n", iface, status );
+
+    if (!status) return E_POINTER;
+    *status = 0;
+
+    EnterCriticalSection( &impl->joystick->base.crit );
+    if (!is_exclusively_acquired( impl->joystick ))
+        hr = DIERR_NOTEXCLUSIVEACQUIRED;
+    else if (!impl->index)
+        hr = DIERR_NOTDOWNLOADED;
+    else
+        *status = impl->status;
+    LeaveCriticalSection( &impl->joystick->base.crit );
+
+    return hr;
+}
+
+static void set_parameter_value( struct hid_joystick_effect *impl, char *report_buf,
+                                 struct hid_value_caps *caps, LONG value )
+{
+    value = scale_to_logical_value( value, caps );
+    return set_report_value( impl->joystick, report_buf, caps, value );
+}
+
+static void set_parameter_value_clamp( struct hid_joystick_effect *impl, char *report_buf,
+                                       struct hid_value_caps *caps, LONG value )
+{
+    value = clamp_to_physical_value( value, caps );
+    return set_parameter_value( impl, report_buf, caps, value );
+}
+
+static void set_parameter_value_angle( struct hid_joystick_effect *impl, char *report_buf,
+                                       struct hid_value_caps *caps, LONG value )
+{
+    LONG exp;
+    if (!caps) return;
+    exp = caps->units_exp;
+    if (caps->units != 0x14) WARN( "unknown angle unit caps %#lx\n", caps->units );
+    else if (exp < -2) while (exp++ < -2) value *= 10;
+    else if (exp > -2) while (exp-- > -2) value /= 10;
+    set_parameter_value_clamp( impl, report_buf, caps, value );
+}
+
+static void set_parameter_value_us( struct hid_joystick_effect *impl, char *report_buf,
+                                    struct hid_value_caps *caps, LONG value )
+{
+    LONG exp;
+
+    if (!caps) return;
+    if (value == INFINITE) return set_report_value( impl->joystick, report_buf, caps, caps->physical_min - 1 );
+
+    exp = caps->units_exp;
+    if (caps->units != 0x1003) WARN( "unknown time unit caps %#lx\n", caps->units );
+    else if (exp < -6) while (exp++ < -6) value *= 10;
+    else if (exp > -6) while (exp-- > -6) value /= 10;
+
+    /* testing shows that duration values are not clamped, any out-of-range values becomes -1 */
+    set_parameter_value( impl, report_buf, caps, value );
+}
+
+static BOOL is_axis_usage_enabled( struct hid_joystick_effect *impl, USAGE usage )
+{
+    DWORD i = impl->params.cAxes;
+    while (i--) if (LOWORD(impl->params.rgdwAxes[i]) == usage) return TRUE;
+    return FALSE;
+}
+
+static HRESULT WINAPI hid_joystick_effect_Download( IDirectInputEffect *iface )
+{
+    static const DWORD complete_mask = DIEP_AXES | DIEP_DIRECTION | DIEP_TYPESPECIFICPARAMS;
+    struct hid_joystick_effect *impl = impl_from_IDirectInputEffect( iface );
+    struct pid_set_constant_force *set_constant_force = &impl->joystick->pid_set_constant_force;
+    struct pid_set_ramp_force *set_ramp_force = &impl->joystick->pid_set_ramp_force;
+    struct pid_effect_update *effect_update = &impl->joystick->pid_effect_update;
+    struct pid_set_condition *set_condition = &impl->joystick->pid_set_condition;
+    struct pid_set_periodic *set_periodic = &impl->joystick->pid_set_periodic;
+    struct pid_set_envelope *set_envelope = &impl->joystick->pid_set_envelope;
+    ULONG report_len = impl->joystick->caps.OutputReportByteLength;
+    HANDLE device = impl->joystick->device;
+    struct hid_value_caps *caps;
+    LONG directions[MAX_PID_AXES] = {0};
+    DWORD i, tmp, count;
+    DIEFFECT spherical;
+    NTSTATUS status;
+    USAGE usage;
+    HRESULT hr;
+
+    TRACE( "iface %p\n", iface );
+
+    EnterCriticalSection( &impl->joystick->base.crit );
+    if (impl->modified) hr = DI_OK;
+    else hr = DI_NOEFFECT;
+
+    if (!is_exclusively_acquired( impl->joystick ))
+        hr = DIERR_NOTEXCLUSIVEACQUIRED;
+    else if ((impl->flags & complete_mask) != complete_mask)
+        hr = DIERR_INCOMPLETEEFFECT;
+    else if (!impl->index && SUCCEEDED(hr = find_next_effect_id( impl->joystick, &impl->index, impl->type )))
+    {
+        if (!impl->type_specific_buf[0]) status = HIDP_STATUS_SUCCESS;
+        else status = HidP_SetUsageValue( HidP_Output, HID_USAGE_PAGE_PID, 0, PID_USAGE_EFFECT_BLOCK_INDEX,
+                                          impl->index, impl->joystick->preparsed, impl->type_specific_buf, report_len );
+        if (status != HIDP_STATUS_SUCCESS) WARN( "HidP_SetUsageValue returned %#lx\n", status );
+
+        if (!impl->set_envelope_buf[0]) status = HIDP_STATUS_SUCCESS;
+        else status = HidP_SetUsageValue( HidP_Output, HID_USAGE_PAGE_PID, 0, PID_USAGE_EFFECT_BLOCK_INDEX,
+                                          impl->index, impl->joystick->preparsed, impl->set_envelope_buf, report_len );
+        if (status != HIDP_STATUS_SUCCESS) WARN( "HidP_SetUsageValue returned %#lx\n", status );
+
+        status = HidP_SetUsageValue( HidP_Output, HID_USAGE_PAGE_PID, 0, PID_USAGE_EFFECT_BLOCK_INDEX,
+                                     impl->index, impl->joystick->preparsed, impl->effect_update_buf, report_len );
+        if (status != HIDP_STATUS_SUCCESS) hr = status;
+        else hr = DI_OK;
+    }
+
+    if (hr == DI_OK)
+    {
+        switch (impl->type)
+        {
+        case PID_USAGE_ET_SQUARE:
+        case PID_USAGE_ET_SINE:
+        case PID_USAGE_ET_TRIANGLE:
+        case PID_USAGE_ET_SAWTOOTH_UP:
+        case PID_USAGE_ET_SAWTOOTH_DOWN:
+            if (!(impl->modified & DIEP_TYPESPECIFICPARAMS)) break;
+
+            set_parameter_value_clamp( impl, impl->type_specific_buf, set_periodic->magnitude_caps,
+                                       impl->periodic.dwMagnitude );
+            set_parameter_value_us( impl, impl->type_specific_buf, set_periodic->period_caps,
+                                    impl->periodic.dwPeriod );
+            set_parameter_value_clamp( impl, impl->type_specific_buf, set_periodic->phase_caps,
+                                       impl->periodic.dwPhase );
+            set_parameter_value_clamp( impl, impl->type_specific_buf, set_periodic->offset_caps,
+                                       impl->periodic.lOffset );
+
+            if (!WriteFile( device, impl->type_specific_buf, report_len, NULL, NULL )) hr = DIERR_INPUTLOST;
+            else impl->modified &= ~DIEP_TYPESPECIFICPARAMS;
+            break;
+        case PID_USAGE_ET_SPRING:
+        case PID_USAGE_ET_DAMPER:
+        case PID_USAGE_ET_INERTIA:
+        case PID_USAGE_ET_FRICTION:
+            if (!(impl->modified & DIEP_TYPESPECIFICPARAMS)) break;
+
+            for (i = 0; i < impl->params.cbTypeSpecificParams / sizeof(DICONDITION); ++i)
+            {
+                status = HidP_SetUsageValue( HidP_Output, HID_USAGE_PAGE_PID, 0, PID_USAGE_PARAMETER_BLOCK_OFFSET,
+                                             i, impl->joystick->preparsed, impl->type_specific_buf, report_len );
+                if (status != HIDP_STATUS_SUCCESS) WARN( "HidP_SetUsageValue %04x:%04x returned %#lx\n",
+                                                         HID_USAGE_PAGE_PID, PID_USAGE_PARAMETER_BLOCK_OFFSET, status );
+                set_parameter_value_clamp( impl, impl->type_specific_buf, set_condition->center_point_offset_caps,
+                                           impl->condition[i].lOffset );
+                set_parameter_value_clamp( impl, impl->type_specific_buf, set_condition->positive_coefficient_caps,
+                                           impl->condition[i].lPositiveCoefficient );
+                set_parameter_value_clamp( impl, impl->type_specific_buf, set_condition->negative_coefficient_caps,
+                                           impl->condition[i].lNegativeCoefficient );
+
+                /* testing shows that saturation values are not clamped, any out-of-range values becomes -1 */
+                set_parameter_value( impl, impl->type_specific_buf, set_condition->positive_saturation_caps,
+                                     impl->condition[i].dwPositiveSaturation );
+                set_parameter_value( impl, impl->type_specific_buf, set_condition->negative_saturation_caps,
+                                     impl->condition[i].dwNegativeSaturation );
+
+                set_parameter_value_clamp( impl, impl->type_specific_buf, set_condition->dead_band_caps,
+                                           impl->condition[i].lDeadBand );
+
+                if (!WriteFile( device, impl->type_specific_buf, report_len, NULL, NULL )) hr = DIERR_INPUTLOST;
+                else impl->modified &= ~DIEP_TYPESPECIFICPARAMS;
+            }
+            break;
+        case PID_USAGE_ET_CONSTANT_FORCE:
+            if (!(impl->modified & DIEP_TYPESPECIFICPARAMS)) break;
+
+            set_parameter_value_clamp( impl, impl->type_specific_buf, set_constant_force->magnitude_caps,
+                                       impl->constant_force.lMagnitude );
+
+            if (!WriteFile( device, impl->type_specific_buf, report_len, NULL, NULL )) hr = DIERR_INPUTLOST;
+            else impl->modified &= ~DIEP_TYPESPECIFICPARAMS;
+            break;
+        case PID_USAGE_ET_RAMP:
+            if (!(impl->modified & DIEP_TYPESPECIFICPARAMS)) break;
+
+            set_parameter_value_clamp( impl, impl->type_specific_buf, set_ramp_force->start_caps,
+                                       impl->ramp_force.lStart );
+            set_parameter_value_clamp( impl, impl->type_specific_buf, set_ramp_force->end_caps,
+                                       impl->ramp_force.lEnd );
+
+            if (!WriteFile( device, impl->type_specific_buf, report_len, NULL, NULL )) hr = DIERR_INPUTLOST;
+            else impl->modified &= ~DIEP_TYPESPECIFICPARAMS;
+            break;
+        }
+    }
+
+    if (hr == DI_OK)
+    {
+        switch (impl->type)
+        {
+        case PID_USAGE_ET_SQUARE:
+        case PID_USAGE_ET_SINE:
+        case PID_USAGE_ET_TRIANGLE:
+        case PID_USAGE_ET_SAWTOOTH_UP:
+        case PID_USAGE_ET_SAWTOOTH_DOWN:
+        case PID_USAGE_ET_CONSTANT_FORCE:
+        case PID_USAGE_ET_RAMP:
+            if (!(impl->flags & DIEP_ENVELOPE)) break;
+            if (!(impl->modified & DIEP_ENVELOPE)) break;
+
+            set_parameter_value_clamp( impl, impl->set_envelope_buf, set_envelope->attack_level_caps,
+                                       impl->envelope.dwAttackLevel );
+            set_parameter_value_us( impl, impl->set_envelope_buf, set_envelope->attack_time_caps,
+                                    impl->envelope.dwAttackTime );
+            set_parameter_value_clamp( impl, impl->set_envelope_buf, set_envelope->fade_level_caps,
+                                       impl->envelope.dwFadeLevel );
+            set_parameter_value_us( impl, impl->set_envelope_buf, set_envelope->fade_time_caps,
+                                    impl->envelope.dwFadeTime );
+
+            if (!WriteFile( device, impl->set_envelope_buf, report_len, NULL, NULL )) hr = DIERR_INPUTLOST;
+            else impl->modified &= ~DIEP_ENVELOPE;
+            break;
+        }
+    }
+
+    if (hr == DI_OK && impl->modified)
+    {
+        set_parameter_value_us( impl, impl->effect_update_buf, effect_update->duration_caps,
+                                impl->params.dwDuration );
+        set_parameter_value_clamp( impl, impl->effect_update_buf, effect_update->gain_caps,
+                                   impl->params.dwGain );
+        set_parameter_value_us( impl, impl->effect_update_buf, effect_update->sample_period_caps,
+                                impl->params.dwSamplePeriod );
+        set_parameter_value_us( impl, impl->effect_update_buf, effect_update->start_delay_caps,
+                                impl->params.dwStartDelay );
+        set_parameter_value_us( impl, impl->effect_update_buf, effect_update->trigger_repeat_interval_caps,
+                                impl->params.dwTriggerRepeatInterval );
+
+        count = 1;
+        usage = PID_USAGE_DIRECTION_ENABLE;
+        status = HidP_SetUsages( HidP_Output, HID_USAGE_PAGE_PID, 0, &usage, &count,
+                                 impl->joystick->preparsed, impl->effect_update_buf, report_len );
+        if (status != HIDP_STATUS_SUCCESS) WARN( "HidP_SetUsages returned %#lx\n", status );
+
+        spherical.rglDirection = directions;
+        convert_directions_to_spherical( &impl->params, &spherical );
+
+        /* FIXME: as far as the test cases go, directions are only written if
+         * either X or Y axes are enabled, maybe need more tests though */
+        if (!is_axis_usage_enabled( impl, HID_USAGE_GENERIC_X ) &&
+            !is_axis_usage_enabled( impl, HID_USAGE_GENERIC_Y ))
+            WARN( "neither X or Y axes are selected, skipping direction\n" );
+        else for (i = 0; i < min( effect_update->direction_count, spherical.cAxes ); ++i)
+        {
+            tmp = directions[i] + (i == 0 ? 9000 : 0);
+            caps = effect_update->direction_caps[effect_update->direction_count - i - 1];
+            set_parameter_value_angle( impl, impl->effect_update_buf, caps, tmp % 36000 );
+        }
+
+        status = HidP_SetUsageValue( HidP_Output, HID_USAGE_PAGE_PID, 0, PID_USAGE_TRIGGER_BUTTON,
+                                     impl->params.dwTriggerButton, impl->joystick->preparsed,
+                                     impl->effect_update_buf, report_len );
+        if (status != HIDP_STATUS_SUCCESS) WARN( "HidP_SetUsageValue returned %#lx\n", status );
+
+        if (!WriteFile( device, impl->effect_update_buf, report_len, NULL, NULL )) hr = DIERR_INPUTLOST;
+        else impl->modified = 0;
+
+        if (SUCCEEDED(hr)) impl->joystick->base.force_feedback_state &= ~DIGFFS_EMPTY;
+    }
+    LeaveCriticalSection( &impl->joystick->base.crit );
+
+    return hr;
+}
+
+static void check_empty_force_feedback_state( struct hid_joystick *joystick )
+{
+    struct hid_joystick_effect *effect;
+    LIST_FOR_EACH_ENTRY( effect, &joystick->effect_list, struct hid_joystick_effect, entry )
+        if (effect->index) return;
+    joystick->base.force_feedback_state |= DIGFFS_EMPTY;
+}
+
+static HRESULT WINAPI hid_joystick_effect_Unload( IDirectInputEffect *iface )
+{
+    struct hid_joystick_effect *impl = impl_from_IDirectInputEffect( iface );
+    struct hid_joystick *joystick = impl->joystick;
+    struct pid_device_pool *device_pool = &joystick->pid_device_pool;
+    struct pid_block_free *block_free = &joystick->pid_block_free;
+    ULONG report_len = joystick->caps.OutputReportByteLength;
+    HRESULT hr = DI_OK;
+    NTSTATUS status;
+
+    TRACE( "iface %p\n", iface );
+
+    EnterCriticalSection( &joystick->base.crit );
+    if (!impl->index)
+        hr = DI_NOEFFECT;
+    else if (SUCCEEDED(hr = IDirectInputEffect_Stop( iface )))
+    {
+        if (!device_pool->device_managed_caps)
+            joystick->effect_inuse[impl->index - 1] = FALSE;
+        else if (block_free->id)
+        {
+            status = HidP_InitializeReportForID( HidP_Output, block_free->id, joystick->preparsed,
+                                                 joystick->output_report_buf, report_len );
+
+            if (status != HIDP_STATUS_SUCCESS) hr = status;
+            else status = HidP_SetUsageValue( HidP_Output, HID_USAGE_PAGE_PID, 0, PID_USAGE_EFFECT_BLOCK_INDEX,
+                                              impl->index, joystick->preparsed, joystick->output_report_buf, report_len );
+
+            if (status != HIDP_STATUS_SUCCESS) hr = status;
+            else if (WriteFile( joystick->device, joystick->output_report_buf, report_len, NULL, NULL )) hr = DI_OK;
+            else hr = DIERR_INPUTLOST;
+        }
+
+        impl->modified = ~0;
+        impl->index = 0;
+        check_empty_force_feedback_state( joystick );
+    }
+    LeaveCriticalSection( &joystick->base.crit );
+
+    return hr;
+}
+
+static HRESULT WINAPI hid_joystick_effect_Escape( IDirectInputEffect *iface, DIEFFESCAPE *escape )
+{
+    FIXME( "iface %p, escape %p stub!\n", iface, escape );
+    return DIERR_UNSUPPORTED;
+}
+
+static IDirectInputEffectVtbl hid_joystick_effect_vtbl =
+{
+    /*** IUnknown methods ***/
+    hid_joystick_effect_QueryInterface,
+    hid_joystick_effect_AddRef,
+    hid_joystick_effect_Release,
+    /*** IDirectInputEffect methods ***/
+    hid_joystick_effect_Initialize,
+    hid_joystick_effect_GetEffectGuid,
+    hid_joystick_effect_GetParameters,
+    hid_joystick_effect_SetParameters,
+    hid_joystick_effect_Start,
+    hid_joystick_effect_Stop,
+    hid_joystick_effect_GetEffectStatus,
+    hid_joystick_effect_Download,
+    hid_joystick_effect_Unload,
+    hid_joystick_effect_Escape,
+};
+
+static HRESULT hid_joystick_create_effect( IDirectInputDevice8W *iface, IDirectInputEffect **out )
+{
+    struct hid_joystick *joystick = impl_from_IDirectInputDevice8W( iface );
+    struct hid_joystick_effect *impl;
+    ULONG report_len;
+
+    if (!(impl = calloc( 1, sizeof(*impl) ))) return DIERR_OUTOFMEMORY;
+    impl->IDirectInputEffect_iface.lpVtbl = &hid_joystick_effect_vtbl;
+    impl->ref = 1;
+    impl->joystick = joystick;
+    dinput_device_internal_addref( &joystick->base );
+
+    EnterCriticalSection( &joystick->base.crit );
+    list_add_tail( &joystick->effect_list, &impl->entry );
+    LeaveCriticalSection( &joystick->base.crit );
+
+    report_len = joystick->caps.OutputReportByteLength;
+    if (!(impl->effect_control_buf = malloc( report_len ))) goto failed;
+    if (!(impl->effect_update_buf = malloc( report_len ))) goto failed;
+    if (!(impl->type_specific_buf = malloc( report_len ))) goto failed;
+    if (!(impl->set_envelope_buf = malloc( report_len ))) goto failed;
+
+    impl->envelope.dwSize = sizeof(DIENVELOPE);
+    impl->params.dwSize = sizeof(DIEFFECT);
+    impl->params.rgdwAxes = impl->axes;
+    impl->params.rglDirection = impl->directions;
+    impl->params.dwTriggerButton = -1;
+    impl->modified = ~0;
+    impl->status = 0;
+
+    *out = &impl->IDirectInputEffect_iface;
+    return DI_OK;
+
+failed:
+    IDirectInputEffect_Release( &impl->IDirectInputEffect_iface );
+    return DIERR_OUTOFMEMORY;
+}
diff -ruN --show-c-function dlls/dinput/tests/device8.c dlls/dinput/tests/device8.c
--- dlls/dinput/tests/device8.c	2025-10-10 10:17:47.162852263 -0700
+++ dlls/dinput/tests/device8.c	2025-10-10 12:03:54.187911262 -0700
@@ -50,6 +50,17 @@ struct enum_data
     };
 };
 
+static void pump_messages(void)
+{
+    MSG msg;
+
+    while (PeekMessageA( &msg, 0, 0, 0, PM_REMOVE ))
+    {
+        TranslateMessage( &msg );
+        DispatchMessageA( &msg );
+    }
+}
+
 static void flush_events(void)
 {
     int min_timeout = 100, diff = 200;
@@ -1769,13 +1780,121 @@ done:
 
 static UINT pointer_enter_count;
 static UINT pointer_up_count;
-static HANDLE touchdown_event, touchleave_event;
+static HANDLE touchdown_event, touchmoved_event, touchleave_event;
 static WPARAM pointer_wparam[16];
 static WPARAM pointer_lparam[16];
 static UINT pointer_count;
+static int touch_test_line;
+static POINT last_cursor_pos;
+static const BOOL *skip_defwnd_for_pointer_message;
+BOOL skip_touch_mouse_tests, touch_missing_leave_todo;
+
+#define start_touch_test(a) start_touch_test_( __LINE__, a )
+static void start_touch_test_( int line, const BOOL *skip_defwnd )
+{
+    pointer_enter_count = pointer_up_count = pointer_count = 0;
+    memset( pointer_wparam, 0, sizeof(pointer_wparam) );
+    memset( pointer_lparam, 0, sizeof(pointer_lparam) );
+
+    skip_defwnd_for_pointer_message = skip_defwnd;
+    SetCursorPos( 0, 0 );
+    GetCursorPos( &last_cursor_pos );
+    touch_test_line = line;
+}
+
+static BOOL get_touch_mouse_message( HWND hwnd, MSG *msg )
+{
+    while (PeekMessageW( msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE ))
+    {
+        if (msg->message != WM_MOUSEMOVE || (GetMessageExtraInfo() & ~(ULONG_PTR)0xff) == 0xff515700) return TRUE;
+    }
+    return FALSE;
+}
+
+static BOOL touch_mouse_message_matches( UINT msg, UINT expect_msg )
+{
+    /* Pointer quick up / downs, holds are used to simulate right mouse button and double clicks on Windows. That
+     * is randomly triggered with the tests. Since currently that is neither avoided nor consciously emulated
+     * in tests just accept that all. */
+    if (expect_msg == WM_LBUTTONDOWN)
+        return msg == WM_LBUTTONDOWN || msg == WM_RBUTTONDOWN || msg == WM_LBUTTONDBLCLK;
+    if (expect_msg == WM_LBUTTONUP)
+        return msg == WM_LBUTTONUP || msg == WM_RBUTTONUP;
+    return msg == expect_msg;
+}
+
+#define expect_touch_mouse_message(a, b, c) expect_touch_mouse_message_( __LINE__, a, b, c )
+static BOOL expect_touch_mouse_message_( int line, HWND hwnd, UINT expect_msg, BOOL optional )
+{
+    INPUT_MESSAGE_SOURCE source;
+    LPARAM extra;
+    DWORD pos;
+    BOOL bret;
+    POINT cp;
+    MSG msg;
+
+    if (skip_touch_mouse_tests) return TRUE;
+
+    if (!(bret = get_touch_mouse_message( hwnd, &msg )) && !optional)
+    {
+        MsgWaitForMultipleObjects( 0, NULL, FALSE, 100, QS_MOUSE );
+        bret = get_touch_mouse_message( hwnd, &msg );
+    }
+
+    if (!optional)
+        ok_(__FILE__, line)( bret, "did not receive mouse message, expected %#x.\n", expect_msg );
+    if (!bret) return FALSE;
+
+    if (optional && !touch_mouse_message_matches( msg.message, expect_msg ))
+    {
+        trace_(__FILE__, line)( "got message %#x instead of optional %#x.\n", msg.message, expect_msg );
+        return FALSE;
+    }
+
+    ok_(__FILE__, line)( touch_mouse_message_matches( msg.message, expect_msg ),
+                         "got message %#x, expected %#x.\n", msg.message, expect_msg );
+
+    bret = GetCurrentInputMessageSource( &source );
+    ok_(__FILE__, line)( bret, "got error %ld.\n", GetLastError() );
+    ok_(__FILE__, line)( source.deviceType == IMDT_TOUCH, "got deviceType %#x, expected %#x.\n",
+                         source.deviceType, IMDT_TOUCH );
+    ok_(__FILE__, line)( source.originId == IMO_HARDWARE, "got originId %#x, expected %#x.\n",
+                         source.originId, IMO_HARDWARE );
+
+    cp = last_cursor_pos;
+    pos = msg.lParam;
+    ok_(__FILE__, line)( pos == MAKELPARAM(cp.x, cp.y), "got coords (%d, %d), expected (%ld, %ld).\n",
+                         LOWORD(pos), HIWORD(pos), cp.x, cp.y );
+    pos = GetMessagePos();
+    ok_(__FILE__, line)( pos == MAKELPARAM(cp.x, cp.y), "got coords (%d, %d), expected (%ld, %ld).\n",
+                         LOWORD(pos), HIWORD(pos), cp.x, cp.y );
+
+    extra = GetMessageExtraInfo();
+    ok_(__FILE__, line)( (extra & ~(ULONG_PTR)0xff) == 0xff515700, "got message extra info %#Ix, expected %#x.\n",
+                         extra, 0xff515700 );
+    return TRUE;
+}
 
 static LRESULT CALLBACK touch_screen_wndproc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
 {
+    static struct
+    {
+        UINT pointerid;
+        BOOL tracking_started;
+        POINT curr_pos;
+    }
+    state[64];
+    static unsigned int active_touch_count, total_touch_count;
+
+    BOOL pointer_moved, curpos_changed;
+    UINT expect_message_after;
+    unsigned int i;
+    UINT pointerid;
+    LRESULT ret;
+    MSG message;
+    BOOL bret;
+    POINT pt;
+
     if (msg == WM_POINTERENTER)
     {
         pointer_wparam[pointer_count] = wparam;
@@ -1783,8 +1902,6 @@ static LRESULT CALLBACK touch_screen_wnd
         pointer_count++;
         pointer_enter_count++;
     }
-    if (msg == WM_POINTERDOWN) ReleaseSemaphore( touchdown_event, 1, NULL );
-
     if (msg == WM_POINTERUP)
     {
         pointer_wparam[pointer_count] = wparam;
@@ -1792,9 +1909,182 @@ static LRESULT CALLBACK touch_screen_wnd
         pointer_count++;
         pointer_up_count++;
     }
-    if (msg == WM_POINTERLEAVE) ReleaseSemaphore( touchleave_event, 1, NULL );
 
-    return DefWindowProcW( hwnd, msg, wparam, lparam );
+    if (!skip_touch_mouse_tests && msg >= WM_MOUSEFIRST && msg <= WM_MOUSELAST)
+    {
+        INPUT_MESSAGE_SOURCE source;
+        GetCurrentInputMessageSource( &source );
+        ok( source.deviceType != IMDT_TOUCH, "got touch mouse message %#x outside of state tracking.\n", msg );
+    }
+
+    if (!(msg >= WM_POINTERUPDATE && msg <= WM_POINTERLEAVE))
+        return DefWindowProcW( hwnd, msg, wparam, lparam );
+
+    pointerid = GET_POINTERID_WPARAM( wparam );
+    winetest_push_context( "line %d, pointer msg %#x, wp %#Ix, lp %#Ix, pointerid %#x",
+                           touch_test_line, msg, wparam, lparam, pointerid );
+    for (i = 0; i < ARRAY_SIZE(state); ++i)
+    {
+        if (state[i].pointerid == pointerid) break;
+    }
+    if (msg == WM_POINTERENTER)
+    {
+        todo_wine_if(touch_missing_leave_todo) ok( i == ARRAY_SIZE(state), "Duplicate WM_POINTERDOWN for id %#x.\n", pointerid );
+        touch_missing_leave_todo = FALSE;
+        if (i == ARRAY_SIZE(state))
+        {
+            for (i = 0; i < ARRAY_SIZE(state); ++i)
+            {
+                if (!state[i].pointerid) break;
+            }
+        }
+        else
+        {
+            ok( active_touch_count == 1, "got %u.\n", active_touch_count );
+            ok( total_touch_count == 1, "got %u.\n", total_touch_count );
+            if (!--active_touch_count) total_touch_count = 0;
+        }
+        ok( i < ARRAY_SIZE(state), "No free space in state table.\n" );
+        state[i].pointerid = pointerid;
+        state[i].tracking_started = FALSE;
+        state[i].curr_pos.x = LOWORD(lparam);
+        state[i].curr_pos.y = HIWORD(lparam);
+        ++active_touch_count;
+        ++total_touch_count;
+    }
+    else if (msg != WM_POINTERLEAVE)
+    {
+        ok( i < ARRAY_SIZE(state), "Missed WM_POINTERDOWN for id %#x.\n", pointerid );
+    }
+
+    pointer_moved = LOWORD(lparam) != state[i].curr_pos.x || HIWORD(lparam) != state[i].curr_pos.y;
+    curpos_changed = LOWORD(lparam) != last_cursor_pos.x || HIWORD(lparam) != last_cursor_pos.y;
+    expect_message_after = 0;
+
+        if (winetest_debug > 1)
+            trace( "msg %#x, msgpos (%d, %d), tracking %d, t %ld, pointer_moved %d, curpos_changed %d.\n",
+                    msg, LOWORD(lparam), HIWORD(lparam), state[i].tracking_started, GetTickCount(),
+                    pointer_moved, curpos_changed);
+
+    if (state[i].tracking_started)
+    {
+        if (msg == WM_POINTERUPDATE && (pointer_moved || curpos_changed)
+            && active_touch_count && total_touch_count == 1)
+        {
+            state[i].curr_pos.x = LOWORD(lparam);
+            state[i].curr_pos.y = HIWORD(lparam);
+            last_cursor_pos = state[i].curr_pos;
+            expect_touch_mouse_message( hwnd, WM_MOUSEMOVE, FALSE );
+        }
+        else if (msg == WM_POINTERUP)
+        {
+            if (pointer_moved || curpos_changed)
+            {
+                state[i].curr_pos.x = LOWORD(lparam);
+                state[i].curr_pos.y = HIWORD(lparam);
+                last_cursor_pos = state[i].curr_pos;
+                expect_touch_mouse_message( hwnd, WM_MOUSEMOVE, FALSE );
+            }
+            if (!expect_touch_mouse_message( hwnd, WM_LBUTTONUP, TRUE ))
+            {
+                /* This message arrives here most of the time, but sometimes it is delayed until after DefWindowProc
+                 * call, maybe based on timing between WM_POINTERUPDATE which changed the position first time
+                 * and WM_POINTERUP. */
+                expect_message_after = WM_LBUTTONUP;
+            }
+        }
+    }
+    else
+    {
+        if (!skip_touch_mouse_tests) do
+        {
+            bret = get_touch_mouse_message( hwnd, &message );
+
+            ok( !bret, "got mouse message before DefWindowProc, msg  %#x, wp %#Ix, lp %#Ix.\n",
+                       message.message, message.wParam, message.lParam );
+        } while (bret);
+    }
+
+    if (skip_defwnd_for_pointer_message && skip_defwnd_for_pointer_message[msg - WM_POINTERUPDATE])
+    {
+        ret = 0;
+    }
+    else
+    {
+        /* The handling in DefWindowProc() doesn't depend on pointer flags in wparam and position in lparam */
+        ret = DefWindowProcW( hwnd, msg, LOWORD(wparam), 0 );
+        ok( !ret, "got %Id from DefWindowProcW.\n", ret );
+
+        if (skip_defwnd_for_pointer_message && skip_defwnd_for_pointer_message[WM_POINTERDOWN - WM_POINTERUPDATE])
+        {
+            /* No mouse messages al all if DefWindowProcW() wasn't called for WM_POINTERDOWN. */
+        }
+        else if (msg == WM_POINTERUPDATE && pointer_moved && !state[i].tracking_started && active_touch_count && total_touch_count == 1)
+        {
+            last_cursor_pos = state[i].curr_pos;
+            expect_touch_mouse_message( hwnd, WM_MOUSEMOVE, FALSE );
+            state[i].curr_pos.x = LOWORD(lparam);
+            state[i].curr_pos.y = HIWORD(lparam);
+            if (!state[i].tracking_started)
+            {
+                state[i].tracking_started = TRUE;
+                expect_touch_mouse_message( hwnd, WM_LBUTTONDOWN, FALSE );
+                last_cursor_pos = state[i].curr_pos;
+                expect_touch_mouse_message( hwnd, WM_MOUSEMOVE, FALSE );
+            }
+        }
+        else if (msg == WM_POINTERUP && active_touch_count == 1 && total_touch_count == 1)
+        {
+            if (!state[i].tracking_started)
+            {
+                last_cursor_pos = state[i].curr_pos;
+                if (!expect_touch_mouse_message( hwnd, WM_MOUSEMOVE, TRUE ))
+                {
+                    /* A lot of details go different before Win10, so don't perform the rest of mouse message tests. */
+                    win_skip( "Old behaviour detected, skipping remaining mouse tracking tests.\n" );
+                    skip_touch_mouse_tests = TRUE;
+                }
+                expect_touch_mouse_message( hwnd, WM_LBUTTONDOWN, FALSE );
+                expect_touch_mouse_message( hwnd, WM_LBUTTONUP, FALSE );
+            }
+        }
+
+        if (!skip_touch_mouse_tests)
+        {
+            GetCursorPos( &pt );
+            /* This is flaky because GetCursorPos() currently periodically updated from mouse position from
+             * display driver. While we try to update that on mouse position update from pointer that may
+             * still fail. */
+            flaky_wine ok( pt.x == last_cursor_pos.x && pt.y == last_cursor_pos.y, "got (%ld, %ld), expected (%ld, %ld).\n",
+                           pt.x, pt.y, last_cursor_pos.x, last_cursor_pos.y );
+        }
+    }
+
+    if (expect_message_after) expect_touch_mouse_message( hwnd, expect_message_after, FALSE );
+    if (msg == WM_POINTERDOWN && total_touch_count > 1)
+    {
+        /* With double touch, depending on WM_POINTERDOWN / WM_POINTERUPDATE timing, we may get mouse down message
+         * here (both on Windows and Wine). Then we are going to get mouse up before DefWindowProc which will be
+         * handled by our test state tracker with 'tracking_started' set. */
+        if (expect_touch_mouse_message( hwnd, WM_LBUTTONDOWN, TRUE ))
+        {
+            trace( "Got WM_LBUTTONDOWN on WM_POINTERDOWN.\n" );
+            state[i].tracking_started = TRUE;
+        }
+    }
+
+    if (msg == WM_POINTERUP)
+    {
+        state[i].pointerid = 0;
+        ok( active_touch_count, "got 0.\n" );
+        if (!--active_touch_count) total_touch_count = 0;
+    }
+
+    winetest_pop_context();
+    if (msg == WM_POINTERUPDATE && pointer_moved) SetEvent( touchmoved_event );
+    if (msg == WM_POINTERDOWN) ReleaseSemaphore( touchdown_event, 1, NULL );
+    if (msg == WM_POINTERLEAVE) ReleaseSemaphore( touchleave_event, 1, NULL );
+    return ret;
 }
 
 static void test_hid_touch_screen(void)
@@ -1910,6 +2200,16 @@ static void test_hid_touch_screen(void)
         .code = IOCTL_HID_READ_REPORT,
         .report_buf = {1, 1, 0x01,0x02,0x08,0x10},
     };
+    struct hid_expect touch_single2 =
+    {
+        .code = IOCTL_HID_READ_REPORT,
+        .report_buf = {1, 1, 0x01,0x02,0x18,0x20},
+    };
+    struct hid_expect touch_single3 =
+    {
+        .code = IOCTL_HID_READ_REPORT,
+        .report_buf = {1, 1, 0x01,0x02,0x40,0x50},
+    };
     struct hid_expect touch_multiple =
     {
         .code = IOCTL_HID_READ_REPORT,
@@ -1928,11 +2228,26 @@ static void test_hid_touch_screen(void)
         .report_buf = {1,0x02},
     };
 
+    static struct
+    {
+        BOOL skip_message[5];
+    }
+    mouse_tests[] =
+    {
+        /* WM_POINTERUPDATE, WM_POINTERDOWN, WM_POINTERUP, WM_POINTERENTER, WM_POINTERLEAVE */
+        {{ FALSE }},
+        {{ FALSE, TRUE }},
+        {{ TRUE }},
+        {{ FALSE, FALSE, TRUE }},
+        {{ TRUE, FALSE, TRUE }},
+    };
+
     RAWINPUTDEVICE rawdevice = {.usUsagePage = HID_USAGE_PAGE_DIGITIZER, .usUsage = HID_USAGE_DIGITIZER_TOUCH_SCREEN};
     UINT rawbuffer_count, rawbuffer_size, expect_flags, id, width, height;
     WCHAR device_path[MAX_PATH];
     char rawbuffer[1024];
     RAWINPUT *rawinput;
+    unsigned int i, j;
     HANDLE file;
     DWORD res;
     HWND hwnd;
@@ -1943,6 +2258,8 @@ static void test_hid_touch_screen(void)
 
     touchdown_event = CreateSemaphoreW( NULL, 0, LONG_MAX, NULL );
     ok( !!touchdown_event, "CreateSemaphoreW failed, error %lu\n", GetLastError() );
+    touchmoved_event = CreateEventW( NULL, FALSE, FALSE, NULL );
+    ok( !!touchmoved_event, "CreateEventW failed, error %lu\n", GetLastError() );
     touchleave_event = CreateSemaphoreW( NULL, 0, LONG_MAX, NULL );
     ok( !!touchleave_event, "CreateSemaphoreW failed, error %lu\n", GetLastError() );
 
@@ -1986,17 +2303,13 @@ static void test_hid_touch_screen(void)
 
     /* check basic touch_screen input injection to window message */
 
-    SetCursorPos( 0, 0 );
-
     hwnd = create_foreground_window( TRUE );
     SetWindowLongPtrW( hwnd, GWLP_WNDPROC, (LONG_PTR)touch_screen_wndproc );
 
 
     /* a single touch is automatically released if we don't send continuous updates */
 
-    pointer_enter_count = pointer_up_count = pointer_count = 0;
-    memset( pointer_wparam, 0, sizeof(pointer_wparam) );
-    memset( pointer_lparam, 0, sizeof(pointer_lparam) );
+    start_touch_test( NULL );
     bus_send_hid_input( file, &desc, &touch_single, sizeof(touch_single) );
 
     res = MsgWaitForMultipleObjects( 0, NULL, FALSE, 500, QS_POINTER );
@@ -2033,6 +2346,8 @@ static void test_hid_touch_screen(void)
     todo_wine
     ok( HIWORD( pointer_lparam[1] ) * 128 / height == 0x10, "got lparam %#Ix\n", pointer_lparam[1] );
 
+    /* Wine is currently missing WM_POINTERUP generation in this case. */
+    touch_missing_leave_todo = TRUE;
 
     /* test that we receive HID rawinput type with the touchscreen */
 
@@ -2143,9 +2458,7 @@ static void test_hid_touch_screen(void)
 
     /* now the touch is continuously updated */
 
-    pointer_enter_count = pointer_up_count = pointer_count = 0;
-    memset( pointer_wparam, 0, sizeof(pointer_wparam) );
-    memset( pointer_lparam, 0, sizeof(pointer_lparam) );
+    start_touch_test( NULL );
     bus_send_hid_input( file, &desc, &touch_single, sizeof(touch_single) );
 
     res = msg_wait_for_events( 1, &touchdown_event, 1000 );
@@ -2194,12 +2507,14 @@ static void test_hid_touch_screen(void)
     pointer_enter_count = pointer_up_count = pointer_count = 0;
     memset( pointer_wparam, 0, sizeof(pointer_wparam) );
     memset( pointer_lparam, 0, sizeof(pointer_lparam) );
+
     bus_send_hid_input( file, &desc, &touch_multiple, sizeof(touch_multiple) );
 
     res = msg_wait_for_events( 1, &touchdown_event, 1000 );
     ok( res == 0, "WaitForSingleObject returned %#lx\n", res );
     res = msg_wait_for_events( 1, &touchdown_event, 1000 );
     ok( res == 0, "WaitForSingleObject returned %#lx\n", res );
+
     res = msg_wait_for_events( 1, &touchleave_event, 10 );
     ok( res == WAIT_TIMEOUT, "WaitForSingleObject returned %#lx\n", res );
     ok( pointer_enter_count == 2, "got pointer_enter_count %u\n", pointer_enter_count );
@@ -2256,7 +2571,57 @@ static void test_hid_touch_screen(void)
     ok( LOWORD( pointer_lparam[1] ) * 128 / width == 0x18, "got lparam %#Ix\n", pointer_lparam[1] );
     ok( HIWORD( pointer_lparam[1] ) * 128 / height == 0x20, "got lparam %#Ix\n", pointer_lparam[1] );
 
+    /* Test mouse messages generation. */
+    SetCapture( hwnd );
+    pump_messages();
+    for (i = 0; i < ARRAY_SIZE(mouse_tests); ++i)
+    {
+        for (j = 0; j < 2; ++j)
+        {
+            winetest_push_context( "test %u, %u", i, j );
+
+            res = WaitForSingleObject( touchdown_event, 0 );
+            ok( res == WAIT_TIMEOUT, "WaitForSingleObject returned %#lx\n", res );
+            res = WaitForSingleObject( touchleave_event, 0 );
+            ok( res == WAIT_TIMEOUT, "WaitForSingleObject returned %#lx\n", res );
+
+            start_touch_test( mouse_tests[i].skip_message );
+            bus_send_hid_input( file, &desc, &touch_single, sizeof(touch_single) );
+            ResetEvent( touchmoved_event );
+            res = msg_wait_for_events( 1, &touchdown_event, 1000 );
+            ok( res == 0, "WaitForSingleObject returned %#lx\n", res );
+
+            if (j)
+            {
+                /* Current cursor positon affects WM_MOUSEMOVE messages. */
+                start_touch_test( mouse_tests[i].skip_message );
+            }
+            ResetEvent( touchmoved_event );
+            bus_send_hid_input( file, &desc, &touch_single2, sizeof(touch_single2) );
+
+            res = msg_wait_for_events( 1, &touchmoved_event, 1000 );
+            ok( res == 0, "WaitForSingleObject returned %#lx\n", res );
+
+            if (j) start_touch_test( mouse_tests[i].skip_message );
+            ResetEvent( touchmoved_event );
+            bus_send_hid_input( file, &desc, &touch_single3, sizeof(touch_single3) );
+            res = msg_wait_for_events( 1, &touchmoved_event, 1000 );
+            ok( res == 0, "WaitForSingleObject returned %#lx\n", res );
+
+            if (j) start_touch_test( mouse_tests[i].skip_message );
+            bus_send_hid_input( file, & desc, &touch_release, sizeof(touch_release) );
+            res = msg_wait_for_events( 1, &touchleave_event, 1000 );
+            ok( res == 0, "WaitForSingleObject returned %#lx\n", res );
+
+            start_touch_test( NULL );
+            pump_messages();
+
+            winetest_pop_context();
+        }
+    }
 
+    ret = ReleaseCapture();
+    ok( ret, "ReleaseCapture() failed.\n" );
     DestroyWindow( hwnd );
 
     CloseHandle( file );
@@ -2265,6 +2630,7 @@ done:
     hid_device_stop( &desc, 1 );
 
     CloseHandle( touchdown_event );
+    CloseHandle( touchmoved_event );
     CloseHandle( touchleave_event );
 }
 
diff -ruN --show-c-function dlls/dinput8/Makefile.in dlls/dinput8/Makefile.in
--- dlls/dinput8/Makefile.in	2025-10-10 10:17:47.163745056 -0700
+++ dlls/dinput8/Makefile.in	2025-10-10 12:03:54.186523231 -0700
@@ -2,6 +2,7 @@ MODULE    = dinput8.dll
 IMPORTLIB = dinput8
 IMPORTS   = dinput8 dxguid uuid comctl32 ole32 user32 advapi32 hid setupapi
 EXTRADEFS = -DDIRECTINPUT_VERSION=0x0800
+EXTRADLLFLAGS = -Wb,--prefer-native
 PARENTSRC = ../dinput
 
 SOURCES = \
diff -ruN --show-c-function dlls/hidclass.sys/device.c dlls/hidclass.sys/device.c
--- dlls/hidclass.sys/device.c	2025-10-10 10:17:47.208778503 -0700
+++ dlls/hidclass.sys/device.c	2025-10-10 12:03:54.184034086 -0700
@@ -221,6 +221,7 @@ static void hid_device_queue_input( stru
     HIDP_COLLECTION_DESC *desc = pdo->collection_desc;
     ULONG size, report_len = polled ? packet->reportBufferLen : desc->InputLength;
     struct hid_report *last_report, *report;
+    BOOL steam_overlay_open = FALSE;
     struct hid_queue *queue;
     LIST_ENTRY completed, *entry;
     KIRQL irql;
@@ -228,7 +229,10 @@ static void hid_device_queue_input( stru
 
     TRACE( "pdo %p, packet %p\n", pdo, packet );
 
-    if (IsEqualGUID( pdo->base.class_guid, &GUID_DEVINTERFACE_HID ))
+    if (WaitForSingleObject( pdo->base.steam_overlay_event, 0 ) == WAIT_OBJECT_0) /* steam overlay is open */
+        steam_overlay_open = TRUE;
+
+    if (IsEqualGUID( pdo->base.class_guid, &GUID_DEVINTERFACE_HID ) && !steam_overlay_open)
     {
         struct hid_packet *hid;
 
@@ -378,6 +382,8 @@ struct device_strings
 
 static const struct device_strings device_strings[] =
 {
+    /* CW-Bug-Id: #23185 Emulate Steam Input native hooks for native SDL */
+    { .id = L"VID_28DE&PID_11FF", .product = L"Controller (XBOX 360 For Windows)" },
     /* Microsoft controllers */
     { .id = L"VID_045E&PID_028E", .product = L"Controller (XBOX 360 For Windows)" },
     { .id = L"VID_045E&PID_028F", .product = L"Controller (XBOX 360 For Windows)" },
diff -ruN --show-c-function dlls/hidclass.sys/device.c.orig dlls/hidclass.sys/device.c.orig
--- dlls/hidclass.sys/device.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ dlls/hidclass.sys/device.c.orig	2025-10-10 12:03:47.992481472 -0700
@@ -0,0 +1,818 @@
+/*
+ * HIDClass device functions
+ *
+ * Copyright (C) 2015 Aric Stewart
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+#include <stdlib.h>
+#include "hid.h"
+#include "winreg.h"
+#include "ntuser.h"
+
+#include "ddk/hidsdi.h"
+#include "ddk/hidtypes.h"
+#include "ddk/wdm.h"
+
+#include "wine/debug.h"
+#include "wine/list.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(hid);
+
+static void WINAPI read_cancel_routine(DEVICE_OBJECT *device, IRP *irp)
+{
+    struct hid_queue *queue = irp->Tail.Overlay.OriginalFileObject->FsContext;
+    KIRQL irql;
+
+    TRACE("cancel %p IRP on device %p\n", irp, device);
+
+    IoReleaseCancelSpinLock(irp->CancelIrql);
+
+    KeAcquireSpinLock( &queue->lock, &irql );
+
+    RemoveEntryList(&irp->Tail.Overlay.ListEntry);
+
+    KeReleaseSpinLock( &queue->lock, irql );
+
+    irp->IoStatus.Status = STATUS_CANCELLED;
+    irp->IoStatus.Information = 0;
+    IoCompleteRequest(irp, IO_NO_INCREMENT);
+}
+
+static struct hid_report *hid_report_create( HID_XFER_PACKET *packet, ULONG length )
+{
+    struct hid_report *report;
+
+    if (!(report = malloc( offsetof( struct hid_report, buffer[length] ) )))
+        return NULL;
+    report->ref = 1;
+    report->length = length;
+    memcpy( report->buffer, packet->reportBuffer, packet->reportBufferLen );
+    memset( report->buffer + packet->reportBufferLen, 0, length - packet->reportBufferLen );
+
+    return report;
+}
+
+static void hid_report_incref( struct hid_report *report )
+{
+    InterlockedIncrement( &report->ref );
+}
+
+static void hid_report_decref( struct hid_report *report )
+{
+    if (!report) return;
+    if (InterlockedDecrement( &report->ref ) == 0) free( report );
+}
+
+static struct hid_queue *hid_queue_create( void )
+{
+    struct hid_queue *queue;
+
+    if (!(queue = calloc( 1, sizeof(struct hid_queue) ))) return NULL;
+    InitializeListHead( &queue->irp_queue );
+    KeInitializeSpinLock( &queue->lock );
+    list_init( &queue->entry );
+    queue->length = 32;
+    queue->read_idx = 0;
+    queue->write_idx = 0;
+
+    return queue;
+}
+
+static IRP *hid_queue_pop_irp( struct hid_queue *queue )
+{
+    LIST_ENTRY *entry;
+    IRP *irp = NULL;
+    KIRQL irql;
+
+    KeAcquireSpinLock( &queue->lock, &irql );
+
+    while (!irp && (entry = RemoveHeadList( &queue->irp_queue )) != &queue->irp_queue)
+    {
+        irp = CONTAINING_RECORD( entry, IRP, Tail.Overlay.ListEntry );
+        if (!IoSetCancelRoutine( irp, NULL ))
+        {
+            /* cancel routine is already cleared, meaning that it was called. let it handle completion. */
+            InitializeListHead( &irp->Tail.Overlay.ListEntry );
+            irp = NULL;
+        }
+    }
+
+    KeReleaseSpinLock( &queue->lock, irql );
+    return irp;
+}
+
+void hid_queue_remove_pending_irps( struct hid_queue *queue )
+{
+    IRP *irp;
+
+    while ((irp = hid_queue_pop_irp( queue )))
+    {
+        irp->IoStatus.Status = STATUS_DEVICE_NOT_CONNECTED;
+        IoCompleteRequest( irp, IO_NO_INCREMENT );
+    }
+}
+
+void hid_queue_destroy( struct hid_queue *queue )
+{
+    hid_queue_remove_pending_irps( queue );
+    while (queue->length--) hid_report_decref( queue->reports[queue->length] );
+    list_remove( &queue->entry );
+    free( queue );
+}
+
+static NTSTATUS hid_queue_resize( struct hid_queue *queue, ULONG length )
+{
+    struct hid_report *old_reports[512];
+    LONG old_length = queue->length;
+    KIRQL irql;
+
+    if (length < 2 || length > 512) return STATUS_INVALID_PARAMETER;
+    if (length == queue->length) return STATUS_SUCCESS;
+
+    KeAcquireSpinLock( &queue->lock, &irql );
+    memcpy( old_reports, queue->reports, old_length * sizeof(void *) );
+    memset( queue->reports, 0, old_length * sizeof(void *) );
+    queue->length = length;
+    queue->write_idx = 0;
+    queue->read_idx = 0;
+    KeReleaseSpinLock( &queue->lock, irql );
+
+    while (old_length--) hid_report_decref( old_reports[old_length] );
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS hid_queue_push_irp( struct hid_queue *queue, IRP *irp )
+{
+    KIRQL irql;
+
+    KeAcquireSpinLock( &queue->lock, &irql );
+
+    IoSetCancelRoutine( irp, read_cancel_routine );
+    if (irp->Cancel && IoSetCancelRoutine( irp, NULL ))
+    {
+        /* IRP was canceled before we set cancel routine */
+        InitializeListHead( &irp->Tail.Overlay.ListEntry );
+        KeReleaseSpinLock( &queue->lock, irql );
+        return STATUS_CANCELLED;
+    }
+
+    InsertTailList( &queue->irp_queue, &irp->Tail.Overlay.ListEntry );
+    irp->IoStatus.Status = STATUS_PENDING;
+    IoMarkIrpPending( irp );
+
+    KeReleaseSpinLock( &queue->lock, irql );
+    return STATUS_PENDING;
+}
+
+static void hid_queue_push_report( struct hid_queue *queue, struct hid_report *report )
+{
+    ULONG i = queue->write_idx, next = i + 1;
+    struct hid_report *prev;
+    KIRQL irql;
+
+    if (next >= queue->length) next = 0;
+    hid_report_incref( report );
+
+    KeAcquireSpinLock( &queue->lock, &irql );
+    prev = queue->reports[i];
+    queue->reports[i] = report;
+    if (next == queue->read_idx) queue->read_idx = next + 1;
+    if (queue->read_idx >= queue->length) queue->read_idx = 0;
+    KeReleaseSpinLock( &queue->lock, irql );
+
+    hid_report_decref( prev );
+    queue->write_idx = next;
+}
+
+static struct hid_report *hid_queue_pop_report( struct hid_queue *queue )
+{
+    ULONG i = queue->read_idx, next = i + 1;
+    struct hid_report *report;
+    KIRQL irql;
+
+    if (next >= queue->length) next = 0;
+
+    KeAcquireSpinLock( &queue->lock, &irql );
+    report = queue->reports[i];
+    queue->reports[i] = NULL;
+    if (i != queue->write_idx) queue->read_idx = next;
+    KeReleaseSpinLock( &queue->lock, irql );
+
+    return report;
+}
+
+static void hid_device_queue_input( struct phys_device *pdo, HID_XFER_PACKET *packet, BOOL polled )
+{
+    HIDP_COLLECTION_DESC *desc = pdo->collection_desc;
+    ULONG size, report_len = polled ? packet->reportBufferLen : desc->InputLength;
+    struct hid_report *last_report, *report;
+    struct hid_queue *queue;
+    LIST_ENTRY completed, *entry;
+    KIRQL irql;
+    IRP *irp;
+
+    TRACE( "pdo %p, packet %p\n", pdo, packet );
+
+    if (IsEqualGUID( pdo->base.class_guid, &GUID_DEVINTERFACE_HID ))
+    {
+        struct hid_packet *hid;
+
+        size = offsetof( struct hid_packet, data[report_len] );
+        if (!(hid = malloc( size ))) ERR( "Failed to allocate rawinput data!\n" );
+        else
+        {
+            INPUT input = {.type = INPUT_HARDWARE};
+
+            input.hi.uMsg = WM_INPUT;
+            input.hi.wParamH = HIWORD(RIM_INPUT);
+            input.hi.wParamL = LOWORD(RIM_INPUT);
+
+            hid->head.device = pdo->rawinput_handle;
+            hid->head.usage = MAKELONG(desc->Usage, desc->UsagePage);
+
+            hid->head.count = 1;
+            hid->head.length = report_len;
+            memcpy( hid->data, packet->reportBuffer, packet->reportBufferLen );
+            memset( hid->data + packet->reportBufferLen, 0, report_len - packet->reportBufferLen );
+            NtUserSendHardwareInput( 0, 0, &input, (LPARAM)hid );
+
+            free( hid );
+        }
+    }
+
+    if (!(last_report = hid_report_create( packet, report_len )))
+    {
+        ERR( "Failed to allocate hid_report!\n" );
+        return;
+    }
+
+    InitializeListHead( &completed );
+
+    KeAcquireSpinLock( &pdo->lock, &irql );
+    if (pdo->removed) WARN( "Device has been removed, dropping report\n" );
+    else LIST_FOR_EACH_ENTRY( queue, &pdo->queues, struct hid_queue, entry )
+    {
+        if (!polled) hid_queue_push_report( queue, last_report );
+
+        do
+        {
+            if (!(irp = hid_queue_pop_irp( queue ))) break;
+            if (!(report = hid_queue_pop_report( queue ))) hid_report_incref( (report = last_report) );
+
+            memcpy( irp->AssociatedIrp.SystemBuffer, report->buffer, report->length );
+            irp->IoStatus.Information = report->length;
+            irp->IoStatus.Status = STATUS_SUCCESS;
+            hid_report_decref( report );
+
+            InsertTailList( &completed, &irp->Tail.Overlay.ListEntry );
+        }
+        while (polled);
+    }
+    KeReleaseSpinLock( &pdo->lock, irql );
+
+    while ((entry = RemoveHeadList( &completed )) != &completed)
+    {
+        irp = CONTAINING_RECORD( entry, IRP, Tail.Overlay.ListEntry );
+        IoCompleteRequest( irp, IO_NO_INCREMENT );
+    }
+
+    hid_report_decref( last_report );
+}
+
+HIDP_REPORT_IDS *find_report_with_type_and_id( HIDP_DEVICE_DESC *desc, UCHAR collection, BYTE type, BYTE id, BOOL any_id )
+{
+    HIDP_REPORT_IDS *report, *reports = desc->ReportIDs;
+    ULONG report_count = desc->ReportIDsLength;
+
+    for (report = reports; report != reports + report_count; report++)
+    {
+        if (collection && collection != report->CollectionNumber) continue;
+        if (!any_id && report->ReportID && report->ReportID != id) continue;
+        if (type == HidP_Input && report->InputLength) return report;
+        if (type == HidP_Output && report->OutputLength) return report;
+        if (type == HidP_Feature && report->FeatureLength) return report;
+    }
+
+    return NULL;
+}
+
+DWORD CALLBACK hid_device_thread(void *args)
+{
+    DEVICE_OBJECT *device = (DEVICE_OBJECT*)args;
+    struct func_device *fdo = fdo_from_DEVICE_OBJECT( device );
+    HIDP_REPORT_IDS *report;
+    NTSTATUS status;
+
+    do
+    {
+        LARGE_INTEGER delay = {.QuadPart = (LONGLONG)fdo->poll_interval * -10000};
+        HID_XFER_PACKET packet = *fdo->io_packet;
+        BYTE *buffer = packet.reportBuffer;
+        KEVENT *io_event = &fdo->io_event;
+        IO_STATUS_BLOCK *io = &fdo->io;
+
+        if (!(packet.reportBuffer[0] = packet.reportId))
+        {
+            packet.reportBuffer++;
+            packet.reportBufferLen--;
+        }
+
+        KeInitializeEvent( io_event, NotificationEvent, FALSE );
+        fdo->io_irp = IoBuildDeviceIoControlRequest( IOCTL_HID_READ_REPORT, device, NULL, 0, packet.reportBuffer,
+                                                     packet.reportBufferLen, TRUE, io_event, io );
+        if (IoCallDriver( device, fdo->io_irp ) == STATUS_PENDING)
+        {
+            void *events[2] = {io_event, &fdo->halt_event};
+            status = KeWaitForMultipleObjects( 2, events, WaitAny, Executive, KernelMode, FALSE, NULL, NULL );
+            if (status) break;
+        }
+        fdo->io_irp = NULL;
+
+        if (io->Status == STATUS_SUCCESS)
+        {
+            if (!packet.reportId) io->Information++;
+            if (!(report = find_report_with_type_and_id( &fdo->device_desc, 0, HidP_Input, buffer[0], FALSE )))
+                ERR( "dropping unknown input id %u\n", buffer[0] );
+            else if (!fdo->poll_interval && io->Information < report->InputLength)
+                ERR( "dropping short report, len %Iu expected %u\n", io->Information, report->InputLength );
+            else if (!report->CollectionNumber || report->CollectionNumber > fdo->child_count)
+                ERR( "dropping report for unknown child %u\n", report->CollectionNumber );
+            else
+            {
+                struct phys_device *pdo = pdo_from_DEVICE_OBJECT( fdo->child_pdos[report->CollectionNumber - 1] );
+                packet.reportId = buffer[0];
+                packet.reportBuffer = buffer;
+                packet.reportBufferLen = io->Information;
+                hid_device_queue_input( pdo, &packet, !!fdo->poll_interval );
+            }
+        }
+
+        status = KeWaitForSingleObject( &fdo->halt_event, Executive, KernelMode, FALSE, &delay );
+    } while (status == STATUS_TIMEOUT);
+
+    if (status) WARN( "device thread exiting with status %#lx\n", status );
+    else TRACE( "device thread exiting\n" );
+    return 1;
+}
+
+struct device_strings
+{
+    const WCHAR *id;
+    const WCHAR *product;
+};
+
+static const struct device_strings device_strings[] =
+{
+    /* Microsoft controllers */
+    { .id = L"VID_045E&PID_028E", .product = L"Controller (XBOX 360 For Windows)" },
+    { .id = L"VID_045E&PID_028F", .product = L"Controller (XBOX 360 For Windows)" },
+    { .id = L"VID_045E&PID_02D1", .product = L"Controller (Xbox One For Windows)" },
+    { .id = L"VID_045E&PID_02DD", .product = L"Controller (Xbox One For Windows)" },
+    { .id = L"VID_045E&PID_02E3", .product = L"Controller (Xbox One For Windows)" },
+    { .id = L"VID_045E&PID_02EA", .product = L"Controller (Xbox One For Windows)" },
+    { .id = L"VID_045E&PID_02FD", .product = L"Controller (Xbox One For Windows)" },
+    { .id = L"VID_045E&PID_0719", .product = L"Controller (XBOX 360 For Windows)" },
+    { .id = L"VID_045E&PID_0B00", .product = L"Controller (Xbox One For Windows)" },
+    { .id = L"VID_045E&PID_0B05", .product = L"Controller (Xbox One For Windows)" },
+    { .id = L"VID_045E&PID_0B12", .product = L"Controller (Xbox One For Windows)" },
+    { .id = L"VID_045E&PID_0B13", .product = L"Controller (Xbox One For Windows)" },
+    /* Sony controllers */
+    { .id = L"VID_054C&PID_05C4", .product = L"Wireless Controller" },
+    { .id = L"VID_054C&PID_09CC", .product = L"Wireless Controller" },
+    { .id = L"VID_054C&PID_0BA0", .product = L"Wireless Controller" },
+    { .id = L"VID_054C&PID_0CE6", .product = L"Wireless Controller" },
+    { .id = L"VID_054C&PID_0DF2", .product = L"Wireless Controller" },
+};
+
+static const WCHAR *find_device_string( const WCHAR *device_id, ULONG index )
+{
+    const WCHAR *match_id = wcsrchr( device_id, '\\' ) + 1;
+    DWORD i;
+
+    if (index != HID_STRING_ID_IPRODUCT) return NULL;
+
+    for (i = 0; i < ARRAY_SIZE(device_strings); ++i)
+        if (!wcsnicmp( device_strings[i].id, match_id, 17 ))
+            return device_strings[i].product;
+
+    return NULL;
+}
+
+struct completion_params
+{
+    HID_XFER_PACKET packet;
+    ULONG padding;
+    IRP *irp;
+};
+
+static NTSTATUS CALLBACK xfer_completion( DEVICE_OBJECT *device, IRP *irp, void *context )
+{
+    struct completion_params *params = context;
+    IRP *orig_irp = params->irp;
+
+    TRACE( "device %p, irp %p, context %p\n", device, irp, context );
+
+    orig_irp->IoStatus = irp->IoStatus;
+    orig_irp->IoStatus.Information -= params->padding;
+    IoCompleteRequest( orig_irp, IO_NO_INCREMENT );
+
+    free( params );
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS hid_device_xfer_report( struct phys_device *pdo, ULONG code, IRP *irp )
+{
+    IO_STACK_LOCATION *stack = IoGetCurrentIrpStackLocation( irp );
+    ULONG offset, report_len = 0, buffer_len = 0, collection = pdo->collection_desc->CollectionNumber;
+    struct func_device *fdo = fdo_from_DEVICE_OBJECT( pdo->parent_fdo );
+    HIDP_DEVICE_DESC *desc = &fdo->device_desc;
+    struct completion_params *params;
+    HIDP_REPORT_IDS *report = NULL;
+    BYTE *buffer = NULL;
+
+    switch (code)
+    {
+    case IOCTL_HID_GET_FEATURE:
+    case IOCTL_HID_GET_INPUT_REPORT:
+        buffer_len = stack->Parameters.DeviceIoControl.OutputBufferLength;
+        buffer = MmGetSystemAddressForMdlSafe( irp->MdlAddress, NormalPagePriority );
+        break;
+    case IOCTL_HID_SET_FEATURE:
+    case IOCTL_HID_SET_OUTPUT_REPORT:
+        buffer_len = stack->Parameters.DeviceIoControl.InputBufferLength;
+        buffer = irp->AssociatedIrp.SystemBuffer;
+        break;
+    case IOCTL_HID_WRITE_REPORT:
+        buffer_len = stack->Parameters.Write.Length;
+        buffer = irp->AssociatedIrp.SystemBuffer;
+        break;
+    }
+    if (!buffer || !buffer_len) return STATUS_INVALID_USER_BUFFER;
+
+    switch (code)
+    {
+    case IOCTL_HID_GET_INPUT_REPORT:
+        report = find_report_with_type_and_id( desc, collection, HidP_Input, buffer[0], FALSE );
+        if (report) report_len = report->InputLength;
+        break;
+    case IOCTL_HID_SET_OUTPUT_REPORT:
+    case IOCTL_HID_WRITE_REPORT:
+        report = find_report_with_type_and_id( desc, collection, HidP_Output, buffer[0], FALSE );
+        if (report) report_len = report->OutputLength;
+        break;
+    case IOCTL_HID_GET_FEATURE:
+    case IOCTL_HID_SET_FEATURE:
+        report = find_report_with_type_and_id( desc, collection, HidP_Feature, buffer[0], FALSE );
+        if (report) report_len = report->FeatureLength;
+        break;
+    }
+    if (!report || buffer_len < report_len) return STATUS_INVALID_PARAMETER;
+    offset = report->ReportID ? 0 : 1;
+
+    if (!(params = calloc( 1, sizeof(struct completion_params) ))) return STATUS_NO_MEMORY;
+    params->packet.reportId = report->ReportID;
+    params->packet.reportBuffer = buffer + offset;
+    params->irp = irp;
+
+    switch (code)
+    {
+    case IOCTL_HID_GET_FEATURE:
+    case IOCTL_HID_GET_INPUT_REPORT:
+        params->packet.reportBufferLen = buffer_len - offset;
+        irp = IoBuildDeviceIoControlRequest( code, pdo->parent_fdo, NULL, 0, &params->packet,
+                                             sizeof(params->packet), TRUE, NULL, NULL );
+        break;
+    case IOCTL_HID_WRITE_REPORT:
+        params->padding = 1 - offset;
+        /* fallthrough */
+    case IOCTL_HID_SET_FEATURE:
+    case IOCTL_HID_SET_OUTPUT_REPORT:
+        params->packet.reportBufferLen = report_len - offset;
+        irp = IoBuildDeviceIoControlRequest( code, pdo->parent_fdo, NULL, sizeof(params->packet),
+                                             &params->packet, 0, TRUE, NULL, NULL );
+        break;
+    }
+
+    if (!irp)
+    {
+        free( params );
+        return STATUS_NO_MEMORY;
+    }
+
+    IoMarkIrpPending( params->irp );
+    IoSetCompletionRoutine( irp, xfer_completion, params, TRUE, TRUE, TRUE );
+    IoCallDriver( pdo->parent_fdo, irp );
+    return STATUS_PENDING;
+}
+
+NTSTATUS WINAPI pdo_ioctl( DEVICE_OBJECT *device, IRP *irp )
+{
+    IO_STACK_LOCATION *irpsp = IoGetCurrentIrpStackLocation( irp );
+    struct phys_device *pdo = pdo_from_DEVICE_OBJECT( device );
+    NTSTATUS status = irp->IoStatus.Status;
+    ULONG code, index;
+    const WCHAR *str;
+    BOOL removed;
+    KIRQL irql;
+
+    irp->IoStatus.Information = 0;
+
+    TRACE( "device %p code %#lx\n", device, irpsp->Parameters.DeviceIoControl.IoControlCode );
+
+    KeAcquireSpinLock( &pdo->lock, &irql );
+    removed = pdo->removed;
+    KeReleaseSpinLock( &pdo->lock, irql );
+
+    if (removed)
+    {
+        irp->IoStatus.Status = STATUS_DELETE_PENDING;
+        IoCompleteRequest(irp, IO_NO_INCREMENT);
+        return STATUS_DELETE_PENDING;
+    }
+
+    switch ((code = irpsp->Parameters.DeviceIoControl.IoControlCode))
+    {
+        case IOCTL_HID_GET_POLL_FREQUENCY_MSEC:
+            if (irpsp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG))
+                status = STATUS_BUFFER_OVERFLOW;
+            else
+            {
+                struct func_device *fdo = fdo_from_DEVICE_OBJECT( pdo->parent_fdo );
+                *(ULONG *)irp->AssociatedIrp.SystemBuffer = fdo->poll_interval;
+                irp->IoStatus.Information = sizeof(ULONG);
+                status = STATUS_SUCCESS;
+            }
+            break;
+        case IOCTL_HID_SET_POLL_FREQUENCY_MSEC:
+        {
+            ULONG poll_interval;
+            if (irpsp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG))
+                status = STATUS_BUFFER_TOO_SMALL;
+            else
+            {
+                struct func_device *fdo = fdo_from_DEVICE_OBJECT( pdo->parent_fdo );
+                poll_interval = *(ULONG *)irp->AssociatedIrp.SystemBuffer;
+                if (poll_interval) fdo->poll_interval = min( poll_interval, MAX_POLL_INTERVAL_MSEC );
+                status = STATUS_SUCCESS;
+            }
+            break;
+        }
+        case IOCTL_HID_GET_PRODUCT_STRING:
+        case IOCTL_HID_GET_SERIALNUMBER_STRING:
+        case IOCTL_HID_GET_MANUFACTURER_STRING:
+        {
+            WCHAR *output_buf = MmGetSystemAddressForMdlSafe( irp->MdlAddress, NormalPagePriority );
+            ULONG output_len = irpsp->Parameters.DeviceIoControl.OutputBufferLength;
+
+            if (code == IOCTL_HID_GET_PRODUCT_STRING) index = HID_STRING_ID_IPRODUCT;
+            if (code == IOCTL_HID_GET_SERIALNUMBER_STRING) index = HID_STRING_ID_ISERIALNUMBER;
+            if (code == IOCTL_HID_GET_MANUFACTURER_STRING) index = HID_STRING_ID_IMANUFACTURER;
+
+            if ((str = find_device_string( pdo->base.device_id, index )))
+            {
+                irp->IoStatus.Information = (wcslen( str ) + 1) * sizeof(WCHAR);
+                if (irp->IoStatus.Information > output_len)
+                    status = STATUS_BUFFER_TOO_SMALL;
+                else
+                {
+                    memcpy( output_buf, str, irp->IoStatus.Information );
+                    status = STATUS_SUCCESS;
+                }
+                break;
+            }
+
+            call_minidriver( IOCTL_HID_GET_STRING, pdo->parent_fdo, ULongToPtr( index ),
+                             sizeof(index), output_buf, output_len, &irp->IoStatus );
+            status = irp->IoStatus.Status;
+            break;
+        }
+        case IOCTL_HID_GET_COLLECTION_INFORMATION:
+        {
+            irp->IoStatus.Information = sizeof(HID_COLLECTION_INFORMATION);
+            if (irpsp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(HID_COLLECTION_INFORMATION))
+                status = STATUS_BUFFER_OVERFLOW;
+            else
+            {
+                memcpy( irp->AssociatedIrp.SystemBuffer, &pdo->information,
+                        sizeof(HID_COLLECTION_INFORMATION) );
+                status = STATUS_SUCCESS;
+            }
+            break;
+        }
+        case IOCTL_HID_GET_COLLECTION_DESCRIPTOR:
+        {
+            HIDP_COLLECTION_DESC *desc = pdo->collection_desc;
+
+            irp->IoStatus.Information = desc->PreparsedDataLength;
+            if (irpsp->Parameters.DeviceIoControl.OutputBufferLength < desc->PreparsedDataLength)
+                status = STATUS_INVALID_BUFFER_SIZE;
+            else
+            {
+                memcpy( irp->UserBuffer, desc->PreparsedData, desc->PreparsedDataLength );
+                status = STATUS_SUCCESS;
+            }
+            break;
+        }
+        case IOCTL_SET_NUM_DEVICE_INPUT_BUFFERS:
+        {
+            if (irpsp->Parameters.DeviceIoControl.InputBufferLength != sizeof(ULONG))
+                status = STATUS_BUFFER_OVERFLOW;
+            else
+            {
+                struct hid_queue *queue = irp->Tail.Overlay.OriginalFileObject->FsContext;
+                status = hid_queue_resize( queue, *(ULONG *)irp->AssociatedIrp.SystemBuffer );
+            }
+            break;
+        }
+        case IOCTL_GET_NUM_DEVICE_INPUT_BUFFERS:
+        {
+            if (irpsp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG))
+                status = STATUS_BUFFER_TOO_SMALL;
+            else
+            {
+                struct hid_queue *queue = irp->Tail.Overlay.OriginalFileObject->FsContext;
+                *(ULONG *)irp->AssociatedIrp.SystemBuffer = queue->length;
+                irp->IoStatus.Information = sizeof(ULONG);
+                status = STATUS_SUCCESS;
+            }
+            break;
+        }
+        case IOCTL_HID_GET_FEATURE:
+        case IOCTL_HID_SET_FEATURE:
+        case IOCTL_HID_GET_INPUT_REPORT:
+        case IOCTL_HID_SET_OUTPUT_REPORT:
+            status = hid_device_xfer_report( pdo, code, irp );
+            break;
+
+        case IOCTL_HID_GET_WINE_RAWINPUT_HANDLE:
+            if (irpsp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG))
+                status = STATUS_BUFFER_OVERFLOW;
+            else
+            {
+                *(ULONG *)irp->AssociatedIrp.SystemBuffer = pdo->rawinput_handle;
+                irp->IoStatus.Information = sizeof(ULONG);
+                status = STATUS_SUCCESS;
+            }
+            break;
+
+        default:
+        {
+            ULONG code = irpsp->Parameters.DeviceIoControl.IoControlCode;
+            FIXME( "Unsupported ioctl %#lx (device=%lx access=%lx func=%lx method=%lx)\n", code,
+                   code >> 16, (code >> 14) & 3, (code >> 2) & 0xfff, code & 3 );
+            status = STATUS_NOT_SUPPORTED;
+            break;
+        }
+    }
+
+    if (status != STATUS_PENDING)
+    {
+        irp->IoStatus.Status = status;
+        IoCompleteRequest( irp, IO_NO_INCREMENT );
+    }
+    return status;
+}
+
+NTSTATUS WINAPI pdo_read( DEVICE_OBJECT *device, IRP *irp )
+{
+    struct hid_queue *queue = irp->Tail.Overlay.OriginalFileObject->FsContext;
+    struct phys_device *pdo = pdo_from_DEVICE_OBJECT( device );
+    HIDP_COLLECTION_DESC *desc = pdo->collection_desc;
+    IO_STACK_LOCATION *irpsp = IoGetCurrentIrpStackLocation(irp);
+    struct hid_report *report;
+    BOOL removed;
+    KIRQL irql;
+
+    KeAcquireSpinLock( &pdo->lock, &irql );
+    removed = pdo->removed;
+    KeReleaseSpinLock( &pdo->lock, irql );
+
+    if (removed)
+    {
+        irp->IoStatus.Status = STATUS_DELETE_PENDING;
+        IoCompleteRequest(irp, IO_NO_INCREMENT);
+        return STATUS_DELETE_PENDING;
+    }
+
+    if (irpsp->Parameters.Read.Length < desc->InputLength)
+    {
+        irp->IoStatus.Status = STATUS_INVALID_BUFFER_SIZE;
+        IoCompleteRequest( irp, IO_NO_INCREMENT );
+        return STATUS_INVALID_BUFFER_SIZE;
+    }
+
+    irp->IoStatus.Information = 0;
+    if ((report = hid_queue_pop_report( queue )))
+    {
+        memcpy( irp->AssociatedIrp.SystemBuffer, report->buffer, report->length );
+        irp->IoStatus.Information = report->length;
+        irp->IoStatus.Status = STATUS_SUCCESS;
+        hid_report_decref( report );
+
+        IoCompleteRequest( irp, IO_NO_INCREMENT );
+        return STATUS_SUCCESS;
+    }
+
+    return hid_queue_push_irp( queue, irp );
+
+}
+
+NTSTATUS WINAPI pdo_write( DEVICE_OBJECT *device, IRP *irp )
+{
+    struct phys_device *pdo = pdo_from_DEVICE_OBJECT( device );
+    NTSTATUS status = hid_device_xfer_report( pdo, IOCTL_HID_WRITE_REPORT, irp );
+    if (status != STATUS_PENDING)
+    {
+        irp->IoStatus.Status = status;
+        IoCompleteRequest( irp, IO_NO_INCREMENT );
+    }
+    return status;
+}
+
+NTSTATUS WINAPI pdo_create( DEVICE_OBJECT *device, IRP *irp )
+{
+    struct phys_device *pdo = pdo_from_DEVICE_OBJECT( device );
+    struct hid_queue *queue;
+    BOOL removed;
+    KIRQL irql;
+
+    TRACE("Open handle on device %p\n", device);
+
+    KeAcquireSpinLock( &pdo->lock, &irql );
+    removed = pdo->removed;
+    KeReleaseSpinLock( &pdo->lock, irql );
+
+    if (removed)
+    {
+        irp->IoStatus.Status = STATUS_DELETE_PENDING;
+        IoCompleteRequest( irp, IO_NO_INCREMENT );
+        return STATUS_DELETE_PENDING;
+    }
+
+    if (!(queue = hid_queue_create())) irp->IoStatus.Status = STATUS_NO_MEMORY;
+    else
+    {
+        KeAcquireSpinLock( &pdo->lock, &irql );
+        list_add_tail( &pdo->queues, &queue->entry );
+        KeReleaseSpinLock( &pdo->lock, irql );
+
+        irp->Tail.Overlay.OriginalFileObject->FsContext = queue;
+        irp->IoStatus.Status = STATUS_SUCCESS;
+    }
+
+    IoCompleteRequest( irp, IO_NO_INCREMENT );
+    return STATUS_SUCCESS;
+}
+
+NTSTATUS WINAPI pdo_close( DEVICE_OBJECT *device, IRP *irp )
+{
+    struct hid_queue *queue = irp->Tail.Overlay.OriginalFileObject->FsContext;
+    struct phys_device *pdo = pdo_from_DEVICE_OBJECT( device );
+    BOOL removed;
+    KIRQL irql;
+
+    TRACE("Close handle on device %p\n", device);
+
+    KeAcquireSpinLock( &pdo->lock, &irql );
+    removed = pdo->removed;
+    KeReleaseSpinLock( &pdo->lock, irql );
+
+    if (removed)
+    {
+        irp->IoStatus.Status = STATUS_DELETE_PENDING;
+        IoCompleteRequest( irp, IO_NO_INCREMENT );
+        return STATUS_DELETE_PENDING;
+    }
+
+    if (queue)
+    {
+        KeAcquireSpinLock( &pdo->lock, &irql );
+        list_remove( &queue->entry );
+        KeReleaseSpinLock( &pdo->lock, irql );
+        hid_queue_destroy( queue );
+    }
+
+    irp->IoStatus.Status = STATUS_SUCCESS;
+    IoCompleteRequest( irp, IO_NO_INCREMENT );
+    return STATUS_SUCCESS;
+}
+
+NTSTATUS WINAPI DriverEntry( DRIVER_OBJECT *driver, UNICODE_STRING *path )
+{
+    return STATUS_SUCCESS;
+}
diff -ruN --show-c-function dlls/hidclass.sys/hid.h dlls/hidclass.sys/hid.h
--- dlls/hidclass.sys/hid.h	2025-10-10 10:17:47.208778503 -0700
+++ dlls/hidclass.sys/hid.h	2025-10-10 12:03:54.180986979 -0700
@@ -48,6 +48,8 @@ struct device
     WCHAR container_id[MAX_GUID_STRING_LEN];
     const GUID *class_guid;
 
+    HANDLE steam_overlay_event;
+
     BOOL is_fdo;
 };
 
@@ -133,6 +135,8 @@ typedef struct _minidriver
 
     PDRIVER_ADD_DEVICE AddDevice;
     PDRIVER_DISPATCH PNPDispatch;
+
+    HANDLE steam_overlay_event;
 } minidriver;
 
 void call_minidriver( ULONG code, DEVICE_OBJECT *device, void *in_buff, ULONG in_size,
diff -ruN --show-c-function dlls/hidclass.sys/hid.h.orig dlls/hidclass.sys/hid.h.orig
--- dlls/hidclass.sys/hid.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ dlls/hidclass.sys/hid.h.orig	2025-10-10 12:03:47.992481472 -0700
@@ -0,0 +1,152 @@
+/*
+ * Copyright 2015 Aric Stewart
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winbase.h"
+#include "winternl.h"
+#include "winioctl.h"
+#include "winreg.h"
+#include "ddk/wdm.h"
+#include "hidusage.h"
+#include "ddk/hidport.h"
+#include "ddk/hidclass.h"
+#include "ddk/hidpi.h"
+#include "ddk/hidpddi.h"
+#include "cfgmgr32.h"
+#include "wine/list.h"
+#include "wine/hid.h"
+
+#define DEFAULT_POLL_INTERVAL 200
+#define MAX_POLL_INTERVAL_MSEC 10000
+
+/* Ring buffer functions */
+struct ReportRingBuffer;
+
+struct device
+{
+    HID_DEVICE_EXTENSION hid; /* must be first */
+
+    WCHAR device_id[MAX_DEVICE_ID_LEN];
+    WCHAR instance_id[MAX_DEVICE_ID_LEN];
+    WCHAR container_id[MAX_GUID_STRING_LEN];
+    const GUID *class_guid;
+
+    BOOL is_fdo;
+};
+
+struct func_device
+{
+    struct device base;
+    HID_DEVICE_ATTRIBUTES attrs;
+    HIDP_DEVICE_DESC device_desc;
+    WCHAR serial[256];
+
+    ULONG poll_interval;
+    KEVENT halt_event;
+    HANDLE thread;
+
+    HID_XFER_PACKET *io_packet;
+    IO_STATUS_BLOCK io;
+    KEVENT io_event;
+    IRP *io_irp;
+
+    DEVICE_OBJECT **child_pdos;
+    UINT child_count;
+};
+
+struct phys_device
+{
+    struct device base;
+    DEVICE_OBJECT *parent_fdo;
+
+    HIDP_COLLECTION_DESC *collection_desc;
+    HID_COLLECTION_INFORMATION information;
+
+    UINT32 rawinput_handle;
+    UNICODE_STRING link_name;
+
+    KSPIN_LOCK lock;
+    struct list queues;
+    BOOL removed;
+
+    BOOL is_mouse;
+    UNICODE_STRING mouse_link_name;
+    BOOL is_keyboard;
+    UNICODE_STRING keyboard_link_name;
+};
+
+static inline struct phys_device *pdo_from_DEVICE_OBJECT( DEVICE_OBJECT *device )
+{
+    struct device *impl = device->DeviceExtension;
+    return CONTAINING_RECORD( impl, struct phys_device, base );
+}
+
+static inline struct func_device *fdo_from_DEVICE_OBJECT( DEVICE_OBJECT *device )
+{
+    struct device *impl = device->DeviceExtension;
+    if (!impl->is_fdo) impl = pdo_from_DEVICE_OBJECT( device )->parent_fdo->DeviceExtension;
+    return CONTAINING_RECORD( impl, struct func_device, base );
+}
+
+struct hid_report
+{
+    LONG  ref;
+    ULONG length;
+    BYTE  buffer[1];
+};
+
+struct hid_queue
+{
+    struct list        entry;
+    KSPIN_LOCK         lock;
+    ULONG              length;
+    ULONG              read_idx;
+    ULONG              write_idx;
+    struct hid_report *reports[512];
+    LIST_ENTRY         irp_queue;
+};
+
+typedef struct _minidriver
+{
+    struct list entry;
+
+    HID_MINIDRIVER_REGISTRATION minidriver;
+
+    PDRIVER_UNLOAD DriverUnload;
+
+    PDRIVER_ADD_DEVICE AddDevice;
+    PDRIVER_DISPATCH PNPDispatch;
+} minidriver;
+
+void call_minidriver( ULONG code, DEVICE_OBJECT *device, void *in_buff, ULONG in_size,
+                      void *out_buff, ULONG out_size, IO_STATUS_BLOCK *io );
+HIDP_REPORT_IDS *find_report_with_type_and_id( HIDP_DEVICE_DESC *desc, UCHAR collection,
+                                               BYTE type, BYTE id, BOOL any_id );
+
+/* Internal device functions */
+DWORD CALLBACK hid_device_thread(void *args);
+void hid_queue_remove_pending_irps( struct hid_queue *queue );
+void hid_queue_destroy( struct hid_queue *queue );
+
+NTSTATUS WINAPI pdo_ioctl( DEVICE_OBJECT *device, IRP *irp );
+NTSTATUS WINAPI pdo_read( DEVICE_OBJECT *device, IRP *irp );
+NTSTATUS WINAPI pdo_write( DEVICE_OBJECT *device, IRP *irp );
+NTSTATUS WINAPI pdo_create( DEVICE_OBJECT *device, IRP *irp );
+NTSTATUS WINAPI pdo_close( DEVICE_OBJECT *device, IRP *irp );
diff -ruN --show-c-function dlls/hidclass.sys/pnp.c dlls/hidclass.sys/pnp.c
--- dlls/hidclass.sys/pnp.c	2025-10-10 10:17:47.208778503 -0700
+++ dlls/hidclass.sys/pnp.c	2025-10-10 12:03:54.181058114 -0700
@@ -171,6 +171,8 @@ static NTSTATUS WINAPI driver_add_device
     if (get_device_id( bus_pdo, BusQueryContainerID, fdo->base.container_id ))
         fdo->base.container_id[0] = 0;
 
+    fdo->base.steam_overlay_event = minidriver->steam_overlay_event;
+
     is_xinput_class = !wcsncmp(device_id, L"WINEXINPUT\\", 7) && wcsstr(device_id, L"&XI_") != NULL;
     if (is_xinput_class) fdo->base.class_guid = &GUID_DEVINTERFACE_WINEXINPUT;
     else fdo->base.class_guid = &GUID_DEVINTERFACE_HID;
@@ -314,6 +316,8 @@ static NTSTATUS create_child_pdos( minid
         pdo->information.Polled = minidriver->minidriver.DevicesArePolled;
         pdo->information.DescriptorSize = pdo->collection_desc->PreparsedDataLength;
 
+        pdo->base.steam_overlay_event = minidriver->steam_overlay_event;
+
         page = pdo->collection_desc->UsagePage;
         usage = pdo->collection_desc->Usage;
         if (page == HID_USAGE_PAGE_GENERIC && usage == HID_USAGE_GENERIC_MOUSE)
@@ -692,6 +696,8 @@ static void WINAPI driver_unload(DRIVER_
         if (md->DriverUnload)
             md->DriverUnload(md->minidriver.DriverObject);
         list_remove(&md->entry);
+
+        CloseHandle(md->steam_overlay_event);
         free(md);
     }
 }
@@ -707,6 +713,8 @@ NTSTATUS WINAPI HidRegisterMinidriver(HI
     if (!(driver = calloc(1, sizeof(*driver))))
         return STATUS_NO_MEMORY;
 
+    driver->steam_overlay_event = CreateEventA(NULL, TRUE, FALSE, "__wine_steamclient_GameOverlayActivated");
+
     driver->DriverUnload = registration->DriverObject->DriverUnload;
     registration->DriverObject->DriverUnload = driver_unload;
 
diff -ruN --show-c-function dlls/hidclass.sys/pnp.c.orig dlls/hidclass.sys/pnp.c.orig
--- dlls/hidclass.sys/pnp.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ dlls/hidclass.sys/pnp.c.orig	2025-10-10 12:03:47.992481472 -0700
@@ -0,0 +1,743 @@
+/*
+ * Human Interface Device class driver
+ *
+ * Copyright 2015 Aric Stewart
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <unistd.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include "initguid.h"
+#include "hid.h"
+#include "devguid.h"
+#include "ntddmou.h"
+#include "ntddkbd.h"
+#include "ddk/hidtypes.h"
+#include "ddk/wdm.h"
+#include "regstr.h"
+#include "ntuser.h"
+#include "wine/debug.h"
+#include "wine/asm.h"
+#include "wine/list.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(hid);
+
+DEFINE_GUID(GUID_DEVINTERFACE_WINEXINPUT, 0x6c53d5fd, 0x6480, 0x440f, 0xb6, 0x18, 0x47, 0x67, 0x50, 0xc5, 0xe1, 0xa6);
+
+#ifdef __ASM_USE_FASTCALL_WRAPPER
+
+extern void * WINAPI wrap_fastcall_func1( void *func, const void *a );
+__ASM_STDCALL_FUNC( wrap_fastcall_func1, 8,
+                   "popl %ecx\n\t"
+                   "popl %eax\n\t"
+                   "xchgl (%esp),%ecx\n\t"
+                   "jmp *%eax" );
+
+#define call_fastcall_func1(func,a) wrap_fastcall_func1(func,a)
+
+#else
+
+#define call_fastcall_func1(func,a) func(a)
+
+#endif
+
+static struct list minidriver_list = LIST_INIT(minidriver_list);
+
+static minidriver *find_minidriver(DRIVER_OBJECT *driver)
+{
+    minidriver *md;
+    LIST_FOR_EACH_ENTRY(md, &minidriver_list, minidriver, entry)
+    {
+        if (md->minidriver.DriverObject == driver)
+            return md;
+    }
+    return NULL;
+}
+
+static NTSTATUS get_device_id(DEVICE_OBJECT *device, BUS_QUERY_ID_TYPE type, WCHAR *id)
+{
+    IO_STACK_LOCATION *irpsp;
+    IO_STATUS_BLOCK irp_status;
+    KEVENT event;
+    IRP *irp;
+
+    KeInitializeEvent(&event, NotificationEvent, FALSE);
+    irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP, device, NULL, 0, NULL, &event, &irp_status);
+    if (irp == NULL)
+        return STATUS_NO_MEMORY;
+
+    irpsp = IoGetNextIrpStackLocation(irp);
+    irpsp->MinorFunction = IRP_MN_QUERY_ID;
+    irpsp->Parameters.QueryId.IdType = type;
+
+    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
+    if (IoCallDriver(device, irp) == STATUS_PENDING)
+        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
+
+    if (!irp_status.Status)
+    {
+        wcscpy(id, (WCHAR *)irp_status.Information);
+        ExFreePool((WCHAR *)irp_status.Information);
+    }
+
+    return irp_status.Status;
+}
+
+/* user32 reserves 1 & 2 for winemouse and winekeyboard,
+ * keep this in sync with user_private.h */
+#define WINE_MOUSE_HANDLE 1
+#define WINE_KEYBOARD_HANDLE 2
+
+static UINT32 alloc_rawinput_handle(void)
+{
+    static LONG counter = WINE_KEYBOARD_HANDLE + 1;
+    return InterlockedIncrement(&counter);
+}
+
+/* make sure bRawData can hold UsagePage and Usage without requiring additional allocation */
+C_ASSERT(offsetof(RAWINPUT, data.hid.bRawData[2 * sizeof(USAGE)]) < sizeof(RAWINPUT));
+
+static void send_wm_input_device_change( struct phys_device *pdo, LPARAM param )
+{
+    HIDP_COLLECTION_DESC *desc = pdo->collection_desc;
+    INPUT input = {.type = INPUT_HARDWARE};
+    struct hid_packet hid = {0};
+
+    TRACE( "pdo %p, lparam %p\n", pdo, (void *)param );
+
+    if (!IsEqualGUID( pdo->base.class_guid, &GUID_DEVINTERFACE_HID )) return;
+
+    input.hi.uMsg = WM_INPUT_DEVICE_CHANGE;
+    input.hi.wParamH = HIWORD(param);
+    input.hi.wParamL = LOWORD(param);
+
+    hid.head.device = pdo->rawinput_handle;
+    hid.head.usage = MAKELONG(desc->Usage, desc->UsagePage);
+    NtUserSendHardwareInput(0, 0, &input, (LPARAM)&hid);
+}
+
+static NTSTATUS WINAPI driver_add_device(DRIVER_OBJECT *driver, DEVICE_OBJECT *bus_pdo)
+{
+    WCHAR device_id[MAX_DEVICE_ID_LEN], instance_id[MAX_DEVICE_ID_LEN];
+    struct func_device *fdo;
+    BOOL is_xinput_class;
+    DEVICE_OBJECT *device;
+    NTSTATUS status;
+    minidriver *minidriver;
+
+    if ((status = get_device_id(bus_pdo, BusQueryDeviceID, device_id)))
+    {
+        ERR( "Failed to get PDO device id, status %#lx.\n", status );
+        return status;
+    }
+
+    if ((status = get_device_id(bus_pdo, BusQueryInstanceID, instance_id)))
+    {
+        ERR( "Failed to get PDO instance id, status %#lx.\n", status );
+        return status;
+    }
+
+    TRACE("Adding device to PDO %p, id %s\\%s.\n", bus_pdo, debugstr_w(device_id), debugstr_w(instance_id));
+    minidriver = find_minidriver(driver);
+
+    if ((status = IoCreateDevice( driver, sizeof(*fdo) + minidriver->minidriver.DeviceExtensionSize,
+                                  NULL, FILE_DEVICE_BUS_EXTENDER, 0, FALSE, &device )))
+    {
+        ERR( "Failed to create bus FDO, status %#lx.\n", status );
+        return status;
+    }
+    fdo = device->DeviceExtension;
+    fdo->base.is_fdo = TRUE;
+    fdo->base.hid.MiniDeviceExtension = fdo + 1;
+    fdo->base.hid.PhysicalDeviceObject = bus_pdo;
+    fdo->base.hid.NextDeviceObject = bus_pdo;
+    swprintf( fdo->base.device_id, ARRAY_SIZE(fdo->base.device_id), L"HID\\%s", wcsrchr( device_id, '\\' ) + 1 );
+    wcscpy( fdo->base.instance_id, instance_id );
+
+    if (get_device_id( bus_pdo, BusQueryContainerID, fdo->base.container_id ))
+        fdo->base.container_id[0] = 0;
+
+    is_xinput_class = !wcsncmp(device_id, L"WINEXINPUT\\", 7) && wcsstr(device_id, L"&XI_") != NULL;
+    if (is_xinput_class) fdo->base.class_guid = &GUID_DEVINTERFACE_WINEXINPUT;
+    else fdo->base.class_guid = &GUID_DEVINTERFACE_HID;
+
+    status = minidriver->AddDevice( minidriver->minidriver.DriverObject, device );
+    if (status != STATUS_SUCCESS)
+    {
+        ERR( "Minidriver AddDevice failed (%lx)\n", status );
+        IoDeleteDevice( device );
+        return status;
+    }
+
+    IoAttachDeviceToDeviceStack( device, bus_pdo );
+    device->Flags &= ~DO_DEVICE_INITIALIZING;
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS get_hid_device_desc( minidriver *minidriver, DEVICE_OBJECT *device, HIDP_DEVICE_DESC *desc )
+{
+    HID_DESCRIPTOR descriptor = {0};
+    IO_STATUS_BLOCK io;
+    BYTE *report_desc;
+    INT i;
+
+    call_minidriver( IOCTL_HID_GET_DEVICE_DESCRIPTOR, device, NULL, 0, &descriptor, sizeof(descriptor), &io );
+    if (io.Status) return io.Status;
+
+    for (i = 0; i < descriptor.bNumDescriptors; i++)
+        if (descriptor.DescriptorList[i].bReportType == HID_REPORT_DESCRIPTOR_TYPE)
+            break;
+    if (i >= descriptor.bNumDescriptors) return STATUS_NOT_FOUND;
+
+    if (!(report_desc = malloc( descriptor.DescriptorList[i].wReportLength ))) return STATUS_NO_MEMORY;
+    call_minidriver( IOCTL_HID_GET_REPORT_DESCRIPTOR, device, NULL, 0, report_desc,
+                     descriptor.DescriptorList[i].wReportLength, &io );
+    if (!io.Status) io.Status = HidP_GetCollectionDescription( report_desc, descriptor.DescriptorList[i].wReportLength,
+                                                               PagedPool, desc );
+    free( report_desc );
+
+    if (io.Status && io.Status != HIDP_STATUS_SUCCESS) return STATUS_INVALID_PARAMETER;
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS initialize_device( minidriver *minidriver, DEVICE_OBJECT *device )
+{
+    struct func_device *fdo = fdo_from_DEVICE_OBJECT( device );
+    ULONG index = HID_STRING_ID_ISERIALNUMBER;
+    IO_STATUS_BLOCK io;
+    NTSTATUS status;
+
+    call_minidriver( IOCTL_HID_GET_DEVICE_ATTRIBUTES, device, NULL, 0, &fdo->attrs,
+                     sizeof(fdo->attrs), &io );
+    if (io.Status != STATUS_SUCCESS)
+    {
+        ERR( "Minidriver failed to get attributes, status %#lx.\n", io.Status );
+        return io.Status;
+    }
+
+    call_minidriver( IOCTL_HID_GET_STRING, device, ULongToPtr(index), sizeof(index),
+                     &fdo->serial, sizeof(fdo->serial), &io );
+    if (io.Status != STATUS_SUCCESS)
+    {
+        ERR( "Minidriver failed to get serial number, status %#lx.\n", io.Status );
+        return io.Status;
+    }
+
+    if ((status = get_hid_device_desc( minidriver, device, &fdo->device_desc )))
+    {
+        ERR( "Failed to get HID device description, status %#lx\n", status );
+        return status;
+    }
+
+    if (!(fdo->child_pdos = malloc( fdo->device_desc.CollectionDescLength * sizeof(*fdo->child_pdos) )))
+    {
+        ERR( "Cannot allocate child PDOs array\n" );
+        return STATUS_NO_MEMORY;
+    }
+
+    fdo->poll_interval = minidriver->minidriver.DevicesArePolled ? DEFAULT_POLL_INTERVAL : 0;
+    KeInitializeEvent( &fdo->halt_event, NotificationEvent, FALSE );
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS create_child_pdos( minidriver *minidriver, DEVICE_OBJECT *device )
+{
+    struct func_device *fdo = fdo_from_DEVICE_OBJECT( device );
+    DEVICE_OBJECT *child_device;
+    struct phys_device *pdo;
+    UNICODE_STRING string;
+    WCHAR pdo_name[255];
+    USAGE page, usage;
+    NTSTATUS status;
+    INT i;
+
+    for (i = 0; i < fdo->device_desc.CollectionDescLength; ++i)
+    {
+        if (fdo->device_desc.CollectionDescLength > 1)
+            swprintf( pdo_name, ARRAY_SIZE(pdo_name), L"\\Device\\HID#%p&%p&%d", device->DriverObject,
+                      fdo->base.hid.PhysicalDeviceObject, i );
+        else
+            swprintf( pdo_name, ARRAY_SIZE(pdo_name), L"\\Device\\HID#%p&%p", device->DriverObject,
+                      fdo->base.hid.PhysicalDeviceObject );
+
+        RtlInitUnicodeString(&string, pdo_name);
+        if ((status = IoCreateDevice( device->DriverObject, sizeof(*pdo), &string, 0, 0, FALSE, &child_device )))
+        {
+            ERR( "Failed to create child PDO, status %#lx.\n", status );
+            return status;
+        }
+
+        fdo->child_pdos[i] = child_device;
+        fdo->child_count++;
+
+        pdo = pdo_from_DEVICE_OBJECT( child_device );
+        pdo->base.hid = fdo->base.hid;
+        pdo->parent_fdo = device;
+        list_init( &pdo->queues );
+        KeInitializeSpinLock( &pdo->lock );
+
+        pdo->collection_desc = fdo->device_desc.CollectionDesc + i;
+
+        if (fdo->device_desc.CollectionDescLength > 1)
+        {
+            swprintf( pdo->base.device_id, ARRAY_SIZE(pdo->base.device_id), L"%s&Col%02d",
+                      fdo->base.device_id, pdo->collection_desc->CollectionNumber );
+            swprintf( pdo->base.instance_id, ARRAY_SIZE(pdo->base.instance_id), L"%u&%s&%x&%u&%04u",
+                      fdo->attrs.VersionNumber, fdo->serial, 0, 0, i );
+        }
+        else
+        {
+            wcscpy( pdo->base.device_id, fdo->base.device_id );
+            wcscpy( pdo->base.instance_id, fdo->base.instance_id );
+        }
+        wcscpy( pdo->base.container_id, fdo->base.container_id );
+        pdo->base.class_guid = fdo->base.class_guid;
+
+        pdo->information.VendorID = fdo->attrs.VendorID;
+        pdo->information.ProductID = fdo->attrs.ProductID;
+        pdo->information.VersionNumber = fdo->attrs.VersionNumber;
+        pdo->information.Polled = minidriver->minidriver.DevicesArePolled;
+        pdo->information.DescriptorSize = pdo->collection_desc->PreparsedDataLength;
+
+        page = pdo->collection_desc->UsagePage;
+        usage = pdo->collection_desc->Usage;
+        if (page == HID_USAGE_PAGE_GENERIC && usage == HID_USAGE_GENERIC_MOUSE)
+            pdo->rawinput_handle = WINE_MOUSE_HANDLE;
+        else if (page == HID_USAGE_PAGE_GENERIC && usage == HID_USAGE_GENERIC_KEYBOARD)
+            pdo->rawinput_handle = WINE_KEYBOARD_HANDLE;
+        else
+            pdo->rawinput_handle = alloc_rawinput_handle();
+
+        TRACE( "created pdo %p, rawinput handle %#x\n", pdo, pdo->rawinput_handle );
+    }
+
+    IoInvalidateDeviceRelations( fdo->base.hid.PhysicalDeviceObject, BusRelations );
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS create_device_thread( DEVICE_OBJECT *device )
+{
+    struct func_device *fdo = fdo_from_DEVICE_OBJECT( device );
+    ULONG i, input_length = 0;
+    HIDP_REPORT_IDS *report;
+
+    for (i = 0; i < fdo->device_desc.CollectionDescLength; i++)
+    {
+        HIDP_COLLECTION_DESC *desc = fdo->device_desc.CollectionDesc + i;
+        input_length = max( input_length, desc->InputLength );
+    }
+
+    if (!(fdo->io_packet = malloc( sizeof(*fdo->io_packet) + input_length ))) return STATUS_NO_MEMORY;
+
+    if (!(report = find_report_with_type_and_id( &fdo->device_desc, 0, HidP_Input, 0, TRUE ))) WARN( "no input report found.\n" );
+    fdo->io_packet->reportId = report ? report->ReportID : 0;
+    fdo->io_packet->reportBuffer = (BYTE *)(fdo->io_packet + 1);
+    fdo->io_packet->reportBufferLen = input_length;
+
+    if (!(fdo->thread = CreateThread( NULL, 0, hid_device_thread, device, 0, NULL ))) return STATUS_UNSUCCESSFUL;
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS fdo_pnp(DEVICE_OBJECT *device, IRP *irp)
+{
+    minidriver *minidriver = find_minidriver(device->DriverObject);
+    IO_STACK_LOCATION *stack = IoGetCurrentIrpStackLocation(irp);
+    struct func_device *fdo = fdo_from_DEVICE_OBJECT( device );
+    NTSTATUS status;
+
+    TRACE("irp %p, minor function %#x.\n", irp, stack->MinorFunction);
+
+    switch (stack->MinorFunction)
+    {
+        case IRP_MN_QUERY_DEVICE_RELATIONS:
+        {
+            DEVICE_RELATIONS *devices;
+            UINT32 i;
+
+            if (stack->Parameters.QueryDeviceRelations.Type != BusRelations)
+                return minidriver->PNPDispatch(device, irp);
+
+            if (!(devices = ExAllocatePool( PagedPool, offsetof( DEVICE_RELATIONS, Objects[fdo->child_count] ) )))
+            {
+                irp->IoStatus.Status = STATUS_NO_MEMORY;
+                IoCompleteRequest(irp, IO_NO_INCREMENT);
+                return STATUS_NO_MEMORY;
+            }
+
+            for (i = 0, devices->Count = 0; i < fdo->child_count; ++i)
+            {
+                devices->Objects[i] = fdo->child_pdos[i];
+                call_fastcall_func1( ObfReferenceObject, fdo->child_pdos[i] );
+                devices->Count++;
+            }
+
+            irp->IoStatus.Information = (ULONG_PTR)devices;
+            irp->IoStatus.Status = STATUS_SUCCESS;
+            IoSkipCurrentIrpStackLocation(irp);
+            return IoCallDriver( fdo->base.hid.NextDeviceObject, irp );
+        }
+
+        case IRP_MN_START_DEVICE:
+            status = minidriver->PNPDispatch( device, irp );
+            if (!status) status = initialize_device( minidriver, device );
+            if (!status) status = create_child_pdos( minidriver, device );
+            if (!status) status = create_device_thread( device );
+            return status;
+
+        case IRP_MN_REMOVE_DEVICE:
+            if (fdo->thread)
+            {
+                KeSetEvent( &fdo->halt_event, IO_NO_INCREMENT, FALSE );
+                WaitForSingleObject( fdo->thread, INFINITE );
+            }
+
+            if ((status = minidriver->PNPDispatch( device, irp ))) return status;
+            if (fdo->io_irp) KeWaitForSingleObject( &fdo->io_event, Executive, KernelMode, FALSE, NULL );
+            free( fdo->io_packet );
+
+            HidP_FreeCollectionDescription( &fdo->device_desc );
+            free( fdo->child_pdos );
+            IoDetachDevice( fdo->base.hid.NextDeviceObject );
+            IoDeleteDevice( device );
+            return status;
+
+        case IRP_MN_SURPRISE_REMOVAL:
+            if ((status = minidriver->PNPDispatch( device, irp ))) return status;
+            KeSetEvent( &fdo->halt_event, IO_NO_INCREMENT, FALSE );
+            return STATUS_SUCCESS;
+
+        default:
+            return minidriver->PNPDispatch(device, irp);
+    }
+}
+
+static WCHAR *query_hardware_ids(DEVICE_OBJECT *device)
+{
+    static const WCHAR vid_pid_format[] = L"HID\\VID_%04X&PID_%04X";
+    static const WCHAR vid_usage_format[] = L"HID\\VID_%04X&UP:%04X_U:%04X";
+    static const WCHAR usage_format[] = L"HID_DEVICE_UP:%04X_U:%04X";
+    static const WCHAR hid_format[] = L"HID_DEVICE";
+
+    struct phys_device *pdo = pdo_from_DEVICE_OBJECT( device );
+    HIDP_COLLECTION_DESC *desc = pdo->collection_desc;
+    HID_COLLECTION_INFORMATION *info = &pdo->information;
+    WCHAR *dst;
+    DWORD size;
+
+    size = sizeof(vid_pid_format);
+    size += sizeof(vid_usage_format);
+    size += sizeof(usage_format);
+    size += sizeof(hid_format);
+
+    if ((dst = ExAllocatePool(PagedPool, size + sizeof(WCHAR))))
+    {
+        DWORD len = size / sizeof(WCHAR), pos = 0;
+        pos += swprintf( dst + pos, len - pos, vid_pid_format, info->VendorID, info->ProductID ) + 1;
+        pos += swprintf( dst + pos, len - pos, vid_usage_format, info->VendorID, desc->UsagePage, desc->Usage ) + 1;
+        pos += swprintf( dst + pos, len - pos, usage_format, desc->UsagePage, desc->Usage ) + 1;
+        pos += swprintf( dst + pos, len - pos, hid_format ) + 1;
+        dst[pos] = 0;
+    }
+
+    return dst;
+}
+
+static WCHAR *query_compatible_ids(DEVICE_OBJECT *device)
+{
+    WCHAR *dst;
+    if ((dst = ExAllocatePool(PagedPool, sizeof(WCHAR)))) dst[0] = 0;
+    return dst;
+}
+
+static WCHAR *query_device_id(DEVICE_OBJECT *device)
+{
+    struct device *ext = device->DeviceExtension;
+    DWORD size = (wcslen(ext->device_id) + 1) * sizeof(WCHAR);
+    WCHAR *dst;
+
+    if ((dst = ExAllocatePool(PagedPool, size)))
+        memcpy(dst, ext->device_id, size);
+
+    return dst;
+}
+
+static WCHAR *query_instance_id(DEVICE_OBJECT *device)
+{
+    struct device *ext = device->DeviceExtension;
+    DWORD size = (wcslen(ext->instance_id) + 1) * sizeof(WCHAR);
+    WCHAR *dst;
+
+    if ((dst = ExAllocatePool(PagedPool, size)))
+        memcpy(dst, ext->instance_id, size);
+
+    return dst;
+}
+
+static WCHAR *query_container_id(DEVICE_OBJECT *device)
+{
+    struct device *ext = device->DeviceExtension;
+    DWORD size = (wcslen(ext->container_id) + 1) * sizeof(WCHAR);
+    WCHAR *dst;
+
+    if ((dst = ExAllocatePool(PagedPool, size)))
+        memcpy(dst, ext->container_id, size);
+
+    return dst;
+}
+
+static NTSTATUS pdo_pnp( DEVICE_OBJECT *device, IRP *irp )
+{
+    IO_STACK_LOCATION *irpsp = IoGetCurrentIrpStackLocation(irp);
+    struct phys_device *pdo = pdo_from_DEVICE_OBJECT( device );
+    HIDP_COLLECTION_DESC *desc = pdo->collection_desc;
+    NTSTATUS status = irp->IoStatus.Status;
+    struct hid_queue *queue, *next;
+    KIRQL irql;
+
+    TRACE("irp %p, minor function %#x.\n", irp, irpsp->MinorFunction);
+
+    switch(irpsp->MinorFunction)
+    {
+        case IRP_MN_QUERY_ID:
+        {
+            BUS_QUERY_ID_TYPE type = irpsp->Parameters.QueryId.IdType;
+            switch (type)
+            {
+            case BusQueryHardwareIDs:
+                irp->IoStatus.Information = (ULONG_PTR)query_hardware_ids(device);
+                if (!irp->IoStatus.Information) status = STATUS_NO_MEMORY;
+                else status = STATUS_SUCCESS;
+                break;
+            case BusQueryCompatibleIDs:
+                irp->IoStatus.Information = (ULONG_PTR)query_compatible_ids(device);
+                if (!irp->IoStatus.Information) status = STATUS_NO_MEMORY;
+                else status = STATUS_SUCCESS;
+                break;
+            case BusQueryDeviceID:
+                irp->IoStatus.Information = (ULONG_PTR)query_device_id(device);
+                if (!irp->IoStatus.Information) status = STATUS_NO_MEMORY;
+                else status = STATUS_SUCCESS;
+                break;
+            case BusQueryInstanceID:
+                irp->IoStatus.Information = (ULONG_PTR)query_instance_id(device);
+                if (!irp->IoStatus.Information) status = STATUS_NO_MEMORY;
+                else status = STATUS_SUCCESS;
+                break;
+            case BusQueryContainerID:
+                if (pdo->base.container_id[0])
+                {
+                    irp->IoStatus.Information = (ULONG_PTR)query_container_id(device);
+                    if (!irp->IoStatus.Information) status = STATUS_NO_MEMORY;
+                    else status = STATUS_SUCCESS;
+                }
+                break;
+            default:
+                WARN("IRP_MN_QUERY_ID type %u, not implemented!\n", type);
+                break;
+            }
+            break;
+        }
+
+        case IRP_MN_QUERY_CAPABILITIES:
+        {
+            DEVICE_CAPABILITIES *caps = irpsp->Parameters.DeviceCapabilities.Capabilities;
+
+            caps->RawDeviceOK = 1;
+            status = STATUS_SUCCESS;
+            break;
+        }
+
+        case IRP_MN_START_DEVICE:
+            send_wm_input_device_change( pdo, GIDC_ARRIVAL );
+
+            if ((status = IoRegisterDeviceInterface( device, pdo->base.class_guid, NULL, &pdo->link_name )))
+            {
+                ERR( "Failed to register interface, status %#lx.\n", status );
+                break;
+            }
+
+            /* FIXME: This should probably be done in mouhid.sys. */
+            if (desc->UsagePage == HID_USAGE_PAGE_GENERIC && desc->Usage == HID_USAGE_GENERIC_MOUSE)
+            {
+                if (!IoRegisterDeviceInterface( device, &GUID_DEVINTERFACE_MOUSE, NULL, &pdo->mouse_link_name ))
+                    pdo->is_mouse = TRUE;
+            }
+            if (desc->UsagePage == HID_USAGE_PAGE_GENERIC && desc->Usage == HID_USAGE_GENERIC_KEYBOARD)
+            {
+                if (!IoRegisterDeviceInterface( device, &GUID_DEVINTERFACE_KEYBOARD, NULL, &pdo->keyboard_link_name ))
+                    pdo->is_keyboard = TRUE;
+            }
+
+            IoSetDeviceInterfaceState( &pdo->link_name, TRUE );
+            if (pdo->is_mouse) IoSetDeviceInterfaceState( &pdo->mouse_link_name, TRUE );
+            if (pdo->is_keyboard) IoSetDeviceInterfaceState( &pdo->keyboard_link_name, TRUE );
+
+            pdo->removed = FALSE;
+            status = STATUS_SUCCESS;
+            break;
+
+        case IRP_MN_REMOVE_DEVICE:
+            send_wm_input_device_change( pdo, GIDC_REMOVAL );
+
+            IoSetDeviceInterfaceState( &pdo->link_name, FALSE );
+            if (pdo->is_mouse) IoSetDeviceInterfaceState( &pdo->mouse_link_name, FALSE );
+            if (pdo->is_keyboard) IoSetDeviceInterfaceState( &pdo->keyboard_link_name, FALSE );
+
+            KeAcquireSpinLock( &pdo->lock, &irql );
+            LIST_FOR_EACH_ENTRY_SAFE( queue, next, &pdo->queues, struct hid_queue, entry )
+                hid_queue_destroy( queue );
+            KeReleaseSpinLock( &pdo->lock, irql );
+
+            RtlFreeUnicodeString( &pdo->link_name );
+
+            irp->IoStatus.Status = STATUS_SUCCESS;
+            IoCompleteRequest(irp, IO_NO_INCREMENT);
+            IoDeleteDevice(device);
+            return STATUS_SUCCESS;
+
+        case IRP_MN_SURPRISE_REMOVAL:
+            KeAcquireSpinLock( &pdo->lock, &irql );
+            pdo->removed = TRUE;
+            LIST_FOR_EACH_ENTRY_SAFE( queue, next, &pdo->queues, struct hid_queue, entry )
+                hid_queue_remove_pending_irps( queue );
+            KeReleaseSpinLock( &pdo->lock, irql );
+
+            status = STATUS_SUCCESS;
+            break;
+
+        case IRP_MN_QUERY_DEVICE_TEXT:
+        {
+            DEVICE_TEXT_TYPE type = irpsp->Parameters.QueryDeviceText.DeviceTextType;
+            WARN("Ignoring IRP_MN_QUERY_TEXT type %u.\n", type);
+            status = STATUS_NOT_SUPPORTED;
+            break;
+        }
+
+        default:
+            FIXME("Unhandled minor function %#x.\n", irpsp->MinorFunction);
+    }
+
+    irp->IoStatus.Status = status;
+    IoCompleteRequest( irp, IO_NO_INCREMENT );
+    return status;
+}
+
+static NTSTATUS WINAPI driver_pnp(DEVICE_OBJECT *device, IRP *irp)
+{
+    struct device *ext = device->DeviceExtension;
+
+    if (ext->is_fdo)
+        return fdo_pnp(device, irp);
+    else
+        return pdo_pnp(device, irp);
+}
+
+static NTSTATUS WINAPI driver_create(DEVICE_OBJECT *device, IRP *irp)
+{
+    struct device *ext = device->DeviceExtension;
+
+    if (ext->is_fdo)
+    {
+        irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
+        IoCompleteRequest(irp, IO_NO_INCREMENT);
+        return STATUS_UNSUCCESSFUL;
+    }
+
+    return pdo_create(device, irp);
+}
+
+static NTSTATUS WINAPI driver_close(DEVICE_OBJECT *device, IRP *irp)
+{
+    return pdo_close(device, irp);
+}
+
+static NTSTATUS WINAPI driver_ioctl(DEVICE_OBJECT *device, IRP *irp)
+{
+    return pdo_ioctl(device, irp);
+}
+
+static NTSTATUS WINAPI driver_read(DEVICE_OBJECT *device, IRP *irp)
+{
+    return pdo_read(device, irp);
+}
+
+static NTSTATUS WINAPI driver_write(DEVICE_OBJECT *device, IRP *irp)
+{
+    return pdo_write(device, irp);
+}
+
+static void WINAPI driver_unload(DRIVER_OBJECT *driver)
+{
+    minidriver *md;
+
+    TRACE("\n");
+
+    if ((md = find_minidriver(driver)))
+    {
+        if (md->DriverUnload)
+            md->DriverUnload(md->minidriver.DriverObject);
+        list_remove(&md->entry);
+        free(md);
+    }
+}
+
+NTSTATUS WINAPI HidRegisterMinidriver(HID_MINIDRIVER_REGISTRATION *registration)
+{
+    minidriver *driver;
+
+    /* make sure we have a window station and a desktop, we need one to send input */
+    if (!GetProcessWindowStation())
+        return STATUS_INVALID_PARAMETER;
+
+    if (!(driver = calloc(1, sizeof(*driver))))
+        return STATUS_NO_MEMORY;
+
+    driver->DriverUnload = registration->DriverObject->DriverUnload;
+    registration->DriverObject->DriverUnload = driver_unload;
+
+    registration->DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = driver_ioctl;
+    registration->DriverObject->MajorFunction[IRP_MJ_READ] = driver_read;
+    registration->DriverObject->MajorFunction[IRP_MJ_WRITE] = driver_write;
+    registration->DriverObject->MajorFunction[IRP_MJ_CREATE] = driver_create;
+    registration->DriverObject->MajorFunction[IRP_MJ_CLOSE] = driver_close;
+
+    driver->PNPDispatch = registration->DriverObject->MajorFunction[IRP_MJ_PNP];
+    registration->DriverObject->MajorFunction[IRP_MJ_PNP] = driver_pnp;
+
+    driver->AddDevice = registration->DriverObject->DriverExtension->AddDevice;
+    registration->DriverObject->DriverExtension->AddDevice = driver_add_device;
+
+    driver->minidriver = *registration;
+    list_add_tail(&minidriver_list, &driver->entry);
+
+    return STATUS_SUCCESS;
+}
+
+void call_minidriver( ULONG code, DEVICE_OBJECT *device, void *in_buff, ULONG in_size,
+                      void *out_buff, ULONG out_size, IO_STATUS_BLOCK *io )
+{
+    IRP *irp;
+    KEVENT event;
+
+    KeInitializeEvent(&event, NotificationEvent, FALSE);
+
+    irp = IoBuildDeviceIoControlRequest( code, device, in_buff, in_size, out_buff, out_size, TRUE, &event, io );
+
+    if (IoCallDriver(device, irp) == STATUS_PENDING)
+        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
+}
diff -ruN --show-c-function dlls/ntdll/unix/file.c dlls/ntdll/unix/file.c
--- dlls/ntdll/unix/file.c	2025-10-10 10:17:47.372819327 -0700
+++ dlls/ntdll/unix/file.c	2025-10-10 12:03:54.184385925 -0700
@@ -3014,6 +3014,67 @@ not_found:
     return STATUS_OBJECT_NAME_NOT_FOUND;
 }
 
+/* CW-Bug-Id: #23185 Emulate Steam Input native hooks for native SDL */
+static BOOL replace_steam_input_path( OBJECT_ATTRIBUTES *attr, UNICODE_STRING *redir )
+{
+    static const WCHAR pipe_prefixW[] =
+    {
+        '\\','?','?','\\','p','i','p','e','\\','H','I','D','#','V','I','D','_','0','4','5','E',
+        '&','P','I','D','_','0','2','8','E','&','I','G','_','0','0',
+    };
+    static const WCHAR hid_prefixW[] =
+    {
+        '\\','?','?','\\','h','i','d','#','v','i','d','_','2','8','d','e',
+        '&','p','i','d','_','1','1','f','f','&','i','g','_','0'
+    };
+    static const WCHAR hid_midW[] =
+    {
+        '#','0',
+    };
+    static const WCHAR hid_tailW[] =
+    {
+        '&','0','&','0','&','1','#','{','4','d','1','e','5','5','b','2','-','f','1','6','f','-',
+        '1','1','c','f','-','8','8','c','b','-','0','0','1','1','1','1','0','0','0','0','3','0','}'
+    };
+    UNICODE_STRING *path = attr->ObjectName;
+    const WCHAR *slot = NULL, *slot_end = NULL, *serial, *serial_end = NULL;
+    UINT len = 0;
+
+    if (!path || !path->Buffer || path->Length <= sizeof(pipe_prefixW)) return FALSE;
+    if (wcsnicmp( path->Buffer, pipe_prefixW, ARRAY_SIZE(pipe_prefixW) )) return FALSE;
+
+    serial = path->Buffer + path->Length / sizeof(WCHAR);
+    while (serial > path->Buffer && *serial != '&')
+    {
+        if (*serial == '#')
+        {
+            slot_end = serial_end;
+            serial_end = serial;
+            slot = serial_end + 1;
+        }
+        serial--;
+    }
+    if (serial == path->Buffer || *serial != '&' || !slot_end || !serial_end) return FALSE;
+
+    redir->Length = sizeof(hid_prefixW) + sizeof(hid_midW) + sizeof(hid_tailW);
+    redir->Length += (serial_end - serial + slot_end - slot) * sizeof(WCHAR);
+    redir->MaximumLength = redir->Length + sizeof(WCHAR);
+    if (!(redir->Buffer = malloc( redir->MaximumLength ))) return FALSE;
+
+    memcpy( redir->Buffer, hid_prefixW, sizeof(hid_prefixW) );
+    len += ARRAY_SIZE(hid_prefixW);
+    memcpy( redir->Buffer + len, slot, (slot_end - slot) * sizeof(WCHAR) );
+    len += slot_end - slot;
+    memcpy( redir->Buffer + len, hid_midW, sizeof(hid_midW) );
+    len += ARRAY_SIZE(hid_midW);
+    memcpy( redir->Buffer + len, serial, (serial_end - serial) * sizeof(WCHAR) );
+    len += serial_end - serial;
+    memcpy( redir->Buffer + len, hid_tailW, sizeof(hid_tailW) );
+
+    TRACE( "HACK: %s -> %s\n", debugstr_us(attr->ObjectName), debugstr_us(redir) );
+    attr->ObjectName = redir;
+    return TRUE;
+}
 
 #ifndef _WIN64
 
@@ -3114,6 +3175,9 @@ static void get_redirect( OBJECT_ATTRIBU
     const WCHAR *name = attr->ObjectName->Buffer;
     unsigned int i, prefix_len = 0, len = attr->ObjectName->Length / sizeof(WCHAR);
 
+    /* CW-Bug-Id: #23185 Emulate Steam Input native hooks for native SDL */
+    if (replace_steam_input_path( attr, redir )) return;
+
     if (!NtCurrentTeb64()) return;
 
     if (!attr->RootDirectory)
diff -ruN --show-c-function dlls/ntdll/unix/file.c.orig dlls/ntdll/unix/file.c.orig
--- dlls/ntdll/unix/file.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ dlls/ntdll/unix/file.c.orig	2025-10-10 12:03:48.157411094 -0700
@@ -0,0 +1,7493 @@
+/*
+ * NTDLL directory and file functions
+ *
+ * Copyright 1993 Erik Bos
+ * Copyright 2003 Eric Pouech
+ * Copyright 1996, 2004 Alexandre Julliard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include <assert.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <limits.h>
+#include <unistd.h>
+#ifdef HAVE_MNTENT_H
+#include <mntent.h>
+#endif
+#include <poll.h>
+#include <sys/stat.h>
+#ifdef HAVE_SYS_STATVFS_H
+# include <sys/statvfs.h>
+#endif
+#ifdef HAVE_SYS_SYSCALL_H
+# include <sys/syscall.h>
+#endif
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <sys/ioctl.h>
+#ifdef HAVE_SYS_ATTR_H
+#include <sys/attr.h>
+#endif
+#ifdef MAJOR_IN_MKDEV
+# include <sys/mkdev.h>
+#elif defined(MAJOR_IN_SYSMACROS)
+# include <sys/sysmacros.h>
+#endif
+#ifdef HAVE_SYS_VNODE_H
+/* Work around a conflict with Solaris' system list defined in sys/list.h. */
+#define list SYSLIST
+#define list_next SYSLIST_NEXT
+#define list_prev SYSLIST_PREV
+#define list_head SYSLIST_HEAD
+#define list_tail SYSLIST_TAIL
+#define list_move_tail SYSLIST_MOVE_TAIL
+#define list_remove SYSLIST_REMOVE
+#include <sys/vnode.h>
+#undef list
+#undef list_next
+#undef list_prev
+#undef list_head
+#undef list_tail
+#undef list_move_tail
+#undef list_remove
+#endif
+#ifdef HAVE_LINUX_IOCTL_H
+#include <linux/ioctl.h>
+#endif
+#ifdef HAVE_LINUX_MAJOR_H
+# include <linux/major.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#ifdef HAVE_SYS_CONF_H
+#include <sys/conf.h>
+#endif
+#ifdef HAVE_SYS_MOUNT_H
+#include <sys/mount.h>
+#endif
+#ifdef HAVE_SYS_STATFS_H
+#include <sys/statfs.h>
+#endif
+#ifdef HAVE_SYS_XATTR_H
+#include <sys/xattr.h>
+#endif
+#ifdef HAVE_SYS_EXTATTR_H
+#undef XATTR_ADDITIONAL_OPTIONS
+#include <sys/extattr.h>
+#endif
+#include <time.h>
+#include <unistd.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winnt.h"
+#include "winioctl.h"
+#include "winternl.h"
+#include "ddk/ntddk.h"
+#include "ddk/ntddser.h"
+#include "ddk/wdm.h"
+#define WINE_MOUNTMGR_EXTENSIONS
+#include "ddk/mountmgr.h"
+#include "wine/server.h"
+#include "wine/list.h"
+#include "wine/debug.h"
+#include "unix_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(file);
+WINE_DECLARE_DEBUG_CHANNEL(winediag);
+
+#define MAX_DOS_DRIVES 26
+
+/* just in case... */
+#undef VFAT_IOCTL_READDIR_BOTH
+#undef EXT2_IOC_GETFLAGS
+#undef EXT4_CASEFOLD_FL
+
+#ifdef linux
+
+/* We want the real kernel dirent structure, not the libc one */
+typedef struct
+{
+    long d_ino;
+    long d_off;
+    unsigned short d_reclen;
+    char d_name[256];
+} KERNEL_DIRENT;
+
+/* Define the VFAT ioctl to get both short and long file names */
+#define VFAT_IOCTL_READDIR_BOTH  _IOR('r', 1, KERNEL_DIRENT [2] )
+
+/* Define the ext2 ioctl for handling extra attributes */
+#define EXT2_IOC_GETFLAGS _IOR('f', 1, long)
+
+/* Case-insensitivity attribute */
+#define EXT4_CASEFOLD_FL 0x40000000
+
+#ifndef O_DIRECTORY
+# define O_DIRECTORY 0200000 /* must be directory */
+#endif
+
+#ifndef AT_NO_AUTOMOUNT
+#define AT_NO_AUTOMOUNT 0x800
+#endif
+
+#endif  /* linux */
+
+#define IS_SEPARATOR(ch)   ((ch) == '\\' || (ch) == '/')
+
+#define INVALID_NT_CHARS   '*','?','<','>','|','"'
+#define INVALID_DOS_CHARS  INVALID_NT_CHARS,'+','=',',',';','[',']',' ','\345'
+
+#define MAX_DIR_ENTRY_LEN 255  /* max length of a directory entry in chars */
+
+#define MAX_IGNORED_FILES 4
+
+#ifndef XATTR_USER_PREFIX
+# define XATTR_USER_PREFIX "user."
+#endif
+#ifndef XATTR_USER_PREFIX_LEN
+# define XATTR_USER_PREFIX_LEN (sizeof(XATTR_USER_PREFIX) - 1)
+#endif
+
+#define SAMBA_XATTR_DOS_ATTRIB  XATTR_USER_PREFIX "DOSATTRIB"
+#define XATTR_ATTRIBS_MASK      (FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_SYSTEM)
+
+struct file_identity
+{
+    dev_t dev;
+    ino_t ino;
+};
+
+static struct file_identity ignored_files[MAX_IGNORED_FILES];
+static unsigned int ignored_files_count;
+
+union file_directory_info
+{
+    ULONG                              next;
+    FILE_DIRECTORY_INFORMATION         dir;
+    FILE_BOTH_DIRECTORY_INFORMATION    both;
+    FILE_FULL_DIRECTORY_INFORMATION    full;
+    FILE_ID_BOTH_DIRECTORY_INFORMATION id_both;
+    FILE_ID_FULL_DIRECTORY_INFORMATION id_full;
+    FILE_ID_GLOBAL_TX_DIR_INFORMATION  id_tx;
+    FILE_NAMES_INFORMATION             names;
+};
+
+struct dir_data_buffer
+{
+    struct dir_data_buffer *next;    /* next buffer in the list */
+    unsigned int            size;    /* total size of the buffer */
+    unsigned int            pos;     /* current position in the buffer */
+    char                    data[1];
+};
+
+struct dir_data_names
+{
+    const WCHAR *long_name;          /* long file name in Unicode */
+    const WCHAR *short_name;         /* short file name in Unicode */
+    const char  *unix_name;          /* Unix file name in host encoding */
+};
+
+struct dir_data
+{
+    unsigned int            size;    /* size of the names array */
+    unsigned int            count;   /* count of used entries in the names array */
+    unsigned int            pos;     /* current reading position in the names array */
+    struct file_identity    id;      /* directory file identity */
+    struct dir_data_names  *names;   /* directory file names */
+    struct dir_data_buffer *buffer;  /* head of data buffers list */
+    UNICODE_STRING          mask;    /* the mask used when creating the cache entry */
+};
+
+static const unsigned int dir_data_buffer_initial_size = 4096;
+static const unsigned int dir_data_cache_initial_size  = 256;
+static const unsigned int dir_data_names_initial_size  = 64;
+
+static struct dir_data **dir_data_cache;
+static unsigned int dir_data_cache_size;
+
+static BOOL show_dot_files;
+static mode_t start_umask;
+
+static const WCHAR nt_prefixW[] = {'\\','?','?','\\'};
+static const WCHAR dos_prefixW[] = {'\\','?','?','\\','A',':','\\'};
+static const WCHAR unc_prefixW[] = {'\\','?','?','\\','U','N','C','\\'};
+static const WCHAR unix_prefixW[] = {'\\','?','?','\\','u','n','i','x'};
+
+/* at some point we may want to allow Winelib apps to set this */
+static const BOOL is_case_sensitive = FALSE;
+
+static pthread_mutex_t dir_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pthread_mutex_t mnt_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+/* check if a given Unicode char is OK in a DOS short name */
+static inline BOOL is_invalid_dos_char( WCHAR ch )
+{
+    static const WCHAR invalid_chars[] = { INVALID_DOS_CHARS,'~','.',0 };
+    if (ch > 0x7f) return TRUE;
+    return wcschr( invalid_chars, ch ) != NULL;
+}
+
+/* check if the device can be a mounted volume */
+static inline BOOL is_valid_mounted_device( const struct stat *st )
+{
+#if defined(linux) || defined(__sun__)
+    return S_ISBLK( st->st_mode );
+#else
+    /* disks are char devices on *BSD */
+    return S_ISCHR( st->st_mode );
+#endif
+}
+
+static inline void ignore_file( const char *name )
+{
+    struct stat st;
+    assert( ignored_files_count < MAX_IGNORED_FILES );
+    if (!stat( name, &st ))
+    {
+        ignored_files[ignored_files_count].dev = st.st_dev;
+        ignored_files[ignored_files_count].ino = st.st_ino;
+        ignored_files_count++;
+    }
+}
+
+static inline BOOL is_same_file( const struct file_identity *file, const struct stat *st )
+{
+    return st->st_dev == file->dev && st->st_ino == file->ino;
+}
+
+static inline BOOL is_ignored_file( const struct stat *st )
+{
+    unsigned int i;
+
+    for (i = 0; i < ignored_files_count; i++)
+        if (is_same_file( &ignored_files[i], st )) return TRUE;
+    return FALSE;
+}
+
+static inline unsigned int dir_info_align( unsigned int len )
+{
+    return (len + 7) & ~7;
+}
+
+static inline unsigned int dir_info_size( FILE_INFORMATION_CLASS class, unsigned int len )
+{
+    switch (class)
+    {
+    case FileDirectoryInformation:
+        return offsetof( FILE_DIRECTORY_INFORMATION, FileName[len] );
+    case FileBothDirectoryInformation:
+        return offsetof( FILE_BOTH_DIRECTORY_INFORMATION, FileName[len] );
+    case FileFullDirectoryInformation:
+        return offsetof( FILE_FULL_DIRECTORY_INFORMATION, FileName[len] );
+    case FileIdBothDirectoryInformation:
+        return offsetof( FILE_ID_BOTH_DIRECTORY_INFORMATION, FileName[len] );
+    case FileIdFullDirectoryInformation:
+        return offsetof( FILE_ID_FULL_DIRECTORY_INFORMATION, FileName[len] );
+    case FileIdGlobalTxDirectoryInformation:
+        return offsetof( FILE_ID_GLOBAL_TX_DIR_INFORMATION, FileName[len] );
+    case FileNamesInformation:
+        return offsetof( FILE_NAMES_INFORMATION, FileName[len] );
+    default:
+        assert(0);
+        return 0;
+    }
+}
+
+static BOOL is_wildcard( WCHAR c )
+{
+    return c == '*' || c == '?' || c == '>' || c == '<' || c == '\"';
+}
+
+static inline BOOL has_wildcard( const UNICODE_STRING *mask )
+{
+    int i;
+
+    if (!mask) return TRUE;
+    for (i = 0; i < mask->Length / sizeof(WCHAR); i++)
+        if (is_wildcard( mask->Buffer[i] )) return TRUE;
+
+    return FALSE;
+}
+
+NTSTATUS errno_to_status( int err )
+{
+    TRACE( "errno = %d\n", err );
+    switch (err)
+    {
+    case EAGAIN:    return STATUS_SHARING_VIOLATION;
+    case EBADF:     return STATUS_INVALID_HANDLE;
+    case EBUSY:     return STATUS_DEVICE_BUSY;
+    case ENOSPC:    return STATUS_DISK_FULL;
+    case EPERM:
+    case EROFS:
+    case EACCES:    return STATUS_ACCESS_DENIED;
+    case ENOTDIR:   return STATUS_OBJECT_PATH_NOT_FOUND;
+    case ENOENT:    return STATUS_OBJECT_NAME_NOT_FOUND;
+    case EISDIR:    return STATUS_INVALID_DEVICE_REQUEST;
+    case EMFILE:
+    case ENFILE:    return STATUS_TOO_MANY_OPENED_FILES;
+    case EINVAL:    return STATUS_INVALID_PARAMETER;
+    case ENOTEMPTY: return STATUS_DIRECTORY_NOT_EMPTY;
+    case EPIPE:     return STATUS_PIPE_DISCONNECTED;
+    case EIO:       return STATUS_DEVICE_NOT_READY;
+#ifdef ENOMEDIUM
+    case ENOMEDIUM: return STATUS_NO_MEDIA_IN_DEVICE;
+#endif
+    case ENXIO:     return STATUS_NO_SUCH_DEVICE;
+    case ENOTTY:
+    case EOPNOTSUPP:return STATUS_NOT_SUPPORTED;
+    case ECONNRESET:return STATUS_PIPE_DISCONNECTED;
+    case EFAULT:    return STATUS_ACCESS_VIOLATION;
+    case ESPIPE:    return STATUS_ILLEGAL_FUNCTION;
+    case ELOOP:     return STATUS_REPARSE_POINT_NOT_RESOLVED;
+#ifdef ETIME /* Missing on FreeBSD */
+    case ETIME:     return STATUS_IO_TIMEOUT;
+#endif
+    case ENOEXEC:   /* ?? */
+    case EEXIST:    /* ?? */
+    default:
+        FIXME( "Converting errno %d to STATUS_UNSUCCESSFUL\n", err );
+        return STATUS_UNSUCCESSFUL;
+    }
+}
+
+
+static int xattr_fremove( int filedes, const char *name )
+{
+#ifdef HAVE_SYS_XATTR_H
+# ifdef XATTR_ADDITIONAL_OPTIONS
+    return fremovexattr( filedes, name, 0 );
+# else
+    return fremovexattr( filedes, name );
+# endif
+#elif defined(HAVE_SYS_EXTATTR_H)
+    return extattr_delete_fd( filedes, EXTATTR_NAMESPACE_USER, &name[XATTR_USER_PREFIX_LEN] );
+#else
+    errno = ENOSYS;
+    return -1;
+#endif
+}
+
+
+static int xattr_fset( int filedes, const char *name, const void *value, size_t size )
+{
+#ifdef HAVE_SYS_XATTR_H
+# ifdef XATTR_ADDITIONAL_OPTIONS
+    return fsetxattr( filedes, name, value, size, 0, 0 );
+# else
+    return fsetxattr( filedes, name, value, size, 0 );
+# endif
+#elif defined(HAVE_SYS_EXTATTR_H)
+    return extattr_set_fd( filedes, EXTATTR_NAMESPACE_USER, &name[XATTR_USER_PREFIX_LEN],
+                           value, size );
+#else
+    errno = ENOSYS;
+    return -1;
+#endif
+}
+
+
+/* On macOS, getxattr() is significantly slower than listxattr()
+ * (even for files with no extended attributes).
+ */
+#ifdef __APPLE__
+static BOOL xattr_exists( const char **path, int *filedes, const char *name )
+{
+    char xattrs[1024];
+    ssize_t i = 0, ret;
+
+    if (path)
+        ret = listxattr( *path, xattrs, sizeof(xattrs), 0 );
+    else
+        ret = flistxattr( *filedes, xattrs, sizeof(xattrs), 0 );
+    if (ret == -1)
+        return errno == ERANGE;
+
+    while (i < ret)
+    {
+        if (!strcmp( name, &xattrs[i] ))
+            return TRUE;
+        i += strlen(&xattrs[i]) + 1;
+    }
+
+    errno = ENOATTR;
+    return FALSE;
+}
+#endif
+
+
+static int xattr_get( const char *path, const char *name, void *value, size_t size )
+{
+#ifdef __APPLE__
+    if (!xattr_exists( &path, NULL, name ))
+        return -1;
+#endif
+
+#ifdef HAVE_SYS_XATTR_H
+# ifdef XATTR_ADDITIONAL_OPTIONS
+    return getxattr( path, name, value, size, 0, 0 );
+# else
+    return getxattr( path, name, value, size );
+# endif
+#elif defined(HAVE_SYS_EXTATTR_H)
+    return extattr_get_file( path, EXTATTR_NAMESPACE_USER, &name[XATTR_USER_PREFIX_LEN],
+                             value, size );
+#else
+    errno = ENOSYS;
+    return -1;
+#endif
+}
+
+
+static int xattr_fget( int filedes, const char *name, void *value, size_t size )
+{
+#ifdef __APPLE__
+    if (!xattr_exists( NULL, &filedes, name ))
+        return -1;
+#endif
+
+#ifdef HAVE_SYS_XATTR_H
+# ifdef XATTR_ADDITIONAL_OPTIONS
+    return fgetxattr( filedes, name, value, size, 0, 0 );
+# else
+    return fgetxattr( filedes, name, value, size );
+# endif
+#elif defined(HAVE_SYS_EXTATTR_H)
+    return extattr_get_fd( filedes, EXTATTR_NAMESPACE_USER, &name[XATTR_USER_PREFIX_LEN],
+                           value, size );
+#else
+    errno = ENOSYS;
+    return -1;
+#endif
+}
+
+
+/* get space from the current directory data buffer, allocating a new one if necessary */
+static void *get_dir_data_space( struct dir_data *data, unsigned int size )
+{
+    struct dir_data_buffer *buffer = data->buffer;
+    void *ret;
+
+    if (!buffer || size > buffer->size - buffer->pos)
+    {
+        unsigned int new_size = buffer ? buffer->size * 2 : dir_data_buffer_initial_size;
+        if (new_size < size) new_size = size;
+        if (!(buffer = malloc( offsetof( struct dir_data_buffer, data[new_size] ) ))) return NULL;
+        buffer->pos  = 0;
+        buffer->size = new_size;
+        buffer->next = data->buffer;
+        data->buffer = buffer;
+    }
+    ret = buffer->data + buffer->pos;
+    buffer->pos += size;
+    return ret;
+}
+
+/* add a string to the directory data buffer */
+static const char *add_dir_data_nameA( struct dir_data *data, const char *name )
+{
+    /* keep buffer data WCHAR-aligned */
+    char *ptr = get_dir_data_space( data, (strlen( name ) + sizeof(WCHAR)) & ~(sizeof(WCHAR) - 1) );
+    if (ptr) strcpy( ptr, name );
+    return ptr;
+}
+
+/* add a Unicode string to the directory data buffer */
+static const WCHAR *add_dir_data_nameW( struct dir_data *data, const WCHAR *name )
+{
+    WCHAR *ptr = get_dir_data_space( data, (wcslen( name ) + 1) * sizeof(WCHAR) );
+    if (ptr) wcscpy( ptr, name );
+    return ptr;
+}
+
+/* add an entry to the directory names array */
+static BOOL add_dir_data_names( struct dir_data *data, const WCHAR *long_name,
+                                const WCHAR *short_name, const char *unix_name )
+{
+    static const WCHAR empty[1];
+    struct dir_data_names *names = data->names;
+
+    if (data->count >= data->size)
+    {
+        unsigned int new_size = max( data->size * 2, dir_data_names_initial_size );
+
+        if (!(names = realloc( names, new_size * sizeof(*names) ))) return FALSE;
+        data->size  = new_size;
+        data->names = names;
+    }
+
+    if (short_name[0])
+    {
+        if (!(names[data->count].short_name = add_dir_data_nameW( data, short_name ))) return FALSE;
+    }
+    else names[data->count].short_name = empty;
+
+    if (!(names[data->count].long_name = add_dir_data_nameW( data, long_name ))) return FALSE;
+    if (!(names[data->count].unix_name = add_dir_data_nameA( data, unix_name ))) return FALSE;
+    data->count++;
+    return TRUE;
+}
+
+/* free the complete directory data structure */
+static void free_dir_data( struct dir_data *data )
+{
+    struct dir_data_buffer *buffer, *next;
+
+    if (!data) return;
+
+    for (buffer = data->buffer; buffer; buffer = next)
+    {
+        next = buffer->next;
+        free( buffer );
+    }
+    free( data->names );
+    free( data->mask.Buffer );
+    free( data );
+}
+
+
+/* support for a directory queue for filesystem searches */
+
+struct dir_name
+{
+    struct list entry;
+    char name[1];
+};
+
+static NTSTATUS add_dir_to_queue( struct list *queue, const char *name )
+{
+    int len = strlen( name ) + 1;
+    struct dir_name *dir = malloc( offsetof( struct dir_name, name[len] ));
+    if (!dir) return STATUS_NO_MEMORY;
+    strcpy( dir->name, name );
+    list_add_tail( queue, &dir->entry );
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS next_dir_in_queue( struct list *queue, char *name )
+{
+    struct list *head = list_head( queue );
+    if (head)
+    {
+        struct dir_name *dir = LIST_ENTRY( head, struct dir_name, entry );
+        strcpy( name, dir->name );
+        list_remove( &dir->entry );
+        free( dir );
+        return STATUS_SUCCESS;
+    }
+    return STATUS_OBJECT_NAME_NOT_FOUND;
+}
+
+static void flush_dir_queue( struct list *queue )
+{
+    struct list *head;
+
+    while ((head = list_head( queue )))
+    {
+        struct dir_name *dir = LIST_ENTRY( head, struct dir_name, entry );
+        list_remove( &dir->entry );
+        free( dir );
+    }
+}
+
+
+#ifdef __ANDROID__
+
+static char *unescape_field( char *str )
+{
+    char *in, *out;
+
+    for (in = out = str; *in; in++, out++)
+    {
+        *out = *in;
+        if (in[0] == '\\')
+        {
+            if (in[1] == '\\')
+            {
+                out[0] = '\\';
+                in++;
+            }
+            else if (in[1] == '0' && in[2] == '4' && in[3] == '0')
+            {
+                out[0] = ' ';
+                in += 3;
+            }
+            else if (in[1] == '0' && in[2] == '1' && in[3] == '1')
+            {
+                out[0] = '\t';
+                in += 3;
+            }
+            else if (in[1] == '0' && in[2] == '1' && in[3] == '2')
+            {
+                out[0] = '\n';
+                in += 3;
+            }
+            else if (in[1] == '1' && in[2] == '3' && in[3] == '4')
+            {
+                out[0] = '\\';
+                in += 3;
+            }
+        }
+    }
+    *out = '\0';
+
+    return str;
+}
+
+static inline char *get_field( char **str )
+{
+    char *ret;
+
+    ret = strsep( str, " \t" );
+    if (*str) *str += strspn( *str, " \t" );
+
+    return ret;
+}
+/************************************************************************
+ *                    getmntent_replacement
+ *
+ * getmntent replacement for Android.
+ *
+ * NB returned static buffer is not thread safe; protect with mnt_mutex.
+ */
+static struct mntent *getmntent_replacement( FILE *f )
+{
+    static struct mntent entry;
+    static char buf[4096];
+    char *p, *start;
+
+    do
+    {
+        if (!fgets( buf, sizeof(buf), f )) return NULL;
+        p = strchr( buf, '\n' );
+        if (p) *p = '\0';
+        else /* Partially unread line, move file ptr to end */
+        {
+            char tmp[1024];
+            while (fgets( tmp, sizeof(tmp), f ))
+                if (strchr( tmp, '\n' )) break;
+        }
+        start = buf + strspn( buf, " \t" );
+    } while (start[0] == '\0' || start[0] == '#');
+
+    p = get_field( &start );
+    entry.mnt_fsname = p ? unescape_field( p ) : (char *)"";
+
+    p = get_field( &start );
+    entry.mnt_dir = p ? unescape_field( p ) : (char *)"";
+
+    p = get_field( &start );
+    entry.mnt_type = p ? unescape_field( p ) : (char *)"";
+
+    p = get_field( &start );
+    entry.mnt_opts = p ? unescape_field( p ) : (char *)"";
+
+    p = get_field( &start );
+    entry.mnt_freq = p ? atoi(p) : 0;
+
+    p = get_field( &start );
+    entry.mnt_passno = p ? atoi(p) : 0;
+
+    return &entry;
+}
+#define getmntent getmntent_replacement
+#endif
+
+/***********************************************************************
+ *           parse_mount_entries
+ *
+ * Parse mount entries looking for a given device. Helper for get_default_drive_device.
+ */
+
+#ifdef sun
+#include <sys/vfstab.h>
+static char *parse_vfstab_entries( FILE *f, dev_t dev, ino_t ino)
+{
+    struct vfstab entry;
+    struct stat st;
+    char *device;
+
+    while (! getvfsent( f, &entry ))
+    {
+        /* don't even bother stat'ing network mounts, there's no meaningful device anyway */
+        if (!strcmp( entry.vfs_fstype, "nfs" ) ||
+            !strcmp( entry.vfs_fstype, "smbfs" ) ||
+            !strcmp( entry.vfs_fstype, "ncpfs" )) continue;
+
+        if (stat( entry.vfs_mountp, &st ) == -1) continue;
+        if (st.st_dev != dev || st.st_ino != ino) continue;
+        if (!strcmp( entry.vfs_fstype, "fd" ))
+        {
+            if ((device = strstr( entry.vfs_mntopts, "dev=" )))
+            {
+                char *p = strchr( device + 4, ',' );
+                if (p) *p = 0;
+                return device + 4;
+            }
+        }
+        else
+            return entry.vfs_special;
+    }
+    return NULL;
+}
+#endif
+
+#ifdef linux
+static char *parse_mount_entries( FILE *f, dev_t dev, ino_t ino )
+{
+    struct mntent *entry;
+    struct stat st;
+    char *device;
+
+    while ((entry = getmntent( f )))
+    {
+        /* don't even bother stat'ing network mounts, there's no meaningful device anyway */
+        if (!strcmp( entry->mnt_type, "nfs" ) ||
+            !strcmp( entry->mnt_type, "cifs" ) ||
+            !strcmp( entry->mnt_type, "smbfs" ) ||
+            !strcmp( entry->mnt_type, "ncpfs" )) continue;
+
+        if (stat( entry->mnt_dir, &st ) == -1) continue;
+        if (st.st_dev != dev || st.st_ino != ino) continue;
+        if (!strcmp( entry->mnt_type, "supermount" ))
+        {
+            if ((device = strstr( entry->mnt_opts, "dev=" )))
+            {
+                char *p = strchr( device + 4, ',' );
+                if (p) *p = 0;
+                return device + 4;
+            }
+        }
+        else if (!stat( entry->mnt_fsname, &st ) && S_ISREG(st.st_mode))
+        {
+            /* if device is a regular file check for a loop mount */
+            if ((device = strstr( entry->mnt_opts, "loop=" )))
+            {
+                char *p = strchr( device + 5, ',' );
+                if (p) *p = 0;
+                return device + 5;
+            }
+        }
+        else
+            return entry->mnt_fsname;
+    }
+    return NULL;
+}
+#endif
+
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
+#include <fstab.h>
+static char *parse_mount_entries( FILE *f, dev_t dev, ino_t ino )
+{
+    struct fstab *entry;
+    struct stat st;
+
+    while ((entry = getfsent()))
+    {
+        /* don't even bother stat'ing network mounts, there's no meaningful device anyway */
+        if (!strcmp( entry->fs_vfstype, "nfs" ) ||
+            !strcmp( entry->fs_vfstype, "smbfs" ) ||
+            !strcmp( entry->fs_vfstype, "ncpfs" )) continue;
+
+        if (stat( entry->fs_file, &st ) == -1) continue;
+        if (st.st_dev != dev || st.st_ino != ino) continue;
+        return entry->fs_spec;
+    }
+    return NULL;
+}
+#endif
+
+#ifdef sun
+#include <sys/mnttab.h>
+static char *parse_mount_entries( FILE *f, dev_t dev, ino_t ino )
+{
+    struct mnttab entry;
+    struct stat st;
+    char *device;
+
+
+    while (( ! getmntent( f, &entry) ))
+    {
+        /* don't even bother stat'ing network mounts, there's no meaningful device anyway */
+        if (!strcmp( entry.mnt_fstype, "nfs" ) ||
+            !strcmp( entry.mnt_fstype, "smbfs" ) ||
+            !strcmp( entry.mnt_fstype, "ncpfs" )) continue;
+
+        if (stat( entry.mnt_mountp, &st ) == -1) continue;
+        if (st.st_dev != dev || st.st_ino != ino) continue;
+        if (!strcmp( entry.mnt_fstype, "fd" ))
+        {
+            if ((device = strstr( entry.mnt_mntopts, "dev=" )))
+            {
+                char *p = strchr( device + 4, ',' );
+                if (p) *p = 0;
+                return device + 4;
+            }
+        }
+        else
+            return entry.mnt_special;
+    }
+    return NULL;
+}
+#endif
+
+/***********************************************************************
+ *           get_default_drive_device
+ *
+ * Return the default device to use for a given drive mount point.
+ */
+static char *get_default_drive_device( const char *root )
+{
+    char *ret = NULL;
+
+#ifdef linux
+    FILE *f;
+    char *device = NULL;
+    int fd, res = -1;
+    struct stat st;
+
+    /* try to open it first to force it to get mounted */
+    if ((fd = open( root, O_RDONLY | O_DIRECTORY )) != -1)
+    {
+        res = fstat( fd, &st );
+        close( fd );
+    }
+    /* now try normal stat just in case */
+    if (res == -1) res = stat( root, &st );
+    if (res == -1) return NULL;
+
+    mutex_lock( &mnt_mutex );
+
+#ifdef __ANDROID__
+    if ((f = fopen( "/proc/mounts", "r" )))
+    {
+        device = parse_mount_entries( f, st.st_dev, st.st_ino );
+        fclose( f );
+    }
+#else
+    if ((f = fopen( "/etc/mtab", "r" )))
+    {
+        device = parse_mount_entries( f, st.st_dev, st.st_ino );
+        fclose( f );
+    }
+    /* look through fstab too in case it's not mounted (for instance if it's an audio CD) */
+    if (!device && (f = fopen( "/etc/fstab", "r" )))
+    {
+        device = parse_mount_entries( f, st.st_dev, st.st_ino );
+        fclose( f );
+    }
+#endif
+    if (device) ret = strdup( device );
+    mutex_unlock( &mnt_mutex );
+
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__ ) || defined(__DragonFly__)
+    char *device = NULL;
+    int fd, res = -1;
+    struct stat st;
+
+    /* try to open it first to force it to get mounted */
+    if ((fd = open( root, O_RDONLY )) != -1)
+    {
+        res = fstat( fd, &st );
+        close( fd );
+    }
+    /* now try normal stat just in case */
+    if (res == -1) res = stat( root, &st );
+    if (res == -1) return NULL;
+
+    mutex_lock( &mnt_mutex );
+
+    /* The FreeBSD parse_mount_entries doesn't require a file argument, so just
+     * pass NULL.  Leave the argument in for symmetry.
+     */
+    device = parse_mount_entries( NULL, st.st_dev, st.st_ino );
+    if (device) ret = strdup( device );
+    mutex_unlock( &mnt_mutex );
+
+#elif defined( sun )
+    FILE *f;
+    char *device = NULL;
+    int fd, res = -1;
+    struct stat st;
+
+    /* try to open it first to force it to get mounted */
+    if ((fd = open( root, O_RDONLY )) != -1)
+    {
+        res = fstat( fd, &st );
+        close( fd );
+    }
+    /* now try normal stat just in case */
+    if (res == -1) res = stat( root, &st );
+    if (res == -1) return NULL;
+
+    mutex_lock( &mnt_mutex );
+
+    if ((f = fopen( "/etc/mnttab", "r" )))
+    {
+        device = parse_mount_entries( f, st.st_dev, st.st_ino);
+        fclose( f );
+    }
+    /* look through fstab too in case it's not mounted (for instance if it's an audio CD) */
+    if (!device && (f = fopen( "/etc/vfstab", "r" )))
+    {
+        device = parse_vfstab_entries( f, st.st_dev, st.st_ino );
+        fclose( f );
+    }
+    if (device) ret = strdup( device );
+    mutex_unlock( &mnt_mutex );
+
+#elif defined(__APPLE__)
+    struct statfs *mntStat;
+    struct stat st;
+    int i;
+    int mntSize;
+    dev_t dev;
+    ino_t ino;
+    static const char path_bsd_device[] = "/dev/disk";
+    int res;
+
+    res = stat( root, &st );
+    if (res == -1) return NULL;
+
+    dev = st.st_dev;
+    ino = st.st_ino;
+
+    mutex_lock( &mnt_mutex );
+
+    mntSize = getmntinfo(&mntStat, MNT_NOWAIT);
+
+    for (i = 0; i < mntSize && !ret; i++)
+    {
+        if (stat(mntStat[i].f_mntonname, &st ) == -1) continue;
+        if (st.st_dev != dev || st.st_ino != ino) continue;
+
+        /* FIXME add support for mounted network drive */
+        if ( strncmp(mntStat[i].f_mntfromname, path_bsd_device, strlen(path_bsd_device)) == 0)
+        {
+            /* set return value to the corresponding raw BSD node */
+            ret = malloc( strlen(mntStat[i].f_mntfromname) + 2 /* 2 : r and \0 */ );
+            if (ret)
+            {
+                strcpy(ret, "/dev/r");
+                strcat(ret, mntStat[i].f_mntfromname+sizeof("/dev/")-1);
+            }
+        }
+    }
+    mutex_unlock( &mnt_mutex );
+#else
+    static int warned;
+    if (!warned++) FIXME( "auto detection of DOS devices not supported on this platform\n" );
+#endif
+    return ret;
+}
+
+
+/***********************************************************************
+ *           get_device_mount_point
+ *
+ * Return the current mount point for a device.
+ */
+static char *get_device_mount_point( dev_t dev )
+{
+    char *ret = NULL;
+
+#ifdef linux
+    FILE *f;
+
+    mutex_lock( &mnt_mutex );
+
+#ifdef __ANDROID__
+    if ((f = fopen( "/proc/mounts", "r" )))
+#else
+    if ((f = fopen( "/etc/mtab", "r" )))
+#endif
+    {
+        struct mntent *entry;
+        struct stat st;
+        char *p, *device;
+
+        while ((entry = getmntent( f )))
+        {
+            /* don't even bother stat'ing network mounts, there's no meaningful device anyway */
+            if (!strcmp( entry->mnt_type, "nfs" ) ||
+                !strcmp( entry->mnt_type, "cifs" ) ||
+                !strcmp( entry->mnt_type, "smbfs" ) ||
+                !strcmp( entry->mnt_type, "ncpfs" )) continue;
+
+            if (!strcmp( entry->mnt_type, "supermount" ))
+            {
+                if ((device = strstr( entry->mnt_opts, "dev=" )))
+                {
+                    device += 4;
+                    if ((p = strchr( device, ',' ))) *p = 0;
+                }
+            }
+            else if (!stat( entry->mnt_fsname, &st ) && S_ISREG(st.st_mode))
+            {
+                /* if device is a regular file check for a loop mount */
+                if ((device = strstr( entry->mnt_opts, "loop=" )))
+                {
+                    device += 5;
+                    if ((p = strchr( device, ',' ))) *p = 0;
+                }
+            }
+            else device = entry->mnt_fsname;
+
+            if (device && !stat( device, &st ) && S_ISBLK(st.st_mode) && st.st_rdev == dev)
+            {
+                ret = strdup( entry->mnt_dir );
+                break;
+            }
+        }
+        fclose( f );
+    }
+    mutex_unlock( &mnt_mutex );
+#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+    struct statfs *entry;
+    struct stat st;
+    int i, size;
+
+    mutex_lock( &mnt_mutex );
+
+    size = getmntinfo( &entry, MNT_NOWAIT );
+    for (i = 0; i < size; i++)
+    {
+        if (stat( entry[i].f_mntfromname, &st ) == -1) continue;
+        if (S_ISBLK(st.st_mode) && st.st_rdev == dev)
+        {
+            ret = strdup( entry[i].f_mntonname );
+            break;
+        }
+    }
+    mutex_unlock( &mnt_mutex );
+#else
+    static int warned;
+    if (!warned++) FIXME( "unmounting devices not supported on this platform\n" );
+#endif
+    return ret;
+}
+
+
+#if defined(HAVE_GETATTRLIST) && defined(ATTR_VOL_CAPABILITIES) && \
+    defined(VOL_CAPABILITIES_FORMAT) && defined(VOL_CAP_FMT_CASE_SENSITIVE)
+
+static pthread_mutex_t fs_cache_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+struct get_fsid
+{
+    ULONG size;
+    dev_t dev;
+    fsid_t fsid;
+};
+
+struct fs_cache
+{
+    dev_t dev;
+    fsid_t fsid;
+    BOOLEAN case_sensitive;
+} fs_cache[64];
+
+struct vol_caps
+{
+    ULONG size;
+    vol_capabilities_attr_t caps;
+};
+
+/***********************************************************************
+ *           look_up_fs_cache
+ *
+ * Checks if the specified file system is in the cache.
+ */
+static struct fs_cache *look_up_fs_cache( dev_t dev )
+{
+    int i;
+    for (i = 0; i < ARRAY_SIZE( fs_cache ); i++)
+        if (fs_cache[i].dev == dev)
+            return fs_cache+i;
+    return NULL;
+}
+
+/***********************************************************************
+ *           add_fs_cache
+ *
+ * Adds the specified file system to the cache.
+ */
+static void add_fs_cache( dev_t dev, fsid_t fsid, BOOLEAN case_sensitive )
+{
+    int i;
+    struct fs_cache *entry = look_up_fs_cache( dev );
+    static int once = 0;
+    if (entry)
+    {
+        /* Update the cache */
+        entry->fsid = fsid;
+        entry->case_sensitive = case_sensitive;
+        return;
+    }
+
+    /* Add a new entry */
+    for (i = 0; i < ARRAY_SIZE( fs_cache ); i++)
+        if (fs_cache[i].dev == 0)
+        {
+            /* This entry is empty, use it */
+            fs_cache[i].dev = dev;
+            fs_cache[i].fsid = fsid;
+            fs_cache[i].case_sensitive = case_sensitive;
+            return;
+        }
+
+    /* Cache is out of space, warn */
+    if (!once++)
+        WARN( "FS cache is out of space, expect performance problems\n" );
+}
+
+/***********************************************************************
+ *           get_dir_case_sensitivity_attr
+ *
+ * Checks if the volume containing the specified directory is case
+ * sensitive or not. Uses getattrlist(2)/getattrlistat(2).
+ */
+static int get_dir_case_sensitivity_attr( int root_fd, const char *dir )
+{
+    BOOLEAN ret = FALSE;
+    char *mntpoint;
+    struct attrlist attr;
+    struct vol_caps caps;
+    struct get_fsid get_fsid;
+    struct fs_cache *entry;
+
+    /* First get the FS ID of the volume */
+    attr.bitmapcount = ATTR_BIT_MAP_COUNT;
+    attr.reserved = 0;
+    attr.commonattr = ATTR_CMN_DEVID|ATTR_CMN_FSID;
+    attr.volattr = attr.dirattr = attr.fileattr = attr.forkattr = 0;
+    get_fsid.size = 0;
+    if (getattrlistat( root_fd, dir, &attr, &get_fsid, sizeof(get_fsid), 0 ) != 0 ||
+        get_fsid.size != sizeof(get_fsid))
+        return -1;
+
+    /* Try to look it up in the cache */
+    mutex_lock( &fs_cache_mutex );
+    entry = look_up_fs_cache( get_fsid.dev );
+    if (entry && !memcmp( &entry->fsid, &get_fsid.fsid, sizeof(fsid_t) ))
+    {
+        /* Cache lookup succeeded */
+        ret = entry->case_sensitive;
+        goto done;
+    }
+
+    /* Cache is stale at this point, we have to update it */
+    mntpoint = get_device_mount_point( get_fsid.dev );
+    /* Now look up the case-sensitivity */
+    attr.commonattr = 0;
+    attr.volattr = ATTR_VOL_INFO|ATTR_VOL_CAPABILITIES;
+    if (getattrlist( mntpoint, &attr, &caps, sizeof(caps), 0 ) < 0)
+    {
+        free( mntpoint );
+        add_fs_cache( get_fsid.dev, get_fsid.fsid, TRUE );
+        ret = TRUE;
+        goto done;
+    }
+    free( mntpoint );
+    if (caps.size == sizeof(caps) &&
+        (caps.caps.valid[VOL_CAPABILITIES_FORMAT] &
+         (VOL_CAP_FMT_CASE_SENSITIVE | VOL_CAP_FMT_CASE_PRESERVING)) ==
+        (VOL_CAP_FMT_CASE_SENSITIVE | VOL_CAP_FMT_CASE_PRESERVING))
+    {
+        if ((caps.caps.capabilities[VOL_CAPABILITIES_FORMAT] &
+            VOL_CAP_FMT_CASE_SENSITIVE) != VOL_CAP_FMT_CASE_SENSITIVE)
+            ret = FALSE;
+        else
+            ret = TRUE;
+        /* Update the cache */
+        add_fs_cache( get_fsid.dev, get_fsid.fsid, ret );
+        goto done;
+    }
+
+done:
+    mutex_unlock( &fs_cache_mutex );
+    return ret;
+}
+#endif
+
+/***********************************************************************
+ *           get_dir_case_sensitivity_stat
+ *
+ * Checks if the volume containing the specified directory is case
+ * sensitive or not. Uses (f)statfs(2), statvfs(2), fstatat(2), or ioctl(2).
+ */
+static BOOLEAN get_dir_case_sensitivity_stat( int root_fd, const char *dir )
+{
+#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+    struct statfs stfs;
+    int fd;
+
+    if ((fd = openat( root_fd, dir, O_RDONLY )) == -1) return TRUE;
+    if (fstatfs( fd, &stfs ) == -1)
+    {
+        close( fd );
+        return TRUE;
+    }
+    close( fd );
+    /* Assume these file systems are always case insensitive.*/
+    if (!strcmp( stfs.f_fstypename, "fusefs" ) &&
+        !strncmp( stfs.f_mntfromname, "ciopfs", 5 ))
+        return FALSE;
+    /* msdosfs was case-insensitive since FreeBSD 8, if not earlier */
+    if (!strcmp( stfs.f_fstypename, "msdosfs" ) ||
+        /* older CIFS protocol versions uppercase filename on the client,
+         * newer versions should be case-insensitive on the server anyway */
+        !strcmp( stfs.f_fstypename, "smbfs" ))
+        return FALSE;
+    /* no ntfs-3g: modern fusefs has no way to report the filesystem on FreeBSD
+     * no cd9660 or udf, they're case-sensitive on FreeBSD
+     */
+#ifdef __APPLE__
+    if (!strcmp( stfs.f_fstypename, "msdos" ) ||
+        !strcmp( stfs.f_fstypename, "cd9660" ) ||
+        !strcmp( stfs.f_fstypename, "udf" ) ||
+        !strcmp( stfs.f_fstypename, "ntfs" ))
+        return FALSE;
+#ifdef _DARWIN_FEATURE_64_BIT_INODE
+     if (!strcmp( stfs.f_fstypename, "hfs" ) && (stfs.f_fssubtype == 0 ||
+                                                 stfs.f_fssubtype == 1 ||
+                                                 stfs.f_fssubtype == 128))
+        return FALSE;
+#else
+     /* The field says "reserved", but a quick look at the kernel source
+      * tells us that this "reserved" field is really the same as the
+      * "fssubtype" field from the inode64 structure (see munge_statfs()
+      * in <xnu-source>/bsd/vfs/vfs_syscalls.c).
+      */
+     if (!strcmp( stfs.f_fstypename, "hfs" ) && (stfs.f_reserved1 == 0 ||
+                                                 stfs.f_reserved1 == 1 ||
+                                                 stfs.f_reserved1 == 128))
+        return FALSE;
+#endif
+#endif
+    return TRUE;
+
+#elif defined(__linux__)
+    BOOLEAN sens = TRUE;
+    struct statfs stfs;
+    struct stat st;
+    int fd, flags;
+
+    if ((fd = openat( root_fd, dir, O_RDONLY | O_NONBLOCK )) == -1)
+        return TRUE;
+
+    if (ioctl( fd, EXT2_IOC_GETFLAGS, &flags ) != -1 && (flags & EXT4_CASEFOLD_FL))
+    {
+        sens = FALSE;
+    }
+    else if (fstatfs( fd, &stfs ) == 0 &&                          /* CIOPFS is case insensitive.  Instead of */
+             stfs.f_type == 0x65735546 /* FUSE_SUPER_MAGIC */ &&   /* parsing mtab to discover if the FUSE FS */
+             fstatat( fd, ".ciopfs", &st, AT_NO_AUTOMOUNT ) == 0)  /* is CIOPFS, look for .ciopfs in the dir. */
+    {
+        sens = FALSE;
+    }
+
+    close( fd );
+    return sens;
+#else
+    return TRUE;
+#endif
+}
+
+
+/***********************************************************************
+ *           get_dir_case_sensitivity
+ *
+ * Checks if the volume containing the specified directory is case
+ * sensitive or not. Uses multiple methods, depending on platform.
+ */
+static BOOLEAN get_dir_case_sensitivity( int root_fd, const char *dir )
+{
+#if defined(HAVE_GETATTRLIST) && defined(ATTR_VOL_CAPABILITIES) && \
+    defined(VOL_CAPABILITIES_FORMAT) && defined(VOL_CAP_FMT_CASE_SENSITIVE)
+    int case_sensitive = get_dir_case_sensitivity_attr( root_fd, dir );
+    if (case_sensitive != -1) return case_sensitive;
+#endif
+    return get_dir_case_sensitivity_stat( root_fd, dir );
+}
+
+
+/***********************************************************************
+ *           is_hidden_file
+ *
+ * Check if the specified file should be hidden based on its unix path and the show dot files option.
+ */
+static BOOL is_hidden_file( const char *name )
+{
+    const char *p;
+
+    if (show_dot_files) return FALSE;
+
+    p = name + strlen( name );
+    while (p > name && p[-1] == '/') p--;
+    while (p > name && p[-1] != '/') p--;
+    if (*p++ != '.') return FALSE;
+    if (!*p || *p == '/') return FALSE;  /* "." directory */
+    if (*p++ != '.') return TRUE;
+    if (!*p || *p == '/') return FALSE;  /* ".." directory */
+    return TRUE;
+}
+
+
+/***********************************************************************
+ *           hash_short_file_name
+ *
+ * Transform a Unix file name into a hashed DOS name. If the name is not a valid
+ * DOS name, it is replaced by a hashed version that fits in 8.3 format.
+ * 'buffer' must be at least 12 characters long.
+ * Returns length of short name in bytes; short name is NOT null-terminated.
+ */
+static ULONG hash_short_file_name( const WCHAR *name, int length, LPWSTR buffer )
+{
+    static const char hash_chars[32] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ012345";
+
+    LPCWSTR p, ext, end = name + length;
+    LPWSTR dst;
+    unsigned short hash;
+    int i;
+
+    /* Compute the hash code of the file name */
+    /* If you know something about hash functions, feel free to */
+    /* insert a better algorithm here... */
+    if (!is_case_sensitive)
+    {
+        for (p = name, hash = 0xbeef; p < end - 1; p++)
+            hash = (hash<<3) ^ (hash>>5) ^ towlower(*p) ^ (towlower(p[1]) << 8);
+        hash = (hash<<3) ^ (hash>>5) ^ towlower(*p); /* Last character */
+    }
+    else
+    {
+        for (p = name, hash = 0xbeef; p < end - 1; p++)
+            hash = (hash << 3) ^ (hash >> 5) ^ *p ^ (p[1] << 8);
+        hash = (hash << 3) ^ (hash >> 5) ^ *p;  /* Last character */
+    }
+
+    /* Find last dot for start of the extension */
+    p = name;
+    while (*p == '.') ++p;
+    for (p = p + 1, ext = NULL; p < end - 1; p++) if (*p == '.') ext = p;
+
+    /* Copy first 4 chars, replacing invalid chars with '_' */
+    for (i = 4, p = name, dst = buffer; i > 0; p++)
+    {
+        if (p == end || p == ext) break;
+        if (*p == '.') continue;
+        *dst++ = is_invalid_dos_char(*p) ? '_' : *p;
+        i--;
+    }
+    /* Pad to 5 chars with '~' */
+    while (i-- >= 0) *dst++ = '~';
+
+    /* Insert hash code converted to 3 ASCII chars */
+    *dst++ = hash_chars[(hash >> 10) & 0x1f];
+    *dst++ = hash_chars[(hash >> 5) & 0x1f];
+    *dst++ = hash_chars[hash & 0x1f];
+
+    /* Copy the first 3 chars of the extension (if any) */
+    if (ext)
+    {
+        *dst++ = '.';
+        for (i = 3, ext++; (i > 0) && ext < end; i--, ext++)
+            *dst++ = is_invalid_dos_char(*ext) ? '_' : *ext;
+    }
+    return dst - buffer;
+}
+
+
+/***********************************************************************
+ *           match_filename_part
+ *
+ * Recursive helper for match_filename().
+ *
+ */
+static BOOLEAN match_filename_part( const WCHAR *name, const WCHAR *name_end, const WCHAR *mask, const WCHAR *mask_end )
+{
+    WCHAR c;
+
+    while (name < name_end && mask < mask_end)
+    {
+        switch(*mask)
+        {
+        case '*':
+            mask++;
+            while (mask < mask_end && *mask == '*') mask++;  /* Skip consecutive '*' */
+            if (mask == mask_end) return TRUE; /* end of mask is all '*', so match */
+
+            while (name < name_end)
+            {
+                c = *mask == '"' ? '.' : *mask;
+                if (!is_wildcard(c))
+                {
+                    if (is_case_sensitive)
+                        while (name < name_end && (*name != c)) name++;
+                    else
+                        while (name < name_end && (towupper(*name) != towupper(c))) name++;
+                }
+                if (match_filename_part( name, name_end, mask, mask_end )) return TRUE;
+                ++name;
+            }
+            break;
+        case '<':
+        {
+            const WCHAR *next_dot;
+            BOOL had_dot = FALSE;
+
+            ++mask;
+            while (name < name_end)
+            {
+                next_dot = name;
+                while (next_dot < name_end && *next_dot != '.') ++next_dot;
+                if (next_dot == name_end && had_dot) break;
+                if (next_dot < name_end)
+                {
+                    had_dot = TRUE;
+                    ++next_dot;
+                }
+                if (mask < mask_end)
+                {
+                    while (name < next_dot)
+                    {
+                        c = *mask == '"' ? '.' : *mask;
+                        if (!is_wildcard(c))
+                        {
+                            if (is_case_sensitive)
+                                while (name < next_dot && (*name != c)) name++;
+                            else
+                                while (name < next_dot && (towupper(*name) != towupper(c))) name++;
+                        }
+                        if (match_filename_part( name, name_end, mask, mask_end )) return TRUE;
+                        ++name;
+                    }
+                }
+                name = next_dot;
+            }
+            break;
+        }
+        case '?':
+            mask++;
+            name++;
+            break;
+        case '>':
+            mask++;
+            if (*name == '.')
+            {
+                while (mask < mask_end && *mask == '>') mask++;
+                if (mask == mask_end) name++;
+            }
+            else name++;
+            break;
+        default:
+            c = *mask == '"' ? '.' : *mask;
+            if (is_case_sensitive && c != *name) return FALSE;
+            if (!is_case_sensitive && towupper(c) != towupper(*name)) return FALSE;
+            mask++;
+            name++;
+            break;
+        }
+    }
+    while (mask < mask_end && (*mask == '*' || *mask == '<' || *mask == '"' || *mask == '>'))
+        mask++;
+    return (name == name_end && mask == mask_end);
+}
+
+
+/***********************************************************************
+ *           match_filename
+ *
+ * Check a file name against a mask.
+ *
+ */
+static BOOLEAN match_filename( const WCHAR *name, int length, const UNICODE_STRING *mask_str )
+{
+    /* Special handling for parent directory. */
+    if (length == 2 && name[0] == '.' && name[1] == '.') --length;
+
+    return match_filename_part( name, name + length, mask_str->Buffer,
+                                mask_str->Buffer + mask_str->Length / sizeof(WCHAR));
+}
+
+
+/***********************************************************************
+ *           is_legal_8dot3_name
+ *
+ * Simplified version of RtlIsNameLegalDOS8Dot3.
+ */
+static BOOLEAN is_legal_8dot3_name( const WCHAR *name, int len )
+{
+    static const WCHAR invalid_chars[] = { INVALID_DOS_CHARS,':','/','\\',0 };
+    int i, dot = -1;
+
+    if (len > 12) return FALSE;
+
+    /* a starting . is invalid, except for . and .. */
+    if (len > 0 && name[0] == '.') return (len == 1 || (len == 2 && name[1] == '.'));
+
+    for (i = 0; i < len; i++)
+    {
+        if (name[i] > 0x7f) return FALSE;
+        if (wcschr( invalid_chars, name[i] )) return FALSE;
+        if (name[i] == '.')
+        {
+            if (dot != -1) return FALSE;
+            dot = i;
+        }
+    }
+
+    if (dot == -1) return (len <= 8);
+    if (dot > 8) return FALSE;
+    return (len - dot > 1 && len - dot < 5);
+}
+
+
+/***********************************************************************
+ *           append_entry
+ *
+ * Add a file to the directory data if it matches the mask.
+ */
+static BOOL append_entry( struct dir_data *data, const char *long_name,
+                          const char *short_name, const UNICODE_STRING *mask )
+{
+    int long_len, short_len;
+    WCHAR long_nameW[MAX_DIR_ENTRY_LEN + 1];
+    WCHAR short_nameW[13];
+
+    long_len = ntdll_umbstowcs( long_name, strlen(long_name), long_nameW, ARRAY_SIZE(long_nameW) );
+    if (long_len == ARRAY_SIZE(long_nameW)) return TRUE;
+    long_nameW[long_len] = 0;
+
+    if (short_name)
+    {
+        short_len = ntdll_umbstowcs( short_name, strlen(short_name),
+                                     short_nameW, ARRAY_SIZE( short_nameW ) - 1 );
+    }
+    else  /* generate a short name if necessary */
+    {
+        short_len = 0;
+        if (!is_legal_8dot3_name( long_nameW, long_len ))
+            short_len = hash_short_file_name( long_nameW, long_len, short_nameW );
+    }
+    short_nameW[short_len] = 0;
+    wcsupr( short_nameW );
+
+    TRACE( "long %s short %s mask %s\n",
+           debugstr_w( long_nameW ), debugstr_w( short_nameW ), debugstr_us( mask ));
+
+    if (mask && !match_filename( long_nameW, long_len, mask ))
+    {
+        if (!short_len) return TRUE;  /* no short name to match */
+        if (!match_filename( short_nameW, short_len, mask )) return TRUE;
+    }
+
+    return add_dir_data_names( data, long_nameW, short_nameW, long_name );
+}
+
+
+/* fetch the attributes of a file */
+static inline ULONG get_file_attributes( const struct stat *st )
+{
+    ULONG attr;
+
+    if (S_ISDIR(st->st_mode))
+        attr = FILE_ATTRIBUTE_DIRECTORY;
+    else
+        attr = FILE_ATTRIBUTE_ARCHIVE;
+    if (!(st->st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)))
+        attr |= FILE_ATTRIBUTE_READONLY;
+    return attr;
+}
+
+
+/* decode the xattr-stored DOS attributes */
+static int parse_samba_dos_attrib_data( char *data, int len )
+{
+    char *end;
+    int val;
+
+    if (len > 2 && data[0] == '0' && data[1] == 'x')
+    {
+        data[len] = 0;
+        val = strtol( data, &end, 16 );
+        if (!*end) return val & XATTR_ATTRIBS_MASK;
+    }
+    else
+    {
+        static BOOL once;
+        if (!once++) FIXME( "Unhandled " SAMBA_XATTR_DOS_ATTRIB " extended attribute value.\n" );
+    }
+    return 0;
+}
+
+
+static BOOL fd_is_mount_point( int fd, const struct stat *st )
+{
+    struct stat parent;
+    return S_ISDIR( st->st_mode ) && !fstatat( fd, "..", &parent, 0 )
+            && (parent.st_dev != st->st_dev || parent.st_ino == st->st_ino);
+}
+
+
+/* get the stat info and file attributes for a file (by file descriptor) */
+static int fd_get_file_info( int fd, unsigned int options, struct stat *st, ULONG *attr )
+{
+    char attr_data[65];
+    int attr_len, ret;
+
+    *attr = 0;
+    ret = fstat( fd, st );
+    if (ret == -1) return ret;
+    *attr |= get_file_attributes( st );
+    /* consider mount points to be reparse points (IO_REPARSE_TAG_MOUNT_POINT) */
+    if ((options & FILE_OPEN_REPARSE_POINT) && fd_is_mount_point( fd, st ))
+        *attr |= FILE_ATTRIBUTE_REPARSE_POINT;
+
+    attr_len = xattr_fget( fd, SAMBA_XATTR_DOS_ATTRIB, attr_data, sizeof(attr_data)-1 );
+    if (attr_len != -1)
+        *attr |= parse_samba_dos_attrib_data( attr_data, attr_len );
+    else
+    {
+        if (errno == ENOTSUP) return ret;
+#ifdef ENODATA
+        if (errno == ENODATA) return ret;
+#endif
+#ifdef ENOATTR
+        if (errno == ENOATTR) return ret;
+#endif
+        WARN( "Failed to get extended attribute " SAMBA_XATTR_DOS_ATTRIB ". errno %d (%s)\n",
+              errno, strerror( errno ) );
+    }
+    return ret;
+}
+
+
+static int fd_set_dos_attrib( int fd, UINT attr, BOOL force_set )
+{
+    /* we only store the HIDDEN and SYSTEM attributes */
+    attr &= XATTR_ATTRIBS_MASK;
+    if (force_set || attr != 0)
+    {
+        /* encode the attributes in Samba 3 ASCII format. Samba 4 has extended
+         * this format with more features, but retains compatibility with the
+         * earlier format. */
+        char data[11];
+        int len = snprintf( data, sizeof(data), "0x%x", attr );
+        return xattr_fset( fd, SAMBA_XATTR_DOS_ATTRIB, data, len );
+    }
+    else return xattr_fremove( fd, SAMBA_XATTR_DOS_ATTRIB );
+}
+
+
+/* set the stat info and file attributes for a file (by file descriptor) */
+static NTSTATUS fd_set_file_info( int fd, UINT attr, BOOL force_set_xattr )
+{
+    struct stat st;
+
+    if (fstat( fd, &st ) == -1) return errno_to_status( errno );
+    if (attr & FILE_ATTRIBUTE_READONLY)
+    {
+        if (S_ISDIR( st.st_mode))
+            WARN("FILE_ATTRIBUTE_READONLY ignored for directory.\n");
+        else
+            st.st_mode &= ~0222; /* clear write permission bits */
+    }
+    else
+    {
+        /* add write permission only where we already have read permission */
+        st.st_mode |= (0600 | ((st.st_mode & 044) >> 1)) & (~start_umask);
+    }
+    if (fchmod( fd, st.st_mode ) == -1) return errno_to_status( errno );
+
+    /* if the file has multiple names, we can't be sure that it is safe to not
+       set the extended attribute, since any of the names could start with a dot */
+    force_set_xattr = force_set_xattr || st.st_nlink > 1;
+
+    if (fd_set_dos_attrib( fd, attr, force_set_xattr ) == -1 && errno != ENOTSUP)
+        WARN( "Failed to set extended attribute " SAMBA_XATTR_DOS_ATTRIB ". errno %d (%s)\n",
+              errno, strerror( errno ) );
+
+    return STATUS_SUCCESS;
+}
+
+
+/* get the stat info and file attributes for a file (by name) */
+static int get_file_info( const char *path, struct stat *st, ULONG *attr )
+{
+    char *parent_path;
+    char attr_data[65];
+    int attr_len, ret;
+
+    *attr = 0;
+    ret = lstat( path, st );
+    if (ret == -1) return ret;
+    if (S_ISLNK( st->st_mode ))
+    {
+        ret = stat( path, st );
+        if (ret == -1) return ret;
+        /* is a symbolic link and a directory, consider these "reparse points" */
+        if (S_ISDIR( st->st_mode )) *attr |= FILE_ATTRIBUTE_REPARSE_POINT;
+    }
+    else if (S_ISDIR( st->st_mode ) && (parent_path = malloc( strlen(path) + 4 )))
+    {
+        struct stat parent_st;
+
+        /* consider mount points to be reparse points (IO_REPARSE_TAG_MOUNT_POINT) */
+        strcpy( parent_path, path );
+        strcat( parent_path, "/.." );
+        if (!stat( parent_path, &parent_st )
+                && (st->st_dev != parent_st.st_dev || st->st_ino == parent_st.st_ino))
+            *attr |= FILE_ATTRIBUTE_REPARSE_POINT;
+
+        free( parent_path );
+    }
+    *attr |= get_file_attributes( st );
+
+    attr_len = xattr_get( path, SAMBA_XATTR_DOS_ATTRIB, attr_data, sizeof(attr_data)-1 );
+    if (attr_len != -1)
+        *attr |= parse_samba_dos_attrib_data( attr_data, attr_len );
+    else
+    {
+        if (is_hidden_file( path ))
+            *attr |= FILE_ATTRIBUTE_HIDDEN;
+        if (errno == ENOTSUP) return ret;
+#ifdef ENODATA
+        if (errno == ENODATA) return ret;
+#endif
+#ifdef ENOATTR
+        if (errno == ENOATTR) return ret;
+#endif
+        WARN( "Failed to get extended attribute " SAMBA_XATTR_DOS_ATTRIB " from %s. errno %d (%s)\n",
+              debugstr_a(path), errno, strerror( errno ) );
+    }
+    return ret;
+}
+
+
+#if defined(__ANDROID__) && !defined(HAVE_FUTIMENS)
+static int futimens( int fd, const struct timespec spec[2] )
+{
+    return syscall( __NR_utimensat, fd, NULL, spec, 0 );
+}
+#define HAVE_FUTIMENS
+#endif  /* __ANDROID__ */
+
+#ifndef UTIME_OMIT
+#define UTIME_OMIT ((1 << 30) - 2)
+#endif
+
+static BOOL set_file_times_precise( int fd, const LARGE_INTEGER *mtime,
+                                    const LARGE_INTEGER *atime, NTSTATUS *status )
+{
+#ifdef HAVE_FUTIMENS
+    struct timespec tv[2];
+
+    tv[0].tv_sec = tv[1].tv_sec = 0;
+    tv[0].tv_nsec = tv[1].tv_nsec = UTIME_OMIT;
+    if (atime->QuadPart)
+    {
+        tv[0].tv_sec = atime->QuadPart / 10000000 - SECS_1601_TO_1970;
+        tv[0].tv_nsec = (atime->QuadPart % 10000000) * 100;
+    }
+    if (mtime->QuadPart)
+    {
+        tv[1].tv_sec = mtime->QuadPart / 10000000 - SECS_1601_TO_1970;
+        tv[1].tv_nsec = (mtime->QuadPart % 10000000) * 100;
+    }
+#ifdef __APPLE__
+    if (!&futimens) return FALSE;
+#endif
+    if (futimens( fd, tv ) == -1) *status = errno_to_status( errno );
+    else *status = STATUS_SUCCESS;
+    return TRUE;
+#else
+    return FALSE;
+#endif
+}
+
+
+static NTSTATUS set_file_times( int fd, const LARGE_INTEGER *mtime, const LARGE_INTEGER *atime )
+{
+    NTSTATUS status = STATUS_SUCCESS;
+#if defined(HAVE_FUTIMES) || defined(HAVE_FUTIMESAT)
+    struct timeval tv[2];
+    struct stat st;
+#endif
+
+    if (set_file_times_precise( fd, mtime, atime, &status ))
+        return status;
+
+#if defined(HAVE_FUTIMES) || defined(HAVE_FUTIMESAT)
+    if (!atime->QuadPart || !mtime->QuadPart)
+    {
+
+        tv[0].tv_sec = tv[0].tv_usec = 0;
+        tv[1].tv_sec = tv[1].tv_usec = 0;
+        if (!fstat( fd, &st ))
+        {
+            tv[0].tv_sec = st.st_atime;
+            tv[1].tv_sec = st.st_mtime;
+#ifdef HAVE_STRUCT_STAT_ST_ATIM
+            tv[0].tv_usec = st.st_atim.tv_nsec / 1000;
+#elif defined(HAVE_STRUCT_STAT_ST_ATIMESPEC)
+            tv[0].tv_usec = st.st_atimespec.tv_nsec / 1000;
+#endif
+#ifdef HAVE_STRUCT_STAT_ST_MTIM
+            tv[1].tv_usec = st.st_mtim.tv_nsec / 1000;
+#elif defined(HAVE_STRUCT_STAT_ST_MTIMESPEC)
+            tv[1].tv_usec = st.st_mtimespec.tv_nsec / 1000;
+#endif
+        }
+    }
+    if (atime->QuadPart)
+    {
+        tv[0].tv_sec = atime->QuadPart / 10000000 - SECS_1601_TO_1970;
+        tv[0].tv_usec = (atime->QuadPart % 10000000) / 10;
+    }
+    if (mtime->QuadPart)
+    {
+        tv[1].tv_sec = mtime->QuadPart / 10000000 - SECS_1601_TO_1970;
+        tv[1].tv_usec = (mtime->QuadPart % 10000000) / 10;
+    }
+#ifdef HAVE_FUTIMES
+    if (futimes( fd, tv ) == -1) status = errno_to_status( errno );
+#elif defined(HAVE_FUTIMESAT)
+    if (futimesat( fd, NULL, tv ) == -1) status = errno_to_status( errno );
+#endif
+
+#else  /* HAVE_FUTIMES || HAVE_FUTIMESAT */
+    FIXME( "setting file times not supported\n" );
+    status = STATUS_NOT_IMPLEMENTED;
+#endif
+    return status;
+}
+
+
+static inline void get_file_times( const struct stat *st, LARGE_INTEGER *mtime, LARGE_INTEGER *ctime,
+                                   LARGE_INTEGER *atime, LARGE_INTEGER *creation )
+{
+    mtime->QuadPart = ticks_from_time_t( st->st_mtime );
+    ctime->QuadPart = ticks_from_time_t( st->st_ctime );
+    atime->QuadPart = ticks_from_time_t( st->st_atime );
+#ifdef HAVE_STRUCT_STAT_ST_MTIM
+    mtime->QuadPart += st->st_mtim.tv_nsec / 100;
+#elif defined(HAVE_STRUCT_STAT_ST_MTIMESPEC)
+    mtime->QuadPart += st->st_mtimespec.tv_nsec / 100;
+#endif
+#ifdef HAVE_STRUCT_STAT_ST_CTIM
+    ctime->QuadPart += st->st_ctim.tv_nsec / 100;
+#elif defined(HAVE_STRUCT_STAT_ST_CTIMESPEC)
+    ctime->QuadPart += st->st_ctimespec.tv_nsec / 100;
+#endif
+#ifdef HAVE_STRUCT_STAT_ST_ATIM
+    atime->QuadPart += st->st_atim.tv_nsec / 100;
+#elif defined(HAVE_STRUCT_STAT_ST_ATIMESPEC)
+    atime->QuadPart += st->st_atimespec.tv_nsec / 100;
+#endif
+#ifdef HAVE_STRUCT_STAT_ST_BIRTHTIME
+    creation->QuadPart = ticks_from_time_t( st->st_birthtime );
+#ifdef HAVE_STRUCT_STAT_ST_BIRTHTIM
+    creation->QuadPart += st->st_birthtim.tv_nsec / 100;
+#elif defined(HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC)
+    creation->QuadPart += st->st_birthtimespec.tv_nsec / 100;
+#endif
+#elif defined(HAVE_STRUCT_STAT___ST_BIRTHTIME)
+    creation->QuadPart = ticks_from_time_t( st->__st_birthtime );
+#ifdef HAVE_STRUCT_STAT___ST_BIRTHTIM
+    creation->QuadPart += st->__st_birthtim.tv_nsec / 100;
+#endif
+#else
+    *creation = *mtime;
+#endif
+}
+
+
+/* fill in the file information that depends on the stat and attribute info */
+static NTSTATUS fill_file_info( const struct stat *st, ULONG attr, void *ptr,
+                                FILE_INFORMATION_CLASS class )
+{
+    switch (class)
+    {
+    case FileBasicInformation:
+        {
+            FILE_BASIC_INFORMATION *info = ptr;
+
+            get_file_times( st, &info->LastWriteTime, &info->ChangeTime,
+                            &info->LastAccessTime, &info->CreationTime );
+            info->FileAttributes = attr;
+        }
+        break;
+    case FileStandardInformation:
+        {
+            FILE_STANDARD_INFORMATION *info = ptr;
+
+            if ((info->Directory = S_ISDIR(st->st_mode)))
+            {
+                info->AllocationSize.QuadPart = 0;
+                info->EndOfFile.QuadPart      = 0;
+                info->NumberOfLinks           = 1;
+            }
+            else
+            {
+                info->AllocationSize.QuadPart = (ULONGLONG)st->st_blocks * 512;
+                info->EndOfFile.QuadPart      = st->st_size;
+                info->NumberOfLinks           = st->st_nlink;
+            }
+        }
+        break;
+    case FileInternalInformation:
+        {
+            FILE_INTERNAL_INFORMATION *info = ptr;
+            info->IndexNumber.QuadPart = st->st_ino;
+        }
+        break;
+    case FileEndOfFileInformation:
+        {
+            FILE_END_OF_FILE_INFORMATION *info = ptr;
+            info->EndOfFile.QuadPart = S_ISDIR(st->st_mode) ? 0 : st->st_size;
+        }
+        break;
+    case FileAllInformation:
+        {
+            FILE_ALL_INFORMATION *info = ptr;
+            fill_file_info( st, attr, &info->BasicInformation, FileBasicInformation );
+            fill_file_info( st, attr, &info->StandardInformation, FileStandardInformation );
+            fill_file_info( st, attr, &info->InternalInformation, FileInternalInformation );
+        }
+        break;
+    case FileNetworkOpenInformation:
+        {
+            FILE_NETWORK_OPEN_INFORMATION *info = ptr;
+            get_file_times( st, &info->LastWriteTime, &info->ChangeTime,
+                            &info->LastAccessTime, &info->CreationTime );
+            info->FileAttributes = attr;
+            if (S_ISDIR(st->st_mode))
+            {
+                info->AllocationSize.QuadPart = 0;
+                info->EndOfFile.QuadPart      = 0;
+            }
+            else
+            {
+                info->AllocationSize.QuadPart = (ULONGLONG)st->st_blocks * 512;
+                info->EndOfFile.QuadPart      = st->st_size;
+            }
+        }
+        break;
+    /* all directory structures start with the FileDirectoryInformation layout */
+    case FileBothDirectoryInformation:
+    case FileFullDirectoryInformation:
+    case FileDirectoryInformation:
+        {
+            FILE_DIRECTORY_INFORMATION *info = ptr;
+
+            get_file_times( st, &info->LastWriteTime, &info->ChangeTime,
+                            &info->LastAccessTime, &info->CreationTime );
+            if (S_ISDIR(st->st_mode))
+            {
+                info->AllocationSize.QuadPart = 0;
+                info->EndOfFile.QuadPart      = 0;
+            }
+            else
+            {
+                info->AllocationSize.QuadPart = (ULONGLONG)st->st_blocks * 512;
+                info->EndOfFile.QuadPart      = st->st_size;
+            }
+            info->FileAttributes = attr;
+        }
+        break;
+    case FileIdFullDirectoryInformation:
+        {
+            FILE_ID_FULL_DIRECTORY_INFORMATION *info = ptr;
+            info->FileId.QuadPart = st->st_ino;
+            fill_file_info( st, attr, info, FileDirectoryInformation );
+        }
+        break;
+    case FileIdBothDirectoryInformation:
+        {
+            FILE_ID_BOTH_DIRECTORY_INFORMATION *info = ptr;
+            info->FileId.QuadPart = st->st_ino;
+            fill_file_info( st, attr, info, FileDirectoryInformation );
+        }
+        break;
+    case FileIdGlobalTxDirectoryInformation:
+        {
+            FILE_ID_GLOBAL_TX_DIR_INFORMATION *info = ptr;
+            info->FileId.QuadPart = st->st_ino;
+            fill_file_info( st, attr, info, FileDirectoryInformation );
+        }
+        break;
+
+    default:
+        return STATUS_INVALID_INFO_CLASS;
+    }
+    return STATUS_SUCCESS;
+}
+
+
+static unsigned int server_get_unix_name( HANDLE handle, char **unix_name )
+{
+    data_size_t size = 1024;
+    unsigned int ret;
+    char *name;
+
+    for (;;)
+    {
+        if (!(name = malloc( size + 1 ))) return STATUS_NO_MEMORY;
+
+        SERVER_START_REQ( get_handle_unix_name )
+        {
+            req->handle = wine_server_obj_handle( handle );
+            wine_server_set_reply( req, name, size );
+            ret = wine_server_call( req );
+            size = reply->name_len;
+        }
+        SERVER_END_REQ;
+
+        if (!ret)
+        {
+            name[size] = 0;
+            *unix_name = name;
+            break;
+        }
+        free( name );
+        if (ret != STATUS_BUFFER_OVERFLOW) break;
+    }
+    return ret;
+}
+
+static NTSTATUS server_get_name_info( HANDLE handle, FILE_NAME_INFORMATION *info, LONG *name_len )
+{
+    data_size_t size = 1024;
+    NTSTATUS status;
+    OBJECT_NAME_INFORMATION *name;
+
+    for (;;)
+    {
+        if (!(name = malloc( size ))) return STATUS_NO_MEMORY;
+        if (!(status = NtQueryObject( handle, ObjectNameInformation, name, size, &size )))
+        {
+            const WCHAR *ptr = name->Name.Buffer;
+            const WCHAR *end = ptr + name->Name.Length / sizeof(WCHAR);
+
+            /* Skip the volume mount point. */
+            while (ptr != end && *ptr == '\\') ++ptr;
+            while (ptr != end && *ptr != '\\') ++ptr;
+            while (ptr != end && *ptr == '\\') ++ptr;
+            while (ptr != end && *ptr != '\\') ++ptr;
+
+            info->FileNameLength = (end - ptr) * sizeof(WCHAR);
+            if (*name_len < info->FileNameLength) status = STATUS_BUFFER_OVERFLOW;
+            else if (!info->FileNameLength) status = STATUS_INVALID_INFO_CLASS;
+            else *name_len = info->FileNameLength;
+            memcpy( info->FileName, ptr, *name_len );
+            free( name );
+        }
+        else
+        {
+            free( name );
+            if (status == STATUS_INFO_LENGTH_MISMATCH || status == STATUS_BUFFER_OVERFLOW) continue;
+        }
+        return status;
+    }
+}
+
+
+static NTSTATUS get_full_size_info(int fd, FILE_FS_FULL_SIZE_INFORMATION *info) {
+    struct stat st;
+    ULONGLONG bsize;
+
+#if !defined(linux) || !defined(HAVE_FSTATFS)
+    struct statvfs stfs;
+#else
+    struct statfs stfs;
+#endif
+
+    if (fstat( fd, &st ) < 0) return errno_to_status( errno );
+    if (!S_ISREG(st.st_mode) && !S_ISDIR(st.st_mode)) return STATUS_INVALID_DEVICE_REQUEST;
+
+    /* Linux's fstatvfs is buggy */
+#if !defined(linux) || !defined(HAVE_FSTATFS)
+    if (fstatvfs( fd, &stfs ) < 0) return errno_to_status( errno );
+    bsize = stfs.f_frsize;
+#else
+    if (fstatfs( fd, &stfs ) < 0) return errno_to_status( errno );
+    bsize = stfs.f_bsize;
+#endif
+    if (bsize == 2048)  /* assume CD-ROM */
+    {
+        info->BytesPerSector = 2048;
+        info->SectorsPerAllocationUnit = 1;
+    }
+    else
+    {
+        info->BytesPerSector = 512;
+        info->SectorsPerAllocationUnit = 8;
+    }
+    info->TotalAllocationUnits.QuadPart = bsize * stfs.f_blocks / (info->BytesPerSector * info->SectorsPerAllocationUnit);
+    info->CallerAvailableAllocationUnits.QuadPart = bsize * stfs.f_bavail / (info->BytesPerSector * info->SectorsPerAllocationUnit);
+    info->ActualAvailableAllocationUnits.QuadPart = bsize * stfs.f_bfree / (info->BytesPerSector * info->SectorsPerAllocationUnit);
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS get_full_size_info_ex(int fd, FILE_FS_FULL_SIZE_INFORMATION_EX *info)
+{
+    FILE_FS_FULL_SIZE_INFORMATION full_info;
+    NTSTATUS status;
+
+    if ((status = get_full_size_info(fd, &full_info)) != STATUS_SUCCESS)
+        return status;
+
+    info->ActualTotalAllocationUnits = full_info.TotalAllocationUnits.QuadPart;
+    info->ActualAvailableAllocationUnits = full_info.ActualAvailableAllocationUnits.QuadPart;
+    info->ActualPoolUnavailableAllocationUnits = 0;
+    info->CallerAvailableAllocationUnits = full_info.CallerAvailableAllocationUnits.QuadPart;
+    info->CallerPoolUnavailableAllocationUnits = 0;
+    info->UsedAllocationUnits = info->ActualTotalAllocationUnits - info->ActualAvailableAllocationUnits;
+    info->CallerTotalAllocationUnits = info->CallerAvailableAllocationUnits + info->UsedAllocationUnits;
+    info->TotalReservedAllocationUnits = 0;
+    info->VolumeStorageReserveAllocationUnits = 0;
+    info->AvailableCommittedAllocationUnits = 0;
+    info->PoolAvailableAllocationUnits = 0;
+    info->SectorsPerAllocationUnit = full_info.SectorsPerAllocationUnit;
+    info->BytesPerSector = full_info.BytesPerSector;
+
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS server_get_file_info( HANDLE handle, IO_STATUS_BLOCK *io, void *buffer,
+                                      ULONG length, FILE_INFORMATION_CLASS info_class )
+{
+    SERVER_START_REQ( get_file_info )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        req->info_class = info_class;
+        wine_server_set_reply( req, buffer, length );
+        io->Status = wine_server_call( req );
+        io->Information = wine_server_reply_size( reply );
+    }
+    SERVER_END_REQ;
+    if (io->Status == STATUS_NOT_IMPLEMENTED)
+        FIXME( "Unsupported info class %x\n", info_class );
+    return io->Status;
+
+}
+
+
+static unsigned int server_open_file_object( HANDLE *handle, ACCESS_MASK access, OBJECT_ATTRIBUTES *attr,
+                                             ULONG sharing, ULONG options )
+{
+    unsigned int status;
+
+    SERVER_START_REQ( open_file_object )
+    {
+        req->access     = access;
+        req->attributes = attr->Attributes;
+        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
+        req->sharing    = sharing;
+        req->options    = options;
+        wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
+        status = wine_server_call( req );
+        *handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+    return status;
+}
+
+
+/* retrieve device/inode number for all the drives */
+static unsigned int get_drives_info( struct file_identity info[MAX_DOS_DRIVES] )
+{
+    static pthread_mutex_t cache_mutex = PTHREAD_MUTEX_INITIALIZER;
+    static struct file_identity cache[MAX_DOS_DRIVES];
+    static time_t last_update;
+    static unsigned int nb_drives;
+    unsigned int ret;
+    time_t now = time(NULL);
+
+    mutex_lock( &cache_mutex );
+    if (now != last_update)
+    {
+        char *buffer, *p;
+        struct stat st;
+        unsigned int i;
+
+        if (asprintf( &buffer, "%s/dosdevices/a:", config_dir ) != -1)
+        {
+            p = buffer + strlen(buffer) - 2;
+
+            for (i = nb_drives = 0; i < MAX_DOS_DRIVES; i++)
+            {
+                *p = 'a' + i;
+                if (!stat( buffer, &st ))
+                {
+                    cache[i].dev = st.st_dev;
+                    cache[i].ino = st.st_ino;
+                    nb_drives++;
+                }
+                else
+                {
+                    cache[i].dev = 0;
+                    cache[i].ino = 0;
+                }
+            }
+            free( buffer );
+        }
+        last_update = now;
+    }
+    memcpy( info, cache, sizeof(cache) );
+    ret = nb_drives;
+    mutex_unlock( &cache_mutex );
+    return ret;
+}
+
+
+/* Find a DOS device which can act as the root of "path".
+ * Similar to find_drive_root(), but returns -1 instead of crossing volumes. */
+static int find_dos_device( const char *path )
+{
+    int len = strlen(path);
+    int drive;
+    char *buffer;
+    struct stat st;
+    struct file_identity info[MAX_DOS_DRIVES];
+    dev_t dev_id;
+
+    if (!get_drives_info( info )) return -1;
+
+    if (stat( path, &st ) < 0) return -1;
+    dev_id = st.st_dev;
+
+    /* strip off trailing slashes */
+    while (len > 1 && path[len - 1] == '/') len--;
+
+    /* make a copy of the path */
+    if (!(buffer = malloc( len + 1 ))) return -1;
+    memcpy( buffer, path, len );
+    buffer[len] = 0;
+
+    for (;;)
+    {
+        if (!stat( buffer, &st ) && S_ISDIR( st.st_mode ))
+        {
+            if (st.st_dev != dev_id) break;
+
+            for (drive = 0; drive < MAX_DOS_DRIVES; drive++)
+            {
+                if ((info[drive].dev == st.st_dev) && (info[drive].ino == st.st_ino))
+                {
+                    TRACE( "%s -> drive %c:, root=%s, name=%s\n",
+                           debugstr_a(path), 'A' + drive, debugstr_a(buffer), debugstr_a(path + len));
+                    free( buffer );
+                    return drive;
+                }
+            }
+        }
+        if (len <= 1) break;  /* reached root */
+        while (len > 1 && path[len - 1] != '/') len--;
+        while (len > 1 && path[len - 1] == '/') len--;
+        buffer[len] = 0;
+    }
+    free( buffer );
+    return -1;
+}
+
+static NTSTATUS get_mountmgr_fs_info( HANDLE handle, int fd, struct mountmgr_unix_drive *drive, ULONG size )
+{
+    OBJECT_ATTRIBUTES attr;
+    UNICODE_STRING string;
+    char *unix_name;
+    HANDLE mountmgr;
+    unsigned int status;
+    int letter = -1;
+
+    if (!server_get_unix_name( handle, &unix_name ))
+    {
+        letter = find_dos_device( unix_name );
+        free( unix_name );
+    }
+    memset( drive, 0, sizeof(*drive) );
+    if (letter == -1)
+    {
+        struct stat st;
+
+        fstat( fd, &st );
+        drive->unix_dev = st.st_rdev ? st.st_rdev : st.st_dev;
+    }
+    else
+        drive->letter = 'a' + letter;
+
+    init_unicode_string( &string, MOUNTMGR_DEVICE_NAME );
+    InitializeObjectAttributes( &attr, &string, 0, NULL, NULL );
+    status = server_open_file_object( &mountmgr, GENERIC_READ | SYNCHRONIZE, &attr,
+                                      FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_SYNCHRONOUS_IO_NONALERT );
+    if (status) return status;
+
+    status = sync_ioctl( mountmgr, IOCTL_MOUNTMGR_QUERY_UNIX_DRIVE, drive, sizeof(*drive), drive, size );
+    NtClose( mountmgr );
+    if (status == STATUS_BUFFER_OVERFLOW) status = STATUS_SUCCESS;
+    else if (status) WARN("failed to retrieve filesystem type from mountmgr, status %#x\n", status);
+    return status;
+}
+
+
+/***********************************************************************
+ *           get_dir_data_entry
+ *
+ * Return a directory entry from the cached data.
+ */
+static NTSTATUS get_dir_data_entry( struct dir_data *dir_data, void *info_ptr, IO_STATUS_BLOCK *io,
+                                    ULONG max_length, FILE_INFORMATION_CLASS class,
+                                    union file_directory_info **last_info )
+{
+    const struct dir_data_names *names = &dir_data->names[dir_data->pos];
+    union file_directory_info *info;
+    struct stat st;
+    ULONG name_len, start, dir_size, attributes;
+
+    if (get_file_info( names->unix_name, &st, &attributes ) == -1)
+    {
+        TRACE( "file no longer exists %s\n", debugstr_a(names->unix_name) );
+        return STATUS_SUCCESS;
+    }
+    if (is_ignored_file( &st ))
+    {
+        TRACE( "ignoring file %s\n", debugstr_a(names->unix_name) );
+        return STATUS_SUCCESS;
+    }
+    start = dir_info_align( io->Information );
+    dir_size = dir_info_size( class, 0 );
+    if (start + dir_size > max_length) return STATUS_MORE_ENTRIES;
+
+    max_length -= start + dir_size;
+    name_len = wcslen( names->long_name ) * sizeof(WCHAR);
+    /* if this is not the first entry, fail; the first entry is always returned (but truncated) */
+    if (*last_info && name_len > max_length) return STATUS_MORE_ENTRIES;
+
+    info = (union file_directory_info *)((char *)info_ptr + start);
+    info->dir.NextEntryOffset = 0;
+    info->dir.FileIndex = 0;  /* NTFS always has 0 here, so let's not bother with it */
+
+    /* all the structures except FileNamesInformation start with a FileDirectoryInformation layout */
+    if (class != FileNamesInformation)
+    {
+        if (st.st_dev != dir_data->id.dev) st.st_ino = 0;  /* ignore inode if on a different device */
+        fill_file_info( &st, attributes, info, class );
+    }
+
+    switch (class)
+    {
+    case FileDirectoryInformation:
+        info->dir.FileNameLength = name_len;
+        break;
+
+    case FileFullDirectoryInformation:
+        info->full.EaSize = 0; /* FIXME */
+        info->full.FileNameLength = name_len;
+        break;
+
+    case FileIdFullDirectoryInformation:
+        info->id_full.EaSize = 0; /* FIXME */
+        info->id_full.FileNameLength = name_len;
+        break;
+
+    case FileBothDirectoryInformation:
+        info->both.EaSize = 0; /* FIXME */
+        info->both.ShortNameLength = wcslen( names->short_name ) * sizeof(WCHAR);
+        memcpy( info->both.ShortName, names->short_name, info->both.ShortNameLength );
+        info->both.FileNameLength = name_len;
+        break;
+
+    case FileIdBothDirectoryInformation:
+        info->id_both.EaSize = 0; /* FIXME */
+        info->id_both.ShortNameLength = wcslen( names->short_name ) * sizeof(WCHAR);
+        memcpy( info->id_both.ShortName, names->short_name, info->id_both.ShortNameLength );
+        info->id_both.FileNameLength = name_len;
+        break;
+
+    case FileIdGlobalTxDirectoryInformation:
+        info->id_tx.TxInfoFlags = 0;
+        info->id_tx.FileNameLength = name_len;
+        break;
+
+    case FileNamesInformation:
+        info->names.FileNameLength = name_len;
+        break;
+
+    default:
+        assert(0);
+        return 0;
+    }
+
+    memcpy( (char *)info + dir_size, names->long_name, min( name_len, max_length ) );
+    io->Information = start + dir_size + min( name_len, max_length );
+    if (*last_info) (*last_info)->next = (char *)info - (char *)*last_info;
+    *last_info = info;
+    return name_len > max_length ? STATUS_BUFFER_OVERFLOW : STATUS_SUCCESS;
+}
+
+#ifdef VFAT_IOCTL_READDIR_BOTH
+
+/***********************************************************************
+ *           read_directory_vfat
+ *
+ * Read a directory using the VFAT ioctl; helper for NtQueryDirectoryFile.
+ */
+static NTSTATUS read_directory_data_vfat( struct dir_data *data, int fd, const UNICODE_STRING *mask )
+{
+    char *short_name, *long_name;
+    KERNEL_DIRENT de[2];
+    NTSTATUS status = STATUS_NO_MEMORY;
+    off_t old_pos = lseek( fd, 0, SEEK_CUR );
+
+    lseek( fd, 0, SEEK_SET );
+
+    if (ioctl( fd, VFAT_IOCTL_READDIR_BOTH, (long)de ) == -1)
+    {
+        if (errno != ENOENT)
+        {
+            status = STATUS_NOT_SUPPORTED;
+            goto done;
+        }
+        de[0].d_reclen = 0;
+    }
+
+    if (!append_entry( data, ".", NULL, mask )) goto done;
+    if (!append_entry( data, "..", NULL, mask )) goto done;
+
+    while (de[0].d_reclen)
+    {
+        if (strcmp( de[0].d_name, "." ) && strcmp( de[0].d_name, ".." ))
+        {
+            if (de[1].d_name[0])
+            {
+                short_name = de[0].d_name;
+                long_name = de[1].d_name;
+            }
+            else
+            {
+                long_name = de[0].d_name;
+                short_name = NULL;
+            }
+            if (!append_entry( data, long_name, short_name, mask )) goto done;
+        }
+        if (ioctl( fd, VFAT_IOCTL_READDIR_BOTH, (long)de ) == -1) break;
+    }
+    status = STATUS_SUCCESS;
+done:
+    lseek( fd, old_pos, SEEK_SET );
+    return status;
+}
+#endif /* VFAT_IOCTL_READDIR_BOTH */
+
+
+#ifdef HAVE_GETATTRLIST
+/***********************************************************************
+ *           read_directory_getattrlist
+ *
+ * Read a single file from a directory by determining whether the file
+ * identified by mask exists using getattrlist.
+ */
+static NTSTATUS read_directory_data_getattrlist( struct dir_data *data, const char *unix_name )
+{
+    struct attrlist attrlist;
+#pragma pack(push,4)
+    struct
+    {
+        u_int32_t length;
+        struct attrreference name_reference;
+        fsobj_type_t type;
+        char name[NAME_MAX * 3 + 1];
+    } buffer;
+#pragma pack(pop)
+
+    memset( &attrlist, 0, sizeof(attrlist) );
+    attrlist.bitmapcount = ATTR_BIT_MAP_COUNT;
+    attrlist.commonattr = ATTR_CMN_NAME | ATTR_CMN_OBJTYPE;
+    if (getattrlist( unix_name, &attrlist, &buffer, sizeof(buffer), FSOPT_NOFOLLOW ) == -1)
+        return STATUS_NO_SUCH_FILE;
+    /* If unix_name named a symlink, the above may have succeeded even if the symlink is broken.
+       Check that with another call without FSOPT_NOFOLLOW.  We don't ask for any attributes. */
+    if (buffer.type == VLNK)
+    {
+        u_int32_t dummy;
+        attrlist.commonattr = 0;
+        if (getattrlist( unix_name, &attrlist, &dummy, sizeof(dummy), 0 ) == -1)
+            return STATUS_NO_SUCH_FILE;
+    }
+
+    TRACE( "found %s\n", debugstr_a(buffer.name) );
+
+    if (!append_entry( data, buffer.name, NULL, NULL )) return STATUS_NO_MEMORY;
+
+    return STATUS_SUCCESS;
+}
+#endif  /* HAVE_GETATTRLIST */
+
+
+/***********************************************************************
+ *           read_directory_stat
+ *
+ * Read a single file from a directory by determining whether the file
+ * identified by mask exists using stat.
+ */
+static NTSTATUS read_directory_data_stat( struct dir_data *data, const char *unix_name )
+{
+    struct stat st;
+
+    /* if the file system is not case sensitive we can't find the actual name through stat() */
+    if (!get_dir_case_sensitivity( AT_FDCWD, "." )) return STATUS_NO_SUCH_FILE;
+    if (stat( unix_name, &st ) == -1) return STATUS_NO_SUCH_FILE;
+
+    TRACE( "found %s\n", debugstr_a(unix_name) );
+
+    if (!append_entry( data, unix_name, NULL, NULL )) return STATUS_NO_MEMORY;
+
+    return STATUS_SUCCESS;
+}
+
+
+/***********************************************************************
+ *           read_directory_readdir
+ *
+ * Read a directory using the POSIX readdir interface; helper for NtQueryDirectoryFile.
+ */
+static NTSTATUS read_directory_data_readdir( struct dir_data *data, const UNICODE_STRING *mask )
+{
+    struct dirent *de;
+    NTSTATUS status = STATUS_NO_MEMORY;
+    DIR *dir = opendir( "." );
+
+    if (!dir) return STATUS_NO_SUCH_FILE;
+
+    if (!append_entry( data, ".", NULL, mask )) goto done;
+    if (!append_entry( data, "..", NULL, mask )) goto done;
+    while ((de = readdir( dir )))
+    {
+        if (!strcmp( de->d_name, "." ) || !strcmp( de->d_name, ".." )) continue;
+        if (!append_entry( data, de->d_name, NULL, mask )) goto done;
+    }
+    status = STATUS_SUCCESS;
+
+done:
+    closedir( dir );
+    return status;
+}
+
+
+/***********************************************************************
+ *           read_directory_data
+ *
+ * Read the full contents of a directory, using one of the above helper functions.
+ */
+static NTSTATUS read_directory_data( struct dir_data *data, int fd, const UNICODE_STRING *mask )
+{
+    NTSTATUS status;
+
+#ifdef VFAT_IOCTL_READDIR_BOTH
+    if (!(status = read_directory_data_vfat( data, fd, mask ))) return status;
+#endif
+
+    if (!has_wildcard( mask ))
+    {
+        /* convert the mask to a Unix name and check for it */
+        char unix_name[MAX_DIR_ENTRY_LEN * 3 + 1];
+        int ret = ntdll_wcstoumbs( mask->Buffer, mask->Length / sizeof(WCHAR),
+                                   unix_name, sizeof(unix_name) - 1, TRUE );
+        if (ret > 0)
+        {
+            unix_name[ret] = 0;
+#ifdef HAVE_GETATTRLIST
+            if (!(status = read_directory_data_getattrlist( data, unix_name ))) return status;
+#endif
+            if (!(status = read_directory_data_stat( data, unix_name ))) return status;
+        }
+    }
+
+    return read_directory_data_readdir( data, mask );
+}
+
+
+/* compare file names for directory sorting */
+static int name_compare( const void *a, const void *b )
+{
+    const struct dir_data_names *file_a = (const struct dir_data_names *)a;
+    const struct dir_data_names *file_b = (const struct dir_data_names *)b;
+    int ret = wcsicmp( file_a->long_name, file_b->long_name );
+    if (!ret) ret = wcscmp( file_a->long_name, file_b->long_name );
+    return ret;
+}
+
+
+/***********************************************************************
+ *           init_cached_dir_data
+ *
+ * Initialize the cached directory contents.
+ */
+static NTSTATUS init_cached_dir_data( struct dir_data **data_ret, int fd, const UNICODE_STRING *mask )
+{
+    struct dir_data *data;
+    struct stat st;
+    NTSTATUS status;
+    unsigned int i;
+
+    if (!(data = calloc( 1, sizeof(*data) ))) return STATUS_NO_MEMORY;
+
+    if ((status = read_directory_data( data, fd, mask )))
+    {
+        free_dir_data( data );
+        return status;
+    }
+
+    if (mask)
+    {
+        data->mask.Length = data->mask.MaximumLength = mask->Length;
+        if (!(data->mask.Buffer = malloc( mask->Length )))
+        {
+            free_dir_data( data );
+            return STATUS_NO_MEMORY;
+        }
+        memcpy(data->mask.Buffer, mask->Buffer, mask->Length);
+    }
+
+    /* sort filenames, but not "." and ".." */
+    i = 0;
+    if (i < data->count && !strcmp( data->names[i].unix_name, "." )) i++;
+    if (i < data->count && !strcmp( data->names[i].unix_name, ".." )) i++;
+    if (i < data->count) qsort( data->names + i, data->count - i, sizeof(*data->names), name_compare );
+
+    if (data->count)
+    {
+        fstat( fd, &st );
+        data->id.dev = st.st_dev;
+        data->id.ino = st.st_ino;
+    }
+
+    TRACE( "mask %s found %u files\n", debugstr_us( mask ), data->count );
+    for (i = 0; i < data->count; i++)
+        TRACE( "%s %s\n", debugstr_w(data->names[i].long_name), debugstr_w(data->names[i].short_name) );
+
+    *data_ret = data;
+    return data->count ? STATUS_SUCCESS : STATUS_NO_SUCH_FILE;
+}
+
+
+/***********************************************************************
+ *           ustring_equal
+ *
+ * Simplified version of RtlEqualUnicodeString that performs only case-sensitive comparisons.
+ */
+static BOOLEAN ustring_equal( const UNICODE_STRING *a, const UNICODE_STRING *b )
+{
+    USHORT length_a = (a ? a->Length : 0);
+    USHORT length_b = (b ? b->Length : 0);
+
+    if (length_a != length_b) return FALSE;
+    if (length_a == 0) return TRUE;
+    return !memcmp(a->Buffer, b->Buffer, a->Length);
+}
+
+
+/***********************************************************************
+ *           get_cached_dir_data
+ *
+ * Retrieve the cached directory data, or initialize it if necessary.
+ */
+static unsigned int get_cached_dir_data( HANDLE handle, struct dir_data **data_ret, int fd,
+                                         const UNICODE_STRING *mask, BOOLEAN restart_scan )
+{
+    unsigned int i;
+    int entry = -1, free_entries[16];
+    unsigned int status;
+    BOOLEAN fresh_handle;
+
+    SERVER_START_REQ( get_directory_cache_entry )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        wine_server_set_reply( req, free_entries, sizeof(free_entries) );
+        if (!(status = wine_server_call( req ))) entry = reply->entry;
+
+        for (i = 0; i < wine_server_reply_size( reply ) / sizeof(*free_entries); i++)
+        {
+            int free_idx = free_entries[i];
+            if (free_idx < dir_data_cache_size)
+            {
+                free_dir_data( dir_data_cache[free_idx] );
+                dir_data_cache[free_idx] = NULL;
+            }
+        }
+    }
+    SERVER_END_REQ;
+
+    if (status)
+    {
+        if (status == STATUS_SHARING_VIOLATION) FIXME( "shared directory handle not supported yet\n" );
+        return status;
+    }
+
+    if (entry >= dir_data_cache_size)
+    {
+        unsigned int size = max( dir_data_cache_initial_size, max( dir_data_cache_size * 2, entry + 1 ) );
+        struct dir_data **new_cache = realloc( dir_data_cache, size * sizeof(*new_cache) );
+
+        if (!new_cache) return STATUS_NO_MEMORY;
+        memset( new_cache + dir_data_cache_size, 0, (size - dir_data_cache_size) * sizeof(*new_cache) );
+        dir_data_cache = new_cache;
+        dir_data_cache_size = size;
+    }
+
+    fresh_handle = !dir_data_cache[entry];
+
+    if (dir_data_cache[entry] && restart_scan && mask &&
+        !ustring_equal(&dir_data_cache[entry]->mask, mask))
+    {
+        TRACE( "invalidating existing cache entry for handle %p, old mask: \"%s\", new mask: \"%s\"\n",
+               handle, debugstr_us(&(dir_data_cache[entry]->mask)), debugstr_us(mask));
+        free_dir_data( dir_data_cache[entry] );
+        dir_data_cache[entry] = NULL;
+    }
+
+    if (!dir_data_cache[entry])
+    {
+        status = init_cached_dir_data( &dir_data_cache[entry], fd, mask );
+        if (status == STATUS_NO_SUCH_FILE && !fresh_handle) status = STATUS_NO_MORE_FILES;
+    }
+
+    *data_ret = dir_data_cache[entry];
+    if (restart_scan) (*data_ret)->pos = 0;
+    return status;
+}
+
+
+/******************************************************************************
+ *              NtQueryDirectoryFile   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtQueryDirectoryFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc_routine,
+                                      void *apc_context, IO_STATUS_BLOCK *io, void *buffer, ULONG length,
+                                      FILE_INFORMATION_CLASS info_class, BOOLEAN single_entry,
+                                      UNICODE_STRING *mask, BOOLEAN restart_scan )
+{
+    int cwd, fd, needs_close;
+    enum server_fd_type type;
+    struct dir_data *data;
+    unsigned int status;
+
+    TRACE("(%p %p %p %p %p %p 0x%08x 0x%08x 0x%08x %s 0x%08x\n",
+          handle, event, apc_routine, apc_context, io, buffer,
+          length, info_class, single_entry, debugstr_us(mask),
+          restart_scan);
+
+    if (event || apc_routine)
+    {
+        FIXME( "Unsupported yet option\n" );
+        return STATUS_NOT_IMPLEMENTED;
+    }
+    switch (info_class)
+    {
+    case FileDirectoryInformation:
+    case FileBothDirectoryInformation:
+    case FileFullDirectoryInformation:
+    case FileIdBothDirectoryInformation:
+    case FileIdFullDirectoryInformation:
+    case FileIdGlobalTxDirectoryInformation:
+    case FileNamesInformation:
+        if (length < dir_info_align( dir_info_size( info_class, 1 ))) return STATUS_INFO_LENGTH_MISMATCH;
+        break;
+    case FileObjectIdInformation:
+        if (length != sizeof(FILE_OBJECTID_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
+        return STATUS_INVALID_INFO_CLASS;
+    case FileQuotaInformation:
+        if (length != sizeof(FILE_QUOTA_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
+        return STATUS_INVALID_INFO_CLASS;
+    case FileReparsePointInformation:
+        if (length != sizeof(FILE_REPARSE_POINT_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
+        return STATUS_INVALID_INFO_CLASS;
+    default:
+        return STATUS_INVALID_INFO_CLASS;
+    }
+    if (!buffer) return STATUS_ACCESS_VIOLATION;
+
+    if ((status = server_get_unix_fd( handle, FILE_LIST_DIRECTORY, &fd, &needs_close, &type, NULL )))
+        return status;
+
+    if (type != FD_TYPE_DIR)
+    {
+        if (needs_close) close( fd );
+        return STATUS_INVALID_PARAMETER;
+    }
+
+    io->Information = 0;
+    if (mask && mask->Length == 0) mask = NULL;
+
+    mutex_lock( &dir_mutex );
+
+    cwd = open( ".", O_RDONLY );
+    if (fchdir( fd ) != -1)
+    {
+        if (!(status = get_cached_dir_data( handle, &data, fd, mask, restart_scan )))
+        {
+            union file_directory_info *last_info = NULL;
+
+            while (!status && data->pos < data->count)
+            {
+                status = get_dir_data_entry( data, buffer, io, length, info_class, &last_info );
+                if (!status || status == STATUS_BUFFER_OVERFLOW) data->pos++;
+                if (single_entry && last_info) break;
+            }
+
+            if (!last_info) status = STATUS_NO_MORE_FILES;
+            else if (status == STATUS_MORE_ENTRIES) status = STATUS_SUCCESS;
+        }
+        if (cwd == -1 || fchdir( cwd ) == -1) chdir( "/" );
+    }
+    else status = errno_to_status( errno );
+
+    if (status != STATUS_NO_SUCH_FILE) io->Status = status;
+
+    mutex_unlock( &dir_mutex );
+
+    if (needs_close) close( fd );
+    if (cwd != -1) close( cwd );
+    TRACE( "=> %x (%ld)\n", status, io->Information );
+    return status;
+}
+
+
+/***********************************************************************
+ *           find_file_in_dir
+ *
+ * Find a file in a directory the hard way, by doing a case-insensitive search.
+ * The file found is appended to unix_name at pos.
+ * There must be at least MAX_DIR_ENTRY_LEN+2 chars available at pos.
+ */
+static NTSTATUS find_file_in_dir( int root_fd, char *unix_name, int pos, const WCHAR *name, int length,
+                                  BOOLEAN check_case )
+{
+    WCHAR buffer[MAX_DIR_ENTRY_LEN];
+    BOOLEAN is_name_8_dot_3;
+    DIR *dir;
+    struct dirent *de;
+    struct stat st;
+    int fd, ret;
+
+    /* try a shortcut for this directory */
+
+    unix_name[pos++] = '/';
+    ret = ntdll_wcstoumbs( name, length, unix_name + pos, MAX_DIR_ENTRY_LEN + 1, TRUE );
+    if (ret >= 0 && ret <= MAX_DIR_ENTRY_LEN)
+    {
+        unix_name[pos + ret] = 0;
+        if (!fstatat( root_fd, unix_name, &st, 0 )) return STATUS_SUCCESS;
+    }
+    if (check_case) goto not_found;  /* we want an exact match */
+
+    if (pos > 1) unix_name[pos - 1] = 0;
+    else unix_name[1] = 0;  /* keep the initial slash */
+
+    /* check if it fits in 8.3 so that we don't look for short names if we won't need them */
+
+    is_name_8_dot_3 = is_legal_8dot3_name( name, length );
+#ifndef VFAT_IOCTL_READDIR_BOTH
+    is_name_8_dot_3 = is_name_8_dot_3 && length >= 8 && name[4] == '~';
+#endif
+
+    if (!is_name_8_dot_3 && !get_dir_case_sensitivity( root_fd, unix_name )) goto not_found;
+
+    /* now look for it through the directory */
+
+#ifdef VFAT_IOCTL_READDIR_BOTH
+    if (is_name_8_dot_3)
+    {
+        int fd = openat( root_fd, unix_name, O_RDONLY | O_DIRECTORY );
+        if (fd != -1)
+        {
+            KERNEL_DIRENT kde[2];
+
+            if (ioctl( fd, VFAT_IOCTL_READDIR_BOTH, (long)kde ) != -1)
+            {
+                unix_name[pos - 1] = '/';
+                while (kde[0].d_reclen)
+                {
+                    if (kde[1].d_name[0])
+                    {
+                        ret = ntdll_umbstowcs( kde[1].d_name, strlen(kde[1].d_name),
+                                               buffer, MAX_DIR_ENTRY_LEN );
+                        if (ret == length && !wcsnicmp( buffer, name, ret ))
+                        {
+                            strcpy( unix_name + pos, kde[1].d_name );
+                            close( fd );
+                            return STATUS_SUCCESS;
+                        }
+                    }
+                    ret = ntdll_umbstowcs( kde[0].d_name, strlen(kde[0].d_name),
+                                           buffer, MAX_DIR_ENTRY_LEN );
+                    if (ret == length && !wcsnicmp( buffer, name, ret ))
+                    {
+                        strcpy( unix_name + pos,
+                                kde[1].d_name[0] ? kde[1].d_name : kde[0].d_name );
+                        close( fd );
+                        return STATUS_SUCCESS;
+                    }
+                    if (ioctl( fd, VFAT_IOCTL_READDIR_BOTH, (long)kde ) == -1)
+                    {
+                        close( fd );
+                        goto not_found;
+                    }
+                }
+                /* if that did not work, restore previous state of unix_name */
+                unix_name[pos - 1] = 0;
+            }
+            close( fd );
+        }
+        /* fall through to normal handling */
+    }
+#endif /* VFAT_IOCTL_READDIR_BOTH */
+
+    if ((fd = openat( root_fd, unix_name, O_RDONLY )) == -1) return errno_to_status( errno );
+    if (!(dir = fdopendir( fd )))
+    {
+        close( fd );
+        return errno_to_status( errno );
+    }
+
+    unix_name[pos - 1] = '/';
+    while ((de = readdir( dir )))
+    {
+        ret = ntdll_umbstowcs( de->d_name, strlen(de->d_name), buffer, MAX_DIR_ENTRY_LEN );
+        if (ret == length && !wcsnicmp( buffer, name, ret ))
+        {
+            strcpy( unix_name + pos, de->d_name );
+            closedir( dir );
+            return STATUS_SUCCESS;
+        }
+
+        if (!is_name_8_dot_3) continue;
+
+        if (!is_legal_8dot3_name( buffer, ret ))
+        {
+            WCHAR short_nameW[12];
+            ret = hash_short_file_name( buffer, ret, short_nameW );
+            if (ret == length && !wcsnicmp( short_nameW, name, length ))
+            {
+                strcpy( unix_name + pos, de->d_name );
+                closedir( dir );
+                return STATUS_SUCCESS;
+            }
+        }
+    }
+    closedir( dir );
+
+not_found:
+    unix_name[pos - 1] = 0;
+    return STATUS_OBJECT_NAME_NOT_FOUND;
+}
+
+
+#ifndef _WIN64
+
+static const WCHAR catrootW[] = {'s','y','s','t','e','m','3','2','\\','c','a','t','r','o','o','t',0};
+static const WCHAR catroot2W[] = {'s','y','s','t','e','m','3','2','\\','c','a','t','r','o','o','t','2',0};
+static const WCHAR driversstoreW[] = {'s','y','s','t','e','m','3','2','\\','d','r','i','v','e','r','s','s','t','o','r','e',0};
+static const WCHAR driversetcW[] = {'s','y','s','t','e','m','3','2','\\','d','r','i','v','e','r','s','\\','e','t','c',0};
+static const WCHAR logfilesW[] = {'s','y','s','t','e','m','3','2','\\','l','o','g','f','i','l','e','s',0};
+static const WCHAR spoolW[] = {'s','y','s','t','e','m','3','2','\\','s','p','o','o','l',0};
+static const WCHAR system32W[] = {'s','y','s','t','e','m','3','2',0};
+static const WCHAR syswow64W[] = {'s','y','s','w','o','w','6','4',0};
+static const WCHAR sysnativeW[] = {'s','y','s','n','a','t','i','v','e',0};
+static const WCHAR regeditW[] = {'r','e','g','e','d','i','t','.','e','x','e',0};
+static const WCHAR syswow64_regeditW[] = {'s','y','s','w','o','w','6','4','\\','r','e','g','e','d','i','t','.','e','x','e',0};
+static const WCHAR windirW[] = {'\\','?','?','\\','C',':','\\','w','i','n','d','o','w','s','\\',0};
+static const WCHAR syswow64dirW[] = {'\\','?','?','\\','C',':','\\','w','i','n','d','o','w','s','\\','s','y','s','w','o','w','6','4','\\'};
+
+static const WCHAR * const no_redirect[] =
+{
+    catrootW,
+    catroot2W,
+    driversstoreW,
+    driversetcW,
+    logfilesW,
+    spoolW
+};
+
+static struct file_identity windir, sysdir;
+
+static inline ULONG starts_with_path( const WCHAR *name, ULONG name_len, const WCHAR *prefix )
+{
+    ULONG len = wcslen( prefix );
+
+    if (name_len < len) return 0;
+    if (wcsnicmp( name, prefix, len )) return 0;
+    if (name_len > len && name[len] != '\\') return 0;
+    return len;
+}
+
+static BOOL replace_path( OBJECT_ATTRIBUTES *attr, UNICODE_STRING *str, ULONG prefix_len,
+                          const WCHAR *match, const WCHAR *replace )
+{
+    const WCHAR *name = attr->ObjectName->Buffer;
+    ULONG match_len, replace_len, len = attr->ObjectName->Length / sizeof(WCHAR);
+    WCHAR *p;
+
+    if (!starts_with_path( name + prefix_len, len - prefix_len, match )) return FALSE;
+
+    match_len = wcslen( match );
+    replace_len = wcslen( replace );
+    str->Length = (len + replace_len - match_len) * sizeof(WCHAR);
+    str->MaximumLength = str->Length + sizeof(WCHAR);
+    if (!(p = str->Buffer = malloc( str->MaximumLength ))) return FALSE;
+
+    memcpy( p, name, prefix_len * sizeof(WCHAR) );
+    p += prefix_len;
+    memcpy( p, replace, replace_len * sizeof(WCHAR) );
+    p += replace_len;
+    name += prefix_len + match_len;
+    len -= prefix_len + match_len;
+    memcpy( p, name, len * sizeof(WCHAR) );
+    p[len] = 0;
+    attr->ObjectName = str;
+    return TRUE;
+}
+
+/***********************************************************************
+ *           init_redirects
+ */
+static void init_redirects(void)
+{
+    static const char system_dir[] = "/dosdevices/c:/windows/system32";
+    char *dir;
+    struct stat st;
+
+    if (asprintf( &dir, "%s%s", config_dir, system_dir ) == -1) return;
+    if (!stat( dir, &st ))
+    {
+        sysdir.dev = st.st_dev;
+        sysdir.ino = st.st_ino;
+    }
+    *strrchr( dir, '/' ) = 0;
+    if (!stat( dir, &st ))
+    {
+        windir.dev = st.st_dev;
+        windir.ino = st.st_ino;
+    }
+    else ERR( "%s: %s\n", dir, strerror(errno) );
+    free( dir );
+
+}
+
+/***********************************************************************
+ *           get_redirect
+ */
+static void get_redirect( OBJECT_ATTRIBUTES *attr, UNICODE_STRING *redir )
+{
+    const WCHAR *name = attr->ObjectName->Buffer;
+    unsigned int i, prefix_len = 0, len = attr->ObjectName->Length / sizeof(WCHAR);
+
+    if (!NtCurrentTeb64()) return;
+
+    if (!attr->RootDirectory)
+    {
+        prefix_len = wcslen( windirW );
+        if (len < prefix_len || wcsnicmp( name, windirW, prefix_len )) return;
+    }
+    else
+    {
+        int fd, needs_close;
+        struct stat st;
+
+        if (!len) return;
+        if (server_get_unix_fd( attr->RootDirectory, 0, &fd, &needs_close, NULL, NULL )) return;
+        fstat( fd, &st );
+        if (needs_close) close( fd );
+        if (!is_same_file( &windir, &st ))
+        {
+            if (!is_same_file( &sysdir, &st )) return;
+            if (NtCurrentTeb64()->TlsSlots[WOW64_TLS_FILESYSREDIR]) return;
+            if (name[0] == '\\') return;
+
+            /* only check for paths that should NOT be redirected */
+            for (i = 0; i < ARRAY_SIZE( no_redirect ); i++)
+                if (starts_with_path( name, len, no_redirect[i] + 9 /* "system32\\" */)) return;
+
+            /* redirect everything else */
+            redir->Length = sizeof(syswow64dirW) + len * sizeof(WCHAR);
+            redir->MaximumLength = redir->Length + sizeof(WCHAR);
+            if (!(redir->Buffer = malloc( redir->MaximumLength ))) return;
+            memcpy( redir->Buffer, syswow64dirW, sizeof(syswow64dirW) );
+            memcpy( redir->Buffer + ARRAY_SIZE(syswow64dirW), name, len * sizeof(WCHAR) );
+            redir->Buffer[redir->Length / sizeof(WCHAR)] = 0;
+            attr->RootDirectory = 0;
+            attr->ObjectName = redir;
+            return;
+        }
+    }
+
+    /* sysnative is redirected even when redirection is disabled */
+
+    if (replace_path( attr, redir, prefix_len, sysnativeW, system32W )) return;
+
+    if (NtCurrentTeb64()->TlsSlots[WOW64_TLS_FILESYSREDIR]) return;
+
+    for (i = 0; i < ARRAY_SIZE( no_redirect ); i++)
+        if (starts_with_path( name + prefix_len, len - prefix_len, no_redirect[i] )) return;
+
+    if (replace_path( attr, redir, prefix_len, system32W, syswow64W )) return;
+    if (replace_path( attr, redir, prefix_len, regeditW, syswow64_regeditW )) return;
+}
+
+#endif
+
+
+#define IS_OPTION_TRUE(ch) ((ch) == 'y' || (ch) == 'Y' || (ch) == 't' || (ch) == 'T' || (ch) == '1')
+
+/***********************************************************************
+ *           init_files
+ */
+void init_files(void)
+{
+    HANDLE key;
+
+#ifndef _WIN64
+    if (is_old_wow64()) init_redirects();
+#endif
+    /* a couple of directories that we don't want to return in directory searches */
+    ignore_file( config_dir );
+    ignore_file( "/dev" );
+    ignore_file( "/proc" );
+#ifdef linux
+    ignore_file( "/sys" );
+#endif
+    /* retrieve initial umask */
+    start_umask = umask( 0777 );
+    umask( start_umask );
+
+    if (!open_hkcu_key( "Software\\Wine", &key ))
+    {
+        static WCHAR showdotfilesW[] = {'S','h','o','w','D','o','t','F','i','l','e','s',0};
+        char tmp[80];
+        DWORD dummy;
+        UNICODE_STRING nameW;
+
+        init_unicode_string( &nameW, showdotfilesW );
+        if (!NtQueryValueKey( key, &nameW, KeyValuePartialInformation, tmp, sizeof(tmp), &dummy ))
+        {
+            WCHAR *str = (WCHAR *)((KEY_VALUE_PARTIAL_INFORMATION *)tmp)->Data;
+            show_dot_files = IS_OPTION_TRUE( str[0] );
+        }
+        NtClose( key );
+    }
+}
+
+
+/******************************************************************************
+ *           get_dos_device
+ *
+ * Get the Unix path of a DOS device.
+ */
+static NTSTATUS get_dos_device( char **unix_name, int start_pos )
+{
+    struct stat st;
+    char *new_name, *dev = *unix_name + start_pos;
+
+    /* special case for drive devices */
+    if (dev[0] && dev[1] == ':' && !dev[2]) strcpy( dev + 1, "::" );
+
+    if (strchr( dev, '/' )) goto failed;
+
+    for (;;)
+    {
+        if (!stat( *unix_name, &st ))
+        {
+            TRACE( "-> %s\n", debugstr_a(*unix_name));
+            return STATUS_SUCCESS;
+        }
+        if (!dev) break;
+
+        /* now try some defaults for it */
+        if (!strcmp( dev, "aux" ))
+        {
+            strcpy( dev, "com1" );
+            continue;
+        }
+        if (!strcmp( dev, "prn" ))
+        {
+            strcpy( dev, "lpt1" );
+            continue;
+        }
+
+        new_name = NULL;
+        if (dev[1] == ':' && dev[2] == ':')  /* drive device */
+        {
+            dev[2] = 0;  /* remove last ':' to get the drive mount point symlink */
+            new_name = get_default_drive_device( *unix_name );
+        }
+        free( *unix_name );
+        *unix_name = new_name;
+        if (!new_name) return STATUS_BAD_DEVICE_TYPE;
+        dev = NULL; /* last try */
+    }
+failed:
+    free( *unix_name );
+    *unix_name = NULL;
+    return STATUS_BAD_DEVICE_TYPE;
+}
+
+
+/* return the length of the DOS namespace prefix if any */
+static inline int get_dos_prefix_len( const UNICODE_STRING *name )
+{
+    static const WCHAR dosdev_prefixW[] = {'\\','D','o','s','D','e','v','i','c','e','s','\\'};
+
+    if (name->Length >= sizeof(nt_prefixW) &&
+        !memcmp( name->Buffer, nt_prefixW, sizeof(nt_prefixW) ))
+        return ARRAY_SIZE( nt_prefixW );
+
+    if (name->Length >= sizeof(dosdev_prefixW) &&
+        !wcsnicmp( name->Buffer, dosdev_prefixW, ARRAY_SIZE( dosdev_prefixW )))
+        return ARRAY_SIZE( dosdev_prefixW );
+
+    return 0;
+}
+
+
+/***********************************************************************
+ *           remove_last_component
+ *
+ * Remove the last component of the path. Helper for find_drive_rootA.
+ */
+static unsigned int remove_last_component( const char *path, unsigned int len )
+{
+    int level = 0;
+
+    while (level < 1)
+    {
+        /* find start of the last path component */
+        unsigned int prev = len;
+        if (prev <= 1) break;  /* reached root */
+        while (prev > 1 && path[prev - 1] != '/') prev--;
+        /* does removing it take us up a level? */
+        if (len - prev != 1 || path[prev] != '.')  /* not '.' */
+        {
+            if (len - prev == 2 && path[prev] == '.' && path[prev+1] == '.')  /* is it '..'? */
+                level--;
+            else
+                level++;
+        }
+        /* strip off trailing slashes */
+        while (prev > 1 && path[prev - 1] == '/') prev--;
+        len = prev;
+    }
+    return len;
+}
+
+
+/******************************************************************************
+ *           find_file_id
+ *
+ * Recursively search directories from the dir queue for a given inode.
+ */
+static NTSTATUS find_file_id( int root_fd, char **unix_name, ULONG *len, ULONGLONG file_id, dev_t dev, struct list *dir_queue )
+{
+    unsigned int pos;
+    int dir_fd;
+    DIR *dir;
+    struct dirent *de;
+    NTSTATUS status;
+    struct stat st;
+    char *name = *unix_name;
+
+    while (!(status = next_dir_in_queue( dir_queue, name )))
+    {
+        if ((dir_fd = openat( root_fd, name, O_RDONLY )) == -1) continue;
+        if (!(dir = fdopendir( dir_fd )))
+        {
+            close( dir_fd );
+            continue;
+        }
+        TRACE( "searching %s for %s\n", debugstr_a(name), wine_dbgstr_longlong(file_id) );
+        pos = strlen( name );
+        if (pos + MAX_DIR_ENTRY_LEN >= *len / sizeof(WCHAR))
+        {
+            if (!(name = realloc( name, *len * 2 )))
+            {
+                closedir( dir );
+                return STATUS_NO_MEMORY;
+            }
+            *len *= 2;
+            *unix_name = name;
+        }
+        name[pos++] = '/';
+        while ((de = readdir( dir )))
+        {
+            if (!strcmp( de->d_name, "." ) || !strcmp( de->d_name, ".." )) continue;
+            strcpy( name + pos, de->d_name );
+            if (fstatat( root_fd, name, &st, AT_SYMLINK_NOFOLLOW ) == -1) continue;
+            if (st.st_dev != dev) continue;
+            if (st.st_ino == file_id)
+            {
+                closedir( dir );
+                return STATUS_SUCCESS;
+            }
+            if (!S_ISDIR( st.st_mode )) continue;
+            if ((status = add_dir_to_queue( dir_queue, name )) != STATUS_SUCCESS)
+            {
+                closedir( dir );
+                return status;
+            }
+        }
+        closedir( dir );
+    }
+    return status;
+}
+
+
+/******************************************************************************
+ *           file_id_to_unix_file_name
+ *
+ * Lookup a file from its file id instead of its name.
+ */
+static NTSTATUS file_id_to_unix_file_name( const OBJECT_ATTRIBUTES *attr, char **unix_name_ret,
+                                           UNICODE_STRING *nt_name )
+{
+    enum server_fd_type type;
+    int root_fd, needs_close;
+    char *unix_name;
+    ULONG len;
+    NTSTATUS status;
+    ULONGLONG file_id;
+    struct stat st, root_st;
+    struct list dir_queue = LIST_INIT( dir_queue );
+
+    nt_name->Buffer = NULL;
+    if (attr->ObjectName->Length != sizeof(ULONGLONG)) return STATUS_OBJECT_PATH_SYNTAX_BAD;
+    if (!attr->RootDirectory) return STATUS_INVALID_PARAMETER;
+    memcpy( &file_id, attr->ObjectName->Buffer, sizeof(file_id) );
+
+    len = 2 * MAX_DIR_ENTRY_LEN + 4;
+    if (!(unix_name = malloc( len ))) return STATUS_NO_MEMORY;
+    strcpy( unix_name, "." );
+
+    if ((status = server_get_unix_fd( attr->RootDirectory, 0, &root_fd, &needs_close, &type, NULL )))
+        goto done;
+
+    if (type != FD_TYPE_DIR)
+    {
+        status = STATUS_OBJECT_TYPE_MISMATCH;
+        goto done;
+    }
+
+    fstat( root_fd, &root_st );
+    if (root_st.st_ino == file_id)  /* shortcut for "." */
+    {
+        status = STATUS_SUCCESS;
+        goto done;
+    }
+
+    /* shortcut for ".." */
+    if (!fstatat( root_fd, "..", &st, 0 ) && st.st_dev == root_st.st_dev && st.st_ino == file_id)
+    {
+        strcpy( unix_name, ".." );
+        status = STATUS_SUCCESS;
+    }
+    else
+    {
+        status = add_dir_to_queue( &dir_queue, "." );
+        if (!status)
+            status = find_file_id( root_fd, &unix_name, &len, file_id, root_st.st_dev, &dir_queue );
+        if (!status)  /* get rid of "./" prefix */
+            memmove( unix_name, unix_name + 2, strlen(unix_name) - 1 );
+        flush_dir_queue( &dir_queue );
+    }
+
+done:
+    if (status == STATUS_SUCCESS)
+    {
+        TRACE( "%s -> %s\n", wine_dbgstr_longlong(file_id), debugstr_a(unix_name) );
+        *unix_name_ret = unix_name;
+
+        nt_name->MaximumLength = (strlen(unix_name) + 1) * sizeof(WCHAR);
+        if ((nt_name->Buffer = malloc( nt_name->MaximumLength )))
+        {
+            DWORD i, len = ntdll_umbstowcs( unix_name, strlen(unix_name), nt_name->Buffer, strlen(unix_name) );
+            nt_name->Buffer[len] = 0;
+            nt_name->Length = len * sizeof(WCHAR);
+            for (i = 0; i < len; i++) if (nt_name->Buffer[i] == '/') nt_name->Buffer[i] = '\\';
+        }
+    }
+    else
+    {
+        TRACE( "%s not found in dir %p\n", wine_dbgstr_longlong(file_id), attr->RootDirectory );
+        free( unix_name );
+    }
+    if (needs_close) close( root_fd );
+    return status;
+}
+
+
+/******************************************************************************
+ *           lookup_unix_name
+ *
+ * Helper for nt_to_unix_file_name
+ */
+static NTSTATUS lookup_unix_name( int root_fd, const WCHAR *name, int name_len, char **buffer, int unix_len,
+                                  int pos, UINT disposition, BOOL is_unix )
+{
+    static const WCHAR invalid_charsW[] = { INVALID_NT_CHARS, '/', 0 };
+    NTSTATUS status;
+    int ret;
+    struct stat st;
+    char *unix_name = *buffer;
+    const WCHAR *ptr, *end;
+
+    /* check syntax of individual components */
+
+    for (ptr = name, end = name + name_len; ptr < end; ptr++)
+    {
+        if (*ptr == '\\') return STATUS_OBJECT_NAME_INVALID;  /* duplicate backslash */
+        if (*ptr == '.')
+        {
+            if (ptr + 1 == end) return STATUS_OBJECT_NAME_INVALID;  /* "." element */
+            if (ptr[1] == '\\') return STATUS_OBJECT_NAME_INVALID;  /* "." element */
+            if (ptr[1] == '.')
+            {
+                if (ptr + 2 == end) return STATUS_OBJECT_NAME_INVALID;  /* ".." element */
+                if (ptr[2] == '\\') return STATUS_OBJECT_NAME_INVALID;  /* ".." element */
+            }
+        }
+        /* check for invalid characters (all chars except 0 are valid for unix) */
+        for ( ; ptr < end && *ptr != '\\'; ptr++)
+        {
+            if (!*ptr) return STATUS_OBJECT_NAME_INVALID;
+            if (is_unix) continue;
+            if (*ptr < 32 || wcschr( invalid_charsW, *ptr )) return STATUS_OBJECT_NAME_INVALID;
+        }
+    }
+
+    /* try a shortcut first */
+
+    unix_name[pos] = '/';
+    ret = ntdll_wcstoumbs( name, name_len, unix_name + pos + 1, unix_len - pos - 1, TRUE );
+    if (ret >= 0 && ret < unix_len - pos - 1)
+    {
+        char *p;
+        unix_name[pos + 1 + ret] = 0;
+        for (p = unix_name + pos ; *p; p++) if (*p == '\\') *p = '/';
+        if (!fstatat( root_fd, unix_name, &st, 0 ))
+        {
+            if (disposition == FILE_CREATE) return STATUS_OBJECT_NAME_COLLISION;
+            return STATUS_SUCCESS;
+        }
+    }
+
+    if (!name_len)  /* empty name -> drive root doesn't exist */
+        return STATUS_OBJECT_PATH_NOT_FOUND;
+    if (is_unix && (disposition == FILE_OPEN || disposition == FILE_OVERWRITE))
+        return STATUS_OBJECT_NAME_NOT_FOUND;
+
+    /* now do it component by component */
+
+    while (name_len)
+    {
+        const WCHAR *end, *next;
+
+        end = name;
+        while (end < name + name_len && *end != '\\') end++;
+        next = end;
+        if (next < name + name_len) next++;
+        name_len -= next - name;
+
+        /* grow the buffer if needed */
+
+        if (unix_len - pos < MAX_DIR_ENTRY_LEN + 3)
+        {
+            char *new_name;
+            unix_len += 2 * MAX_DIR_ENTRY_LEN;
+            if (!(new_name = realloc( unix_name, unix_len ))) return STATUS_NO_MEMORY;
+            unix_name = *buffer = new_name;
+        }
+
+        status = find_file_in_dir( root_fd, unix_name, pos, name, end - name, is_unix );
+
+        /* if this is the last element, not finding it is not necessarily fatal */
+        if (!name_len)
+        {
+            if (status == STATUS_OBJECT_NAME_NOT_FOUND)
+            {
+                if (disposition != FILE_OPEN && disposition != FILE_OVERWRITE)
+                {
+                    ret = ntdll_wcstoumbs( name, end - name, unix_name + pos + 1, MAX_DIR_ENTRY_LEN + 1, TRUE );
+                    if (ret > 0 && ret <= MAX_DIR_ENTRY_LEN)
+                    {
+                        unix_name[pos] = '/';
+                        pos += ret + 1;
+                        if (end < next) unix_name[pos++] = '/';
+                        unix_name[pos] = 0;
+                        status = STATUS_NO_SUCH_FILE;
+                        break;
+                    }
+                }
+            }
+            else if (status == STATUS_SUCCESS && disposition == FILE_CREATE)
+            {
+                status = STATUS_OBJECT_NAME_COLLISION;
+            }
+            if (end < next) strcat( unix_name, "/" );
+        }
+        else if (status == STATUS_OBJECT_NAME_NOT_FOUND) status = STATUS_OBJECT_PATH_NOT_FOUND;
+
+        if (status != STATUS_SUCCESS) break;
+
+        pos += strlen( unix_name + pos );
+        name = next;
+    }
+
+    return status;
+}
+
+
+/******************************************************************************
+ *           nt_to_unix_file_name_no_root
+ */
+static NTSTATUS nt_to_unix_file_name_no_root( const UNICODE_STRING *nameW, char **unix_name_ret,
+                                              UINT disposition )
+{
+    static const WCHAR unixW[] = {'u','n','i','x'};
+    static const WCHAR invalid_charsW[] = { INVALID_NT_CHARS, 0 };
+
+    NTSTATUS status = STATUS_SUCCESS;
+    const WCHAR *name;
+    struct stat st;
+    char *unix_name;
+    int pos, ret, name_len, unix_len, prefix_len;
+    WCHAR prefix[MAX_DIR_ENTRY_LEN + 1];
+    BOOLEAN is_unix = FALSE;
+
+    name     = nameW->Buffer;
+    name_len = nameW->Length / sizeof(WCHAR);
+
+    if (!name_len || name[0] != '\\') return STATUS_OBJECT_PATH_SYNTAX_BAD;
+
+    if (!(pos = get_dos_prefix_len( nameW )))
+        return STATUS_BAD_DEVICE_TYPE;  /* no DOS prefix, assume NT native name */
+
+    name += pos;
+    name_len -= pos;
+
+    if (!name_len) return STATUS_OBJECT_NAME_INVALID;
+
+    /* check for sub-directory */
+    for (pos = 0; pos < name_len && pos <= MAX_DIR_ENTRY_LEN; pos++)
+    {
+        if (name[pos] == '\\') break;
+        if (name[pos] < 32 || wcschr( invalid_charsW, name[pos] ))
+            return STATUS_OBJECT_NAME_INVALID;
+        prefix[pos] = (name[pos] >= 'A' && name[pos] <= 'Z') ? name[pos] + 'a' - 'A' : name[pos];
+    }
+    if (pos > MAX_DIR_ENTRY_LEN) return STATUS_OBJECT_NAME_INVALID;
+
+    if (pos >= 4 && !memcmp( prefix, unixW, sizeof(unixW) ))
+    {
+        /* allow slash for unix namespace */
+        if (pos > 4 && prefix[4] == '/') pos = 4;
+        is_unix = pos == 4;
+    }
+    prefix_len = pos;
+    prefix[prefix_len] = 0;
+
+    unix_len = name_len * 3 + MAX_DIR_ENTRY_LEN + 3;
+    unix_len += strlen(config_dir) + sizeof("/dosdevices/");
+    if (!(unix_name = malloc( unix_len ))) return STATUS_NO_MEMORY;
+    strcpy( unix_name, config_dir );
+    strcat( unix_name, "/dosdevices/" );
+    pos = strlen(unix_name);
+
+    ret = ntdll_wcstoumbs( prefix, prefix_len, unix_name + pos, unix_len - pos - 1, TRUE );
+    if (ret <= 0)
+    {
+        free( unix_name );
+        return STATUS_OBJECT_NAME_INVALID;
+    }
+
+    if (prefix_len == name_len)  /* no subdir, plain DOS device */
+    {
+        unix_name[pos + ret] = 0;
+        *unix_name_ret = unix_name;
+        return get_dos_device( unix_name_ret, pos );
+    }
+    pos += ret;
+
+    /* check if prefix exists (except for DOS drives to avoid extra stat calls) */
+
+    if (wcschr( prefix, '/' ))
+    {
+        free( unix_name );
+        return STATUS_OBJECT_PATH_NOT_FOUND;
+    }
+
+    if (prefix_len != 2 || prefix[1] != ':')
+    {
+        unix_name[pos] = 0;
+        if (lstat( unix_name, &st ) == -1 && errno == ENOENT)
+        {
+            if (!is_unix)
+            {
+                free( unix_name );
+                return STATUS_BAD_DEVICE_TYPE;
+            }
+            pos = 0;  /* fall back to unix root */
+        }
+    }
+
+    prefix_len++;  /* skip initial backslash */
+    if (name_len > prefix_len && name[prefix_len] == '\\') prefix_len++;  /* allow a second backslash */
+    name += prefix_len;
+    name_len -= prefix_len;
+
+    status = lookup_unix_name( AT_FDCWD, name, name_len, &unix_name, unix_len, pos, disposition, is_unix );
+    if (status == STATUS_SUCCESS || status == STATUS_NO_SUCH_FILE)
+    {
+        TRACE( "%s -> %s\n", debugstr_us(nameW), debugstr_a(unix_name) );
+        *unix_name_ret = unix_name;
+    }
+    else
+    {
+        TRACE( "%s not found in %s\n", debugstr_w(name), debugstr_an(unix_name, pos) );
+        free( unix_name );
+    }
+    return status;
+}
+
+
+/******************************************************************************
+ *           nt_to_unix_file_name
+ *
+ * Convert a file name from NT namespace to Unix namespace.
+ *
+ * If disposition is not FILE_OPEN or FILE_OVERWRITE, the last path
+ * element doesn't have to exist; in that case STATUS_NO_SUCH_FILE is
+ * returned, but the unix name is still filled in properly.
+ */
+static NTSTATUS nt_to_unix_file_name( const OBJECT_ATTRIBUTES *attr, char **name_ret, UINT disposition )
+{
+    enum server_fd_type type;
+    int root_fd, needs_close;
+    const WCHAR *name;
+    char *unix_name;
+    int name_len, unix_len;
+    NTSTATUS status;
+
+    if (!attr->RootDirectory)  /* without root dir fall back to normal lookup */
+        return nt_to_unix_file_name_no_root( attr->ObjectName, name_ret, disposition );
+
+    name     = attr->ObjectName->Buffer;
+    name_len = attr->ObjectName->Length / sizeof(WCHAR);
+
+    if (name_len && name[0] == '\\') return STATUS_INVALID_PARAMETER;
+
+    unix_len = name_len * 3 + MAX_DIR_ENTRY_LEN + 3;
+    if (!(unix_name = malloc( unix_len ))) return STATUS_NO_MEMORY;
+    unix_name[0] = '.';
+
+    if (!(status = server_get_unix_fd( attr->RootDirectory, 0, &root_fd, &needs_close, &type, NULL )))
+    {
+        if (type != FD_TYPE_DIR)
+        {
+            if (needs_close) close( root_fd );
+            status = STATUS_BAD_DEVICE_TYPE;
+        }
+        else
+        {
+            status = lookup_unix_name( root_fd, name, name_len, &unix_name, unix_len, 1, disposition, FALSE );
+            if (needs_close) close( root_fd );
+        }
+    }
+    else if (status == STATUS_OBJECT_TYPE_MISMATCH) status = STATUS_BAD_DEVICE_TYPE;
+
+    if (status == STATUS_SUCCESS || status == STATUS_NO_SUCH_FILE)
+    {
+        TRACE( "%s -> %s\n", debugstr_us(attr->ObjectName), debugstr_a(unix_name) );
+        *name_ret = unix_name;
+    }
+    else
+    {
+        TRACE( "%s not found in %s\n", debugstr_w(name), unix_name );
+        free( unix_name );
+    }
+    return status;
+}
+
+
+/******************************************************************
+ *		collapse_path
+ *
+ * Get rid of . and .. components in the path.
+ */
+static WCHAR *collapse_path( WCHAR *path )
+{
+    WCHAR *p, *start, *next;
+
+    /* convert every / into a \ */
+    for (p = path; *p; p++) if (*p == '/') *p = '\\';
+
+    p = path + 4;
+    while (*p && *p != '\\') p++;
+    start = p + 1;
+
+    /* collapse duplicate backslashes */
+    next = start;
+    for (p = next; *p; p++) if (*p != '\\' || next[-1] != '\\') *next++ = *p;
+    *next = 0;
+
+    p = start;
+    while (*p)
+    {
+        if (*p == '.')
+        {
+            switch(p[1])
+            {
+            case '\\': /* .\ component */
+                next = p + 2;
+                memmove( p, next, (wcslen(next) + 1) * sizeof(WCHAR) );
+                continue;
+            case 0:  /* final . */
+                if (p > start) p--;
+                *p = 0;
+                continue;
+            case '.':
+                if (p[2] == '\\')  /* ..\ component */
+                {
+                    next = p + 3;
+                    if (p > start)
+                    {
+                        p--;
+                        while (p > start && p[-1] != '\\') p--;
+                    }
+                    memmove( p, next, (wcslen(next) + 1) * sizeof(WCHAR) );
+                    continue;
+                }
+                else if (!p[2])  /* final .. */
+                {
+                    if (p > start)
+                    {
+                        p--;
+                        while (p > start && p[-1] != '\\') p--;
+                        if (p > start) p--;
+                    }
+                    *p = 0;
+                    continue;
+                }
+                break;
+            }
+        }
+        /* skip to the next component */
+        while (*p && *p != '\\') p++;
+        if (*p == '\\')
+        {
+            /* remove last dot in previous dir name */
+            if (p > start && p[-1] == '.') memmove( p-1, p, (wcslen(p) + 1) * sizeof(WCHAR) );
+            else p++;
+        }
+    }
+
+    /* remove trailing spaces and dots (yes, Windows really does that, don't ask) */
+    while (p > start && (p[-1] == ' ' || p[-1] == '.')) p--;
+    *p = 0;
+    return path;
+}
+
+
+/***********************************************************************
+ *           find_drive_nt_root
+ */
+static NTSTATUS find_drive_nt_root( char *unix_name, unsigned int len,
+                                    WCHAR **nt_name, UINT disposition )
+{
+    unsigned int i, pos, lenW;
+    WCHAR *buffer;
+    NTSTATUS status = STATUS_SUCCESS;
+    struct stat st;
+    struct file_identity info[MAX_DOS_DRIVES];
+
+    *nt_name = NULL;
+
+    /* get device and inode of all drives */
+    if (!get_drives_info( info )) return STATUS_OBJECT_PATH_NOT_FOUND;
+
+    /* strip off trailing slashes */
+    while (len > 1 && unix_name[len - 1] == '/') len--;
+    unix_name[len] = 0;
+
+    for (pos = len; pos; pos = remove_last_component( unix_name, pos ))
+    {
+        char prev = unix_name[pos];
+        unix_name[pos] = 0;
+        if (stat( unix_name, &st ))
+        {
+            if (pos < len) return STATUS_OBJECT_PATH_NOT_FOUND;
+            if (disposition == FILE_OPEN || disposition == FILE_OVERWRITE)
+                return STATUS_OBJECT_NAME_NOT_FOUND;
+            status = STATUS_NO_SUCH_FILE;
+            continue;
+        }
+        unix_name[pos] = prev;
+        if (!S_ISDIR( st.st_mode )) continue;
+
+        /* find the drive */
+        for (i = 0; i < MAX_DOS_DRIVES; i++)
+        {
+            if (info[i].dev != st.st_dev || info[i].ino != st.st_ino) continue;
+            while (pos < len && unix_name[pos] == '/') pos++;
+            len -= pos;
+            buffer = malloc( (len + ARRAY_SIZE(dos_prefixW) + 1) * sizeof(WCHAR) );
+            if (!buffer) return STATUS_NO_MEMORY;
+            memcpy( buffer, dos_prefixW, sizeof(dos_prefixW) );
+            buffer[4] += i;
+            lenW = ARRAY_SIZE(dos_prefixW);
+            lenW += ntdll_umbstowcs( unix_name + pos, len, buffer + lenW, len );
+            buffer[lenW] = 0;
+            *nt_name = collapse_path( buffer );
+            return status;
+        }
+        if (pos <= 1) break;
+    }
+    return status;
+}
+
+
+/******************************************************************
+ *           unix_to_nt_file_name
+ */
+NTSTATUS unix_to_nt_file_name( const char *unix_name, WCHAR **nt, UINT disposition )
+{
+    NTSTATUS status;
+    WCHAR *buffer;
+    ULONG len = strlen(unix_name) + 1;
+    char *name = strdup( unix_name );
+
+    *nt = NULL;
+    if (!name) return STATUS_NO_MEMORY;
+    status = find_drive_nt_root( name, len - 1, &buffer, disposition );
+    free( name );
+    if (status && status != STATUS_NO_SUCH_FILE) return status;
+
+    if (!buffer)  /* conversion failed, return \\?\unix path */
+    {
+        if (!(buffer = malloc( sizeof(unix_prefixW) + len * sizeof(WCHAR) ))) return STATUS_NO_MEMORY;
+        memcpy( buffer, unix_prefixW, sizeof(unix_prefixW) );
+        ntdll_umbstowcs( unix_name, len, buffer + ARRAY_SIZE(unix_prefixW), len );
+        collapse_path( buffer );
+    }
+
+    *nt = buffer;
+    return status;
+}
+
+
+/******************************************************************
+ *           ntdll_get_dos_file_name
+ */
+NTSTATUS ntdll_get_dos_file_name( const char *unix_name, WCHAR **dos, UINT disposition )
+{
+    WCHAR *buffer;
+    NTSTATUS status = unix_to_nt_file_name( unix_name, &buffer, disposition );
+
+    if (buffer)
+    {
+        if (buffer[5] == ':') memmove( buffer, buffer + 4, (wcslen(buffer + 4) + 1) * sizeof(WCHAR) );
+        else buffer[1] = '\\';
+    }
+    *dos = buffer;
+    return status;
+}
+
+
+/* remove trailing backslash from NT name; helper for get_nt_and_unix_names */
+static void remove_trailing_backslash( OBJECT_ATTRIBUTES *attr, UNICODE_STRING *nt_name )
+{
+    UNICODE_STRING *obj_name = attr->ObjectName;
+    ULONG len = obj_name->Length / sizeof(WCHAR);
+
+    if (!len || obj_name->Buffer[len - 1] != '\\') return;
+    if (!attr->RootDirectory)
+    {
+        ULONG i, count = 0;
+        for (i = 0; i < len; i++) if (obj_name->Buffer[i] == '\\') count++;
+        if (count <= 3) return;
+    }
+    if (obj_name != nt_name)  /* not already redirected, make a copy */
+    {
+        nt_name->Length = nt_name->MaximumLength = obj_name->Length;
+        if (!(nt_name->Buffer = malloc( nt_name->MaximumLength ))) return;
+        memcpy( nt_name->Buffer, obj_name->Buffer, nt_name->Length );
+        attr->ObjectName = nt_name;
+    }
+
+    nt_name->Length -= sizeof(WCHAR);
+    nt_name->Buffer[len - 1] = 0;
+}
+
+/***********************************************************************
+ *           get_nt_and_unix_names
+ *
+ * Get the true NT name (potentially after wow64 redirection) and the
+ * Unix name to open a file.
+ *
+ * If disposition is not FILE_OPEN or FILE_OVERWRITE, the last path
+ * element doesn't have to exist; in that case STATUS_NO_SUCH_FILE is
+ * returned, but the names are still filled in properly.
+ *
+ * nt_name.Buffer and unix_name must be freed by caller in all cases.
+ */
+NTSTATUS get_nt_and_unix_names( OBJECT_ATTRIBUTES *attr, UNICODE_STRING *nt_name,
+                                char **unix_name_ret, UINT disposition )
+{
+    ULONG lenA, lenW = attr->ObjectName->Length / sizeof(WCHAR);
+    UNICODE_STRING *orig = attr->ObjectName;
+    NTSTATUS status;
+
+    nt_name->Buffer = NULL;
+    *unix_name_ret = NULL;
+
+    if (!attr->RootDirectory && lenW > ARRAY_SIZE(unix_prefixW) &&
+        !wcsncmp( attr->ObjectName->Buffer, unix_prefixW, ARRAY_SIZE(unix_prefixW) ))
+    {
+        const WCHAR *name = attr->ObjectName->Buffer + ARRAY_SIZE(unix_prefixW);
+        char *unix_name;
+        WCHAR *buffer;
+
+        lenW -= ARRAY_SIZE(unix_prefixW);
+        *unix_name_ret = unix_name = malloc( lenW * 3 + 1 );
+        if (!unix_name) return STATUS_NO_MEMORY;
+        lenA = ntdll_wcstoumbs( name, lenW, unix_name, lenW * 3, FALSE );
+        for (ULONG i = 0; i < lenA; i++) if (unix_name[i] == '\\') unix_name[i] = '/';
+
+        status = find_drive_nt_root( unix_name, lenA, &buffer, disposition );
+        if (buffer)
+        {
+            init_unicode_string( nt_name, buffer );
+            attr->ObjectName = nt_name;
+        }
+    }
+    else
+    {
+#ifndef _WIN64
+        get_redirect( attr, nt_name );
+#endif
+        status = nt_to_unix_file_name( attr, unix_name_ret, disposition );
+    }
+
+    if (!status || status == STATUS_NO_SUCH_FILE)
+    {
+        remove_trailing_backslash( attr, nt_name );
+        TRACE( "%s -> ret %x nt %s unix %s\n", debugstr_us(orig),
+               status, debugstr_us(attr->ObjectName), debugstr_a(*unix_name_ret) );
+    }
+    else TRACE( "%s -> ret %x\n", debugstr_us(orig), status );
+    return status;
+}
+
+
+/***********************************************************************
+ *           get_full_path
+ *
+ * Simplified version of RtlGetFullPathName_U.
+ */
+NTSTATUS get_full_path( char *name, const WCHAR *curdir, UNICODE_STRING *nt_name )
+{
+    WCHAR *ret;
+    ULONG prefix_len, len = max( ARRAY_SIZE(unix_prefixW), wcslen(curdir) ) + strlen(name) + 1;
+
+    /* special case for Unix file name */
+    if (name[0] == '/' && !find_drive_nt_root( name, strlen(name), &ret, FILE_OPEN )) goto done;
+
+    if (!(ret = malloc( len * sizeof(WCHAR) ))) return STATUS_NO_MEMORY;
+
+    if (IS_SEPARATOR(name[0]) && name[1] == '?' && name[2] == '?' && IS_SEPARATOR(name[3]))  /* \??\ */
+    {
+        prefix_len = 0;
+    }
+    else if (IS_SEPARATOR(name[0]) && IS_SEPARATOR(name[1]))  /* \\ prefix */
+    {
+        if ((name[2] == '.' || name[2] == '?') && IS_SEPARATOR(name[3])) /* \\?\ device */
+        {
+            name += 4;
+            memcpy( ret, nt_prefixW, sizeof(nt_prefixW) );
+            prefix_len = ARRAY_SIZE(nt_prefixW);
+        }
+        else  /* UNC path */
+        {
+            name += 2;
+            memcpy( ret, unc_prefixW, sizeof(unc_prefixW) );
+            prefix_len = ARRAY_SIZE(unc_prefixW);
+        }
+    }
+    else if (IS_SEPARATOR(name[0]))  /* absolute path */
+    {
+        memcpy( ret, dos_prefixW, sizeof(dos_prefixW) );
+        prefix_len = ARRAY_SIZE(dos_prefixW);
+        ret[4] = curdir[4];
+    }
+    else if (name[0] && name[1] == ':')  /* drive letter */
+    {
+        memcpy( ret, dos_prefixW, sizeof(dos_prefixW) );
+        prefix_len = ARRAY_SIZE(dos_prefixW);
+        ret[4] = towupper(name[0]);
+        name += 2;
+    }
+    else  /* relative path */
+    {
+        prefix_len = wcslen( curdir );
+        memcpy( ret, curdir, prefix_len * sizeof(WCHAR) );
+    }
+
+    ntdll_umbstowcs( name, strlen(name) + 1, ret + prefix_len, len - prefix_len );
+    collapse_path( ret );
+ done:
+    init_unicode_string( nt_name, ret );
+    return STATUS_SUCCESS;
+}
+
+
+/***********************************************************************
+ *           get_nt_path
+ *
+ * Simplified version of RtlDosPathNameToNtPathName_U.
+ */
+NTSTATUS get_nt_path( const WCHAR *name, UNICODE_STRING *nt_name )
+{
+    ULONG len = wcslen( name );
+    WCHAR *ret, *p;
+
+    nt_name->Buffer = NULL;
+    if (!(ret = p = malloc( (len + 8) * sizeof(WCHAR) ))) return STATUS_NO_MEMORY;
+
+    if (name[0] == '\\' && name[1] == '\\')
+    {
+        if ((name[2] == '.' || name[2] == '?') && name[3] == '\\')
+        {
+            memcpy( p, nt_prefixW, sizeof(nt_prefixW) );
+            p += ARRAY_SIZE( nt_prefixW );
+            name += 4;
+        }
+        else
+        {
+            memcpy( p, unc_prefixW, sizeof(unc_prefixW) );
+            p += ARRAY_SIZE( unc_prefixW );
+            name += 2;
+        }
+    }
+    else if (wcsncmp( name, nt_prefixW, ARRAY_SIZE(nt_prefixW) ))
+    {
+        memcpy( p, nt_prefixW, sizeof(nt_prefixW) );
+        p += ARRAY_SIZE( nt_prefixW );
+    }
+    wcscpy( p, name );
+    collapse_path( ret );
+    init_unicode_string( nt_name, ret );
+    return STATUS_SUCCESS;
+}
+
+
+/***********************************************************************
+ *           ntdll_get_unix_file_name
+ */
+NTSTATUS ntdll_get_unix_file_name( const WCHAR *dos, char **unix_name, UINT disposition )
+{
+    UNICODE_STRING nt_name, true_nt_name;
+    OBJECT_ATTRIBUTES attr;
+    char *buffer = NULL;
+    NTSTATUS status = get_nt_path( dos, &nt_name );
+
+    if (status) return status;
+    InitializeObjectAttributes( &attr, &nt_name, 0, 0, NULL );
+    status = get_nt_and_unix_names( &attr, &true_nt_name, &buffer, disposition );
+    free( nt_name.Buffer );
+    free( true_nt_name.Buffer );
+
+    if (!status || status == STATUS_NO_SUCH_FILE)
+    {
+        /* remove dosdevices prefix for z: drive if it points to the Unix root */
+        if (!strncmp( buffer, config_dir, strlen(config_dir) ) &&
+            !strncmp( buffer + strlen(config_dir), "/dosdevices/z:/", 15 ))
+        {
+            struct stat st1, st2;
+            BOOL is_root;
+            char *p = buffer + strlen(config_dir) + 14;
+            *p = 0;
+            is_root = !stat( buffer, &st1 ) && !stat( "/", &st2 ) &&
+                      st1.st_dev == st2.st_dev && st1.st_ino == st2.st_ino;
+            *p = '/';
+            if (is_root) memmove( buffer, p, strlen(p) + 1 );
+        }
+        *unix_name = buffer;
+    }
+    else free( buffer );
+
+    return status;
+}
+
+
+/***********************************************************************
+ *           unmount_device
+ *
+ * Unmount the specified device.
+ */
+static NTSTATUS unmount_device( HANDLE handle )
+{
+    NTSTATUS status;
+    int unix_fd, needs_close;
+
+    if (!(status = server_get_unix_fd( handle, 0, &unix_fd, &needs_close, NULL, NULL )))
+    {
+        struct stat st;
+        char *mount_point = NULL;
+
+        if (fstat( unix_fd, &st ) == -1 || !is_valid_mounted_device( &st ))
+            status = STATUS_INVALID_PARAMETER;
+        else
+        {
+            if ((mount_point = get_device_mount_point( st.st_rdev )))
+            {
+#ifdef __APPLE__
+                static char diskutil[] = "diskutil";
+                static char unmount[] = "unmount";
+                char *argv[4] = {diskutil, unmount, mount_point, NULL};
+#else
+                static char umount[] = "umount";
+                char *argv[3] = {umount, mount_point, NULL};
+#endif
+                __wine_unix_spawnvp( argv, TRUE );
+#ifdef linux
+                /* umount will fail to release the loop device since we still have
+                    a handle to it, so we release it here */
+                if (major(st.st_rdev) == LOOP_MAJOR) ioctl( unix_fd, 0x4c01 /*LOOP_CLR_FD*/, 0 );
+#endif
+                /* Add in a small delay. Without this subsequent tasks
+                    like IOCTL_STORAGE_EJECT_MEDIA might fail. */
+                usleep( 100000 );
+            }
+        }
+        if (needs_close) close( unix_fd );
+    }
+    return status;
+}
+
+
+/******************************************************************************
+ *              open_unix_file
+ *
+ * Helper for NtCreateFile that takes a Unix path.
+ */
+NTSTATUS open_unix_file( HANDLE *handle, const char *unix_name, ACCESS_MASK access,
+                         OBJECT_ATTRIBUTES *attr, ULONG attributes, ULONG sharing, ULONG disposition,
+                         ULONG options, void *ea_buffer, ULONG ea_length )
+{
+    struct object_attributes *objattr;
+    unsigned int status;
+    data_size_t len;
+
+    if ((status = alloc_object_attributes( attr, &objattr, &len ))) return status;
+
+    SERVER_START_REQ( create_file )
+    {
+        req->access     = access;
+        req->sharing    = sharing;
+        req->create     = disposition;
+        req->options    = options;
+        req->attrs      = attributes;
+        wine_server_add_data( req, objattr, len );
+        wine_server_add_data( req, unix_name, strlen(unix_name) );
+        status = wine_server_call( req );
+        *handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+    free( objattr );
+    return status;
+}
+
+
+/******************************************************************************
+ *              NtCreateFile   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtCreateFile( HANDLE *handle, ACCESS_MASK access, OBJECT_ATTRIBUTES *attr,
+                              IO_STATUS_BLOCK *io, LARGE_INTEGER *alloc_size,
+                              ULONG attributes, ULONG sharing, ULONG disposition,
+                              ULONG options, void *ea_buffer, ULONG ea_length )
+{
+    OBJECT_ATTRIBUTES new_attr;
+    UNICODE_STRING nt_name;
+    char *unix_name = NULL;
+    BOOL name_hidden = FALSE;
+    BOOL created = FALSE;
+    unsigned int status;
+
+    TRACE( "handle=%p access=%08x name=%s objattr=%08x root=%p sec=%p io=%p alloc_size=%p "
+           "attr=%08x sharing=%08x disp=%d options=%08x ea=%p.0x%08x\n",
+           handle, access, debugstr_us(attr->ObjectName), attr->Attributes,
+           attr->RootDirectory, attr->SecurityDescriptor, io, alloc_size,
+           attributes, sharing, disposition, options, ea_buffer, ea_length );
+
+    *handle = 0;
+    if (!attr || !attr->ObjectName) return STATUS_INVALID_PARAMETER;
+
+    if (alloc_size) FIXME( "alloc_size not supported\n" );
+
+    new_attr = *attr;
+    if (options & FILE_OPEN_BY_FILE_ID)
+    {
+        status = file_id_to_unix_file_name( &new_attr, &unix_name, &nt_name );
+        if (!status) new_attr.ObjectName = &nt_name;
+    }
+    else status = get_nt_and_unix_names( &new_attr, &nt_name, &unix_name, disposition );
+
+    if (status == STATUS_BAD_DEVICE_TYPE)
+    {
+        status = server_open_file_object( handle, access, &new_attr, sharing, options );
+        if (status == STATUS_SUCCESS) io->Information = FILE_OPENED;
+        goto done;
+    }
+
+    if (status == STATUS_NO_SUCH_FILE && disposition != FILE_OPEN && disposition != FILE_OVERWRITE)
+    {
+        created = TRUE;
+        status = STATUS_SUCCESS;
+    }
+
+    if (status == STATUS_SUCCESS)
+    {
+        name_hidden = is_hidden_file( unix_name );
+        status = open_unix_file( handle, unix_name, access, &new_attr, attributes,
+                                 sharing, disposition, options, ea_buffer, ea_length );
+    }
+    else WARN( "%s not found (%x)\n", debugstr_us(attr->ObjectName), status );
+
+    if (status == STATUS_SUCCESS)
+    {
+        if (created) io->Information = FILE_CREATED;
+        else switch(disposition)
+        {
+        case FILE_SUPERSEDE:
+            io->Information = FILE_SUPERSEDED;
+            break;
+        case FILE_CREATE:
+            io->Information = FILE_CREATED;
+            break;
+        case FILE_OPEN:
+        case FILE_OPEN_IF:
+            io->Information = FILE_OPENED;
+            break;
+        case FILE_OVERWRITE:
+        case FILE_OVERWRITE_IF:
+            io->Information = FILE_OVERWRITTEN;
+            break;
+        }
+
+        if (io->Information == FILE_CREATED &&
+            ((attributes & XATTR_ATTRIBS_MASK) || name_hidden))
+        {
+            int fd, needs_close;
+
+            /* set any DOS extended attributes */
+            if (!server_get_unix_fd( *handle, 0, &fd, &needs_close, NULL, NULL ))
+            {
+                if (fd_set_dos_attrib( fd, attributes, TRUE ) == -1 && errno != ENOTSUP)
+                    WARN( "Failed to set extended attribute " SAMBA_XATTR_DOS_ATTRIB ". errno %d (%s)",
+                          errno, strerror( errno ) );
+                if (needs_close) close( fd );
+            }
+        }
+    }
+    else if (status == STATUS_TOO_MANY_OPENED_FILES)
+    {
+        static int once;
+        if (!once++) ERR_(winediag)( "Too many open files, ulimit -n probably needs to be increased\n" );
+    }
+
+ done:
+    free( unix_name );
+    free( nt_name.Buffer );
+    return io->Status = status;
+}
+
+
+/******************************************************************************
+ *              NtOpenFile   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtOpenFile( HANDLE *handle, ACCESS_MASK access, OBJECT_ATTRIBUTES *attr,
+                            IO_STATUS_BLOCK *io, ULONG sharing, ULONG options )
+{
+    return NtCreateFile( handle, access, attr, io, NULL, 0, sharing, FILE_OPEN, options, NULL, 0 );
+}
+
+
+/******************************************************************************
+ *		NtCreateMailslotFile    (NTDLL.@)
+ */
+NTSTATUS WINAPI NtCreateMailslotFile( HANDLE *handle, ULONG access, OBJECT_ATTRIBUTES *attr,
+                                      IO_STATUS_BLOCK *io, ULONG options, ULONG quota, ULONG msg_size,
+                                      LARGE_INTEGER *timeout )
+{
+    unsigned int status;
+    data_size_t len;
+    struct object_attributes *objattr;
+
+    TRACE( "%p %08x %p %p %08x %08x %08x %p\n",
+           handle, access, attr, io, options, quota, msg_size, timeout );
+
+    *handle = 0;
+    if (!attr) return STATUS_INVALID_PARAMETER;
+    if ((status = alloc_object_attributes( attr, &objattr, &len ))) return status;
+
+    SERVER_START_REQ( create_mailslot )
+    {
+        req->access       = access;
+        req->options      = options;
+        req->max_msgsize  = msg_size;
+        req->read_timeout = timeout ? timeout->QuadPart : -1;
+        wine_server_add_data( req, objattr, len );
+        if (!(status = wine_server_call( req ))) *handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+
+    free( objattr );
+    return status;
+}
+
+
+/******************************************************************
+ *		NtCreateNamedPipeFile    (NTDLL.@)
+ */
+NTSTATUS WINAPI NtCreateNamedPipeFile( HANDLE *handle, ULONG access, OBJECT_ATTRIBUTES *attr,
+                                       IO_STATUS_BLOCK *io, ULONG sharing, ULONG dispo, ULONG options,
+                                       ULONG pipe_type, ULONG read_mode, ULONG completion_mode,
+                                       ULONG max_inst, ULONG inbound_quota, ULONG outbound_quota,
+                                       LARGE_INTEGER *timeout )
+{
+    unsigned int status;
+    data_size_t len;
+    struct object_attributes *objattr;
+
+    *handle = 0;
+    if (!attr) return STATUS_INVALID_PARAMETER;
+
+    TRACE( "(%p %x %s %p %x %d %x %d %d %d %d %d %d %p)\n",
+           handle, access, debugstr_us(attr->ObjectName), io, sharing, dispo,
+           options, pipe_type, read_mode, completion_mode, max_inst,
+           inbound_quota, outbound_quota, timeout );
+
+    /* assume we only get relative timeout */
+    if (timeout && timeout->QuadPart > 0) FIXME( "Wrong time %s\n", wine_dbgstr_longlong(timeout->QuadPart) );
+
+    if ((status = alloc_object_attributes( attr, &objattr, &len ))) return status;
+
+    SERVER_START_REQ( create_named_pipe )
+    {
+        req->access  = access;
+        req->options = options;
+        req->sharing = sharing;
+        req->flags =
+            (pipe_type ? NAMED_PIPE_MESSAGE_STREAM_WRITE   : 0) |
+            (read_mode ? NAMED_PIPE_MESSAGE_STREAM_READ    : 0) |
+            (completion_mode ? NAMED_PIPE_NONBLOCKING_MODE : 0);
+        req->disposition  = dispo;
+        req->maxinstances = max_inst;
+        req->outsize = outbound_quota;
+        req->insize  = inbound_quota;
+        req->timeout = timeout ? timeout->QuadPart : 0ULL;
+        wine_server_add_data( req, objattr, len );
+        if (!(status = wine_server_call( req )))
+        {
+            *handle = wine_server_ptr_handle( reply->handle );
+            io->Information = reply->created ? FILE_CREATED : FILE_OPENED;
+        }
+    }
+    SERVER_END_REQ;
+
+    free( objattr );
+    return io->Status = status;
+}
+
+
+/******************************************************************
+ *              NtDeleteFile   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtDeleteFile( OBJECT_ATTRIBUTES *attr )
+{
+    HANDLE handle;
+    NTSTATUS status;
+    char *unix_name;
+    UNICODE_STRING nt_name;
+    OBJECT_ATTRIBUTES new_attr = *attr;
+
+    if (!(status = get_nt_and_unix_names( &new_attr, &nt_name, &unix_name, FILE_OPEN )))
+    {
+        if (!(status = open_unix_file( &handle, unix_name, GENERIC_READ | GENERIC_WRITE | DELETE, &new_attr,
+                                       0, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_OPEN,
+                                       FILE_DELETE_ON_CLOSE, NULL, 0 )))
+            NtClose( handle );
+    }
+    free( unix_name );
+    free( nt_name.Buffer );
+    return status;
+}
+
+
+/******************************************************************************
+ *              NtQueryFullAttributesFile   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtQueryFullAttributesFile( const OBJECT_ATTRIBUTES *attr,
+                                           FILE_NETWORK_OPEN_INFORMATION *info )
+{
+    char *unix_name;
+    unsigned int status;
+    UNICODE_STRING nt_name;
+    OBJECT_ATTRIBUTES new_attr = *attr;
+
+    if (!(status = get_nt_and_unix_names( &new_attr, &nt_name, &unix_name, FILE_OPEN )))
+    {
+        ULONG attributes;
+        struct stat st;
+
+        if (get_file_info( unix_name, &st, &attributes ) == -1)
+            status = errno_to_status( errno );
+        else if (!S_ISREG(st.st_mode) && !S_ISDIR(st.st_mode))
+            status = STATUS_INVALID_INFO_CLASS;
+        else
+            fill_file_info( &st, attributes, info, FileNetworkOpenInformation );
+    }
+    else WARN( "%s not found (%x)\n", debugstr_us(attr->ObjectName), status );
+    free( unix_name );
+    free( nt_name.Buffer );
+    return status;
+}
+
+
+/******************************************************************************
+ *              NtQueryAttributesFile   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtQueryAttributesFile( const OBJECT_ATTRIBUTES *attr, FILE_BASIC_INFORMATION *info )
+{
+    char *unix_name;
+    unsigned int status;
+    UNICODE_STRING nt_name;
+    OBJECT_ATTRIBUTES new_attr = *attr;
+
+    if (!(status = get_nt_and_unix_names( &new_attr, &nt_name, &unix_name, FILE_OPEN )))
+    {
+        ULONG attributes;
+        struct stat st;
+
+        if (get_file_info( unix_name, &st, &attributes ) == -1)
+            status = errno_to_status( errno );
+        else if (!S_ISREG(st.st_mode) && !S_ISDIR(st.st_mode))
+            status = STATUS_INVALID_INFO_CLASS;
+        else
+            status = fill_file_info( &st, attributes, info, FileBasicInformation );
+    }
+    else WARN( "%s not found (%x)\n", debugstr_us(attr->ObjectName), status );
+    free( unix_name );
+    free( nt_name.Buffer );
+    return status;
+}
+
+
+/******************************************************************************
+ *              NtQueryInformationFile   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtQueryInformationFile( HANDLE handle, IO_STATUS_BLOCK *io,
+                                        void *ptr, ULONG len, FILE_INFORMATION_CLASS class )
+{
+    static const size_t info_sizes[FileMaximumInformation] =
+    {
+        0,
+        sizeof(FILE_DIRECTORY_INFORMATION),            /* FileDirectoryInformation */
+        sizeof(FILE_FULL_DIRECTORY_INFORMATION),       /* FileFullDirectoryInformation */
+        sizeof(FILE_BOTH_DIRECTORY_INFORMATION),       /* FileBothDirectoryInformation */
+        sizeof(FILE_BASIC_INFORMATION),                /* FileBasicInformation */
+        sizeof(FILE_STANDARD_INFORMATION),             /* FileStandardInformation */
+        sizeof(FILE_INTERNAL_INFORMATION),             /* FileInternalInformation */
+        sizeof(FILE_EA_INFORMATION),                   /* FileEaInformation */
+        0,                                             /* FileAccessInformation */
+        sizeof(FILE_NAME_INFORMATION),                 /* FileNameInformation */
+        sizeof(FILE_RENAME_INFORMATION)-sizeof(WCHAR), /* FileRenameInformation */
+        0,                                             /* FileLinkInformation */
+        sizeof(FILE_NAMES_INFORMATION)-sizeof(WCHAR),  /* FileNamesInformation */
+        sizeof(FILE_DISPOSITION_INFORMATION),          /* FileDispositionInformation */
+        sizeof(FILE_POSITION_INFORMATION),             /* FilePositionInformation */
+        sizeof(FILE_FULL_EA_INFORMATION),              /* FileFullEaInformation */
+        0,                                             /* FileModeInformation */
+        sizeof(FILE_ALIGNMENT_INFORMATION),            /* FileAlignmentInformation */
+        sizeof(FILE_ALL_INFORMATION),                  /* FileAllInformation */
+        sizeof(FILE_ALLOCATION_INFORMATION),           /* FileAllocationInformation */
+        sizeof(FILE_END_OF_FILE_INFORMATION),          /* FileEndOfFileInformation */
+        0,                                             /* FileAlternateNameInformation */
+        sizeof(FILE_STREAM_INFORMATION)-sizeof(WCHAR), /* FileStreamInformation */
+        sizeof(FILE_PIPE_INFORMATION),                 /* FilePipeInformation */
+        sizeof(FILE_PIPE_LOCAL_INFORMATION),           /* FilePipeLocalInformation */
+        0,                                             /* FilePipeRemoteInformation */
+        sizeof(FILE_MAILSLOT_QUERY_INFORMATION),       /* FileMailslotQueryInformation */
+        0,                                             /* FileMailslotSetInformation */
+        0,                                             /* FileCompressionInformation */
+        0,                                             /* FileObjectIdInformation */
+        0,                                             /* FileCompletionInformation */
+        0,                                             /* FileMoveClusterInformation */
+        0,                                             /* FileQuotaInformation */
+        0,                                             /* FileReparsePointInformation */
+        sizeof(FILE_NETWORK_OPEN_INFORMATION),         /* FileNetworkOpenInformation */
+        sizeof(FILE_ATTRIBUTE_TAG_INFORMATION),        /* FileAttributeTagInformation */
+        0,                                             /* FileTrackingInformation */
+        0,                                             /* FileIdBothDirectoryInformation */
+        0,                                             /* FileIdFullDirectoryInformation */
+        0,                                             /* FileValidDataLengthInformation */
+        0,                                             /* FileShortNameInformation */
+        0,                                             /* FileIoCompletionNotificationInformation, */
+        0,                                             /* FileIoStatusBlockRangeInformation */
+        0,                                             /* FileIoPriorityHintInformation */
+        0,                                             /* FileSfioReserveInformation */
+        0,                                             /* FileSfioVolumeInformation */
+        0,                                             /* FileHardLinkInformation */
+        0,                                             /* FileProcessIdsUsingFileInformation */
+        0,                                             /* FileNormalizedNameInformation */
+        0,                                             /* FileNetworkPhysicalNameInformation */
+        0,                                             /* FileIdGlobalTxDirectoryInformation */
+        0,                                             /* FileIsRemoteDeviceInformation */
+        0,                                             /* FileAttributeCacheInformation */
+        0,                                             /* FileNumaNodeInformation */
+        0,                                             /* FileStandardLinkInformation */
+        0,                                             /* FileRemoteProtocolInformation */
+        0,                                             /* FileRenameInformationBypassAccessCheck */
+        0,                                             /* FileLinkInformationBypassAccessCheck */
+        0,                                             /* FileVolumeNameInformation */
+        sizeof(FILE_ID_INFORMATION),                   /* FileIdInformation */
+        0,                                             /* FileIdExtdDirectoryInformation */
+        0,                                             /* FileReplaceCompletionInformation */
+        0,                                             /* FileHardLinkFullIdInformation */
+        0,                                             /* FileIdExtdBothDirectoryInformation */
+        0,                                             /* FileDispositionInformationEx */
+        0,                                             /* FileRenameInformationEx */
+        0,                                             /* FileRenameInformationExBypassAccessCheck */
+        0,                                             /* FileDesiredStorageClassInformation */
+        sizeof(FILE_STAT_INFORMATION),                 /* FileStatInformation */
+        0,                                             /* FileMemoryPartitionInformation */
+        0,                                             /* FileStatLxInformation */
+        0,                                             /* FileCaseSensitiveInformation */
+        0,                                             /* FileLinkInformationEx */
+        0,                                             /* FileLinkInformationExBypassAccessCheck */
+        0,                                             /* FileStorageReserveIdInformation */
+        0,                                             /* FileCaseSensitiveInformationForceAccessCheck */
+        0,                                             /* FileKnownFolderInformation */
+    };
+
+    struct stat st;
+    int fd, needs_close = FALSE;
+    ULONG attr;
+    unsigned int options;
+    unsigned int status;
+
+    TRACE( "(%p,%p,%p,0x%08x,0x%08x)\n", handle, io, ptr, len, class);
+
+    io->Information = 0;
+
+    if (class == WineFileUnixNameInformation)
+        return server_get_file_info( handle, io, ptr, len, class );
+    if (class <= 0 || class >= FileMaximumInformation)
+        return io->Status = STATUS_INVALID_INFO_CLASS;
+    if (!info_sizes[class])
+        return server_get_file_info( handle, io, ptr, len, class );
+    if (len < info_sizes[class])
+        return io->Status = STATUS_INFO_LENGTH_MISMATCH;
+
+    if ((status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, &options )))
+    {
+        if (status != STATUS_BAD_DEVICE_TYPE) return io->Status = status;
+        return server_get_file_info( handle, io, ptr, len, class );
+    }
+
+    switch (class)
+    {
+    case FileBasicInformation:
+        if (fd_get_file_info( fd, options, &st, &attr ) == -1)
+            status = errno_to_status( errno );
+        else if (!S_ISREG(st.st_mode) && !S_ISDIR(st.st_mode))
+            status = STATUS_INVALID_INFO_CLASS;
+        else
+            fill_file_info( &st, attr, ptr, class );
+        break;
+    case FileStandardInformation:
+        {
+            FILE_STANDARD_INFORMATION *info = ptr;
+
+            if (fd_get_file_info( fd, options, &st, &attr ) == -1) status = errno_to_status( errno );
+            else
+            {
+                fill_file_info( &st, attr, info, class );
+                info->DeletePending = FALSE; /* FIXME */
+            }
+        }
+        break;
+    case FilePositionInformation:
+        {
+            FILE_POSITION_INFORMATION *info = ptr;
+            off_t res = lseek( fd, 0, SEEK_CUR );
+            if (res == (off_t)-1) status = errno_to_status( errno );
+            else info->CurrentByteOffset.QuadPart = res;
+        }
+        break;
+    case FileInternalInformation:
+        if (fd_get_file_info( fd, options, &st, &attr ) == -1) status = errno_to_status( errno );
+        else fill_file_info( &st, attr, ptr, class );
+        break;
+    case FileEaInformation:
+        {
+            FILE_EA_INFORMATION *info = ptr;
+            info->EaSize = 0;
+        }
+        break;
+    case FileEndOfFileInformation:
+        if (fd_get_file_info( fd, options, &st, &attr ) == -1) status = errno_to_status( errno );
+        else fill_file_info( &st, attr, ptr, class );
+        break;
+    case FileAllInformation:
+        {
+            FILE_ALL_INFORMATION *info = ptr;
+
+            if (fd_get_file_info( fd, options, &st, &attr ) == -1) status = errno_to_status( errno );
+            else
+            {
+                LONG name_len = len - FIELD_OFFSET(FILE_ALL_INFORMATION, NameInformation.FileName);
+
+                fill_file_info( &st, attr, info, FileAllInformation );
+                info->StandardInformation.DeletePending = FALSE; /* FIXME */
+                info->EaInformation.EaSize = 0;
+                info->AccessInformation.AccessFlags = 0;  /* FIXME */
+                info->PositionInformation.CurrentByteOffset.QuadPart = lseek( fd, 0, SEEK_CUR );
+                info->ModeInformation.Mode = 0;  /* FIXME */
+                info->AlignmentInformation.AlignmentRequirement = 1;  /* FIXME */
+                status = server_get_name_info( handle, &info->NameInformation, &name_len );
+                io->Information = FIELD_OFFSET(FILE_ALL_INFORMATION, NameInformation.FileName) + name_len;
+            }
+        }
+        break;
+    case FileNameInformation:
+        {
+            LONG name_len = len - FIELD_OFFSET(FILE_NAME_INFORMATION, FileName);
+            status = server_get_name_info( handle, ptr, &name_len );
+            io->Information = offsetof( FILE_NAME_INFORMATION, FileName ) + name_len;
+        }
+        break;
+    case FileNetworkOpenInformation:
+        if (fd_get_file_info( fd, options, &st, &attr ) == -1) status = errno_to_status( errno );
+        else fill_file_info( &st, attr, ptr, FileNetworkOpenInformation );
+        break;
+    case FileIdInformation:
+        if (fd_get_file_info( fd, options, &st, &attr ) == -1) status = errno_to_status( errno );
+        else
+        {
+            struct mountmgr_unix_drive drive;
+            FILE_ID_INFORMATION *info = ptr;
+
+            info->VolumeSerialNumber = 0;
+            if (!get_mountmgr_fs_info( handle, fd, &drive, sizeof(drive) ))
+                info->VolumeSerialNumber = drive.serial;
+            memset( &info->FileId, 0, sizeof(info->FileId) );
+            *(ULONGLONG *)&info->FileId = st.st_ino;
+        }
+        break;
+    case FileAttributeTagInformation:
+        if (fd_get_file_info( fd, options, &st, &attr ) == -1) status = errno_to_status( errno );
+        else
+        {
+            FILE_ATTRIBUTE_TAG_INFORMATION *info = ptr;
+            info->FileAttributes = attr;
+            info->ReparseTag = 0; /* FIXME */
+            if ((options & FILE_OPEN_REPARSE_POINT) && fd_is_mount_point( fd, &st ))
+                info->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
+        }
+        break;
+    case FileStatInformation:
+        if (fd_get_file_info( fd, options, &st, &attr ) == -1) status = errno_to_status( errno );
+        else if (!S_ISREG(st.st_mode) && !S_ISDIR(st.st_mode))
+            status = STATUS_INVALID_INFO_CLASS;
+        else
+        {
+            FILE_STAT_INFORMATION *info = ptr;
+            FILE_BASIC_INFORMATION basic;
+            FILE_STANDARD_INFORMATION std;
+
+            fill_file_info( &st, attr, &basic, FileBasicInformation );
+            fill_file_info( &st, attr, &std, FileStandardInformation );
+
+            info->FileId.QuadPart = st.st_ino;
+            info->CreationTime   = basic.CreationTime;
+            info->LastAccessTime = basic.LastAccessTime;
+            info->LastWriteTime  = basic.LastWriteTime;
+            info->ChangeTime     = basic.ChangeTime;
+            info->AllocationSize = std.AllocationSize;
+            info->EndOfFile      = std.EndOfFile;
+            info->FileAttributes = attr;
+            info->ReparseTag     = 0; /* FIXME */
+            if ((options & FILE_OPEN_REPARSE_POINT) && fd_is_mount_point( fd, &st ))
+                info->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
+            info->NumberOfLinks  = std.NumberOfLinks;
+            info->EffectiveAccess = FILE_ALL_ACCESS; /* FIXME */
+        }
+        break;
+    default:
+        FIXME("Unsupported class (%d)\n", class);
+        status = STATUS_NOT_IMPLEMENTED;
+        break;
+    }
+    if (needs_close) close( fd );
+    if (status == STATUS_SUCCESS && !io->Information) io->Information = info_sizes[class];
+    return io->Status = status;
+}
+
+
+/******************************************************************************
+ *              NtSetInformationFile   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtSetInformationFile( HANDLE handle, IO_STATUS_BLOCK *io,
+                                      void *ptr, ULONG len, FILE_INFORMATION_CLASS class )
+{
+    int fd, needs_close;
+    unsigned int status = STATUS_SUCCESS;
+
+    TRACE( "(%p,%p,%p,0x%08x,0x%08x)\n", handle, io, ptr, len, class );
+
+    switch (class)
+    {
+    case FileBasicInformation:
+        if (len >= sizeof(FILE_BASIC_INFORMATION))
+        {
+            const FILE_BASIC_INFORMATION *info = ptr;
+            LARGE_INTEGER mtime, atime;
+            char *unix_name;
+
+            if ((status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL )))
+                return io->Status = status;
+
+            if (server_get_unix_name( handle, &unix_name )) unix_name = NULL;
+
+            mtime.QuadPart = info->LastWriteTime.QuadPart == -1 ? 0 : info->LastWriteTime.QuadPart;
+            atime.QuadPart = info->LastAccessTime.QuadPart == -1 ? 0 : info->LastAccessTime.QuadPart;
+
+            if (atime.QuadPart || mtime.QuadPart)
+                status = set_file_times( fd, &mtime, &atime );
+
+            if (status == STATUS_SUCCESS)
+                status = fd_set_file_info( fd, info->FileAttributes,
+                                           unix_name && is_hidden_file( unix_name ));
+
+            if (needs_close) close( fd );
+            free( unix_name );
+        }
+        else status = STATUS_INVALID_PARAMETER_3;
+        break;
+
+    case FilePositionInformation:
+        if (len >= sizeof(FILE_POSITION_INFORMATION))
+        {
+            const FILE_POSITION_INFORMATION *info = ptr;
+
+            if ((status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL )))
+                return io->Status = status;
+
+            if (lseek( fd, info->CurrentByteOffset.QuadPart, SEEK_SET ) == (off_t)-1)
+                status = errno_to_status( errno );
+
+            if (needs_close) close( fd );
+        }
+        else status = STATUS_INVALID_PARAMETER_3;
+        break;
+
+    case FileEndOfFileInformation:
+        if (len >= sizeof(FILE_END_OF_FILE_INFORMATION))
+        {
+            const FILE_END_OF_FILE_INFORMATION *info = ptr;
+
+            SERVER_START_REQ( set_fd_eof_info )
+            {
+                req->handle   = wine_server_obj_handle( handle );
+                req->eof      = info->EndOfFile.QuadPart;
+                status = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        }
+        else status = STATUS_INVALID_PARAMETER_3;
+        break;
+
+    case FilePipeInformation:
+        if (len >= sizeof(FILE_PIPE_INFORMATION))
+        {
+            FILE_PIPE_INFORMATION *info = ptr;
+
+            if ((info->CompletionMode | info->ReadMode) & ~1)
+            {
+                status = STATUS_INVALID_PARAMETER;
+                break;
+            }
+
+            SERVER_START_REQ( set_named_pipe_info )
+            {
+                req->handle = wine_server_obj_handle( handle );
+                req->flags  = (info->CompletionMode ? NAMED_PIPE_NONBLOCKING_MODE    : 0) |
+                              (info->ReadMode       ? NAMED_PIPE_MESSAGE_STREAM_READ : 0);
+                status = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        }
+        else status = STATUS_INVALID_PARAMETER_3;
+        break;
+
+    case FileMailslotSetInformation:
+        {
+            FILE_MAILSLOT_SET_INFORMATION *info = ptr;
+
+            SERVER_START_REQ( set_mailslot_info )
+            {
+                req->handle = wine_server_obj_handle( handle );
+                req->flags = MAILSLOT_SET_READ_TIMEOUT;
+                req->read_timeout = info->ReadTimeout.QuadPart;
+                status = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        }
+        break;
+
+    case FileCompletionInformation:
+        if (len >= sizeof(FILE_COMPLETION_INFORMATION))
+        {
+            FILE_COMPLETION_INFORMATION *info = ptr;
+
+            SERVER_START_REQ( set_completion_info )
+            {
+                req->handle   = wine_server_obj_handle( handle );
+                req->chandle  = wine_server_obj_handle( info->CompletionPort );
+                req->ckey     = info->CompletionKey;
+                status = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        }
+        else status = STATUS_INVALID_PARAMETER_3;
+        break;
+
+    case FileIoCompletionNotificationInformation:
+        if (len >= sizeof(FILE_IO_COMPLETION_NOTIFICATION_INFORMATION))
+        {
+            FILE_IO_COMPLETION_NOTIFICATION_INFORMATION *info = ptr;
+
+            if (info->Flags & FILE_SKIP_SET_USER_EVENT_ON_FAST_IO)
+                FIXME( "FILE_SKIP_SET_USER_EVENT_ON_FAST_IO not supported\n" );
+
+            SERVER_START_REQ( set_fd_completion_mode )
+            {
+                req->handle   = wine_server_obj_handle( handle );
+                req->flags    = info->Flags;
+                status = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        }
+        else status = STATUS_INFO_LENGTH_MISMATCH;
+        break;
+
+    case FileIoPriorityHintInformation:
+        if (len >= sizeof(FILE_IO_PRIORITY_HINT_INFO))
+        {
+            FILE_IO_PRIORITY_HINT_INFO *info = ptr;
+            if (info->PriorityHint < MaximumIoPriorityHintType)
+                TRACE( "ignoring FileIoPriorityHintInformation %u\n", info->PriorityHint );
+            else
+                status = STATUS_INVALID_PARAMETER;
+        }
+        else status = STATUS_INFO_LENGTH_MISMATCH;
+        break;
+
+    case FileAllInformation:
+        status = STATUS_INVALID_INFO_CLASS;
+        break;
+
+    case FileValidDataLengthInformation:
+        if (len >= sizeof(FILE_VALID_DATA_LENGTH_INFORMATION))
+        {
+            struct stat st;
+            const FILE_VALID_DATA_LENGTH_INFORMATION *info = ptr;
+
+            if ((status = server_get_unix_fd( handle, FILE_WRITE_DATA, &fd, &needs_close, NULL, NULL )))
+                return io->Status = status;
+
+            if (fstat( fd, &st ) == -1) status = errno_to_status( errno );
+            else if (info->ValidDataLength.QuadPart <= 0 || (off_t)info->ValidDataLength.QuadPart > st.st_size)
+                status = STATUS_INVALID_PARAMETER;
+            else
+            {
+#ifdef HAVE_POSIX_FALLOCATE
+                int err;
+                if ((err = posix_fallocate( fd, 0, (off_t)info->ValidDataLength.QuadPart )) != 0)
+                {
+                    if (err == EOPNOTSUPP) WARN( "posix_fallocate not supported on this filesystem\n" );
+                    else status = errno_to_status( err );
+                }
+#else
+                WARN( "setting valid data length not supported\n" );
+#endif
+            }
+            if (needs_close) close( fd );
+        }
+        else status = STATUS_INVALID_PARAMETER_3;
+        break;
+
+    case FileDispositionInformation:
+        if (len >= sizeof(FILE_DISPOSITION_INFORMATION))
+        {
+            FILE_DISPOSITION_INFORMATION *info = ptr;
+
+            SERVER_START_REQ( set_fd_disp_info )
+            {
+                req->handle   = wine_server_obj_handle( handle );
+                req->flags    = info->DoDeleteFile ? FILE_DISPOSITION_DELETE : FILE_DISPOSITION_DO_NOT_DELETE;
+                status = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        }
+        else status = STATUS_INVALID_PARAMETER_3;
+        break;
+
+    case FileDispositionInformationEx:
+        if (len >= sizeof(FILE_DISPOSITION_INFORMATION_EX))
+        {
+            FILE_DISPOSITION_INFORMATION_EX *info = ptr;
+
+            if (info->Flags & FILE_DISPOSITION_FORCE_IMAGE_SECTION_CHECK)
+                FIXME( "FILE_DISPOSITION_FORCE_IMAGE_SECTION_CHECK not supported\n" );
+
+            SERVER_START_REQ( set_fd_disp_info )
+            {
+                req->handle   = wine_server_obj_handle( handle );
+                req->flags    = info->Flags;
+                status = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        }
+        else status = STATUS_INVALID_PARAMETER_3;
+        break;
+
+    case FileRenameInformation:
+    case FileRenameInformationEx:
+        if (len >= sizeof(FILE_RENAME_INFORMATION))
+        {
+            FILE_RENAME_INFORMATION *info = ptr;
+            unsigned int flags;
+            UNICODE_STRING name_str, nt_name;
+            OBJECT_ATTRIBUTES attr;
+            char *unix_name;
+
+            if (class == FileRenameInformation)
+                flags = info->ReplaceIfExists ? FILE_RENAME_REPLACE_IF_EXISTS : 0;
+            else
+                flags = info->Flags;
+
+            if (flags & ~(FILE_RENAME_REPLACE_IF_EXISTS | FILE_RENAME_IGNORE_READONLY_ATTRIBUTE))
+                FIXME( "unsupported flags: %#x\n", flags );
+
+            name_str.Buffer = info->FileName;
+            name_str.Length = info->FileNameLength;
+            name_str.MaximumLength = info->FileNameLength + sizeof(WCHAR);
+            InitializeObjectAttributes( &attr, &name_str, OBJ_CASE_INSENSITIVE, info->RootDirectory, NULL );
+            status = get_nt_and_unix_names( &attr, &nt_name, &unix_name, FILE_OPEN_IF );
+            if (status == STATUS_SUCCESS || status == STATUS_NO_SUCH_FILE)
+            {
+                SERVER_START_REQ( set_fd_name_info )
+                {
+                    req->handle   = wine_server_obj_handle( handle );
+                    req->rootdir  = wine_server_obj_handle( attr.RootDirectory );
+                    req->namelen  = attr.ObjectName->Length;
+                    req->link     = FALSE;
+                    req->flags    = flags;
+                    wine_server_add_data( req, attr.ObjectName->Buffer, attr.ObjectName->Length );
+                    wine_server_add_data( req, unix_name, strlen(unix_name) );
+                    status = wine_server_call( req );
+                }
+                SERVER_END_REQ;
+
+            }
+            free( unix_name );
+            free( nt_name.Buffer );
+        }
+        else status = STATUS_INVALID_PARAMETER_3;
+        break;
+
+    case FileLinkInformation:
+    case FileLinkInformationEx:
+        if (len >= sizeof(FILE_LINK_INFORMATION))
+        {
+            FILE_LINK_INFORMATION *info = ptr;
+            unsigned int flags;
+            UNICODE_STRING name_str, nt_name;
+            OBJECT_ATTRIBUTES attr;
+            char *unix_name;
+
+            if (class == FileLinkInformation)
+                flags = info->ReplaceIfExists ? FILE_LINK_REPLACE_IF_EXISTS : 0;
+            else
+                flags = info->Flags;
+
+            if (flags & ~(FILE_LINK_REPLACE_IF_EXISTS | FILE_LINK_IGNORE_READONLY_ATTRIBUTE))
+                FIXME( "unsupported flags: %#x\n", flags );
+
+            name_str.Buffer = info->FileName;
+            name_str.Length = info->FileNameLength;
+            name_str.MaximumLength = info->FileNameLength + sizeof(WCHAR);
+            InitializeObjectAttributes( &attr, &name_str, OBJ_CASE_INSENSITIVE, info->RootDirectory, NULL );
+            status = get_nt_and_unix_names( &attr, &nt_name, &unix_name, FILE_OPEN_IF );
+            if (status == STATUS_SUCCESS || status == STATUS_NO_SUCH_FILE)
+            {
+                SERVER_START_REQ( set_fd_name_info )
+                {
+                    req->handle   = wine_server_obj_handle( handle );
+                    req->rootdir  = wine_server_obj_handle( attr.RootDirectory );
+                    req->namelen  = attr.ObjectName->Length;
+                    req->link     = TRUE;
+                    req->flags    = flags;
+                    wine_server_add_data( req, attr.ObjectName->Buffer, attr.ObjectName->Length );
+                    wine_server_add_data( req, unix_name, strlen(unix_name) );
+                    status  = wine_server_call( req );
+                }
+                SERVER_END_REQ;
+
+            }
+            free( unix_name );
+            free( nt_name.Buffer );
+        }
+        else status = STATUS_INVALID_PARAMETER_3;
+        break;
+
+    default:
+        FIXME("Unsupported class (%d)\n", class);
+        status = STATUS_NOT_IMPLEMENTED;
+        break;
+    }
+    io->Information = 0;
+    return io->Status = status;
+}
+
+
+/***********************************************************************
+ *                  Asynchronous file I/O                              *
+ */
+
+struct async_fileio_read
+{
+    struct async_fileio io;
+    char               *buffer;
+    unsigned int        already;
+    unsigned int        count;
+    BOOL                avail_mode;
+};
+
+struct async_fileio_write
+{
+    struct async_fileio io;
+    const char         *buffer;
+    unsigned int        already;
+    unsigned int        count;
+};
+
+struct async_fileio_read_changes
+{
+    struct async_fileio io;
+    void               *buffer;
+    ULONG               buffer_size;
+    ULONG               data_size;
+    char                data[1];
+};
+
+struct async_irp
+{
+    struct async_fileio io;
+    void               *buffer;   /* buffer for output */
+    ULONG               size;     /* size of buffer */
+};
+
+static struct async_fileio *fileio_freelist;
+
+void release_fileio( struct async_fileio *io )
+{
+    for (;;)
+    {
+        struct async_fileio *next = fileio_freelist;
+        io->next = next;
+        if (InterlockedCompareExchangePointer( (void **)&fileio_freelist, io, next ) == next) return;
+    }
+}
+
+struct async_fileio *alloc_fileio( DWORD size, async_callback_t callback, HANDLE handle )
+{
+    /* first free remaining previous fileinfos */
+    struct async_fileio *io = InterlockedExchangePointer( (void **)&fileio_freelist, NULL );
+
+    while (io)
+    {
+        struct async_fileio *next = io->next;
+        free( io );
+        io = next;
+    }
+
+    if ((io = malloc( size )))
+    {
+        io->callback = callback;
+        io->handle   = handle;
+    }
+    return io;
+}
+
+/* callback for irp async I/O completion */
+static BOOL irp_completion( void *user, ULONG_PTR *info, unsigned int *status )
+{
+    struct async_irp *async = user;
+
+    if (*status == STATUS_ALERTED)
+    {
+        SERVER_START_REQ( get_async_result )
+        {
+            req->user_arg = wine_server_client_ptr( async );
+            wine_server_set_reply( req, async->buffer, async->size );
+            *status = virtual_locked_server_call( req );
+        }
+        SERVER_END_REQ;
+    }
+    release_fileio( &async->io );
+    return TRUE;
+}
+
+static BOOL async_read_proc( void *user, ULONG_PTR *info, unsigned int *status )
+{
+    struct async_fileio_read *fileio = user;
+    int fd, needs_close, result;
+
+    switch (*status)
+    {
+    case STATUS_ALERTED: /* got some new data */
+        /* check to see if the data is ready (non-blocking) */
+        if ((*status = server_get_unix_fd( fileio->io.handle, FILE_READ_DATA, &fd,
+                                          &needs_close, NULL, NULL )))
+            break;
+
+        result = virtual_locked_read(fd, &fileio->buffer[fileio->already], fileio->count-fileio->already);
+        if (needs_close) close( fd );
+
+        if (result < 0)
+        {
+            if (errno == EAGAIN || errno == EINTR)
+                return FALSE;
+
+            /* check to see if the transfer is complete */
+            *status = errno_to_status( errno );
+        }
+        else if (result == 0)
+        {
+            *status = fileio->already ? STATUS_SUCCESS : STATUS_PIPE_BROKEN;
+        }
+        else
+        {
+            fileio->already += result;
+
+            if (fileio->already < fileio->count && !fileio->avail_mode)
+                return FALSE;
+
+            *status = STATUS_SUCCESS;
+        }
+        break;
+
+    case STATUS_TIMEOUT:
+    case STATUS_IO_TIMEOUT:
+        if (fileio->already) *status = STATUS_SUCCESS;
+        break;
+    }
+
+    *info = fileio->already;
+    release_fileio( &fileio->io );
+    return TRUE;
+}
+
+static BOOL async_write_proc( void *user, ULONG_PTR *info, unsigned int *status )
+{
+    struct async_fileio_write *fileio = user;
+    int result, fd, needs_close;
+    enum server_fd_type type;
+
+    switch (*status)
+    {
+    case STATUS_ALERTED:
+        /* write some data (non-blocking) */
+        if ((*status = server_get_unix_fd( fileio->io.handle, FILE_WRITE_DATA, &fd,
+                                          &needs_close, &type, NULL )))
+            break;
+
+        result = write( fd, &fileio->buffer[fileio->already], fileio->count - fileio->already );
+
+        if (needs_close) close( fd );
+
+        if (result < 0)
+        {
+            if (errno == EAGAIN || errno == EINTR) return FALSE;
+            *status = errno_to_status( errno );
+        }
+        else
+        {
+            fileio->already += result;
+            if (fileio->already < fileio->count) return FALSE;
+            *status = STATUS_SUCCESS;
+        }
+        break;
+
+    case STATUS_TIMEOUT:
+    case STATUS_IO_TIMEOUT:
+        if (fileio->already) *status = STATUS_SUCCESS;
+        break;
+    }
+
+    *info = fileio->already;
+    release_fileio( &fileio->io );
+    return TRUE;
+}
+
+static void set_sync_iosb( IO_STATUS_BLOCK *io, NTSTATUS status, ULONG_PTR info, unsigned int options )
+{
+    if (in_wow64_call() && !(options & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT)))
+    {
+        IO_STATUS_BLOCK32 *io32 = io->Pointer;
+
+        io32->Status = status;
+        io32->Information = info;
+    }
+    else
+    {
+        io->Status = status;
+        io->Information = info;
+    }
+}
+
+/* do a read call through the server */
+static unsigned int server_read_file( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_context,
+                                      IO_STATUS_BLOCK *io, void *buffer, ULONG size,
+                                      LARGE_INTEGER *offset, ULONG *key )
+{
+    struct async_irp *async;
+    unsigned int status;
+    HANDLE wait_handle;
+    ULONG options;
+
+    if (!(async = (struct async_irp *)alloc_fileio( sizeof(*async), irp_completion, handle )))
+        return STATUS_NO_MEMORY;
+
+    async->buffer  = buffer;
+    async->size    = size;
+
+    SERVER_START_REQ( read )
+    {
+        req->async = server_async( handle, &async->io, event, apc, apc_context, iosb_client_ptr(io) );
+        req->pos   = offset ? offset->QuadPart : 0;
+        wine_server_set_reply( req, buffer, size );
+        status = virtual_locked_server_call( req );
+        wait_handle = wine_server_ptr_handle( reply->wait );
+        options     = reply->options;
+        if (wait_handle && status != STATUS_PENDING)
+            set_sync_iosb( io, status, wine_server_reply_size( reply ), options );
+    }
+    SERVER_END_REQ;
+
+    if (status != STATUS_PENDING) free( async );
+
+    if (wait_handle) status = wait_async( wait_handle, (options & FILE_SYNCHRONOUS_IO_ALERT) );
+    return status;
+}
+
+/* do a write call through the server */
+static unsigned int server_write_file( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_context,
+                                       IO_STATUS_BLOCK *io, const void *buffer, ULONG size,
+                                       LARGE_INTEGER *offset, ULONG *key )
+{
+    struct async_irp *async;
+    unsigned int status;
+    HANDLE wait_handle;
+    ULONG options;
+
+    if (!(async = (struct async_irp *)alloc_fileio( sizeof(*async), irp_completion, handle )))
+        return STATUS_NO_MEMORY;
+
+    async->buffer  = NULL;
+    async->size    = 0;
+
+    SERVER_START_REQ( write )
+    {
+        req->async = server_async( handle, &async->io, event, apc, apc_context, iosb_client_ptr(io) );
+        req->pos   = offset ? offset->QuadPart : 0;
+        wine_server_add_data( req, buffer, size );
+        status = wine_server_call( req );
+        wait_handle = wine_server_ptr_handle( reply->wait );
+        options     = reply->options;
+        if (wait_handle && status != STATUS_PENDING)
+            set_sync_iosb( io, status, reply->size, options );
+    }
+    SERVER_END_REQ;
+
+    if (status != STATUS_PENDING) free( async );
+
+    if (wait_handle) status = wait_async( wait_handle, (options & FILE_SYNCHRONOUS_IO_ALERT) );
+    return status;
+}
+
+/* do an ioctl call through the server */
+static NTSTATUS server_ioctl_file( HANDLE handle, HANDLE event,
+                                   PIO_APC_ROUTINE apc, PVOID apc_context,
+                                   IO_STATUS_BLOCK *io, UINT code,
+                                   const void *in_buffer, UINT in_size,
+                                   PVOID out_buffer, UINT out_size )
+{
+    struct async_irp *async;
+    unsigned int status;
+    HANDLE wait_handle;
+    ULONG options;
+
+    if (!(async = (struct async_irp *)alloc_fileio( sizeof(*async), irp_completion, handle )))
+        return STATUS_NO_MEMORY;
+    async->buffer  = out_buffer;
+    async->size    = out_size;
+
+    SERVER_START_REQ( ioctl )
+    {
+        req->code        = code;
+        req->async       = server_async( handle, &async->io, event, apc, apc_context, iosb_client_ptr(io) );
+        wine_server_add_data( req, in_buffer, in_size );
+        if ((code & 3) != METHOD_BUFFERED) wine_server_add_data( req, out_buffer, out_size );
+        wine_server_set_reply( req, out_buffer, out_size );
+        status = virtual_locked_server_call( req );
+        wait_handle = wine_server_ptr_handle( reply->wait );
+        options     = reply->options;
+        if (wait_handle && status != STATUS_PENDING)
+            set_sync_iosb( io, status, wine_server_reply_size( reply ), options );
+    }
+    SERVER_END_REQ;
+
+    if (status == STATUS_NOT_SUPPORTED)
+        WARN("Unsupported ioctl %x (device=%x access=%x func=%x method=%x)\n",
+             code, code >> 16, (code >> 14) & 3, (code >> 2) & 0xfff, code & 3);
+
+    if (status != STATUS_PENDING) free( async );
+
+    if (wait_handle) status = wait_async( wait_handle, (options & FILE_SYNCHRONOUS_IO_ALERT) );
+    return status;
+}
+
+
+struct io_timeouts
+{
+    int interval;   /* max interval between two bytes */
+    int total;      /* total timeout for the whole operation */
+    int end_time;   /* absolute time of end of operation */
+};
+
+/* retrieve the I/O timeouts to use for a given handle */
+static unsigned int get_io_timeouts( HANDLE handle, enum server_fd_type type, ULONG count, BOOL is_read,
+                                     struct io_timeouts *timeouts )
+{
+    timeouts->interval = timeouts->total = -1;
+
+    switch(type)
+    {
+    case FD_TYPE_SERIAL:
+    {
+        /* GetCommTimeouts */
+        SERIAL_TIMEOUTS st;
+
+        if (sync_ioctl( handle, IOCTL_SERIAL_GET_TIMEOUTS, NULL, 0, &st, sizeof(st) ))
+            break;
+
+        if (is_read)
+        {
+            if (st.ReadIntervalTimeout)
+                timeouts->interval = st.ReadIntervalTimeout;
+
+            if (st.ReadTotalTimeoutMultiplier || st.ReadTotalTimeoutConstant)
+            {
+                timeouts->total = st.ReadTotalTimeoutConstant;
+                if (st.ReadTotalTimeoutMultiplier != MAXDWORD)
+                    timeouts->total += count * st.ReadTotalTimeoutMultiplier;
+            }
+            else if (st.ReadIntervalTimeout == MAXDWORD)
+                timeouts->interval = timeouts->total = 0;
+        }
+        else  /* write */
+        {
+            if (st.WriteTotalTimeoutMultiplier || st.WriteTotalTimeoutConstant)
+            {
+                timeouts->total = st.WriteTotalTimeoutConstant;
+                if (st.WriteTotalTimeoutMultiplier != MAXDWORD)
+                    timeouts->total += count * st.WriteTotalTimeoutMultiplier;
+            }
+        }
+        break;
+    }
+    case FD_TYPE_SOCKET:
+    case FD_TYPE_CHAR:
+        if (is_read) timeouts->interval = 0;  /* return as soon as we got something */
+        break;
+    default:
+        break;
+    }
+    if (timeouts->total != -1) timeouts->end_time = NtGetTickCount() + timeouts->total;
+    return STATUS_SUCCESS;
+}
+
+
+/* retrieve the timeout for the next wait, in milliseconds */
+static inline int get_next_io_timeout( const struct io_timeouts *timeouts, ULONG already )
+{
+    int ret = -1;
+
+    if (timeouts->total != -1)
+    {
+        ret = timeouts->end_time - NtGetTickCount();
+        if (ret < 0) ret = 0;
+    }
+    if (already && timeouts->interval != -1)
+    {
+        if (ret == -1 || ret > timeouts->interval) ret = timeouts->interval;
+    }
+    return ret;
+}
+
+
+/* retrieve the avail_mode flag for async reads */
+static NTSTATUS get_io_avail_mode( HANDLE handle, enum server_fd_type type, BOOL *avail_mode )
+{
+    NTSTATUS status = STATUS_SUCCESS;
+
+    switch(type)
+    {
+    case FD_TYPE_SERIAL:
+    {
+        /* GetCommTimeouts */
+        SERIAL_TIMEOUTS st;
+
+        if (!(status = sync_ioctl( handle, IOCTL_SERIAL_GET_TIMEOUTS, NULL, 0, &st, sizeof(st) )))
+        {
+            *avail_mode = (!st.ReadTotalTimeoutMultiplier &&
+                           !st.ReadTotalTimeoutConstant &&
+                           st.ReadIntervalTimeout == MAXDWORD);
+        }
+        break;
+    }
+    case FD_TYPE_SOCKET:
+    case FD_TYPE_CHAR:
+        *avail_mode = TRUE;
+        break;
+    default:
+        *avail_mode = FALSE;
+        break;
+    }
+    return status;
+}
+
+/* register an async I/O for a file read; helper for NtReadFile */
+static unsigned int register_async_file_read( HANDLE handle, HANDLE event,
+                                              PIO_APC_ROUTINE apc, void *apc_user,
+                                              client_ptr_t iosb, void *buffer,
+                                              ULONG already, ULONG length, BOOL avail_mode )
+{
+    struct async_fileio_read *fileio;
+    unsigned int status;
+
+    if (!(fileio = (struct async_fileio_read *)alloc_fileio( sizeof(*fileio), async_read_proc, handle )))
+        return STATUS_NO_MEMORY;
+
+    fileio->already = already;
+    fileio->count = length;
+    fileio->buffer = buffer;
+    fileio->avail_mode = avail_mode;
+
+    SERVER_START_REQ( register_async )
+    {
+        req->type   = ASYNC_TYPE_READ;
+        req->count  = length;
+        req->async  = server_async( handle, &fileio->io, event, apc, apc_user, iosb );
+        status = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    if (status != STATUS_PENDING) free( fileio );
+    return status;
+}
+
+static void add_completion( HANDLE handle, ULONG_PTR value, NTSTATUS status, ULONG info, BOOL async )
+{
+    SERVER_START_REQ( add_fd_completion )
+    {
+        req->handle      = wine_server_obj_handle( handle );
+        req->cvalue      = value;
+        req->status      = status;
+        req->information = info;
+        req->async       = async;
+        wine_server_call( req );
+    }
+    SERVER_END_REQ;
+}
+
+/* notify direct completion of async and close the wait handle if it is no longer needed */
+void set_async_direct_result( HANDLE *async_handle, unsigned int options, IO_STATUS_BLOCK *io,
+                              NTSTATUS status, ULONG_PTR information, BOOL mark_pending )
+{
+    unsigned int ret;
+
+    /* if we got STATUS_ALERTED, we must have a valid async handle */
+    assert( *async_handle );
+
+    if (!NT_ERROR(status) && status != STATUS_PENDING)
+        set_sync_iosb( io, status, information, options );
+
+    SERVER_START_REQ( set_async_direct_result )
+    {
+        req->handle       = wine_server_obj_handle( *async_handle );
+        req->status       = status;
+        req->information  = information;
+        req->mark_pending = mark_pending;
+        ret = wine_server_call( req );
+        if (ret == STATUS_SUCCESS)
+            *async_handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+
+    if (ret != STATUS_SUCCESS)
+        ERR( "cannot report I/O result back to server: %#x\n", ret );
+}
+
+/* complete async file I/O, signaling completion in all ways necessary */
+void file_complete_async( HANDLE handle, unsigned int options, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
+                          IO_STATUS_BLOCK *io, NTSTATUS status, ULONG_PTR information )
+{
+    ULONG_PTR iosb_ptr = iosb_client_ptr(io);
+
+    set_sync_iosb( io, status, information, options );
+    if (event) NtSetEvent( event, NULL );
+    if (apc)
+        NtQueueApcThread( GetCurrentThread(), (PNTAPCFUNC)apc, (ULONG_PTR)apc_user, iosb_ptr, 0 );
+    else if (apc_user && !(options & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT)))
+        add_completion( handle, (ULONG_PTR)apc_user, status, information, FALSE );
+}
+
+
+static unsigned int set_pending_write( HANDLE device )
+{
+    unsigned int status;
+
+    SERVER_START_REQ( set_serial_info )
+    {
+        req->handle = wine_server_obj_handle( device );
+        req->flags  = SERIALINFO_PENDING_WRITE;
+        status = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+    return status;
+}
+
+
+/******************************************************************************
+ *              NtReadFile   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtReadFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
+                            IO_STATUS_BLOCK *io, void *buffer, ULONG length,
+                            LARGE_INTEGER *offset, ULONG *key )
+{
+    int result, unix_handle, needs_close;
+    unsigned int options;
+    struct io_timeouts timeouts;
+    unsigned int status, ret_status;
+    UINT total = 0;
+    client_ptr_t iosb_ptr = iosb_client_ptr(io);
+    enum server_fd_type type;
+    ULONG_PTR cvalue = apc ? 0 : (ULONG_PTR)apc_user;
+    BOOL send_completion = FALSE, async_read, timeout_init_done = FALSE;
+
+    TRACE( "(%p,%p,%p,%p,%p,%p,0x%08x,%p,%p)\n",
+           handle, event, apc, apc_user, io, buffer, length, offset, key );
+
+    if (!io) return STATUS_ACCESS_VIOLATION;
+
+    status = server_get_unix_fd( handle, FILE_READ_DATA, &unix_handle, &needs_close, &type, &options );
+    if (status && status != STATUS_BAD_DEVICE_TYPE) return status;
+
+    if (!virtual_check_buffer_for_write( buffer, length )) return STATUS_ACCESS_VIOLATION;
+
+    if (status == STATUS_BAD_DEVICE_TYPE)
+        return server_read_file( handle, event, apc, apc_user, io, buffer, length, offset, key );
+
+    async_read = !(options & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT));
+
+    if (type == FD_TYPE_FILE)
+    {
+        if (async_read && (!offset || offset->QuadPart < 0))
+        {
+            status = STATUS_INVALID_PARAMETER;
+            goto done;
+        }
+
+        if (offset && offset->QuadPart != FILE_USE_FILE_POINTER_POSITION)
+        {
+            /* async I/O doesn't make sense on regular files */
+            while ((result = virtual_locked_pread( unix_handle, buffer, length, offset->QuadPart )) == -1)
+            {
+                if (errno != EINTR)
+                {
+                    status = errno_to_status( errno );
+                    goto done;
+                }
+            }
+            if (!async_read) /* update file pointer position */
+                lseek( unix_handle, offset->QuadPart + result, SEEK_SET );
+
+            total = result;
+            status = (total || !length) ? STATUS_SUCCESS : STATUS_END_OF_FILE;
+            goto done;
+        }
+    }
+    else if (type == FD_TYPE_SERIAL || type == FD_TYPE_DEVICE)
+    {
+        if (async_read && (!offset || offset->QuadPart < 0))
+        {
+            status = STATUS_INVALID_PARAMETER;
+            goto done;
+        }
+    }
+    else if (type == FD_TYPE_SOCKET)
+    {
+        status = sock_read( handle, unix_handle, event, apc, apc_user, io, buffer, length );
+        if (needs_close) close( unix_handle );
+        return status;
+    }
+
+    if (type == FD_TYPE_SERIAL && async_read && length)
+    {
+        /* an asynchronous serial port read with a read interval timeout needs to
+           skip the synchronous read to make sure that the server starts the read
+           interval timer after the first read */
+        if ((status = get_io_timeouts( handle, type, length, TRUE, &timeouts ))) goto err;
+        if (timeouts.interval > 0)
+        {
+            status = register_async_file_read( handle, event, apc, apc_user, iosb_ptr,
+                                               buffer, total, length, FALSE );
+            goto err;
+        }
+    }
+
+    for (;;)
+    {
+        if ((result = virtual_locked_read( unix_handle, (char *)buffer + total, length - total )) >= 0)
+        {
+            total += result;
+            if (!result || total == length)
+            {
+                if (total)
+                {
+                    status = STATUS_SUCCESS;
+                    goto done;
+                }
+                switch (type)
+                {
+                case FD_TYPE_FILE:
+                case FD_TYPE_CHAR:
+                case FD_TYPE_DEVICE:
+                    status = length ? STATUS_END_OF_FILE : STATUS_SUCCESS;
+                    goto done;
+                case FD_TYPE_SERIAL:
+                    if (!length)
+                    {
+                        status = STATUS_SUCCESS;
+                        goto done;
+                    }
+                    break;
+                default:
+                    status = STATUS_PIPE_BROKEN;
+                    goto err;
+                }
+            }
+            else if (type == FD_TYPE_FILE) continue;  /* no async I/O on regular files */
+        }
+        else if (errno != EAGAIN)
+        {
+            if (errno == EINTR) continue;
+            if (!total) status = errno_to_status( errno );
+            goto err;
+        }
+
+        if (async_read)
+        {
+            BOOL avail_mode;
+
+            if ((status = get_io_avail_mode( handle, type, &avail_mode ))) goto err;
+            if (total && avail_mode)
+            {
+                status = STATUS_SUCCESS;
+                goto done;
+            }
+            status = register_async_file_read( handle, event, apc, apc_user, iosb_ptr,
+                                               buffer, total, length, avail_mode );
+            goto err;
+        }
+        else  /* synchronous read, wait for the fd to become ready */
+        {
+            struct pollfd pfd;
+            int ret, timeout;
+
+            if (!timeout_init_done)
+            {
+                timeout_init_done = TRUE;
+                if ((status = get_io_timeouts( handle, type, length, TRUE, &timeouts ))) goto err;
+                if (event) NtResetEvent( event, NULL );
+            }
+            timeout = get_next_io_timeout( &timeouts, total );
+
+            pfd.fd = unix_handle;
+            pfd.events = POLLIN;
+
+            if (!timeout || !(ret = poll( &pfd, 1, timeout )))
+            {
+                if (total)  /* return with what we got so far */
+                    status = STATUS_SUCCESS;
+                else
+                    status = STATUS_TIMEOUT;
+                goto done;
+            }
+            if (ret == -1 && errno != EINTR)
+            {
+                status = errno_to_status( errno );
+                goto done;
+            }
+            /* will now restart the read */
+        }
+    }
+
+done:
+    send_completion = cvalue != 0;
+
+err:
+    if (needs_close) close( unix_handle );
+    if (status == STATUS_SUCCESS || (status == STATUS_END_OF_FILE && (!async_read || type == FD_TYPE_FILE)))
+    {
+        set_sync_iosb( io, status, total, options );
+        TRACE("= SUCCESS (%u)\n", total);
+        if (event) NtSetEvent( event, NULL );
+        if (apc && (!status || async_read)) NtQueueApcThread( GetCurrentThread(), (PNTAPCFUNC)apc,
+                                                              (ULONG_PTR)apc_user, iosb_ptr, 0 );
+    }
+    else
+    {
+        TRACE("= 0x%08x\n", status);
+        if (status != STATUS_PENDING && event) NtResetEvent( event, NULL );
+    }
+
+    ret_status = async_read && type == FD_TYPE_FILE && (status == STATUS_SUCCESS || status == STATUS_END_OF_FILE)
+            ? STATUS_PENDING : status;
+
+    if (send_completion && async_read)
+        add_completion( handle, cvalue, status, total, ret_status == STATUS_PENDING );
+    return ret_status;
+}
+
+
+/******************************************************************************
+ *              NtReadFileScatter   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtReadFileScatter( HANDLE file, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
+                                   IO_STATUS_BLOCK *io, FILE_SEGMENT_ELEMENT *segments,
+                                   ULONG length, LARGE_INTEGER *offset, ULONG *key )
+{
+    int result, unix_handle, needs_close;
+    unsigned int options, status;
+    UINT pos = 0, total = 0;
+    client_ptr_t iosb_ptr = iosb_client_ptr(io);
+    enum server_fd_type type;
+    ULONG_PTR cvalue = apc ? 0 : (ULONG_PTR)apc_user;
+    BOOL send_completion = FALSE;
+
+    TRACE( "(%p,%p,%p,%p,%p,%p,0x%08x,%p,%p),partial stub!\n",
+           file, event, apc, apc_user, io, segments, length, offset, key );
+
+    if (!io) return STATUS_ACCESS_VIOLATION;
+
+    status = server_get_unix_fd( file, FILE_READ_DATA, &unix_handle, &needs_close, &type, &options );
+    if (status) return status;
+
+    if ((type != FD_TYPE_FILE) ||
+        (options & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT)) ||
+        !(options & FILE_NO_INTERMEDIATE_BUFFERING))
+    {
+        status = STATUS_INVALID_PARAMETER;
+        goto error;
+    }
+
+    while (length)
+    {
+        if (offset && offset->QuadPart != FILE_USE_FILE_POINTER_POSITION)
+            result = pread( unix_handle, (char *)segments->Buffer + pos,
+                            min( length - pos, page_size - pos ), offset->QuadPart + total );
+        else
+            result = read( unix_handle, (char *)segments->Buffer + pos, min( length - pos, page_size - pos ) );
+
+        if (result == -1)
+        {
+            if (errno == EINTR) continue;
+            status = errno_to_status( errno );
+            break;
+        }
+        if (!result) break;
+        total += result;
+        length -= result;
+        if ((pos += result) == page_size)
+        {
+            pos = 0;
+            segments++;
+        }
+    }
+
+    if (total == 0) status = STATUS_END_OF_FILE;
+
+    send_completion = cvalue != 0;
+
+    if (needs_close) close( unix_handle );
+    set_sync_iosb( io, status, total, options );
+    TRACE("= 0x%08x (%u)\n", status, total);
+    if (event) NtSetEvent( event, NULL );
+    if (apc) NtQueueApcThread( GetCurrentThread(), (PNTAPCFUNC)apc, (ULONG_PTR)apc_user, iosb_ptr, 0 );
+    if (send_completion) add_completion( file, cvalue, status, total, TRUE );
+
+    return STATUS_PENDING;
+
+error:
+    if (needs_close) close( unix_handle );
+    if (event) NtResetEvent( event, NULL );
+    TRACE("= 0x%08x\n", status);
+    return status;
+}
+
+
+/******************************************************************************
+ *              NtWriteFile   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtWriteFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
+                             IO_STATUS_BLOCK *io, const void *buffer, ULONG length,
+                             LARGE_INTEGER *offset, ULONG *key )
+{
+    int result, unix_handle, needs_close;
+    unsigned int options;
+    struct io_timeouts timeouts;
+    unsigned int status, ret_status;
+    UINT total = 0;
+    client_ptr_t iosb_ptr = iosb_client_ptr(io);
+    enum server_fd_type type;
+    ULONG_PTR cvalue = apc ? 0 : (ULONG_PTR)apc_user;
+    BOOL send_completion = FALSE, async_write, append_write = FALSE, timeout_init_done = FALSE;
+    LARGE_INTEGER offset_eof;
+
+    TRACE( "(%p,%p,%p,%p,%p,%p,0x%08x,%p,%p)\n",
+           handle, event, apc, apc_user, io, buffer, length, offset, key );
+
+    if (!io) return STATUS_ACCESS_VIOLATION;
+
+    status = server_get_unix_fd( handle, FILE_WRITE_DATA, &unix_handle, &needs_close, &type, &options );
+    if (status == STATUS_ACCESS_DENIED)
+    {
+        status = server_get_unix_fd( handle, FILE_APPEND_DATA, &unix_handle,
+                                     &needs_close, &type, &options );
+        append_write = TRUE;
+    }
+    if (status && status != STATUS_BAD_DEVICE_TYPE) return status;
+
+    async_write = !(options & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT));
+
+    if (!virtual_check_buffer_for_read( buffer, length ))
+    {
+        status = STATUS_INVALID_USER_BUFFER;
+        goto done;
+    }
+
+    if (status == STATUS_BAD_DEVICE_TYPE)
+        return server_write_file( handle, event, apc, apc_user, io, buffer, length, offset, key );
+
+    if (type == FD_TYPE_FILE)
+    {
+        if (async_write &&
+            (!offset || (offset->QuadPart < 0 && offset->QuadPart != FILE_WRITE_TO_END_OF_FILE)))
+        {
+            status = STATUS_INVALID_PARAMETER;
+            goto done;
+        }
+
+        if (append_write)
+        {
+            offset_eof.QuadPart = FILE_WRITE_TO_END_OF_FILE;
+            offset = &offset_eof;
+        }
+
+        if (offset && offset->QuadPart != FILE_USE_FILE_POINTER_POSITION)
+        {
+            off_t off = offset->QuadPart;
+
+            if (offset->QuadPart == FILE_WRITE_TO_END_OF_FILE)
+            {
+                struct stat st;
+
+                if (fstat( unix_handle, &st ) == -1)
+                {
+                    status = errno_to_status( errno );
+                    goto done;
+                }
+                off = st.st_size;
+            }
+            else if (offset->QuadPart < 0)
+            {
+                status = STATUS_INVALID_PARAMETER;
+                goto done;
+            }
+
+            /* async I/O doesn't make sense on regular files */
+            while ((result = pwrite( unix_handle, buffer, length, off )) == -1)
+            {
+                if (errno != EINTR)
+                {
+                    if (errno == EFAULT) status = STATUS_INVALID_USER_BUFFER;
+                    else status = errno_to_status( errno );
+                    goto done;
+                }
+            }
+
+            if (!async_write) /* update file pointer position */
+                lseek( unix_handle, off + result, SEEK_SET );
+
+            total = result;
+            status = STATUS_SUCCESS;
+            goto done;
+        }
+    }
+    else if (type == FD_TYPE_SERIAL || type == FD_TYPE_DEVICE)
+    {
+        if (async_write &&
+            (!offset || (offset->QuadPart < 0 && offset->QuadPart != FILE_WRITE_TO_END_OF_FILE)))
+        {
+            status = STATUS_INVALID_PARAMETER;
+            goto done;
+        }
+    }
+    else if (type == FD_TYPE_SOCKET)
+    {
+        status = sock_write( handle, unix_handle, event, apc, apc_user, io, buffer, length );
+        if (needs_close) close( unix_handle );
+        return status;
+    }
+
+    for (;;)
+    {
+        result = write( unix_handle, (const char *)buffer + total, length - total );
+
+        if (result >= 0)
+        {
+            total += result;
+            if (total == length)
+            {
+                status = STATUS_SUCCESS;
+                goto done;
+            }
+            if (type == FD_TYPE_FILE) continue;  /* no async I/O on regular files */
+        }
+        else if (errno != EAGAIN)
+        {
+            if (errno == EINTR) continue;
+            if (!total)
+            {
+                if (errno == EFAULT) status = STATUS_INVALID_USER_BUFFER;
+                else status = errno_to_status( errno );
+            }
+            goto err;
+        }
+
+        if (async_write)
+        {
+            struct async_fileio_write *fileio;
+
+            fileio = (struct async_fileio_write *)alloc_fileio( sizeof(*fileio), async_write_proc, handle );
+            if (!fileio)
+            {
+                status = STATUS_NO_MEMORY;
+                goto err;
+            }
+            fileio->already = total;
+            fileio->count = length;
+            fileio->buffer = buffer;
+
+            SERVER_START_REQ( register_async )
+            {
+                req->type   = ASYNC_TYPE_WRITE;
+                req->count  = length;
+                req->async  = server_async( handle, &fileio->io, event, apc, apc_user, iosb_ptr );
+                status = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+
+            if (status != STATUS_PENDING) free( fileio );
+            goto err;
+        }
+        else  /* synchronous write, wait for the fd to become ready */
+        {
+            struct pollfd pfd;
+            int ret, timeout;
+
+            if (!timeout_init_done)
+            {
+                timeout_init_done = TRUE;
+                if ((status = get_io_timeouts( handle, type, length, FALSE, &timeouts )))
+                    goto err;
+                if (event) NtResetEvent( event, NULL );
+            }
+            timeout = get_next_io_timeout( &timeouts, total );
+
+            pfd.fd = unix_handle;
+            pfd.events = POLLOUT;
+
+            if (!timeout || !(ret = poll( &pfd, 1, timeout )))
+            {
+                /* return with what we got so far */
+                status = total ? STATUS_SUCCESS : STATUS_TIMEOUT;
+                goto done;
+            }
+            if (ret == -1 && errno != EINTR)
+            {
+                status = errno_to_status( errno );
+                goto done;
+            }
+            /* will now restart the write */
+        }
+    }
+
+done:
+    send_completion = cvalue != 0;
+
+err:
+    if (needs_close) close( unix_handle );
+
+    if (type == FD_TYPE_SERIAL && (status == STATUS_SUCCESS || status == STATUS_PENDING))
+        set_pending_write( handle );
+
+    if (status == STATUS_SUCCESS)
+    {
+        set_sync_iosb( io, status, total, options );
+        TRACE("= SUCCESS (%u)\n", total);
+        if (event) NtSetEvent( event, NULL );
+        if (apc) NtQueueApcThread( GetCurrentThread(), (PNTAPCFUNC)apc, (ULONG_PTR)apc_user, iosb_ptr, 0 );
+    }
+    else
+    {
+        TRACE("= 0x%08x\n", status);
+        if (status != STATUS_PENDING && event) NtResetEvent( event, NULL );
+    }
+
+    ret_status = async_write && type == FD_TYPE_FILE && status == STATUS_SUCCESS ? STATUS_PENDING : status;
+    if (send_completion && async_write)
+        add_completion( handle, cvalue, status, total, ret_status == STATUS_PENDING );
+    return ret_status;
+}
+
+
+/******************************************************************************
+ *              NtWriteFileGather   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtWriteFileGather( HANDLE file, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
+                                   IO_STATUS_BLOCK *io, FILE_SEGMENT_ELEMENT *segments,
+                                   ULONG length, LARGE_INTEGER *offset, ULONG *key )
+{
+    int result, unix_handle, needs_close;
+    unsigned int options, status;
+    UINT pos = 0, total = 0;
+    enum server_fd_type type;
+
+    TRACE( "(%p,%p,%p,%p,%p,%p,0x%08x,%p,%p),partial stub!\n",
+           file, event, apc, apc_user, io, segments, length, offset, key );
+
+    if (length % page_size) return STATUS_INVALID_PARAMETER;
+    if (!io) return STATUS_ACCESS_VIOLATION;
+
+    status = server_get_unix_fd( file, FILE_WRITE_DATA, &unix_handle, &needs_close, &type, &options );
+    if (status) return status;
+
+    if ((type != FD_TYPE_FILE) ||
+        (options & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT)) ||
+        !(options & FILE_NO_INTERMEDIATE_BUFFERING))
+    {
+        status = STATUS_INVALID_PARAMETER;
+        goto done;
+    }
+
+    while (length)
+    {
+        if (offset && offset->QuadPart != FILE_USE_FILE_POINTER_POSITION)
+            result = pwrite( unix_handle, (char *)segments->Buffer + pos,
+                             page_size - pos, offset->QuadPart + total );
+        else
+            result = write( unix_handle, (char *)segments->Buffer + pos, page_size - pos );
+
+        if (result == -1)
+        {
+            if (errno == EINTR) continue;
+            if (errno == EFAULT)
+            {
+                status = STATUS_INVALID_USER_BUFFER;
+                goto done;
+            }
+            status = errno_to_status( errno );
+            break;
+        }
+        if (!result)
+        {
+            status = STATUS_DISK_FULL;
+            break;
+        }
+        total += result;
+        length -= result;
+        if ((pos += result) == page_size)
+        {
+            pos = 0;
+            segments++;
+        }
+    }
+
+ done:
+    if (needs_close) close( unix_handle );
+    if (status == STATUS_SUCCESS)
+    {
+        file_complete_async( file, options, event, apc, apc_user, io, status, total );
+        TRACE("= SUCCESS (%u)\n", total);
+    }
+    else
+    {
+        TRACE("= 0x%08x\n", status);
+        if (status != STATUS_PENDING && event) NtResetEvent( event, NULL );
+    }
+    return status;
+}
+
+
+/******************************************************************************
+ *              NtDeviceIoControlFile   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtDeviceIoControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_context,
+                                       IO_STATUS_BLOCK *io, ULONG code, void *in_buffer, ULONG in_size,
+                                       void *out_buffer, ULONG out_size )
+{
+    ULONG device = (code >> 16);
+    NTSTATUS status = STATUS_NOT_SUPPORTED;
+
+    TRACE( "(%p,%p,%p,%p,%p,0x%08x,%p,0x%08x,%p,0x%08x)\n",
+           handle, event, apc, apc_context, io, code,
+           in_buffer, in_size, out_buffer, out_size );
+
+    /* some broken applications call this frequently with INVALID_HANDLE_VALUE,
+     * and run slowly if we make a server call every time */
+    if (HandleToLong( handle ) == ~0)
+        return STATUS_INVALID_HANDLE;
+
+    switch (device)
+    {
+    case FILE_DEVICE_BEEP:
+    case FILE_DEVICE_NETWORK:
+        status = sock_ioctl( handle, event, apc, apc_context, io, code, in_buffer, in_size, out_buffer, out_size );
+        break;
+    case FILE_DEVICE_DISK:
+    case FILE_DEVICE_CD_ROM:
+    case FILE_DEVICE_DVD:
+    case FILE_DEVICE_CONTROLLER:
+    case FILE_DEVICE_MASS_STORAGE:
+        status = cdrom_DeviceIoControl( handle, event, apc, apc_context, io, code,
+                                        in_buffer, in_size, out_buffer, out_size );
+        break;
+    case FILE_DEVICE_SERIAL_PORT:
+        status = serial_DeviceIoControl( handle, event, apc, apc_context, io, code,
+                                         in_buffer, in_size, out_buffer, out_size );
+        break;
+    case FILE_DEVICE_TAPE:
+        status = tape_DeviceIoControl( handle, event, apc, apc_context, io, code,
+                                       in_buffer, in_size, out_buffer, out_size );
+        break;
+    }
+
+    if (status == STATUS_NOT_SUPPORTED || status == STATUS_BAD_DEVICE_TYPE)
+        return server_ioctl_file( handle, event, apc, apc_context, io, code,
+                                  in_buffer, in_size, out_buffer, out_size );
+    return status;
+}
+
+
+/* helper for internal ioctl calls */
+NTSTATUS sync_ioctl( HANDLE file, ULONG code, void *in_buffer, ULONG in_size, void *out_buffer, ULONG out_size )
+{
+    IO_STATUS_BLOCK32 io32;
+    IO_STATUS_BLOCK io;
+
+    /* the 32-bit iosb is filled for overlapped file handles */
+    io.Pointer = &io32;
+    return NtDeviceIoControlFile( file, NULL, NULL, NULL, &io, code, in_buffer, in_size, out_buffer, out_size );
+}
+
+
+/* Tell Valgrind to ignore any holes in structs we will be passing to the
+ * server */
+static void ignore_server_ioctl_struct_holes( ULONG code, const void *in_buffer, ULONG in_size )
+{
+#ifdef VALGRIND_MAKE_MEM_DEFINED
+# define IGNORE_STRUCT_HOLE(buf, size, t, f1, f2) \
+    do { \
+        if (FIELD_OFFSET(t, f1) + sizeof(((t *)0)->f1) < FIELD_OFFSET(t, f2)) \
+            if ((size) >= FIELD_OFFSET(t, f2)) \
+                VALGRIND_MAKE_MEM_DEFINED( \
+                    (const char *)(buf) + FIELD_OFFSET(t, f1) + sizeof(((t *)0)->f1), \
+                    FIELD_OFFSET(t, f2) - FIELD_OFFSET(t, f1) + sizeof(((t *)0)->f1)); \
+    } while (0)
+
+    switch (code)
+    {
+    case FSCTL_PIPE_WAIT:
+        IGNORE_STRUCT_HOLE(in_buffer, in_size, FILE_PIPE_WAIT_FOR_BUFFER, TimeoutSpecified, Name);
+        break;
+    }
+#endif
+}
+
+
+/******************************************************************************
+ *              NtFsControlFile   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtFsControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_context,
+                                 IO_STATUS_BLOCK *io, ULONG code, void *in_buffer, ULONG in_size,
+                                 void *out_buffer, ULONG out_size )
+{
+    unsigned int options;
+    int fd, needs_close;
+    ULONG_PTR size = 0;
+    NTSTATUS status;
+
+    TRACE( "(%p,%p,%p,%p,%p,0x%08x,%p,0x%08x,%p,0x%08x)\n",
+           handle, event, apc, apc_context, io, code,
+           in_buffer, in_size, out_buffer, out_size );
+
+    if (!io) return STATUS_INVALID_PARAMETER;
+
+    status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, &options );
+    if (status && status != STATUS_BAD_DEVICE_TYPE)
+        return status;
+    if (needs_close) close( fd );
+
+    ignore_server_ioctl_struct_holes( code, in_buffer, in_size );
+
+    switch (code)
+    {
+    case FSCTL_DISMOUNT_VOLUME:
+        status = server_ioctl_file( handle, event, apc, apc_context, io, code,
+                                    in_buffer, in_size, out_buffer, out_size );
+        if (!status) status = unmount_device( handle );
+        return status;
+
+    case FSCTL_PIPE_IMPERSONATE:
+        FIXME("FSCTL_PIPE_IMPERSONATE: impersonating self\n");
+        return server_ioctl_file( handle, event, apc, apc_context, io, code,
+                                  in_buffer, in_size, out_buffer, out_size );
+
+    case FSCTL_IS_VOLUME_MOUNTED:
+    case FSCTL_LOCK_VOLUME:
+    case FSCTL_UNLOCK_VOLUME:
+        FIXME("stub! return success - Unsupported fsctl %x (device=%x access=%x func=%x method=%x)\n",
+              code, code >> 16, (code >> 14) & 3, (code >> 2) & 0xfff, code & 3);
+        status = STATUS_SUCCESS;
+        break;
+
+    case FSCTL_GET_RETRIEVAL_POINTERS:
+    {
+        RETRIEVAL_POINTERS_BUFFER *buffer = (RETRIEVAL_POINTERS_BUFFER *)out_buffer;
+
+        FIXME("stub: FSCTL_GET_RETRIEVAL_POINTERS\n");
+
+        if (out_size >= sizeof(RETRIEVAL_POINTERS_BUFFER))
+        {
+            buffer->ExtentCount                 = 1;
+            buffer->StartingVcn.QuadPart        = 1;
+            buffer->Extents[0].NextVcn.QuadPart = 0;
+            buffer->Extents[0].Lcn.QuadPart     = 0;
+            size = sizeof(RETRIEVAL_POINTERS_BUFFER);
+            status = STATUS_SUCCESS;
+        }
+        else
+        {
+            status = STATUS_BUFFER_TOO_SMALL;
+        }
+        break;
+    }
+
+    case FSCTL_GET_REPARSE_POINT:
+        if (out_buffer && out_size)
+        {
+            FIXME("FSCTL_GET_REPARSE_POINT semi-stub\n");
+            status = STATUS_NOT_A_REPARSE_POINT;
+        }
+        else status = STATUS_INVALID_USER_BUFFER;
+        break;
+
+    case FSCTL_GET_OBJECT_ID:
+    {
+        FILE_OBJECTID_BUFFER *info = out_buffer;
+        int fd, needs_close;
+        struct stat st;
+
+        if (out_size >= sizeof(*info))
+        {
+            status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL );
+            if (status) break;
+            fstat( fd, &st );
+            if (needs_close) close( fd );
+            memset( info, 0, sizeof(*info) );
+            memcpy( info->ObjectId, &st.st_dev, sizeof(st.st_dev) );
+            memcpy( info->ObjectId + 8, &st.st_ino, sizeof(st.st_ino) );
+            size = sizeof(*info);
+        }
+        else status = STATUS_BUFFER_TOO_SMALL;
+        break;
+    }
+
+    case FSCTL_SET_SPARSE:
+        TRACE("FSCTL_SET_SPARSE: Ignoring request\n");
+        status = STATUS_SUCCESS;
+        break;
+    default:
+        return server_ioctl_file( handle, event, apc, apc_context, io, code,
+                                  in_buffer, in_size, out_buffer, out_size );
+    }
+
+    if (!NT_ERROR(status) && status != STATUS_PENDING)
+        file_complete_async( handle, options, event, apc, apc_context, io, status, size );
+    return status;
+}
+
+
+/******************************************************************************
+ *              NtFlushBuffersFile   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtFlushBuffersFile( HANDLE handle, IO_STATUS_BLOCK *io )
+{
+    return NtFlushBuffersFileEx( handle, 0, NULL, 0, io );
+}
+
+
+/******************************************************************************
+ *              NtFlushBuffersFileEx   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtFlushBuffersFileEx( HANDLE handle, ULONG flags, void *params, ULONG size, IO_STATUS_BLOCK *io )
+{
+    NTSTATUS ret;
+    HANDLE wait_handle;
+    enum server_fd_type type;
+    int fd, needs_close;
+
+    TRACE( "(%p,0x%08x,%p,0x%08x,%p)\n", handle, flags, params, size, io );
+
+    if (flags) FIXME( "flags 0x%08x ignored\n", flags );
+    if (params || size) FIXME( "params %p/0x%08x ignored\n", params, size );
+
+    if (!io || !virtual_check_buffer_for_write( io, sizeof(*io) )) return STATUS_ACCESS_VIOLATION;
+
+    ret = server_get_unix_fd( handle, FILE_WRITE_DATA, &fd, &needs_close, &type, NULL );
+    if (ret == STATUS_ACCESS_DENIED)
+        ret = server_get_unix_fd( handle, FILE_APPEND_DATA, &fd, &needs_close, &type, NULL );
+
+    if (!ret && (type == FD_TYPE_FILE || type == FD_TYPE_DIR || type == FD_TYPE_CHAR))
+    {
+        if (fsync(fd)) ret = errno_to_status( errno );
+        io->Status      = ret;
+        io->Information = 0;
+    }
+    else if (!ret && type == FD_TYPE_SERIAL)
+    {
+        ret = serial_FlushBuffersFile( fd );
+    }
+    else if (ret != STATUS_ACCESS_DENIED)
+    {
+        struct async_irp *async;
+
+        if (!(async = (struct async_irp *)alloc_fileio( sizeof(*async), irp_completion, handle )))
+            return STATUS_NO_MEMORY;
+        async->buffer  = NULL;
+        async->size    = 0;
+
+        SERVER_START_REQ( flush )
+        {
+            req->async = server_async( handle, &async->io, NULL, NULL, NULL, iosb_client_ptr(io) );
+            ret = wine_server_call( req );
+            wait_handle = wine_server_ptr_handle( reply->event );
+            if (wait_handle && ret != STATUS_PENDING)
+            {
+                io->Status      = ret;
+                io->Information = 0;
+            }
+        }
+        SERVER_END_REQ;
+
+        if (ret != STATUS_PENDING) free( async );
+
+        if (wait_handle) ret = wait_async( wait_handle, FALSE );
+    }
+
+    if (needs_close) close( fd );
+    return ret;
+}
+
+
+/**************************************************************************
+ *           NtCancelIoFile   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtCancelIoFile( HANDLE handle, IO_STATUS_BLOCK *io_status )
+{
+    unsigned int status;
+
+    TRACE( "%p %p\n", handle, io_status );
+
+    SERVER_START_REQ( cancel_async )
+    {
+        req->handle      = wine_server_obj_handle( handle );
+        req->only_thread = TRUE;
+        if (!(status = wine_server_call( req )))
+        {
+            io_status->Status = status;
+            io_status->Information = 0;
+        }
+    }
+    SERVER_END_REQ;
+
+    return status;
+}
+
+
+/**************************************************************************
+ *           NtCancelIoFileEx   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtCancelIoFileEx( HANDLE handle, IO_STATUS_BLOCK *io, IO_STATUS_BLOCK *io_status )
+{
+    unsigned int status;
+
+    TRACE( "%p %p %p\n", handle, io, io_status );
+
+    SERVER_START_REQ( cancel_async )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        req->iosb   = wine_server_client_ptr( io );
+        if (!(status = wine_server_call( req )))
+        {
+            io_status->Status = status;
+            io_status->Information = 0;
+        }
+    }
+    SERVER_END_REQ;
+
+    return status;
+}
+
+
+/**************************************************************************
+ *           NtCancelSynchronousIoFile (NTDLL.@)
+ */
+NTSTATUS WINAPI NtCancelSynchronousIoFile( HANDLE handle, IO_STATUS_BLOCK *io, IO_STATUS_BLOCK *io_status )
+{
+    unsigned int status;
+
+    TRACE( "(%p %p %p)\n", handle, io, io_status );
+
+    SERVER_START_REQ( cancel_sync )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        req->iosb   = wine_server_client_ptr( io );
+        status = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    io_status->Status = status;
+    io_status->Information = 0;
+    return status;
+}
+
+/******************************************************************
+ *           NtLockFile   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtLockFile( HANDLE file, HANDLE event, PIO_APC_ROUTINE apc, void* apc_user,
+                            IO_STATUS_BLOCK *io_status, LARGE_INTEGER *offset,
+                            LARGE_INTEGER *count, ULONG *key, BOOLEAN dont_wait, BOOLEAN exclusive )
+{
+    static int warn;
+    unsigned int ret;
+    HANDLE handle;
+    BOOLEAN async;
+
+    if (apc || io_status || key)
+    {
+        FIXME("Unimplemented yet parameter\n");
+        return STATUS_NOT_IMPLEMENTED;
+    }
+    if (apc_user && !warn++) FIXME("I/O completion on lock not implemented yet\n");
+
+    for (;;)
+    {
+        SERVER_START_REQ( lock_file )
+        {
+            req->handle      = wine_server_obj_handle( file );
+            req->offset      = offset->QuadPart;
+            req->count       = count->QuadPart;
+            req->shared      = !exclusive;
+            req->wait        = !dont_wait;
+            ret = wine_server_call( req );
+            handle = wine_server_ptr_handle( reply->handle );
+            async  = reply->overlapped;
+        }
+        SERVER_END_REQ;
+        if (ret != STATUS_PENDING)
+        {
+            if (!ret && event) NtSetEvent( event, NULL );
+            return ret;
+        }
+        if (async)
+        {
+            FIXME( "Async I/O lock wait not implemented, might deadlock\n" );
+            if (handle) NtClose( handle );
+            return STATUS_PENDING;
+        }
+        if (handle)
+        {
+            NtWaitForSingleObject( handle, FALSE, NULL );
+            NtClose( handle );
+        }
+        else  /* Unix lock conflict, sleep a bit and retry */
+        {
+            LARGE_INTEGER time;
+            time.QuadPart = -100 * (ULONGLONG)10000;
+            NtDelayExecution( FALSE, &time );
+        }
+    }
+}
+
+
+/******************************************************************
+ *           NtUnlockFile   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtUnlockFile( HANDLE handle, IO_STATUS_BLOCK *io_status, LARGE_INTEGER *offset,
+                              LARGE_INTEGER *count, ULONG *key )
+{
+    unsigned int status;
+
+    TRACE( "%p %s %s\n",
+           handle, wine_dbgstr_longlong(offset->QuadPart), wine_dbgstr_longlong(count->QuadPart) );
+
+    if (io_status || key)
+    {
+        FIXME("Unimplemented yet parameter\n");
+        return STATUS_NOT_IMPLEMENTED;
+    }
+
+    SERVER_START_REQ( unlock_file )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        req->offset = offset->QuadPart;
+        req->count  = count->QuadPart;
+        status = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+    return status;
+}
+
+
+static BOOL read_changes_apc( void *user, ULONG_PTR *info, unsigned int *status )
+{
+    struct async_fileio_read_changes *fileio = user;
+    int size = 0;
+
+    if (*status == STATUS_ALERTED)
+    {
+        SERVER_START_REQ( read_change )
+        {
+            req->handle = wine_server_obj_handle( fileio->io.handle );
+            wine_server_set_reply( req, fileio->data, fileio->data_size );
+            *status = wine_server_call( req );
+            size = wine_server_reply_size( reply );
+        }
+        SERVER_END_REQ;
+
+        if (*status == STATUS_SUCCESS && fileio->buffer)
+        {
+            FILE_NOTIFY_INFORMATION *pfni = fileio->buffer;
+            int i, left = fileio->buffer_size;
+            DWORD *last_entry_offset = NULL;
+            struct filesystem_event *event = (struct filesystem_event*)fileio->data;
+
+            while (size && left >= sizeof(*pfni))
+            {
+                DWORD len = (left - offsetof(FILE_NOTIFY_INFORMATION, FileName)) / sizeof(WCHAR);
+
+                /* convert to an NT style path */
+                for (i = 0; i < event->len; i++)
+                    if (event->name[i] == '/') event->name[i] = '\\';
+
+                pfni->Action = event->action;
+                pfni->FileNameLength = ntdll_umbstowcs( event->name, event->len, pfni->FileName, len );
+                last_entry_offset = &pfni->NextEntryOffset;
+
+                if (pfni->FileNameLength == len) break;
+
+                i = offsetof(FILE_NOTIFY_INFORMATION, FileName[pfni->FileNameLength]);
+                pfni->FileNameLength *= sizeof(WCHAR);
+                pfni->NextEntryOffset = i;
+                pfni = (FILE_NOTIFY_INFORMATION*)((char*)pfni + i);
+                left -= i;
+
+                i = (offsetof(struct filesystem_event, name[event->len])
+                     + sizeof(int)-1) / sizeof(int) * sizeof(int);
+                event = (struct filesystem_event*)((char*)event + i);
+                size -= i;
+            }
+
+            if (size)
+            {
+                *status = STATUS_NOTIFY_ENUM_DIR;
+                size = 0;
+            }
+            else
+            {
+                if (last_entry_offset) *last_entry_offset = 0;
+                size = fileio->buffer_size - left;
+            }
+        }
+        else
+        {
+            *status = STATUS_NOTIFY_ENUM_DIR;
+            size = 0;
+        }
+    }
+
+    *info = size;
+    release_fileio( &fileio->io );
+    return TRUE;
+}
+
+#define FILE_NOTIFY_ALL        (  \
+ FILE_NOTIFY_CHANGE_FILE_NAME   | \
+ FILE_NOTIFY_CHANGE_DIR_NAME    | \
+ FILE_NOTIFY_CHANGE_ATTRIBUTES  | \
+ FILE_NOTIFY_CHANGE_SIZE        | \
+ FILE_NOTIFY_CHANGE_LAST_WRITE  | \
+ FILE_NOTIFY_CHANGE_LAST_ACCESS | \
+ FILE_NOTIFY_CHANGE_CREATION    | \
+ FILE_NOTIFY_CHANGE_SECURITY   )
+
+/******************************************************************************
+ *              NtNotifyChangeDirectoryFile   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtNotifyChangeDirectoryFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc,
+                                             void *apc_context, IO_STATUS_BLOCK *iosb, void *buffer,
+                                             ULONG buffer_size, ULONG filter, BOOLEAN subtree )
+{
+    struct async_fileio_read_changes *fileio;
+    unsigned int status;
+    ULONG size = max( 4096, buffer_size );
+
+    TRACE( "%p %p %p %p %p %p %u %u %d\n",
+           handle, event, apc, apc_context, iosb, buffer, buffer_size, filter, subtree );
+
+    if (!iosb) return STATUS_ACCESS_VIOLATION;
+    if (filter == 0 || (filter & ~FILE_NOTIFY_ALL)) return STATUS_INVALID_PARAMETER;
+
+    fileio = (struct async_fileio_read_changes *)alloc_fileio(
+        offsetof(struct async_fileio_read_changes, data[size]), read_changes_apc, handle );
+    if (!fileio) return STATUS_NO_MEMORY;
+
+    fileio->buffer      = buffer;
+    fileio->buffer_size = buffer_size;
+    fileio->data_size   = size;
+
+    SERVER_START_REQ( read_directory_changes )
+    {
+        req->filter    = filter;
+        req->want_data = (buffer != NULL);
+        req->subtree   = subtree;
+        req->async     = server_async( handle, &fileio->io, event, apc, apc_context, iosb_client_ptr(iosb) );
+        status = wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    if (status != STATUS_PENDING) free( fileio );
+    return status;
+}
+
+
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__) || defined(__APPLE__)
+/* helper for FILE_GetDeviceInfo to hide some platform differences in fstatfs */
+static inline void get_device_info_fstatfs( FILE_FS_DEVICE_INFORMATION *info, const char *fstypename,
+                                            unsigned int flags )
+{
+    if (!strcmp("cd9660", fstypename) || !strcmp("udf", fstypename))
+    {
+        info->DeviceType = FILE_DEVICE_CD_ROM_FILE_SYSTEM;
+        /* Don't assume read-only, let the mount options set it below */
+        info->Characteristics |= FILE_REMOVABLE_MEDIA;
+    }
+    else if (!strcmp("nfs", fstypename) || !strcmp("nwfs", fstypename) ||
+             !strcmp("smbfs", fstypename) || !strcmp("afpfs", fstypename))
+    {
+        info->DeviceType = FILE_DEVICE_NETWORK_FILE_SYSTEM;
+        info->Characteristics |= FILE_REMOTE_DEVICE;
+    }
+    else if (!strcmp("procfs", fstypename))
+        info->DeviceType = FILE_DEVICE_VIRTUAL_DISK;
+    else
+        info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
+
+    if (flags & MNT_RDONLY)
+        info->Characteristics |= FILE_READ_ONLY_DEVICE;
+
+    if (!(flags & MNT_LOCAL))
+    {
+        info->DeviceType = FILE_DEVICE_NETWORK_FILE_SYSTEM;
+        info->Characteristics |= FILE_REMOTE_DEVICE;
+    }
+}
+#endif
+
+static inline BOOL is_device_placeholder( int fd )
+{
+    static const char wine_placeholder[] = "Wine device placeholder";
+    char buffer[sizeof(wine_placeholder)-1];
+
+    if (pread( fd, buffer, sizeof(wine_placeholder) - 1, 0 ) != sizeof(wine_placeholder) - 1)
+        return FALSE;
+    return !memcmp( buffer, wine_placeholder, sizeof(wine_placeholder) - 1 );
+}
+
+NTSTATUS get_device_info( int fd, FILE_FS_DEVICE_INFORMATION *info )
+{
+    struct stat st;
+
+    info->Characteristics = 0;
+    if (fstat( fd, &st ) < 0) return errno_to_status( errno );
+    if (S_ISCHR( st.st_mode ))
+    {
+        info->DeviceType = FILE_DEVICE_UNKNOWN;
+#ifdef linux
+        switch(major(st.st_rdev))
+        {
+        case MEM_MAJOR:
+            info->DeviceType = FILE_DEVICE_NULL;
+            break;
+        case TTY_MAJOR:
+            info->DeviceType = FILE_DEVICE_SERIAL_PORT;
+            break;
+        case LP_MAJOR:
+            info->DeviceType = FILE_DEVICE_PARALLEL_PORT;
+            break;
+        case SCSI_TAPE_MAJOR:
+            info->DeviceType = FILE_DEVICE_TAPE;
+            break;
+        }
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__APPLE__)
+        {
+            int d_type;
+            if (ioctl(fd, FIODTYPE, &d_type) == 0)
+            {
+                switch(d_type)
+                {
+                case D_TAPE:
+                    info->DeviceType = FILE_DEVICE_TAPE;
+                    break;
+                case D_DISK:
+                    info->DeviceType = FILE_DEVICE_DISK;
+#if defined(__APPLE__)
+                    if (major(st.st_rdev) == 3 && minor(st.st_rdev) == 2) info->DeviceType = FILE_DEVICE_NULL;
+#endif
+                    break;
+                case D_TTY:
+                    info->DeviceType = FILE_DEVICE_SERIAL_PORT;
+                    break;
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+                case D_MEM:
+                    info->DeviceType = FILE_DEVICE_NULL;
+                    break;
+#endif
+                }
+                /* no special d_type for parallel ports */
+            }
+        }
+#endif
+    }
+    else if (S_ISBLK( st.st_mode ))
+    {
+        info->DeviceType = FILE_DEVICE_DISK;
+    }
+    else if (S_ISFIFO( st.st_mode ) || S_ISSOCK( st.st_mode ))
+    {
+        info->DeviceType = FILE_DEVICE_NAMED_PIPE;
+    }
+    else if (is_device_placeholder( fd ))
+    {
+        info->DeviceType = FILE_DEVICE_DISK;
+    }
+    else  /* regular file or directory */
+    {
+#if defined(linux) && defined(HAVE_FSTATFS)
+        struct statfs stfs;
+
+        /* check for floppy disk */
+        if (major(st.st_dev) == FLOPPY_MAJOR)
+            info->Characteristics |= FILE_REMOVABLE_MEDIA;
+
+        if (fstatfs( fd, &stfs ) < 0) stfs.f_type = 0;
+        switch (stfs.f_type)
+        {
+        case 0x9660:      /* iso9660 */
+        case 0x9fa1:      /* supermount */
+        case 0x15013346:  /* udf */
+            info->DeviceType = FILE_DEVICE_CD_ROM_FILE_SYSTEM;
+            info->Characteristics |= FILE_REMOVABLE_MEDIA|FILE_READ_ONLY_DEVICE;
+            break;
+        case 0x6969:  /* nfs */
+        case 0xff534d42: /* cifs */
+        case 0xfe534d42: /* smb2 */
+        case 0x517b:  /* smbfs */
+        case 0x564c:  /* ncpfs */
+            info->DeviceType = FILE_DEVICE_NETWORK_FILE_SYSTEM;
+            info->Characteristics |= FILE_REMOTE_DEVICE;
+            break;
+        case 0x1373:      /* devfs */
+        case 0x9fa0:      /* procfs */
+            info->DeviceType = FILE_DEVICE_VIRTUAL_DISK;
+            break;
+        case 0x01021994:  /* tmpfs */
+        case 0x28cd3d45:  /* cramfs */
+            /* Don't map these to FILE_DEVICE_VIRTUAL_DISK by default. Virtual
+             * filesystems are rare on Windows, and some programs refuse to
+             * recognize them as valid. */
+        default:
+            info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
+            break;
+        }
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__OpenBSD__) || defined(__DragonFly__) || defined(__APPLE__)
+        struct statfs stfs;
+
+        if (fstatfs( fd, &stfs ) < 0)
+            info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
+        else
+            get_device_info_fstatfs( info, stfs.f_fstypename, stfs.f_flags );
+#elif defined(__NetBSD__)
+        struct statvfs stfs;
+
+        if (fstatvfs( fd, &stfs) < 0)
+            info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
+        else
+            get_device_info_fstatfs( info, stfs.f_fstypename, stfs.f_flag );
+#elif defined(sun)
+        /* Use dkio to work out device types */
+        {
+# include <sys/dkio.h>
+# include <sys/vtoc.h>
+            struct dk_cinfo dkinf;
+            int retval = ioctl(fd, DKIOCINFO, &dkinf);
+            if(retval==-1){
+                WARN("Unable to get disk device type information - assuming a disk like device\n");
+                info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
+            }
+            switch (dkinf.dki_ctype)
+            {
+            case DKC_CDROM:
+                info->DeviceType = FILE_DEVICE_CD_ROM_FILE_SYSTEM;
+                info->Characteristics |= FILE_REMOVABLE_MEDIA|FILE_READ_ONLY_DEVICE;
+                break;
+            case DKC_NCRFLOPPY:
+            case DKC_SMSFLOPPY:
+            case DKC_INTEL82072:
+            case DKC_INTEL82077:
+                info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
+                info->Characteristics |= FILE_REMOVABLE_MEDIA;
+                break;
+            case DKC_MD:
+            /* Don't map these to FILE_DEVICE_VIRTUAL_DISK by default. Virtual
+             * filesystems are rare on Windows, and some programs refuse to
+             * recognize them as valid. */
+            default:
+                info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
+            }
+        }
+#else
+        static int warned;
+        if (!warned++) FIXME( "device info not properly supported on this platform\n" );
+        info->DeviceType = FILE_DEVICE_DISK_FILE_SYSTEM;
+#endif
+        info->Characteristics |= FILE_DEVICE_IS_MOUNTED;
+    }
+    return STATUS_SUCCESS;
+}
+
+
+/******************************************************************************
+ *              NtQueryVolumeInformationFile   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtQueryVolumeInformationFile( HANDLE handle, IO_STATUS_BLOCK *io,
+                                              void *buffer, ULONG length,
+                                              FS_INFORMATION_CLASS info_class )
+{
+    int fd, needs_close;
+    unsigned int status;
+
+    status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL );
+    if (status == STATUS_BAD_DEVICE_TYPE)
+    {
+        struct async_irp *async;
+        HANDLE wait_handle;
+
+        if (!(async = (struct async_irp *)alloc_fileio( sizeof(*async), irp_completion, handle )))
+            return STATUS_NO_MEMORY;
+        async->buffer  = buffer;
+        async->size    = length;
+
+        SERVER_START_REQ( get_volume_info )
+        {
+            req->async = server_async( handle, &async->io, NULL, NULL, NULL, iosb_client_ptr(io) );
+            req->handle = wine_server_obj_handle( handle );
+            req->info_class = info_class;
+            wine_server_set_reply( req, buffer, length );
+            status = wine_server_call( req );
+            if (status != STATUS_PENDING)
+            {
+                io->Status = status;
+                io->Information = wine_server_reply_size( reply );
+            }
+            wait_handle = wine_server_ptr_handle( reply->wait );
+        }
+        SERVER_END_REQ;
+        if (status != STATUS_PENDING) free( async );
+        if (wait_handle) status = wait_async( wait_handle, FALSE );
+        return status;
+    }
+    else if (status) return io->Status = status;
+
+    io->Information = 0;
+
+    switch( info_class )
+    {
+    case FileFsLabelInformation:
+        FIXME( "%p: label info not supported\n", handle );
+        status = STATUS_NOT_IMPLEMENTED;
+        break;
+
+    case FileFsSizeInformation:
+        if (length < sizeof(FILE_FS_SIZE_INFORMATION))
+            status = STATUS_BUFFER_TOO_SMALL;
+        else
+        {
+            FILE_FS_SIZE_INFORMATION *info = buffer;
+            FILE_FS_FULL_SIZE_INFORMATION full_info;
+
+            if ((status = get_full_size_info(fd, &full_info)) == STATUS_SUCCESS)
+            {
+                info->TotalAllocationUnits = full_info.TotalAllocationUnits;
+                info->AvailableAllocationUnits = full_info.CallerAvailableAllocationUnits;
+                info->SectorsPerAllocationUnit = full_info.SectorsPerAllocationUnit;
+                info->BytesPerSector = full_info.BytesPerSector;
+                io->Information = sizeof(*info);
+            }
+        }
+        break;
+
+    case FileFsDeviceInformation:
+        if (length < sizeof(FILE_FS_DEVICE_INFORMATION))
+            status = STATUS_BUFFER_TOO_SMALL;
+        else
+        {
+            FILE_FS_DEVICE_INFORMATION *info = buffer;
+
+            if ((status = get_device_info( fd, info )) == STATUS_SUCCESS)
+                io->Information = sizeof(*info);
+        }
+        break;
+
+    case FileFsAttributeInformation:
+    {
+        static const WCHAR fatW[] = {'F','A','T'};
+        static const WCHAR fat32W[] = {'F','A','T','3','2'};
+        static const WCHAR ntfsW[] = {'N','T','F','S'};
+        static const WCHAR cdfsW[] = {'C','D','F','S'};
+        static const WCHAR udfW[] = {'U','D','F'};
+
+        FILE_FS_ATTRIBUTE_INFORMATION *info = buffer;
+        struct mountmgr_unix_drive drive;
+        enum mountmgr_fs_type fs_type = MOUNTMGR_FS_TYPE_NTFS;
+
+        if (length < sizeof(FILE_FS_ATTRIBUTE_INFORMATION))
+        {
+            status = STATUS_INFO_LENGTH_MISMATCH;
+            break;
+        }
+
+        if (!get_mountmgr_fs_info( handle, fd, &drive, sizeof(drive) )) fs_type = drive.fs_type;
+        else
+        {
+            struct statfs stfs;
+
+            if (!fstatfs( fd, &stfs ))
+            {
+#if defined(linux) && defined(HAVE_FSTATFS)
+                switch (stfs.f_type)
+                {
+                case 0x9660:
+                    fs_type = MOUNTMGR_FS_TYPE_ISO9660;
+                    break;
+                case 0x15013346:
+                    fs_type = MOUNTMGR_FS_TYPE_UDF;
+                    break;
+                case 0x4d44:
+                    fs_type = MOUNTMGR_FS_TYPE_FAT32;
+                    break;
+                }
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__OpenBSD__) || defined(__DragonFly__) || defined(__APPLE__)
+                if (!strcmp( stfs.f_fstypename, "cd9660" ))
+                    fs_type = MOUNTMGR_FS_TYPE_ISO9660;
+                else if (!strcmp( stfs.f_fstypename, "udf" ))
+                    fs_type = MOUNTMGR_FS_TYPE_UDF;
+                else if (!strcmp( stfs.f_fstypename, "msdos" )) /* FreeBSD < 5, Apple */
+                    fs_type = MOUNTMGR_FS_TYPE_FAT32;
+                else if (!strcmp( stfs.f_fstypename, "msdosfs" )) /* FreeBSD >= 5 */
+                    fs_type = MOUNTMGR_FS_TYPE_FAT32;
+#endif
+            }
+        }
+
+        switch (fs_type)
+        {
+        case MOUNTMGR_FS_TYPE_ISO9660:
+            info->FileSystemAttributes = FILE_READ_ONLY_VOLUME;
+            info->MaximumComponentNameLength = 221;
+            info->FileSystemNameLength = min( sizeof(cdfsW), length - offsetof( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName ) );
+            memcpy(info->FileSystemName, cdfsW, info->FileSystemNameLength);
+            break;
+        case MOUNTMGR_FS_TYPE_UDF:
+            info->FileSystemAttributes = FILE_READ_ONLY_VOLUME | FILE_UNICODE_ON_DISK | FILE_CASE_SENSITIVE_SEARCH;
+            info->MaximumComponentNameLength = 255;
+            info->FileSystemNameLength = min( sizeof(udfW), length - offsetof( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName ) );
+            memcpy(info->FileSystemName, udfW, info->FileSystemNameLength);
+            break;
+        case MOUNTMGR_FS_TYPE_FAT:
+            info->FileSystemAttributes = FILE_CASE_PRESERVED_NAMES; /* FIXME */
+            info->MaximumComponentNameLength = 255;
+            info->FileSystemNameLength = min( sizeof(fatW), length - offsetof( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName ) );
+            memcpy(info->FileSystemName, fatW, info->FileSystemNameLength);
+            break;
+        case MOUNTMGR_FS_TYPE_FAT32:
+            info->FileSystemAttributes = FILE_CASE_PRESERVED_NAMES; /* FIXME */
+            info->MaximumComponentNameLength = 255;
+            info->FileSystemNameLength = min( sizeof(fat32W), length - offsetof( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName ) );
+            memcpy(info->FileSystemName, fat32W, info->FileSystemNameLength);
+            break;
+        default:
+            info->FileSystemAttributes = FILE_CASE_PRESERVED_NAMES | FILE_PERSISTENT_ACLS;
+            info->MaximumComponentNameLength = 255;
+            info->FileSystemNameLength = min( sizeof(ntfsW), length - offsetof( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName ) );
+            memcpy(info->FileSystemName, ntfsW, info->FileSystemNameLength);
+            break;
+        }
+
+        io->Information = offsetof( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName ) + info->FileSystemNameLength;
+        status = STATUS_SUCCESS;
+        break;
+    }
+
+    case FileFsVolumeInformation:
+    {
+        FILE_FS_VOLUME_INFORMATION *info = buffer;
+        ULONGLONG data[64];
+        struct mountmgr_unix_drive *drive = (struct mountmgr_unix_drive *)data;
+        const WCHAR *label;
+
+        if (length < sizeof(FILE_FS_VOLUME_INFORMATION))
+        {
+            status = STATUS_INFO_LENGTH_MISMATCH;
+            break;
+        }
+
+        if (get_mountmgr_fs_info( handle, fd, drive, sizeof(data) ))
+        {
+            status = STATUS_NOT_IMPLEMENTED;
+            break;
+        }
+
+        label = (WCHAR *)((char *)drive + drive->label_offset);
+        info->VolumeCreationTime.QuadPart = 0; /* FIXME */
+        info->VolumeSerialNumber = drive->serial;
+        info->VolumeLabelLength = min( wcslen( label ) * sizeof(WCHAR),
+                                       length - offsetof( FILE_FS_VOLUME_INFORMATION, VolumeLabel ) );
+        info->SupportsObjects = (drive->fs_type == MOUNTMGR_FS_TYPE_NTFS);
+        memcpy( info->VolumeLabel, label, info->VolumeLabelLength );
+        io->Information = offsetof( FILE_FS_VOLUME_INFORMATION, VolumeLabel ) + info->VolumeLabelLength;
+        status = STATUS_SUCCESS;
+        break;
+    }
+
+    case FileFsControlInformation:
+        FIXME( "%p: control info not supported\n", handle );
+        status = STATUS_NOT_IMPLEMENTED;
+        break;
+
+    case FileFsFullSizeInformation:
+        if (length < sizeof(FILE_FS_FULL_SIZE_INFORMATION))
+            status = STATUS_BUFFER_TOO_SMALL;
+        else
+        {
+            FILE_FS_FULL_SIZE_INFORMATION *info = buffer;
+            if ((status = get_full_size_info(fd, info)) == STATUS_SUCCESS)
+                io->Information = sizeof(*info);
+        }
+        break;
+
+    case FileFsFullSizeInformationEx:
+        if (length < sizeof(FILE_FS_FULL_SIZE_INFORMATION_EX))
+            status = STATUS_BUFFER_TOO_SMALL;
+        else
+        {
+            FILE_FS_FULL_SIZE_INFORMATION_EX *info = buffer;
+            if ((status = get_full_size_info_ex(fd, info)) == STATUS_SUCCESS)
+                io->Information = sizeof(*info);
+        }
+        break;
+
+    case FileFsObjectIdInformation:
+        FIXME( "%p: object id info not supported\n", handle );
+        status = STATUS_NOT_IMPLEMENTED;
+        break;
+
+    case FileFsMaximumInformation:
+        FIXME( "%p: maximum info not supported\n", handle );
+        status = STATUS_NOT_IMPLEMENTED;
+        break;
+
+    default:
+        status = STATUS_INVALID_PARAMETER;
+        break;
+    }
+    if (needs_close) close( fd );
+    return io->Status = status;
+}
+
+
+/******************************************************************************
+ *              NtSetVolumeInformationFile   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtSetVolumeInformationFile( HANDLE handle, IO_STATUS_BLOCK *io, void *info,
+                                            ULONG length, FS_INFORMATION_CLASS class )
+{
+    FIXME( "(%p,%p,%p,0x%08x,0x%08x) stub\n", handle, io, info, length, class );
+    return STATUS_SUCCESS;
+}
+
+
+/******************************************************************
+ *           NtQueryEaFile   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtQueryEaFile( HANDLE handle, IO_STATUS_BLOCK *io, void *buffer, ULONG length,
+                               BOOLEAN single_entry, void *list, ULONG list_len,
+                               ULONG *index, BOOLEAN restart )
+{
+    int fd, needs_close;
+    NTSTATUS status;
+
+    FIXME( "(%p,%p,%p,%d,%d,%p,%d,%p,%d) semi-stub\n",
+           handle, io, buffer, length, single_entry, list, list_len, index, restart );
+
+    if ((status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL )))
+        return status;
+
+    if (buffer && length)
+        memset( buffer, 0, length );
+
+    if (needs_close) close( fd );
+    return STATUS_NO_EAS_ON_FILE;
+}
+
+
+/******************************************************************
+ *           NtSetEaFile   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtSetEaFile( HANDLE handle, IO_STATUS_BLOCK *io, void *buffer, ULONG length )
+{
+    FIXME( "(%p,%p,%p,%d) stub\n", handle, io, buffer, length );
+    return STATUS_ACCESS_DENIED;
+}
+
+
+/* convert type information from server format; helper for NtQueryObject */
+static void *put_object_type_info( OBJECT_TYPE_INFORMATION *p, struct object_type_info *info )
+{
+    const ULONG align = sizeof(DWORD_PTR) - 1;
+
+    memset( p, 0, sizeof(*p) );
+    p->TypeName.Buffer               = (WCHAR *)(p + 1);
+    p->TypeName.Length               = info->name_len;
+    p->TypeName.MaximumLength        = info->name_len + sizeof(WCHAR);
+    p->TotalNumberOfObjects          = info->obj_count;
+    p->TotalNumberOfHandles          = info->handle_count;
+    p->HighWaterNumberOfObjects      = info->obj_max;
+    p->HighWaterNumberOfHandles      = info->handle_max;
+    p->TypeIndex                     = info->index + 2;
+    p->GenericMapping.GenericRead    = info->mapping.read;
+    p->GenericMapping.GenericWrite   = info->mapping.write;
+    p->GenericMapping.GenericExecute = info->mapping.exec;
+    p->GenericMapping.GenericAll     = info->mapping.all;
+    p->ValidAccessMask               = info->valid_access;
+    memcpy( p->TypeName.Buffer, info + 1, info->name_len );
+    p->TypeName.Buffer[info->name_len / sizeof(WCHAR)] = 0;
+    return (char *)(p + 1) + ((p->TypeName.MaximumLength + align) & ~align);
+}
+
+/**************************************************************************
+ *           NtQueryObject   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtQueryObject( HANDLE handle, OBJECT_INFORMATION_CLASS info_class,
+                               void *ptr, ULONG len, ULONG *used_len )
+{
+    unsigned int status;
+
+    TRACE("(%p,0x%08x,%p,0x%08x,%p)\n", handle, info_class, ptr, len, used_len);
+
+    if (used_len) *used_len = 0;
+
+    switch (info_class)
+    {
+    case ObjectBasicInformation:
+    {
+        OBJECT_BASIC_INFORMATION *p = ptr;
+
+        if (len < sizeof(*p)) return STATUS_INFO_LENGTH_MISMATCH;
+
+        SERVER_START_REQ( get_object_info )
+        {
+            req->handle = wine_server_obj_handle( handle );
+            status = wine_server_call( req );
+            if (status == STATUS_SUCCESS)
+            {
+                memset( p, 0, sizeof(*p) );
+                p->GrantedAccess = reply->access;
+                p->PointerCount = reply->ref_count;
+                p->HandleCount = reply->handle_count;
+                if (used_len) *used_len = sizeof(*p);
+            }
+        }
+        SERVER_END_REQ;
+        break;
+    }
+
+    case ObjectNameInformation:
+    {
+        OBJECT_NAME_INFORMATION *p = ptr;
+
+        SERVER_START_REQ( get_object_name )
+        {
+            req->handle = wine_server_obj_handle( handle );
+            if (len > sizeof(*p) + sizeof(WCHAR))
+                wine_server_set_reply( req, p + 1, len - sizeof(*p) - sizeof(WCHAR) );
+            status = wine_server_call( req );
+            if (status == STATUS_SUCCESS)
+            {
+                if (!reply->total)  /* no name */
+                {
+                    if (len < sizeof(*p)) status = STATUS_INFO_LENGTH_MISMATCH;
+                    else memset( p, 0, sizeof(*p) );
+                    if (used_len) *used_len = sizeof(*p);
+                }
+                else
+                {
+                    ULONG res = wine_server_reply_size( reply );
+                    p->Name.Buffer = (WCHAR *)(p + 1);
+                    p->Name.Length = res;
+                    p->Name.MaximumLength = res + sizeof(WCHAR);
+                    p->Name.Buffer[res / sizeof(WCHAR)] = 0;
+                    if (used_len) *used_len = sizeof(*p) + p->Name.MaximumLength;
+                }
+            }
+            else if (status == STATUS_INFO_LENGTH_MISMATCH || status == STATUS_BUFFER_OVERFLOW)
+            {
+                if (len < sizeof(*p)) status = STATUS_INFO_LENGTH_MISMATCH;
+                if (used_len) *used_len = sizeof(*p) + reply->total + sizeof(WCHAR);
+            }
+        }
+        SERVER_END_REQ;
+        break;
+    }
+
+    case ObjectTypeInformation:
+    {
+        OBJECT_TYPE_INFORMATION *p = ptr;
+        char buffer[sizeof(struct object_type_info) + 64];
+        struct object_type_info *info = (struct object_type_info *)buffer;
+
+        SERVER_START_REQ( get_object_type )
+        {
+            req->handle = wine_server_obj_handle( handle );
+            wine_server_set_reply( req, buffer, sizeof(buffer) );
+            status = wine_server_call( req );
+        }
+        SERVER_END_REQ;
+        if (status) break;
+        if (sizeof(*p) + info->name_len + sizeof(WCHAR) <= len)
+        {
+            put_object_type_info( p, info );
+            if (used_len) *used_len = sizeof(*p) + p->TypeName.MaximumLength;
+        }
+        else
+        {
+            if (used_len) *used_len = sizeof(*p) + info->name_len + sizeof(WCHAR);
+            status = STATUS_INFO_LENGTH_MISMATCH;
+        }
+        break;
+    }
+
+    case ObjectTypesInformation:
+    {
+        OBJECT_TYPES_INFORMATION *types = ptr;
+        OBJECT_TYPE_INFORMATION *p;
+        struct object_type_info *buffer;
+        /* assume at most 32 types, with an average 16-char name */
+        UINT size = 32 * (sizeof(struct object_type_info) + 16 * sizeof(WCHAR));
+        UINT i, count, pos, total, align = sizeof(DWORD_PTR) - 1;
+
+        buffer = malloc( size );
+        SERVER_START_REQ( get_object_types )
+        {
+            wine_server_set_reply( req, buffer, size );
+            status = wine_server_call( req );
+            count = reply->count;
+        }
+        SERVER_END_REQ;
+        if (!status)
+        {
+            if (len >= sizeof(*types)) types->NumberOfTypes = count;
+            total = (sizeof(*types) + align) & ~align;
+            p = (OBJECT_TYPE_INFORMATION *)((char *)ptr + total);
+            for (i = pos = 0; i < count; i++)
+            {
+                struct object_type_info *info = (struct object_type_info *)((char *)buffer + pos);
+                pos += sizeof(*info) + ((info->name_len + 3) & ~3);
+                total += sizeof(*p) + ((info->name_len + sizeof(WCHAR) + align) & ~align);
+                if (total <= len) p = put_object_type_info( p, info );
+            }
+            if (used_len) *used_len = total;
+            if (total > len) status = STATUS_INFO_LENGTH_MISMATCH;
+        }
+        else if (status == STATUS_BUFFER_OVERFLOW) FIXME( "size %u too small\n", size );
+
+        free( buffer );
+        break;
+    }
+
+    case ObjectHandleFlagInformation:
+    {
+        OBJECT_HANDLE_FLAG_INFORMATION* p = ptr;
+
+        if (len < sizeof(*p)) return STATUS_INVALID_BUFFER_SIZE;
+
+        SERVER_START_REQ( set_handle_info )
+        {
+            req->handle = wine_server_obj_handle( handle );
+            req->flags  = 0;
+            req->mask   = 0;
+            status = wine_server_call( req );
+            if (status == STATUS_SUCCESS)
+            {
+                p->Inherit = (reply->old_flags & HANDLE_FLAG_INHERIT) != 0;
+                p->ProtectFromClose = (reply->old_flags & HANDLE_FLAG_PROTECT_FROM_CLOSE) != 0;
+                if (used_len) *used_len = sizeof(*p);
+            }
+        }
+        SERVER_END_REQ;
+        break;
+    }
+
+    default:
+        FIXME("Unsupported information class %u\n", info_class);
+        status = STATUS_NOT_IMPLEMENTED;
+        break;
+    }
+    return status;
+}
+
+
+/**************************************************************************
+ *           NtSetInformationObject   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtSetInformationObject( HANDLE handle, OBJECT_INFORMATION_CLASS info_class,
+                                        void *ptr, ULONG len )
+{
+    unsigned int status;
+
+    TRACE("(%p,0x%08x,%p,0x%08x)\n", handle, info_class, ptr, len);
+
+    switch (info_class)
+    {
+    case ObjectHandleFlagInformation:
+    {
+        OBJECT_HANDLE_FLAG_INFORMATION* p = ptr;
+
+        if (len < sizeof(*p)) return STATUS_INVALID_BUFFER_SIZE;
+
+        SERVER_START_REQ( set_handle_info )
+        {
+            req->handle = wine_server_obj_handle( handle );
+            req->mask   = HANDLE_FLAG_INHERIT | HANDLE_FLAG_PROTECT_FROM_CLOSE;
+            if (p->Inherit) req->flags |= HANDLE_FLAG_INHERIT;
+            if (p->ProtectFromClose) req->flags |= HANDLE_FLAG_PROTECT_FROM_CLOSE;
+            status = wine_server_call( req );
+        }
+        SERVER_END_REQ;
+    break;
+    }
+
+    default:
+        FIXME("Unsupported information class %u\n", info_class);
+        status = STATUS_NOT_IMPLEMENTED;
+        break;
+    }
+    return status;
+}
diff -ruN --show-c-function dlls/win32u/rawinput.c dlls/win32u/rawinput.c
--- dlls/win32u/rawinput.c	2025-10-10 10:17:47.497752199 -0700
+++ dlls/win32u/rawinput.c	2025-10-10 12:03:54.184784503 -0700
@@ -374,6 +374,30 @@ UINT WINAPI NtUserGetRawInputDeviceList(
     return count;
 }
 
+static BOOL steam_input_get_vid_pid( UINT slot, UINT16 *vid, UINT16 *pid )
+{
+    const char *info = getenv( "SteamVirtualGamepadInfo" );
+    char buffer[256];
+    UINT current;
+    FILE *file;
+
+    TRACE( "reading SteamVirtualGamepadInfo %s\n", debugstr_a(info) );
+
+    if (!info || !(file = fopen( info, "r" ))) return FALSE;
+    while (fscanf( file, "%255[^\n]\n", buffer ) == 1)
+    {
+        if (sscanf( buffer, "[slot %d]", &current )) continue;
+        if (current < slot) continue;
+        if (current > slot) break;
+        if (sscanf( buffer, "VID=0x%hx", vid )) continue;
+        if (sscanf( buffer, "PID=0x%hx", pid )) continue;
+    }
+
+    fclose( file );
+
+    return TRUE;
+}
+
 /**********************************************************************
  *         NtUserGetRawInputDeviceInfo   (win32u.@)
  */
@@ -411,10 +435,51 @@ UINT WINAPI NtUserGetRawInputDeviceInfo(
     switch (command)
     {
     case RIDI_DEVICENAME:
-        if ((len = wcslen( device->path ) + 1) <= data_len && data)
-            memcpy( data, device->path, len * sizeof(WCHAR) );
+    {
+        static const WCHAR steam_input_idW[] =
+        {
+            '\\','\\','?','\\','H','I','D','#','V','I','D','_','2','8','D','E','&','P','I','D','_','1','1','F','F','&','I','G','_',0
+        };
+        const WCHAR *device_path;
+        WCHAR bufferW[MAX_PATH];
+
+        /* CW-Bug-Id: #23185 Emulate Steam Input native hooks for native SDL */
+        if (wcsnicmp( device->path, steam_input_idW, 29 )) device_path = device->path;
+        else
+        {
+            char buffer[MAX_PATH];
+            UINT size = 0, slot;
+            const WCHAR *tmpW;
+            UINT16 vid, pid;
+
+            tmpW = device->path + 29;
+            while (*tmpW && *tmpW != '#' && size < ARRAY_SIZE(buffer)) buffer[size++] = *tmpW++;
+            buffer[size] = 0;
+            if (sscanf( buffer, "%02u", &slot ) != 1) slot = 0;
+
+            if (!steam_input_get_vid_pid( slot, &vid, &pid ))
+            {
+                vid = 0x045e;
+                pid = 0x028e;
+            }
+
+            size = snprintf( buffer, ARRAY_SIZE(buffer), "\\\\.\\pipe\\HID#VID_045E&PID_028E&IG_00#%04X&%04X", vid, pid );
+            if ((tmpW = wcschr( device->path + 29, '&' )))
+            {
+                do buffer[size++] = *tmpW++;
+                while (*tmpW != '&' && size < ARRAY_SIZE(buffer));
+            }
+            size += snprintf( buffer + size, ARRAY_SIZE(buffer) - size, "#%d#%u", slot, (UINT)GetCurrentProcessId() );
+
+            ntdll_umbstowcs( buffer, size + 1, bufferW, sizeof(bufferW) );
+            device_path = bufferW;
+        }
+
+        if ((len = wcslen( device_path ) + 1) <= data_len && data)
+            memcpy( data, device_path, len * sizeof(WCHAR) );
         *data_size = len;
         break;
+    }
 
     case RIDI_DEVICEINFO:
         if ((len = sizeof(info)) <= data_len && data)
diff -ruN --show-c-function dlls/windows.gaming.input/provider.c dlls/windows.gaming.input/provider.c
--- dlls/windows.gaming.input/provider.c	2025-10-10 10:17:47.503823836 -0700
+++ dlls/windows.gaming.input/provider.c	2025-10-10 12:03:54.189612288 -0700
@@ -141,9 +141,62 @@ static HRESULT WINAPI wine_provider_GetT
     return E_NOTIMPL;
 }
 
+static BOOL steam_input_get_vid_pid( UINT slot, UINT16 *vid, UINT16 *pid )
+{
+    const char *info = getenv( "SteamVirtualGamepadInfo" );
+    char buffer[256];
+    UINT current;
+    FILE *file;
+
+    TRACE( "reading SteamVirtualGamepadInfo %s\n", debugstr_a(info) );
+
+    if (!info || !(file = fopen( info, "r" ))) return FALSE;
+    while (fscanf( file, "%255[^\n]\n", buffer ) == 1)
+    {
+        if (sscanf( buffer, "[slot %d]", &current )) continue;
+        if (current < slot) continue;
+        if (current > slot) break;
+        if (sscanf( buffer, "VID=0x%hx", vid )) continue;
+        if (sscanf( buffer, "PID=0x%hx", pid )) continue;
+    }
+
+    fclose( file );
+
+    return TRUE;
+}
+
 static HRESULT WINAPI wine_provider_get_NonRoamableId( IWineGameControllerProvider *iface, HSTRING *value )
 {
+    struct provider *impl = impl_from_IWineGameControllerProvider( iface );
+    WCHAR buffer[1024];
+    UINT16 vid, pid;
+    HRESULT hr;
+
     FIXME( "iface %p, value %p stub!\n", iface, value );
+
+    if (FAILED(hr = IGameControllerProvider_get_HardwareVendorId( &impl->IGameControllerProvider_iface, &vid ))) return hr;
+    if (FAILED(hr = IGameControllerProvider_get_HardwareProductId( &impl->IGameControllerProvider_iface, &pid ))) return hr;
+
+    /* CW-Bug-Id: #23185 Emulate Steam Input native hooks for native SDL */
+    if (vid == 0x28de && pid == 0x11ff)
+    {
+        const WCHAR *tmp;
+        char serial[256];
+        UINT32 len, slot;
+
+        if (!(tmp = wcschr( impl->device_path + 8, '#' )) || wcsnicmp( tmp - 6, L"&XI_", 4 )) return E_NOTIMPL;
+        if (swscanf( tmp - 2, L"%02u#%*u&%255[^&]&", &slot, serial ) != 2) return E_NOTIMPL;
+
+        if (!steam_input_get_vid_pid( slot, &vid, &pid ))
+        {
+            vid = 0x045e;
+            pid = 0x028e;
+        }
+
+        len = swprintf( buffer, ARRAY_SIZE(buffer), L"{wgi/nrid/:steam-%04X&%04X&%s#%d#%u}", vid, pid, serial, slot, GetCurrentProcessId() );
+        return WindowsCreateString( buffer, len, value );
+    }
+
     return E_NOTIMPL;
 }
 
@@ -151,10 +204,21 @@ static HRESULT WINAPI wine_provider_get_
 {
     struct provider *impl = impl_from_IWineGameControllerProvider( iface );
     DIDEVICEINSTANCEW instance = {.dwSize = sizeof(DIDEVICEINSTANCEW)};
+    UINT16 vid, pid;
     HRESULT hr;
 
     TRACE( "iface %p, value %p\n", iface, value );
 
+    if (FAILED(hr = IGameControllerProvider_get_HardwareVendorId( &impl->IGameControllerProvider_iface, &vid ))) return hr;
+    if (FAILED(hr = IGameControllerProvider_get_HardwareProductId( &impl->IGameControllerProvider_iface, &pid ))) return hr;
+
+    /* CW-Bug-Id: #23185 Emulate Steam Input native hooks for native SDL */
+    if (vid == 0x28de && pid == 0x11ff)
+    {
+        static const WCHAR name[] = L"Xbox 360 Controller for Windows";
+        return WindowsCreateString( name, wcslen( name ), value );
+    }
+
     if (FAILED(hr = IDirectInputDevice8_GetDeviceInfo( impl->dinput_device, &instance ))) return hr;
     return WindowsCreateString( instance.tszProductName, wcslen( instance.tszProductName ), value );
 }
diff -ruN --show-c-function dlls/windows.gaming.input/provider.c.orig dlls/windows.gaming.input/provider.c.orig
--- dlls/windows.gaming.input/provider.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ dlls/windows.gaming.input/provider.c.orig	2025-10-10 12:03:48.292204824 -0700
@@ -0,0 +1,796 @@
+/* WinRT Windows.Gaming.Input implementation
+ *
+ * Copyright 2022 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "private.h"
+
+#include "initguid.h"
+#include "ddk/hidsdi.h"
+#include "dinput.h"
+#include "provider.h"
+#include "hidusage.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(input);
+
+DEFINE_GUID( device_path_guid, 0x00000000, 0x0000, 0x0000, 0x8d, 0x4a, 0x23, 0x90, 0x3f, 0xb6, 0xbd, 0xf8 );
+
+static CRITICAL_SECTION provider_cs;
+static CRITICAL_SECTION_DEBUG provider_cs_debug =
+{
+    0, 0, &provider_cs,
+    { &provider_cs_debug.ProcessLocksList, &provider_cs_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": provider_cs") }
+};
+static CRITICAL_SECTION provider_cs = { &provider_cs_debug, -1, 0, 0, 0, 0 };
+
+static struct list provider_list = LIST_INIT( provider_list );
+
+struct provider
+{
+    IWineGameControllerProvider IWineGameControllerProvider_iface;
+    IGameControllerProvider IGameControllerProvider_iface;
+    LONG ref;
+
+    IDirectInputDevice8W *dinput_device;
+    WCHAR device_path[MAX_PATH];
+    struct list entry;
+
+    struct WineGameControllerVibration vibration;
+
+    char *report_buf;
+    PHIDP_PREPARSED_DATA preparsed;
+    HIDP_VALUE_CAPS haptics_rumble_caps;
+    HIDP_VALUE_CAPS haptics_buzz_caps;
+    HIDP_VALUE_CAPS haptics_left_caps;
+    HIDP_VALUE_CAPS haptics_right_caps;
+    BYTE haptics_report;
+    HIDP_CAPS caps;
+    HANDLE device;
+};
+
+static inline struct provider *impl_from_IWineGameControllerProvider( IWineGameControllerProvider *iface )
+{
+    return CONTAINING_RECORD( iface, struct provider, IWineGameControllerProvider_iface );
+}
+
+static HRESULT WINAPI wine_provider_QueryInterface( IWineGameControllerProvider *iface, REFIID iid, void **out )
+{
+    struct provider *impl = impl_from_IWineGameControllerProvider( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IWineGameControllerProvider ))
+    {
+        IInspectable_AddRef( (*out = &impl->IWineGameControllerProvider_iface) );
+        return S_OK;
+    }
+
+    if (IsEqualGUID( iid, &IID_IGameControllerProvider ))
+    {
+        IInspectable_AddRef( (*out = &impl->IGameControllerProvider_iface) );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI wine_provider_AddRef( IWineGameControllerProvider *iface )
+{
+    struct provider *impl = impl_from_IWineGameControllerProvider( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p increasing refcount to %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI wine_provider_Release( IWineGameControllerProvider *iface )
+{
+    struct provider *impl = impl_from_IWineGameControllerProvider( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+
+    TRACE( "iface %p decreasing refcount to %lu.\n", iface, ref );
+
+    if (!ref)
+    {
+        IDirectInputDevice8_Release( impl->dinput_device );
+        HidD_FreePreparsedData( impl->preparsed );
+        CloseHandle( impl->device );
+        free( impl->report_buf );
+        free( impl );
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI wine_provider_GetIids( IWineGameControllerProvider *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wine_provider_GetRuntimeClassName( IWineGameControllerProvider *iface, HSTRING *class_name )
+{
+    FIXME( "iface %p, class_name %p stub!\n", iface, class_name );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wine_provider_GetTrustLevel( IWineGameControllerProvider *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p stub!\n", iface, trust_level );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wine_provider_get_NonRoamableId( IWineGameControllerProvider *iface, HSTRING *value )
+{
+    FIXME( "iface %p, value %p stub!\n", iface, value );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI wine_provider_get_DisplayName( IWineGameControllerProvider *iface, HSTRING *value )
+{
+    struct provider *impl = impl_from_IWineGameControllerProvider( iface );
+    DIDEVICEINSTANCEW instance = {.dwSize = sizeof(DIDEVICEINSTANCEW)};
+    HRESULT hr;
+
+    TRACE( "iface %p, value %p\n", iface, value );
+
+    if (FAILED(hr = IDirectInputDevice8_GetDeviceInfo( impl->dinput_device, &instance ))) return hr;
+    return WindowsCreateString( instance.tszProductName, wcslen( instance.tszProductName ), value );
+}
+
+static BOOL CALLBACK count_ffb_axes( const DIDEVICEOBJECTINSTANCEW *obj, void *args )
+{
+    DWORD *count = args;
+    if (obj->dwType & DIDFT_FFACTUATOR) (*count)++;
+    return DIENUM_CONTINUE;
+}
+
+static HRESULT WINAPI wine_provider_get_Type( IWineGameControllerProvider *iface, WineGameControllerType *value )
+{
+    struct provider *impl = impl_from_IWineGameControllerProvider( iface );
+    DIDEVICEINSTANCEW instance = {.dwSize = sizeof(DIDEVICEINSTANCEW)};
+    const WCHAR *tmp;
+    HRESULT hr;
+
+    TRACE( "iface %p, value %p.\n", iface, value );
+
+    if (FAILED(hr = IDirectInputDevice8_GetDeviceInfo( impl->dinput_device, &instance ))) return hr;
+
+    if ((tmp = wcschr( impl->device_path + 8, '#' )) && !wcsnicmp( tmp - 6, L"&XI_", 4 ))
+        *value = WineGameControllerType_Gamepad;
+    else switch (GET_DIDEVICE_TYPE( instance.dwDevType ))
+    {
+    case DI8DEVTYPE_DRIVING: *value = WineGameControllerType_RacingWheel; break;
+    default:
+    {
+        DWORD count = 0;
+        hr = IDirectInputDevice8_EnumObjects( impl->dinput_device, count_ffb_axes, &count, DIDFT_AXIS );
+        if (SUCCEEDED(hr) && count == 1) *value = WineGameControllerType_RacingWheel;
+        else *value = WineGameControllerType_Joystick;
+        break;
+    }
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI wine_provider_get_AxisCount( IWineGameControllerProvider *iface, INT32 *value )
+{
+    struct provider *impl = impl_from_IWineGameControllerProvider( iface );
+    DIDEVCAPS caps = {.dwSize = sizeof(DIDEVCAPS)};
+    HRESULT hr;
+
+    TRACE( "iface %p, value %p.\n", iface, value );
+
+    if (SUCCEEDED(hr = IDirectInputDevice8_GetCapabilities( impl->dinput_device, &caps )))
+        *value = caps.dwAxes;
+    return hr;
+}
+
+static HRESULT WINAPI wine_provider_get_ButtonCount( IWineGameControllerProvider *iface, INT32 *value )
+{
+    struct provider *impl = impl_from_IWineGameControllerProvider( iface );
+    DIDEVCAPS caps = {.dwSize = sizeof(DIDEVCAPS)};
+    HRESULT hr;
+
+    TRACE( "iface %p, value %p.\n", iface, value );
+
+    if (SUCCEEDED(hr = IDirectInputDevice8_GetCapabilities( impl->dinput_device, &caps )))
+        *value = caps.dwButtons;
+    return hr;
+}
+
+static HRESULT WINAPI wine_provider_get_SwitchCount( IWineGameControllerProvider *iface, INT32 *value )
+{
+    struct provider *impl = impl_from_IWineGameControllerProvider( iface );
+    DIDEVCAPS caps = {.dwSize = sizeof(DIDEVCAPS)};
+    HRESULT hr;
+
+    TRACE( "iface %p, value %p.\n", iface, value );
+
+    if (SUCCEEDED(hr = IDirectInputDevice8_GetCapabilities( impl->dinput_device, &caps )))
+        *value = caps.dwPOVs;
+    return hr;
+}
+
+static HRESULT WINAPI wine_provider_get_State( IWineGameControllerProvider *iface, struct WineGameControllerState *out )
+{
+    struct provider *impl = impl_from_IWineGameControllerProvider( iface );
+    DIJOYSTATE2 state = {0};
+    UINT32 i = 0;
+    HRESULT hr;
+
+    TRACE( "iface %p, out %p.\n", iface, out );
+
+    if (FAILED(hr = IDirectInputDevice8_GetDeviceState( impl->dinput_device, sizeof(state), &state )))
+    {
+        WARN( "Failed to read device state, hr %#lx\n", hr );
+        return S_OK;
+    }
+
+    i = ARRAY_SIZE(state.rgbButtons);
+    while (i--) out->buttons[i] = (state.rgbButtons[i] != 0);
+
+    i = ARRAY_SIZE(state.rgdwPOV);
+    while (i--)
+    {
+        if (state.rgdwPOV[i] == ~0) out->switches[i] = GameControllerSwitchPosition_Center;
+        else out->switches[i] = state.rgdwPOV[i] * 8 / 36000 + 1;
+    }
+
+    i = 0;
+    out->axes[i++] = state.lX / 65535.;
+    out->axes[i++] = state.lY / 65535.;
+    out->axes[i++] = state.lZ / 65535.;
+    out->axes[i++] = state.lRx / 65535.;
+    out->axes[i++] = state.lRy / 65535.;
+    out->axes[i++] = state.lRz / 65535.;
+    out->axes[i++] = state.rglSlider[0] / 65535.;
+    out->axes[i++] = state.rglSlider[1] / 65535.;
+    out->axes[i++] = state.lVX / 65535.;
+    out->axes[i++] = state.lVY / 65535.;
+    out->axes[i++] = state.lVZ / 65535.;
+    out->axes[i++] = state.lVRx / 65535.;
+    out->axes[i++] = state.lVRy / 65535.;
+    out->axes[i++] = state.lVRz / 65535.;
+    out->axes[i++] = state.rglVSlider[0] / 65535.;
+    out->axes[i++] = state.rglVSlider[1] / 65535.;
+    out->axes[i++] = state.lAX / 65535.;
+    out->axes[i++] = state.lAY / 65535.;
+    out->axes[i++] = state.lAZ / 65535.;
+    out->axes[i++] = state.lARx / 65535.;
+    out->axes[i++] = state.lARy / 65535.;
+    out->axes[i++] = state.lARz / 65535.;
+    out->axes[i++] = state.rglASlider[0] / 65535.;
+    out->axes[i++] = state.rglASlider[1] / 65535.;
+    out->axes[i++] = state.lFX / 65535.;
+    out->axes[i++] = state.lFY / 65535.;
+    out->axes[i++] = state.lFZ / 65535.;
+    out->axes[i++] = state.lFRx / 65535.;
+    out->axes[i++] = state.lFRy / 65535.;
+    out->axes[i++] = state.lFRz / 65535.;
+    out->axes[i++] = state.rglFSlider[0] / 65535.;
+    out->axes[i++] = state.rglFSlider[1] / 65535.;
+    out->timestamp = GetTickCount64();
+
+    return S_OK;
+}
+
+static HRESULT WINAPI wine_provider_get_Vibration( IWineGameControllerProvider *iface, struct WineGameControllerVibration *out )
+{
+    struct provider *impl = impl_from_IWineGameControllerProvider( iface );
+    TRACE( "iface %p, out %p.\n", iface, out );
+    *out = impl->vibration;
+    return S_OK;
+}
+
+static HRESULT WINAPI wine_provider_put_Vibration( IWineGameControllerProvider *iface, struct WineGameControllerVibration value )
+{
+    struct provider *impl = impl_from_IWineGameControllerProvider( iface );
+    ULONG report_len = impl->caps.OutputReportByteLength;
+    PHIDP_PREPARSED_DATA preparsed = impl->preparsed;
+    char *report_buf = impl->report_buf;
+    USHORT collection;
+    NTSTATUS status;
+    BOOL ret;
+
+    TRACE( "iface %p, value %p.\n", iface, &value );
+
+    if (!memcmp( &impl->vibration, &value, sizeof(value) )) return S_OK;
+    impl->vibration = value;
+
+    status = HidP_InitializeReportForID( HidP_Output, impl->haptics_report, preparsed, report_buf, report_len );
+    if (status != HIDP_STATUS_SUCCESS) WARN( "HidP_InitializeReportForID returned %#lx\n", status );
+
+    collection = impl->haptics_rumble_caps.LinkCollection;
+    status = HidP_SetUsageValue( HidP_Output, HID_USAGE_PAGE_HAPTICS, collection, HID_USAGE_HAPTICS_INTENSITY,
+                                 impl->vibration.rumble, preparsed, report_buf, report_len );
+    if (status != HIDP_STATUS_SUCCESS) WARN( "HidP_SetUsageValue INTENSITY returned %#lx\n", status );
+
+    collection = impl->haptics_buzz_caps.LinkCollection;
+    status = HidP_SetUsageValue( HidP_Output, HID_USAGE_PAGE_HAPTICS, collection, HID_USAGE_HAPTICS_INTENSITY,
+                                 impl->vibration.buzz, preparsed, report_buf, report_len );
+    if (status != HIDP_STATUS_SUCCESS) WARN( "HidP_SetUsageValue INTENSITY returned %#lx\n", status );
+
+    collection = impl->haptics_left_caps.LinkCollection;
+    status = HidP_SetUsageValue( HidP_Output, HID_USAGE_PAGE_HAPTICS, collection, HID_USAGE_HAPTICS_INTENSITY,
+                                 impl->vibration.left, preparsed, report_buf, report_len );
+    if (status != HIDP_STATUS_SUCCESS) WARN( "HidP_SetUsageValue INTENSITY returned %#lx\n", status );
+
+    collection = impl->haptics_right_caps.LinkCollection;
+    status = HidP_SetUsageValue( HidP_Output, HID_USAGE_PAGE_HAPTICS, collection, HID_USAGE_HAPTICS_INTENSITY,
+                                 impl->vibration.right, preparsed, report_buf, report_len );
+    if (status != HIDP_STATUS_SUCCESS) WARN( "HidP_SetUsageValue INTENSITY returned %#lx\n", status );
+
+    ret = HidD_SetOutputReport( impl->device, report_buf, report_len );
+    if (!ret) WARN( "HidD_SetOutputReport failed with error %lu\n", GetLastError() );
+
+    return S_OK;
+}
+
+static HRESULT WINAPI wine_provider_get_ForceFeedbackMotor( IWineGameControllerProvider *iface, IForceFeedbackMotor **value )
+{
+    struct provider *impl = impl_from_IWineGameControllerProvider( iface );
+    DIDEVCAPS caps = {.dwSize = sizeof(DIDEVCAPS)};
+    HRESULT hr;
+
+    TRACE( "iface %p, value %p.\n", iface, value );
+
+    if (SUCCEEDED(hr = IDirectInputDevice8_GetCapabilities( impl->dinput_device, &caps )) && (caps.dwFlags & DIDC_FORCEFEEDBACK))
+        return force_feedback_motor_create( impl->dinput_device, value );
+
+    *value = NULL;
+    return S_OK;
+}
+
+static const struct IWineGameControllerProviderVtbl wine_provider_vtbl =
+{
+    wine_provider_QueryInterface,
+    wine_provider_AddRef,
+    wine_provider_Release,
+    /* IInspectable methods */
+    wine_provider_GetIids,
+    wine_provider_GetRuntimeClassName,
+    wine_provider_GetTrustLevel,
+    /* IWineGameControllerProvider methods */
+    wine_provider_get_NonRoamableId,
+    wine_provider_get_DisplayName,
+    wine_provider_get_Type,
+    wine_provider_get_AxisCount,
+    wine_provider_get_ButtonCount,
+    wine_provider_get_SwitchCount,
+    wine_provider_get_State,
+    wine_provider_get_Vibration,
+    wine_provider_put_Vibration,
+    wine_provider_get_ForceFeedbackMotor,
+};
+
+DEFINE_IINSPECTABLE( game_provider, IGameControllerProvider, struct provider, IWineGameControllerProvider_iface )
+
+static HRESULT WINAPI game_provider_get_FirmwareVersionInfo( IGameControllerProvider *iface, GameControllerVersionInfo *value )
+{
+    FIXME( "iface %p, value %p stub!\n", iface, value );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_provider_get_HardwareProductId( IGameControllerProvider *iface, UINT16 *value )
+{
+    DIPROPDWORD vid_pid = {.diph = {.dwHeaderSize = sizeof(DIPROPHEADER), .dwSize = sizeof(DIPROPDWORD)}};
+    struct provider *impl = impl_from_IGameControllerProvider( iface );
+    HRESULT hr;
+
+    TRACE( "iface %p, value %p.\n", iface, value );
+
+    if (SUCCEEDED(hr = IDirectInputDevice8_GetProperty( impl->dinput_device, DIPROP_VIDPID, &vid_pid.diph )))
+        *value = HIWORD(vid_pid.dwData);
+    return hr;
+}
+
+static HRESULT WINAPI game_provider_get_HardwareVendorId( IGameControllerProvider *iface, UINT16 *value )
+{
+    DIPROPDWORD vid_pid = {.diph = {.dwHeaderSize = sizeof(DIPROPHEADER), .dwSize = sizeof(DIPROPDWORD)}};
+    struct provider *impl = impl_from_IGameControllerProvider( iface );
+    HRESULT hr;
+
+    TRACE( "iface %p, value %p.\n", iface, value );
+
+    if (SUCCEEDED(hr = IDirectInputDevice8_GetProperty( impl->dinput_device, DIPROP_VIDPID, &vid_pid.diph )))
+        *value = LOWORD(vid_pid.dwData);
+    return hr;
+}
+
+static HRESULT WINAPI game_provider_get_HardwareVersionInfo( IGameControllerProvider *iface, GameControllerVersionInfo *value )
+{
+    FIXME( "iface %p, value %p stub!\n", iface, value );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI game_provider_get_IsConnected( IGameControllerProvider *iface, boolean *value )
+{
+    FIXME( "iface %p, value %p stub!\n", iface, value );
+    return E_NOTIMPL;
+}
+
+static const struct IGameControllerProviderVtbl game_provider_vtbl =
+{
+    game_provider_QueryInterface,
+    game_provider_AddRef,
+    game_provider_Release,
+    /* IInspectable methods */
+    game_provider_GetIids,
+    game_provider_GetRuntimeClassName,
+    game_provider_GetTrustLevel,
+    /* IGameControllerProvider methods */
+    game_provider_get_FirmwareVersionInfo,
+    game_provider_get_HardwareProductId,
+    game_provider_get_HardwareVendorId,
+    game_provider_get_HardwareVersionInfo,
+    game_provider_get_IsConnected,
+};
+
+static void check_haptics_caps( struct provider *provider, HANDLE device, PHIDP_PREPARSED_DATA preparsed,
+                                HIDP_LINK_COLLECTION_NODE *collections, HIDP_VALUE_CAPS *caps )
+{
+    USHORT count, report_len = provider->caps.FeatureReportByteLength;
+    ULONG parent = caps->LinkCollection, waveform = 0;
+    char *report_buf = provider->report_buf;
+    HIDP_VALUE_CAPS value_caps;
+    USAGE_AND_PAGE phy_usages;
+    NTSTATUS status;
+
+    while (collections[parent].LinkUsagePage != HID_USAGE_PAGE_HAPTICS ||
+           collections[parent].LinkUsage != HID_USAGE_HAPTICS_SIMPLE_CONTROLLER)
+        if (!(parent = collections[parent].Parent)) break;
+
+    if (collections[parent].LinkUsagePage != HID_USAGE_PAGE_HAPTICS ||
+        collections[parent].LinkUsage != HID_USAGE_HAPTICS_SIMPLE_CONTROLLER)
+    {
+        WARN( "Failed to find haptics simple controller collection\n" );
+        return;
+    }
+    phy_usages.UsagePage = collections[collections[parent].Parent].LinkUsagePage;
+    phy_usages.Usage = collections[collections[parent].Parent].LinkUsage;
+
+    status = HidP_InitializeReportForID( HidP_Feature, caps->ReportID, preparsed, report_buf, report_len );
+    if (status != HIDP_STATUS_SUCCESS) WARN( "HidP_InitializeReportForID returned %#lx\n", status );
+    if (!HidD_GetFeature( device, report_buf, report_len ))
+    {
+        WARN( "Failed to get waveform list report, error %lu\n", GetLastError() );
+        return;
+    }
+
+    status = HidP_GetUsageValue( HidP_Feature, caps->UsagePage, caps->LinkCollection,
+                                 caps->NotRange.Usage, &waveform, preparsed, report_buf, report_len );
+    if (status != HIDP_STATUS_SUCCESS) WARN( "HidP_GetUsageValue returned %#lx\n", status );
+
+    count = 1;
+    status = HidP_GetSpecificValueCaps( HidP_Output, HID_USAGE_PAGE_HAPTICS, parent,
+                                        HID_USAGE_HAPTICS_INTENSITY, &value_caps, &count, preparsed );
+    if (status != HIDP_STATUS_SUCCESS || !count) WARN( "Failed to get waveform intensity caps, status %#lx\n", status );
+    else if (phy_usages.UsagePage == HID_USAGE_PAGE_GENERIC && phy_usages.Usage == HID_USAGE_GENERIC_Z)
+    {
+        TRACE( "Found left rumble caps, report %u collection %u\n", value_caps.ReportID, value_caps.LinkCollection );
+        provider->haptics_report = value_caps.ReportID;
+        provider->haptics_left_caps = value_caps;
+    }
+    else if (phy_usages.UsagePage == HID_USAGE_PAGE_GENERIC && phy_usages.Usage == HID_USAGE_GENERIC_RZ)
+    {
+        TRACE( "Found right rumble caps, report %u collection %u\n", value_caps.ReportID, value_caps.LinkCollection );
+        provider->haptics_report = value_caps.ReportID;
+        provider->haptics_right_caps = value_caps;
+    }
+    else if (waveform == HID_USAGE_HAPTICS_WAVEFORM_RUMBLE)
+    {
+        TRACE( "Found rumble caps, report %u collection %u\n", value_caps.ReportID, value_caps.LinkCollection );
+        provider->haptics_report = value_caps.ReportID;
+        provider->haptics_rumble_caps = value_caps;
+    }
+    else if (waveform == HID_USAGE_HAPTICS_WAVEFORM_BUZZ)
+    {
+        TRACE( "Found buzz caps, report %u collection %u\n", value_caps.ReportID, value_caps.LinkCollection );
+        provider->haptics_report = value_caps.ReportID;
+        provider->haptics_buzz_caps = value_caps;
+    }
+    else FIXME( "Unsupported waveform type %#lx\n", waveform );
+}
+
+static void open_haptics_device( struct provider *provider )
+{
+    HIDP_LINK_COLLECTION_NODE *collections;
+    PHIDP_PREPARSED_DATA preparsed = NULL;
+    ULONG i, size, coll_count = 0;
+    USHORT count, caps_count = 0;
+    HIDP_VALUE_CAPS caps[8];
+    NTSTATUS status;
+    HANDLE device;
+
+    device = CreateFileW( provider->device_path, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
+                          NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, 0 );
+    if (device == INVALID_HANDLE_VALUE) return;
+
+    if (!HidD_GetPreparsedData( device, &preparsed )) goto failed;
+    if (HidP_GetCaps( preparsed, &provider->caps ) != HIDP_STATUS_SUCCESS) goto failed;
+
+    size = max( provider->caps.OutputReportByteLength, provider->caps.FeatureReportByteLength );
+    if (!(provider->report_buf = malloc( size ))) goto failed;
+
+    coll_count = provider->caps.NumberLinkCollectionNodes;
+    if (!(collections = malloc( sizeof(*collections) * coll_count ))) goto failed;
+
+    status = HidP_GetLinkCollectionNodes( collections, &coll_count, preparsed );
+    if (status != HIDP_STATUS_SUCCESS) WARN( "HidP_GetLinkCollectionNodes returned %#lx\n", status );
+    else for (i = 0; i < coll_count; ++i)
+    {
+        if (collections[i].LinkUsagePage != HID_USAGE_PAGE_HAPTICS) continue;
+        if (collections[i].LinkUsage == HID_USAGE_HAPTICS_WAVEFORM_LIST)
+        {
+            count = ARRAY_SIZE(caps) - caps_count;
+            status = HidP_GetSpecificValueCaps( HidP_Feature, HID_USAGE_PAGE_ORDINAL, i, 0,
+                                                caps + caps_count, &count, preparsed );
+            if (status == HIDP_STATUS_SUCCESS) caps_count += count;
+        }
+    }
+    for (i = 0; i < caps_count; ++i) check_haptics_caps( provider, device, preparsed, collections, caps + i );
+    free( collections );
+
+    provider->preparsed = preparsed;
+    provider->device = device;
+    return;
+
+failed:
+    free( provider->report_buf );
+    provider->report_buf = NULL;
+    HidD_FreePreparsedData( preparsed );
+    CloseHandle( device );
+}
+
+static const DIOBJECTDATAFORMAT data_format_objs[] =
+{
+    {NULL,DIJOFS_X,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_Y,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_Z,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_RX,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_RY,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_RZ,DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_SLIDER(0),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_SLIDER(1),DIDFT_OPTIONAL|DIDFT_AXIS|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_POV(0),DIDFT_OPTIONAL|DIDFT_POV|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_POV(1),DIDFT_OPTIONAL|DIDFT_POV|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_POV(2),DIDFT_OPTIONAL|DIDFT_POV|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_POV(3),DIDFT_OPTIONAL|DIDFT_POV|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(0),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(1),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(2),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(3),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(4),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(5),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(6),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(7),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(8),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(9),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(10),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(11),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(12),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(13),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(14),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(15),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(16),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(17),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(18),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(19),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(20),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(21),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(22),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(23),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(24),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(25),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(26),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(27),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(28),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(29),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(30),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(31),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(32),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(33),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(34),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(35),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(36),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(37),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(38),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(39),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(40),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(41),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(42),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(43),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(44),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(45),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(46),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(47),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(48),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(49),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(50),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(51),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(52),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(53),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(54),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(55),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(56),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(57),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(58),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(59),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(60),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(61),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(62),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(63),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(64),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(65),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(66),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(67),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(68),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(69),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(70),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(71),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(72),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(73),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(74),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(75),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(76),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(77),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(78),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(79),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(80),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(81),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(82),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(83),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(84),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(85),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(86),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(87),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(88),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(89),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(90),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(91),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(92),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(93),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(94),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(95),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(96),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(97),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(98),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(99),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(100),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(101),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(102),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(103),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(104),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(105),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(106),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(107),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(108),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(109),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(110),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(111),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(112),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(113),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(114),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(115),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(116),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(117),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(118),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(119),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(120),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(121),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(122),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(123),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(124),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(125),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(126),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+    {NULL,DIJOFS_BUTTON(127),DIDFT_OPTIONAL|DIDFT_BUTTON|DIDFT_ANYINSTANCE},
+};
+
+static const DIDATAFORMAT data_format =
+{
+    sizeof(DIDATAFORMAT),
+    sizeof(DIOBJECTDATAFORMAT),
+    DIDF_ABSAXIS,
+    sizeof(DIJOYSTATE2),
+    ARRAY_SIZE(data_format_objs),
+    (LPDIOBJECTDATAFORMAT)data_format_objs
+};
+
+void provider_create( const WCHAR *device_path )
+{
+    IDirectInputDevice8W *dinput_device;
+    IGameControllerProvider *provider;
+    struct provider *impl, *entry;
+    GUID guid = device_path_guid;
+    IDirectInput8W *dinput;
+    BOOL found = FALSE;
+    const WCHAR *tmp;
+    HRESULT hr;
+
+    if (wcsnicmp( device_path, L"\\\\?\\HID#", 8 )) return;
+    if ((tmp = wcschr( device_path + 8, '#' )) && !wcsnicmp( tmp - 6, L"&IG_", 4 )) return;
+
+    TRACE( "device_path %s\n", debugstr_w( device_path ) );
+
+    *(const WCHAR **)&guid = device_path;
+    if (FAILED(DirectInput8Create( windows_gaming_input, DIRECTINPUT_VERSION, &IID_IDirectInput8W,
+                                   (void **)&dinput, NULL ))) return;
+    hr = IDirectInput8_CreateDevice( dinput, &guid, &dinput_device, NULL );
+    IDirectInput8_Release( dinput );
+    if (FAILED(hr)) return;
+
+    if (FAILED(hr = IDirectInputDevice8_SetCooperativeLevel( dinput_device, 0, DISCL_BACKGROUND | DISCL_NONEXCLUSIVE ))) goto done;
+    if (FAILED(hr = IDirectInputDevice8_SetDataFormat( dinput_device, &data_format ))) goto done;
+    if (FAILED(hr = IDirectInputDevice8_Acquire( dinput_device ))) goto done;
+
+    if (!(impl = calloc( 1, sizeof(*impl) ))) goto done;
+    impl->IWineGameControllerProvider_iface.lpVtbl = &wine_provider_vtbl;
+    impl->IGameControllerProvider_iface.lpVtbl = &game_provider_vtbl;
+    IDirectInputDevice_AddRef( dinput_device );
+    impl->dinput_device = dinput_device;
+    impl->ref = 1;
+
+    wcscpy( impl->device_path, device_path );
+    list_init( &impl->entry );
+    open_haptics_device( impl );
+
+    provider = &impl->IGameControllerProvider_iface;
+    TRACE( "created WineGameControllerProvider %p\n", provider );
+
+    EnterCriticalSection( &provider_cs );
+    LIST_FOR_EACH_ENTRY( entry, &provider_list, struct provider, entry )
+        if ((found = !wcsicmp( entry->device_path, device_path ))) break;
+    if (!found) list_add_tail( &provider_list, &impl->entry );
+    LeaveCriticalSection( &provider_cs );
+
+    if (found) IGameControllerProvider_Release( provider );
+    else manager_on_provider_created( provider );
+done:
+    IDirectInputDevice_Release( dinput_device );
+}
+
+void provider_remove( const WCHAR *device_path )
+{
+    IGameControllerProvider *provider;
+    struct provider *entry;
+    BOOL found = FALSE;
+
+    TRACE( "device_path %s\n", debugstr_w( device_path ) );
+
+    EnterCriticalSection( &provider_cs );
+    LIST_FOR_EACH_ENTRY( entry, &provider_list, struct provider, entry )
+        if ((found = !wcsicmp( entry->device_path, device_path ))) break;
+    if (found) list_remove( &entry->entry );
+    LeaveCriticalSection( &provider_cs );
+
+    if (!found) WARN( "provider not found for device %s\n", debugstr_w( device_path ) );
+    else
+    {
+        provider = &entry->IGameControllerProvider_iface;
+        manager_on_provider_removed( provider );
+        IGameControllerProvider_Release( provider );
+    }
+}
diff -ruN --show-c-function dlls/winebus.sys/bus_sdl.c dlls/winebus.sys/bus_sdl.c
--- dlls/winebus.sys/bus_sdl.c	2025-10-10 10:17:47.517032094 -0700
+++ dlls/winebus.sys/bus_sdl.c	2025-10-10 12:03:54.183182445 -0700
@@ -116,6 +116,8 @@ MAKE_FUNCPTR(SDL_GameControllerAddMappin
 MAKE_FUNCPTR(SDL_RegisterEvents);
 MAKE_FUNCPTR(SDL_PushEvent);
 MAKE_FUNCPTR(SDL_GetTicks);
+MAKE_FUNCPTR(SDL_LogSetPriority);
+MAKE_FUNCPTR(SDL_SetHintWithPriority);
 static int (*pSDL_JoystickRumble)(SDL_Joystick *joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble, Uint32 duration_ms);
 static int (*pSDL_JoystickRumbleTriggers)(SDL_Joystick *joystick, Uint16 left_rumble, Uint16 right_rumble, Uint32 duration_ms);
 static Uint16 (*pSDL_JoystickGetProduct)(SDL_Joystick * joystick);
@@ -926,6 +928,22 @@ static BOOL set_report_from_controller_e
     return FALSE;
 }
 
+/* logic from SDL2's SDL_ShouldIgnoreGameController */
+BOOL is_sdl_ignored_device(WORD vid, WORD pid)
+{
+    const char *whitelist = getenv("SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT");
+    const char *blacklist = getenv("SDL_GAMECONTROLLER_IGNORE_DEVICES");
+    char needle[16];
+
+    if (vid == 0x056a) return TRUE; /* all Wacom devices */
+    if (vid == 0x28de && pid == 0x11ff) return TRUE; /* Steam Input virtual controller, handled with evdev */
+
+    sprintf(needle, "0x%04x/0x%04x", vid, pid);
+    if (whitelist) return strcasestr(whitelist, needle) == NULL;
+    if (blacklist) return strcasestr(blacklist, needle) != NULL;
+    return FALSE;
+}
+
 static void sdl_add_device(unsigned int index)
 {
     struct device_desc desc =
@@ -974,6 +992,14 @@ static void sdl_add_device(unsigned int
         desc.version = 0;
     }
 
+    if (is_sdl_ignored_device(desc.vid, desc.pid))
+    {
+        TRACE("ignoring %s\n", debugstr_device_desc(&desc));
+        if (controller) pSDL_GameControllerClose(controller);
+        pSDL_JoystickClose(joystick);
+        return;
+    }
+
     if (pSDL_JoystickGetSerial && (sdl_serial = pSDL_JoystickGetSerial(joystick)))
         ntdll_umbstowcs(sdl_serial, strlen(sdl_serial) + 1, desc.serialnumber, ARRAY_SIZE(desc.serialnumber));
 
@@ -1139,6 +1165,8 @@ NTSTATUS sdl_bus_init(void *args)
     LOAD_FUNCPTR(SDL_RegisterEvents);
     LOAD_FUNCPTR(SDL_PushEvent);
     LOAD_FUNCPTR(SDL_GetTicks);
+    LOAD_FUNCPTR(SDL_LogSetPriority);
+    LOAD_FUNCPTR(SDL_SetHintWithPriority);
 #undef LOAD_FUNCPTR
     pSDL_JoystickRumble = dlsym(sdl_handle, "SDL_JoystickRumble");
     pSDL_JoystickRumbleTriggers = dlsym(sdl_handle, "SDL_JoystickRumbleTriggers");
@@ -1148,6 +1176,10 @@ NTSTATUS sdl_bus_init(void *args)
     pSDL_JoystickGetType = dlsym(sdl_handle, "SDL_JoystickGetType");
     pSDL_JoystickGetSerial = dlsym(sdl_handle, "SDL_JoystickGetSerial");
 
+    /* CW-Bug-Id: #23185: Disable SDL 2.30 new behavior, we need the steam virtual
+     * controller name to figure which slot number it represents. */
+    pSDL_SetHintWithPriority("SteamVirtualGamepadInfo", "", SDL_HINT_OVERRIDE);
+
     if (pSDL_Init(SDL_INIT_GAMECONTROLLER | SDL_INIT_HAPTIC) < 0)
     {
         ERR("could not init SDL: %s\n", pSDL_GetError());
@@ -1160,6 +1192,11 @@ NTSTATUS sdl_bus_init(void *args)
         goto failed;
     }
 
+    if (TRACE_ON(hid))
+    {
+        pSDL_LogSetPriority(SDL_LOG_CATEGORY_INPUT, SDL_LOG_PRIORITY_VERBOSE);
+    }
+
     pSDL_JoystickEventState(SDL_ENABLE);
     pSDL_GameControllerEventState(SDL_ENABLE);
 
diff -ruN --show-c-function dlls/winebus.sys/bus_sdl.c.orig dlls/winebus.sys/bus_sdl.c.orig
--- dlls/winebus.sys/bus_sdl.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ dlls/winebus.sys/bus_sdl.c.orig	2025-10-10 12:03:48.305197099 -0700
@@ -0,0 +1,1249 @@
+/*
+ * Plug and Play support for hid devices found through SDL2
+ *
+ * Copyright 2017 CodeWeavers, Aric Stewart
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <dlfcn.h>
+#ifdef HAVE_SDL_H
+# include <SDL.h>
+#endif
+
+#include <pthread.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winbase.h"
+#include "winnls.h"
+#include "winreg.h"
+#include "winternl.h"
+#include "ddk/wdm.h"
+#include "ddk/hidtypes.h"
+#include "ddk/hidsdi.h"
+#include "hidusage.h"
+
+#include "wine/debug.h"
+#include "wine/hid.h"
+#include "wine/unixlib.h"
+
+#include "unix_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(hid);
+
+#ifdef SONAME_LIBSDL2
+
+static pthread_mutex_t sdl_cs = PTHREAD_MUTEX_INITIALIZER;
+static const struct bus_options *options;
+
+static void *sdl_handle = NULL;
+static UINT quit_event = -1;
+static struct list event_queue = LIST_INIT(event_queue);
+static struct list device_list = LIST_INIT(device_list);
+
+#define MAKE_FUNCPTR(f) static typeof(f) * p##f = NULL
+MAKE_FUNCPTR(SDL_GetError);
+MAKE_FUNCPTR(SDL_Init);
+MAKE_FUNCPTR(SDL_JoystickClose);
+MAKE_FUNCPTR(SDL_JoystickEventState);
+MAKE_FUNCPTR(SDL_JoystickGetGUID);
+MAKE_FUNCPTR(SDL_JoystickGetGUIDString);
+MAKE_FUNCPTR(SDL_JoystickInstanceID);
+MAKE_FUNCPTR(SDL_JoystickName);
+MAKE_FUNCPTR(SDL_JoystickNumAxes);
+MAKE_FUNCPTR(SDL_JoystickOpen);
+MAKE_FUNCPTR(SDL_WaitEventTimeout);
+MAKE_FUNCPTR(SDL_JoystickNumButtons);
+MAKE_FUNCPTR(SDL_JoystickNumBalls);
+MAKE_FUNCPTR(SDL_JoystickNumHats);
+MAKE_FUNCPTR(SDL_JoystickGetAxis);
+MAKE_FUNCPTR(SDL_JoystickGetHat);
+MAKE_FUNCPTR(SDL_IsGameController);
+MAKE_FUNCPTR(SDL_GameControllerClose);
+MAKE_FUNCPTR(SDL_GameControllerGetAxis);
+MAKE_FUNCPTR(SDL_GameControllerGetButton);
+MAKE_FUNCPTR(SDL_GameControllerName);
+MAKE_FUNCPTR(SDL_GameControllerOpen);
+MAKE_FUNCPTR(SDL_GameControllerEventState);
+MAKE_FUNCPTR(SDL_HapticClose);
+MAKE_FUNCPTR(SDL_HapticDestroyEffect);
+MAKE_FUNCPTR(SDL_HapticGetEffectStatus);
+MAKE_FUNCPTR(SDL_HapticNewEffect);
+MAKE_FUNCPTR(SDL_HapticNumAxes);
+MAKE_FUNCPTR(SDL_HapticOpenFromJoystick);
+MAKE_FUNCPTR(SDL_HapticPause);
+MAKE_FUNCPTR(SDL_HapticQuery);
+MAKE_FUNCPTR(SDL_HapticRumbleInit);
+MAKE_FUNCPTR(SDL_HapticRumblePlay);
+MAKE_FUNCPTR(SDL_HapticRumbleStop);
+MAKE_FUNCPTR(SDL_HapticRumbleSupported);
+MAKE_FUNCPTR(SDL_HapticRunEffect);
+MAKE_FUNCPTR(SDL_HapticSetGain);
+MAKE_FUNCPTR(SDL_HapticSetAutocenter);
+MAKE_FUNCPTR(SDL_HapticStopAll);
+MAKE_FUNCPTR(SDL_HapticStopEffect);
+MAKE_FUNCPTR(SDL_HapticUnpause);
+MAKE_FUNCPTR(SDL_HapticUpdateEffect);
+MAKE_FUNCPTR(SDL_JoystickIsHaptic);
+MAKE_FUNCPTR(SDL_GameControllerAddMapping);
+MAKE_FUNCPTR(SDL_RegisterEvents);
+MAKE_FUNCPTR(SDL_PushEvent);
+MAKE_FUNCPTR(SDL_GetTicks);
+static int (*pSDL_JoystickRumble)(SDL_Joystick *joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble, Uint32 duration_ms);
+static int (*pSDL_JoystickRumbleTriggers)(SDL_Joystick *joystick, Uint16 left_rumble, Uint16 right_rumble, Uint32 duration_ms);
+static Uint16 (*pSDL_JoystickGetProduct)(SDL_Joystick * joystick);
+static Uint16 (*pSDL_JoystickGetProductVersion)(SDL_Joystick * joystick);
+static Uint16 (*pSDL_JoystickGetVendor)(SDL_Joystick * joystick);
+static SDL_JoystickType (*pSDL_JoystickGetType)(SDL_Joystick * joystick);
+static const char *(*pSDL_JoystickGetSerial)(SDL_Joystick * joystick);
+
+/* internal bits for extended rumble support, SDL_Haptic types are 16-bits */
+#define WINE_SDL_JOYSTICK_RUMBLE  0x40000000 /* using SDL_JoystickRumble API */
+#define WINE_SDL_HAPTIC_RUMBLE    0x80000000 /* using SDL_HapticRumble API */
+
+#define EFFECT_SUPPORT_HAPTICS  (SDL_HAPTIC_LEFTRIGHT|WINE_SDL_HAPTIC_RUMBLE|WINE_SDL_JOYSTICK_RUMBLE)
+#define EFFECT_SUPPORT_PHYSICAL (SDL_HAPTIC_CONSTANT|SDL_HAPTIC_RAMP|SDL_HAPTIC_SINE|SDL_HAPTIC_TRIANGLE| \
+                                 SDL_HAPTIC_SAWTOOTHUP|SDL_HAPTIC_SAWTOOTHDOWN|SDL_HAPTIC_SPRING|SDL_HAPTIC_DAMPER|SDL_HAPTIC_INERTIA| \
+                                 SDL_HAPTIC_FRICTION|SDL_HAPTIC_CUSTOM)
+
+struct sdl_device
+{
+    struct unix_device unix_device;
+
+    SDL_Joystick *sdl_joystick;
+    SDL_GameController *sdl_controller;
+    SDL_JoystickID id;
+    BOOL started;
+
+    DWORD effect_support;
+    SDL_Haptic *sdl_haptic;
+    int haptic_effect_id;
+    int effect_ids[256];
+    int effect_state[256];
+    LONG effect_flags;
+    int axis_offset;
+};
+
+static inline struct sdl_device *impl_from_unix_device(struct unix_device *iface)
+{
+    return CONTAINING_RECORD(iface, struct sdl_device, unix_device);
+}
+
+static struct sdl_device *find_device_from_id(SDL_JoystickID id)
+{
+    struct sdl_device *impl;
+
+    LIST_FOR_EACH_ENTRY(impl, &device_list, struct sdl_device, unix_device.entry)
+        if (impl->id == id && impl->axis_offset == 0) return impl;
+
+    return NULL;
+}
+
+static struct sdl_device *find_device_from_id_and_axis(SDL_JoystickID id, int axis)
+{
+    struct sdl_device *impl;
+
+    LIST_FOR_EACH_ENTRY(impl, &device_list, struct sdl_device, unix_device.entry)
+    {
+        USHORT count = impl->unix_device.hid_device_state.abs_axis_count;
+        if (impl->id == id && impl->axis_offset <= axis && impl->axis_offset + count > axis)
+            return impl;
+    }
+
+    return NULL;
+}
+
+static void set_hat_value(struct unix_device *iface, int index, int value)
+{
+    LONG x = 0, y = 0;
+    switch (value)
+    {
+    case SDL_HAT_CENTERED: break;
+    case SDL_HAT_DOWN: y = 1; break;
+    case SDL_HAT_RIGHTDOWN: y = x = 1; break;
+    case SDL_HAT_RIGHT: x = 1; break;
+    case SDL_HAT_RIGHTUP: x = 1; y = -1; break;
+    case SDL_HAT_UP: y = -1; break;
+    case SDL_HAT_LEFTUP: x = y = -1; break;
+    case SDL_HAT_LEFT: x = -1; break;
+    case SDL_HAT_LEFTDOWN: x = -1; y = 1; break;
+    }
+    hid_device_set_hatswitch_x(iface, index, x);
+    hid_device_set_hatswitch_y(iface, index, y);
+}
+
+static BOOL descriptor_add_haptic(struct sdl_device *impl, BOOL force)
+{
+    USHORT i, count = 0;
+    USAGE usages[16];
+
+    if (impl->axis_offset > 0 || !pSDL_JoystickIsHaptic(impl->sdl_joystick) ||
+        !(impl->sdl_haptic = pSDL_HapticOpenFromJoystick(impl->sdl_joystick)))
+        impl->effect_support = 0;
+    else
+    {
+        impl->effect_support = pSDL_HapticQuery(impl->sdl_haptic);
+        if (!(impl->effect_support & EFFECT_SUPPORT_HAPTICS) &&
+            pSDL_HapticRumbleSupported(impl->sdl_haptic) &&
+            pSDL_HapticRumbleInit(impl->sdl_haptic) == 0)
+            impl->effect_support |= WINE_SDL_HAPTIC_RUMBLE;
+    }
+
+    if (impl->axis_offset == 0 && pSDL_JoystickRumble && !pSDL_JoystickRumble(impl->sdl_joystick, 0, 0, 0))
+        impl->effect_support |= WINE_SDL_JOYSTICK_RUMBLE;
+
+    if (impl->effect_support & EFFECT_SUPPORT_HAPTICS)
+    {
+        if (!hid_device_add_haptics(&impl->unix_device))
+            return FALSE;
+    }
+
+    if ((impl->effect_support & EFFECT_SUPPORT_PHYSICAL))
+    {
+        int axes_count;
+
+        /* SDL_HAPTIC_SQUARE doesn't exist */
+        if (force || (impl->effect_support & SDL_HAPTIC_SINE)) usages[count++] = PID_USAGE_ET_SINE;
+        if (force || (impl->effect_support & SDL_HAPTIC_TRIANGLE)) usages[count++] = PID_USAGE_ET_TRIANGLE;
+        if (force || (impl->effect_support & SDL_HAPTIC_SAWTOOTHUP)) usages[count++] = PID_USAGE_ET_SAWTOOTH_UP;
+        if (force || (impl->effect_support & SDL_HAPTIC_SAWTOOTHDOWN)) usages[count++] = PID_USAGE_ET_SAWTOOTH_DOWN;
+        if (force || (impl->effect_support & SDL_HAPTIC_SPRING)) usages[count++] = PID_USAGE_ET_SPRING;
+        if (force || (impl->effect_support & SDL_HAPTIC_DAMPER)) usages[count++] = PID_USAGE_ET_DAMPER;
+        if (force || (impl->effect_support & SDL_HAPTIC_INERTIA)) usages[count++] = PID_USAGE_ET_INERTIA;
+        if (force || (impl->effect_support & SDL_HAPTIC_FRICTION)) usages[count++] = PID_USAGE_ET_FRICTION;
+        if (force || (impl->effect_support & SDL_HAPTIC_CONSTANT)) usages[count++] = PID_USAGE_ET_CONSTANT_FORCE;
+        if (force || (impl->effect_support & SDL_HAPTIC_RAMP)) usages[count++] = PID_USAGE_ET_RAMP;
+
+        if ((axes_count = pSDL_HapticNumAxes(impl->sdl_haptic)) < 0) axes_count = 2;
+        if (!hid_device_add_physical(&impl->unix_device, usages, count, axes_count))
+            return FALSE;
+    }
+
+    impl->haptic_effect_id = -1;
+    for (i = 0; i < ARRAY_SIZE(impl->effect_ids); ++i) impl->effect_ids[i] = -1;
+    return TRUE;
+}
+
+static const USAGE_AND_PAGE g920_absolute_usages[] =
+{
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_X},  /* wheel */
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_Y},  /* accelerator */
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_Z},  /* brake */
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_RZ}, /* clutch */
+};
+static const USAGE_AND_PAGE absolute_axis_usages[] =
+{
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_X},
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_Y},
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_Z},
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_RX},
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_RY},
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_RZ},
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_SLIDER},
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_DIAL},
+};
+static const USAGE_AND_PAGE relative_axis_usages[] =
+{
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_X},
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_Y},
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_RX},
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_RY},
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_Z},
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_RZ},
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_SLIDER},
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_DIAL},
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_WHEEL},
+};
+
+static int get_absolute_usages(const struct device_desc *desc, const USAGE_AND_PAGE **absolute_usages)
+{
+    if (desc->vid == 0x046d && desc->pid == 0xc262)
+    {
+        *absolute_usages = g920_absolute_usages;
+        return ARRAY_SIZE(g920_absolute_usages);
+    }
+
+    *absolute_usages = absolute_axis_usages;
+    return ARRAY_SIZE(absolute_axis_usages);
+}
+
+static NTSTATUS build_joystick_report_descriptor(struct unix_device *iface, const struct device_desc *desc)
+{
+    const USAGE_AND_PAGE device_usage = {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_JOYSTICK};
+    struct sdl_device *impl = impl_from_unix_device(iface);
+    int i, button_count, axis_count, ball_count, hat_count;
+    USAGE_AND_PAGE physical_usage;
+
+    const USAGE_AND_PAGE *absolute_usages = NULL;
+    size_t absolute_usages_count = get_absolute_usages(desc, &absolute_usages);
+
+    axis_count = pSDL_JoystickNumAxes(impl->sdl_joystick);
+    if (options->split_controllers) axis_count = min(6, axis_count - impl->axis_offset);
+    if (axis_count > absolute_usages_count)
+    {
+        FIXME("More than %zu absolute axes found, ignoring.\n", absolute_usages_count);
+        axis_count = absolute_usages_count;
+    }
+
+    ball_count = pSDL_JoystickNumBalls(impl->sdl_joystick);
+    if (ball_count > ARRAY_SIZE(relative_axis_usages) / 2)
+    {
+        FIXME("More than %zu relative axes found, ignoring.\n", ARRAY_SIZE(relative_axis_usages));
+        ball_count = ARRAY_SIZE(relative_axis_usages) / 2;
+    }
+
+    if (impl->axis_offset == 0)
+    {
+        hat_count = pSDL_JoystickNumHats(impl->sdl_joystick);
+        button_count = pSDL_JoystickNumButtons(impl->sdl_joystick);
+    }
+    else
+    {
+        hat_count = 0;
+        button_count = 0;
+    }
+
+    if (!pSDL_JoystickGetType) physical_usage = device_usage;
+    else switch (pSDL_JoystickGetType(impl->sdl_joystick))
+    {
+    case SDL_JOYSTICK_TYPE_ARCADE_PAD:
+    case SDL_JOYSTICK_TYPE_ARCADE_STICK:
+    case SDL_JOYSTICK_TYPE_DANCE_PAD:
+    case SDL_JOYSTICK_TYPE_DRUM_KIT:
+    case SDL_JOYSTICK_TYPE_GUITAR:
+    case SDL_JOYSTICK_TYPE_UNKNOWN:
+        physical_usage.UsagePage = HID_USAGE_PAGE_GENERIC;
+        physical_usage.Usage = HID_USAGE_GENERIC_JOYSTICK;
+        break;
+    case SDL_JOYSTICK_TYPE_GAMECONTROLLER:
+        physical_usage.UsagePage = HID_USAGE_PAGE_GENERIC;
+        physical_usage.Usage = HID_USAGE_GENERIC_GAMEPAD;
+        break;
+    case SDL_JOYSTICK_TYPE_WHEEL:
+        physical_usage.UsagePage = HID_USAGE_PAGE_SIMULATION;
+        physical_usage.Usage = HID_USAGE_SIMULATION_AUTOMOBILE_SIMULATION_DEVICE;
+        break;
+    case SDL_JOYSTICK_TYPE_FLIGHT_STICK:
+    case SDL_JOYSTICK_TYPE_THROTTLE:
+        physical_usage.UsagePage = HID_USAGE_PAGE_SIMULATION;
+        physical_usage.Usage = HID_USAGE_SIMULATION_FLIGHT_SIMULATION_DEVICE;
+        break;
+    }
+
+    if (!hid_device_begin_report_descriptor(iface, &device_usage))
+        return STATUS_NO_MEMORY;
+
+    if (!hid_device_begin_input_report(iface, &physical_usage))
+        return STATUS_NO_MEMORY;
+
+    for (i = 0; i < axis_count; i++)
+    {
+        if (!hid_device_add_axes(iface, 1, absolute_usages[i].UsagePage,
+                                 &absolute_usages[i].Usage, FALSE, -32768, 32767))
+            return STATUS_NO_MEMORY;
+    }
+
+    for (i = 0; i < ball_count; i++)
+    {
+        if (!hid_device_add_axes(iface, 2, relative_axis_usages[2 * i].UsagePage,
+                                 &relative_axis_usages[2 * i].Usage, TRUE, INT32_MIN, INT32_MAX))
+            return STATUS_NO_MEMORY;
+    }
+
+    if (hat_count && !hid_device_add_hatswitch(iface, hat_count))
+        return STATUS_NO_MEMORY;
+
+    if (button_count && !hid_device_add_buttons(iface, HID_USAGE_PAGE_BUTTON, 1, button_count))
+        return STATUS_NO_MEMORY;
+
+    if (!hid_device_end_input_report(iface))
+        return STATUS_NO_MEMORY;
+
+    if (!descriptor_add_haptic(impl, physical_usage.Usage == HID_USAGE_SIMULATION_AUTOMOBILE_SIMULATION_DEVICE))
+        return STATUS_NO_MEMORY;
+
+    if (!hid_device_end_report_descriptor(iface))
+        return STATUS_NO_MEMORY;
+
+    /* Initialize axis in the report */
+    for (i = 0; i < axis_count; i++)
+        hid_device_set_abs_axis(iface, i, pSDL_JoystickGetAxis(impl->sdl_joystick, i));
+    for (i = 0; i < hat_count; i++)
+        set_hat_value(iface, i, pSDL_JoystickGetHat(impl->sdl_joystick, i));
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS build_controller_report_descriptor(struct unix_device *iface)
+{
+    const USAGE_AND_PAGE device_usage = {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_GAMEPAD};
+    struct sdl_device *impl = impl_from_unix_device(iface);
+    BOOL state;
+
+    C_ASSERT(SDL_CONTROLLER_AXIS_MAX == 6);
+
+    if (!hid_device_begin_report_descriptor(iface, &device_usage)) return STATUS_NO_MEMORY;
+    if (!hid_device_add_gamepad(iface)) return STATUS_NO_MEMORY;
+    if (!descriptor_add_haptic(impl, FALSE)) return STATUS_NO_MEMORY;
+    if (!hid_device_end_report_descriptor(iface)) return STATUS_NO_MEMORY;
+
+    for (int i = SDL_CONTROLLER_AXIS_LEFTX; i < SDL_CONTROLLER_AXIS_MAX; i++)
+    {
+        int value = pSDL_GameControllerGetAxis(impl->sdl_controller, i);
+        if (i == SDL_CONTROLLER_AXIS_LEFTY || i == SDL_CONTROLLER_AXIS_RIGHTY)
+            value = -value - 1; /* match XUSB / GIP protocol */
+        hid_device_set_abs_axis(iface, i, value);
+    }
+
+    state = pSDL_GameControllerGetButton(impl->sdl_controller, SDL_CONTROLLER_BUTTON_DPAD_UP);
+    hid_device_move_hatswitch(iface, 0, 0, state ? -1 : +1);
+    state = pSDL_GameControllerGetButton(impl->sdl_controller, SDL_CONTROLLER_BUTTON_DPAD_DOWN);
+    hid_device_move_hatswitch(iface, 0, 0, state ? +1 : -1);
+    state = pSDL_GameControllerGetButton(impl->sdl_controller, SDL_CONTROLLER_BUTTON_DPAD_LEFT);
+    hid_device_move_hatswitch(iface, 0, state ? -1 : +1, 0);
+    state = pSDL_GameControllerGetButton(impl->sdl_controller, SDL_CONTROLLER_BUTTON_DPAD_RIGHT);
+    hid_device_move_hatswitch(iface, 0, state ? +1 : -1, 0);
+
+    return STATUS_SUCCESS;
+}
+
+static void sdl_device_destroy(struct unix_device *iface)
+{
+}
+
+static NTSTATUS sdl_device_start(struct unix_device *iface)
+{
+    struct sdl_device *impl = impl_from_unix_device(iface);
+
+    pthread_mutex_lock(&sdl_cs);
+    impl->started = TRUE;
+    pthread_mutex_unlock(&sdl_cs);
+
+    return STATUS_SUCCESS;
+}
+
+static void sdl_device_stop(struct unix_device *iface)
+{
+    struct sdl_device *impl = impl_from_unix_device(iface);
+
+    pSDL_JoystickClose(impl->sdl_joystick);
+    if (impl->sdl_controller) pSDL_GameControllerClose(impl->sdl_controller);
+    if (impl->sdl_haptic) pSDL_HapticClose(impl->sdl_haptic);
+
+    pthread_mutex_lock(&sdl_cs);
+    impl->started = FALSE;
+    list_remove(&impl->unix_device.entry);
+    pthread_mutex_unlock(&sdl_cs);
+}
+
+static NTSTATUS sdl_device_haptics_start(struct unix_device *iface, UINT duration_ms,
+                                         USHORT rumble_intensity, USHORT buzz_intensity,
+                                         USHORT left_intensity, USHORT right_intensity)
+{
+    struct sdl_device *impl = impl_from_unix_device(iface);
+
+    TRACE("iface %p, duration_ms %u, rumble_intensity %u, buzz_intensity %u, left_intensity %u, right_intensity %u.\n",
+          iface, duration_ms, rumble_intensity, buzz_intensity, left_intensity, right_intensity);
+
+    if (!(impl->effect_support & EFFECT_SUPPORT_HAPTICS)) return STATUS_NOT_SUPPORTED;
+
+    if (impl->effect_support & WINE_SDL_JOYSTICK_RUMBLE)
+    {
+        pSDL_JoystickRumble(impl->sdl_joystick, rumble_intensity, buzz_intensity, duration_ms);
+        if (pSDL_JoystickRumbleTriggers)
+            pSDL_JoystickRumbleTriggers(impl->sdl_joystick, left_intensity, right_intensity, duration_ms);
+    }
+    else if (impl->effect_support & SDL_HAPTIC_LEFTRIGHT)
+    {
+        SDL_HapticEffect effect;
+
+        memset(&effect, 0, sizeof(SDL_HapticEffect));
+        effect.type = SDL_HAPTIC_LEFTRIGHT;
+        effect.leftright.length = duration_ms;
+        effect.leftright.large_magnitude = rumble_intensity;
+        effect.leftright.small_magnitude = buzz_intensity;
+
+        if (impl->haptic_effect_id >= 0)
+            pSDL_HapticDestroyEffect(impl->sdl_haptic, impl->haptic_effect_id);
+        impl->haptic_effect_id = pSDL_HapticNewEffect(impl->sdl_haptic, &effect);
+        if (impl->haptic_effect_id >= 0)
+            pSDL_HapticRunEffect(impl->sdl_haptic, impl->haptic_effect_id, 1);
+    }
+    else if (impl->effect_support & WINE_SDL_HAPTIC_RUMBLE)
+    {
+        float magnitude = (rumble_intensity + buzz_intensity) / 2.0 / 32767.0;
+        pSDL_HapticRumblePlay(impl->sdl_haptic, magnitude, duration_ms);
+    }
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS sdl_device_haptics_stop(struct unix_device *iface)
+{
+    struct sdl_device *impl = impl_from_unix_device(iface);
+
+    TRACE("iface %p.\n", iface);
+
+    if (impl->effect_support & WINE_SDL_JOYSTICK_RUMBLE)
+    {
+        pSDL_JoystickRumble(impl->sdl_joystick, 0, 0, 0);
+        if (pSDL_JoystickRumbleTriggers)
+            pSDL_JoystickRumbleTriggers(impl->sdl_joystick, 0, 0, 0);
+    }
+    else if (impl->effect_support & SDL_HAPTIC_LEFTRIGHT)
+        pSDL_HapticStopAll(impl->sdl_haptic);
+    else if (impl->effect_support & WINE_SDL_HAPTIC_RUMBLE)
+        pSDL_HapticRumbleStop(impl->sdl_haptic);
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS sdl_device_physical_device_control(struct unix_device *iface, USAGE control)
+{
+    struct sdl_device *impl = impl_from_unix_device(iface);
+    unsigned int i;
+
+    TRACE("iface %p, control %#04x.\n", iface, control);
+
+    switch (control)
+    {
+    case PID_USAGE_DC_ENABLE_ACTUATORS:
+        pSDL_HapticSetGain(impl->sdl_haptic, 100);
+        InterlockedOr(&impl->effect_flags, EFFECT_STATE_ACTUATORS_ENABLED);
+        return STATUS_SUCCESS;
+    case PID_USAGE_DC_DISABLE_ACTUATORS:
+        pSDL_HapticSetGain(impl->sdl_haptic, 0);
+        InterlockedAnd(&impl->effect_flags, ~EFFECT_STATE_ACTUATORS_ENABLED);
+        return STATUS_SUCCESS;
+    case PID_USAGE_DC_STOP_ALL_EFFECTS:
+        pSDL_HapticStopAll(impl->sdl_haptic);
+        return STATUS_SUCCESS;
+    case PID_USAGE_DC_DEVICE_RESET:
+        pSDL_HapticStopAll(impl->sdl_haptic);
+        for (i = 0; i < ARRAY_SIZE(impl->effect_ids); ++i)
+        {
+            if (impl->effect_ids[i] < 0) continue;
+            pSDL_HapticDestroyEffect(impl->sdl_haptic, impl->effect_ids[i]);
+            impl->effect_ids[i] = -1;
+        }
+        return STATUS_SUCCESS;
+    case PID_USAGE_DC_DEVICE_PAUSE:
+        pSDL_HapticPause(impl->sdl_haptic);
+        InterlockedOr(&impl->effect_flags, EFFECT_STATE_DEVICE_PAUSED);
+        return STATUS_SUCCESS;
+    case PID_USAGE_DC_DEVICE_CONTINUE:
+        pSDL_HapticUnpause(impl->sdl_haptic);
+        InterlockedAnd(&impl->effect_flags, ~EFFECT_STATE_DEVICE_PAUSED);
+        return STATUS_SUCCESS;
+    }
+
+    return STATUS_NOT_SUPPORTED;
+}
+
+static NTSTATUS sdl_device_physical_device_set_gain(struct unix_device *iface, BYTE percent)
+{
+    struct sdl_device *impl = impl_from_unix_device(iface);
+
+    TRACE("iface %p, percent %#x.\n", iface, percent);
+
+    pSDL_HapticSetGain(impl->sdl_haptic, percent);
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS sdl_device_physical_effect_control(struct unix_device *iface, BYTE index,
+                                                   USAGE control, BYTE iterations)
+{
+    struct sdl_device *impl = impl_from_unix_device(iface);
+    int id = impl->effect_ids[index];
+
+    TRACE("iface %p, index %u, control %04x, iterations %u.\n", iface, index, control, iterations);
+
+    if (id < 0) return STATUS_SUCCESS;
+
+    switch (control)
+    {
+    case PID_USAGE_OP_EFFECT_START_SOLO:
+        pSDL_HapticStopAll(impl->sdl_haptic);
+        /* fallthrough */
+    case PID_USAGE_OP_EFFECT_START:
+        pSDL_HapticRunEffect(impl->sdl_haptic, id, (iterations == 0xff ? SDL_HAPTIC_INFINITY : iterations));
+        break;
+    case PID_USAGE_OP_EFFECT_STOP:
+        pSDL_HapticStopEffect(impl->sdl_haptic, id);
+        break;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS set_effect_type_from_usage(SDL_HapticEffect *effect, USAGE type)
+{
+    switch (type)
+    {
+    case PID_USAGE_ET_SINE:
+        effect->type = SDL_HAPTIC_SINE;
+        return STATUS_SUCCESS;
+    case PID_USAGE_ET_TRIANGLE:
+        effect->type = SDL_HAPTIC_TRIANGLE;
+        return STATUS_SUCCESS;
+    case PID_USAGE_ET_SAWTOOTH_UP:
+        effect->type = SDL_HAPTIC_SAWTOOTHUP;
+        return STATUS_SUCCESS;
+    case PID_USAGE_ET_SAWTOOTH_DOWN:
+        effect->type = SDL_HAPTIC_SAWTOOTHDOWN;
+        return STATUS_SUCCESS;
+    case PID_USAGE_ET_SPRING:
+        effect->type = SDL_HAPTIC_SPRING;
+        return STATUS_SUCCESS;
+    case PID_USAGE_ET_DAMPER:
+        effect->type = SDL_HAPTIC_DAMPER;
+        return STATUS_SUCCESS;
+    case PID_USAGE_ET_INERTIA:
+        effect->type = SDL_HAPTIC_INERTIA;
+        return STATUS_SUCCESS;
+    case PID_USAGE_ET_FRICTION:
+        effect->type = SDL_HAPTIC_FRICTION;
+        return STATUS_SUCCESS;
+    case PID_USAGE_ET_CONSTANT_FORCE:
+        effect->type = SDL_HAPTIC_CONSTANT;
+        return STATUS_SUCCESS;
+    case PID_USAGE_ET_RAMP:
+        effect->type = SDL_HAPTIC_RAMP;
+        return STATUS_SUCCESS;
+    case PID_USAGE_ET_CUSTOM_FORCE_DATA:
+        effect->type = SDL_HAPTIC_CUSTOM;
+        return STATUS_SUCCESS;
+    default:
+        return STATUS_NOT_SUPPORTED;
+    }
+}
+
+static NTSTATUS sdl_device_physical_effect_update(struct unix_device *iface, BYTE index,
+                                                  struct effect_params *params)
+{
+    struct sdl_device *impl = impl_from_unix_device(iface);
+    int id = impl->effect_ids[index];
+    SDL_HapticEffect effect = {0};
+    int i;
+    INT32 direction;
+    NTSTATUS status;
+
+    TRACE("iface %p, index %u, params %p.\n", iface, index, params);
+
+    if (params->effect_type == PID_USAGE_UNDEFINED) return STATUS_SUCCESS;
+    if ((status = set_effect_type_from_usage(&effect, params->effect_type))) return status;
+
+    /* The first direction we get from PID is in polar coordinate space, so we need to
+     * remove 90° to make it match SDL spherical coordinates. */
+    direction = (params->direction[0] + 27000) % 36000;
+
+    switch (params->effect_type)
+    {
+    case PID_USAGE_ET_SINE:
+    case PID_USAGE_ET_SQUARE:
+    case PID_USAGE_ET_TRIANGLE:
+    case PID_USAGE_ET_SAWTOOTH_UP:
+    case PID_USAGE_ET_SAWTOOTH_DOWN:
+        effect.periodic.length = (params->duration == 0xffff ? SDL_HAPTIC_INFINITY : params->duration);
+        effect.periodic.delay = params->start_delay;
+        effect.periodic.button = params->trigger_button;
+        effect.periodic.interval = params->trigger_repeat_interval;
+        effect.periodic.direction.type = SDL_HAPTIC_SPHERICAL;
+        effect.periodic.direction.dir[0] = direction;
+        effect.periodic.direction.dir[1] = params->direction[1];
+        effect.periodic.period = params->periodic.period;
+        effect.periodic.magnitude = (params->periodic.magnitude * params->gain_percent) / 100;
+        effect.periodic.offset = params->periodic.offset;
+        effect.periodic.phase = params->periodic.phase;
+        effect.periodic.attack_length = params->envelope.attack_time;
+        effect.periodic.attack_level = params->envelope.attack_level;
+        effect.periodic.fade_length = params->envelope.fade_time;
+        effect.periodic.fade_level = params->envelope.fade_level;
+        break;
+
+    case PID_USAGE_ET_SPRING:
+    case PID_USAGE_ET_DAMPER:
+    case PID_USAGE_ET_INERTIA:
+    case PID_USAGE_ET_FRICTION:
+        effect.condition.length = (params->duration == 0xffff ? SDL_HAPTIC_INFINITY : params->duration);
+        effect.condition.delay = params->start_delay;
+        effect.condition.button = params->trigger_button;
+        effect.condition.interval = params->trigger_repeat_interval;
+        effect.condition.direction.type = SDL_HAPTIC_SPHERICAL;
+        effect.condition.direction.dir[0] = direction;
+        effect.condition.direction.dir[1] = params->direction[1];
+
+        for (i = 0; i < max(params->condition_count, 3); i++)
+        {
+            effect.condition.right_sat[i] = params->condition[i].positive_saturation;
+            effect.condition.left_sat[i] = params->condition[i].negative_saturation;
+            effect.condition.right_coeff[i] = params->condition[i].positive_coefficient;
+            effect.condition.left_coeff[i] = params->condition[i].negative_coefficient;
+            effect.condition.deadband[i] = params->condition[i].dead_band;
+            effect.condition.center[i] = params->condition[i].center_point_offset;
+        }
+        /* Testing MS Sidewinder 2 indicates unspecified paramater blocks are full strength */
+        for (; i < 3; i++)
+        {
+            effect.condition.right_sat[i] = 65535;
+            effect.condition.left_sat[i] = 65535;
+            effect.condition.right_coeff[i] = 32767;
+            effect.condition.left_coeff[i] = 32767;
+        }
+        break;
+
+    case PID_USAGE_ET_CONSTANT_FORCE:
+        effect.constant.length = (params->duration == 0xffff ? SDL_HAPTIC_INFINITY : params->duration);
+        effect.constant.delay = params->start_delay;
+        effect.constant.button = params->trigger_button;
+        effect.constant.interval = params->trigger_repeat_interval;
+        effect.constant.direction.type = SDL_HAPTIC_SPHERICAL;
+        effect.constant.direction.dir[0] = direction;
+        effect.constant.direction.dir[1] = params->direction[1];
+        effect.constant.level = (params->constant_force.magnitude * params->gain_percent) / 100;
+        effect.constant.attack_length = params->envelope.attack_time;
+        effect.constant.attack_level = params->envelope.attack_level;
+        effect.constant.fade_length = params->envelope.fade_time;
+        effect.constant.fade_level = params->envelope.fade_level;
+        break;
+
+    /* According to the SDL documentation, ramp effect doesn't
+     * support SDL_HAPTIC_INFINITY. */
+    case PID_USAGE_ET_RAMP:
+        effect.ramp.length = params->duration;
+        effect.ramp.delay = params->start_delay;
+        effect.ramp.button = params->trigger_button;
+        effect.ramp.interval = params->trigger_repeat_interval;
+        effect.ramp.direction.type = SDL_HAPTIC_SPHERICAL;
+        effect.ramp.direction.dir[0] = params->direction[0];
+        effect.ramp.direction.dir[1] = params->direction[1];
+        effect.ramp.start = (params->ramp_force.ramp_start * params->gain_percent) / 100;
+        effect.ramp.end = (params->ramp_force.ramp_end * params->gain_percent) / 100;
+        effect.ramp.attack_length = params->envelope.attack_time;
+        effect.ramp.attack_level = params->envelope.attack_level;
+        effect.ramp.fade_length = params->envelope.fade_time;
+        effect.ramp.fade_level = params->envelope.fade_level;
+        break;
+
+    case PID_USAGE_ET_CUSTOM_FORCE_DATA:
+        FIXME("not implemented!\n");
+        break;
+    }
+
+    if (id < 0) impl->effect_ids[index] = pSDL_HapticNewEffect(impl->sdl_haptic, &effect);
+    else pSDL_HapticUpdateEffect(impl->sdl_haptic, id, &effect);
+
+    return STATUS_SUCCESS;
+}
+
+static const struct hid_device_vtbl sdl_device_vtbl =
+{
+    sdl_device_destroy,
+    sdl_device_start,
+    sdl_device_stop,
+    sdl_device_haptics_start,
+    sdl_device_haptics_stop,
+    sdl_device_physical_device_control,
+    sdl_device_physical_device_set_gain,
+    sdl_device_physical_effect_control,
+    sdl_device_physical_effect_update,
+};
+
+static void check_device_effects_state(struct sdl_device *impl)
+{
+    struct unix_device *iface = &impl->unix_device;
+    struct hid_effect_state *effect_state = &iface->hid_physical.effect_state;
+    ULONG effect_flags = InterlockedOr(&impl->effect_flags, 0);
+    unsigned int i, ret;
+
+    if (!impl->sdl_haptic) return;
+    if (!(impl->effect_support & EFFECT_SUPPORT_PHYSICAL)) return;
+
+    for (i = 0; i < ARRAY_SIZE(impl->effect_ids); ++i)
+    {
+        if (impl->effect_ids[i] == -1) continue;
+        if (!(impl->effect_support & SDL_HAPTIC_STATUS)) ret = 1;
+        else ret = pSDL_HapticGetEffectStatus(impl->sdl_haptic, impl->effect_ids[i]);
+        if (impl->effect_state[i] == ret) continue;
+        impl->effect_state[i] = ret;
+        hid_device_set_effect_state(iface, i, effect_flags | (ret == 1 ? EFFECT_STATE_EFFECT_PLAYING : 0));
+        bus_event_queue_input_report(&event_queue, iface, effect_state->report_buf, effect_state->report_len);
+    }
+}
+
+static void check_all_devices_effects_state(void)
+{
+    static UINT last_ticks = 0;
+    UINT ticks = pSDL_GetTicks();
+    struct sdl_device *impl;
+
+    if (ticks - last_ticks < 10) return;
+    last_ticks = ticks;
+
+    pthread_mutex_lock(&sdl_cs);
+    LIST_FOR_EACH_ENTRY(impl, &device_list, struct sdl_device, unix_device.entry)
+        check_device_effects_state(impl);
+    pthread_mutex_unlock(&sdl_cs);
+}
+
+static BOOL set_report_from_joystick_event(struct sdl_device *impl, SDL_Event *event)
+{
+    struct unix_device *iface = &impl->unix_device;
+    struct hid_device_state *state = &iface->hid_device_state;
+
+    if (impl->sdl_controller) return TRUE; /* use controller events instead */
+
+    switch (event->type)
+    {
+        case SDL_JOYBUTTONDOWN:
+        case SDL_JOYBUTTONUP:
+        {
+            SDL_JoyButtonEvent *ie = &event->jbutton;
+
+            hid_device_set_button(iface, ie->button, ie->state);
+            bus_event_queue_input_report(&event_queue, iface, state->report_buf, state->report_len);
+            break;
+        }
+        case SDL_JOYAXISMOTION:
+        {
+            SDL_JoyAxisEvent *ie = &event->jaxis;
+
+            if (!hid_device_set_abs_axis(iface, ie->axis, ie->value)) break;
+            bus_event_queue_input_report(&event_queue, iface, state->report_buf, state->report_len);
+            break;
+        }
+        case SDL_JOYBALLMOTION:
+        {
+            SDL_JoyBallEvent *ie = &event->jball;
+
+            if (!hid_device_set_rel_axis(iface, 2 * ie->ball, ie->xrel)) break;
+            hid_device_set_rel_axis(iface, 2 * ie->ball + 1, ie->yrel);
+            bus_event_queue_input_report(&event_queue, iface, state->report_buf, state->report_len);
+            break;
+        }
+        case SDL_JOYHATMOTION:
+        {
+            SDL_JoyHatEvent *ie = &event->jhat;
+
+            set_hat_value(iface, ie->hat, ie->value);
+            bus_event_queue_input_report(&event_queue, iface, state->report_buf, state->report_len);
+            break;
+        }
+        default:
+            ERR("TODO: Process Report (0x%x)\n",event->type);
+    }
+
+    check_device_effects_state(impl);
+    return FALSE;
+}
+
+static BOOL set_report_from_controller_event(struct sdl_device *impl, SDL_Event *event)
+{
+    struct unix_device *iface = &impl->unix_device;
+    struct hid_device_state *state = &iface->hid_device_state;
+
+    switch (event->type)
+    {
+        case SDL_CONTROLLERBUTTONDOWN:
+        case SDL_CONTROLLERBUTTONUP:
+        {
+            SDL_ControllerButtonEvent *ie = &event->cbutton;
+            int button;
+
+            switch (ie->button)
+            {
+            case SDL_CONTROLLER_BUTTON_A: button = 0; break;
+            case SDL_CONTROLLER_BUTTON_B: button = 1; break;
+            case SDL_CONTROLLER_BUTTON_X: button = 2; break;
+            case SDL_CONTROLLER_BUTTON_Y: button = 3; break;
+            case SDL_CONTROLLER_BUTTON_LEFTSHOULDER: button = 4; break;
+            case SDL_CONTROLLER_BUTTON_RIGHTSHOULDER: button = 5; break;
+            case SDL_CONTROLLER_BUTTON_BACK: button = 6; break;
+            case SDL_CONTROLLER_BUTTON_START: button = 7; break;
+            case SDL_CONTROLLER_BUTTON_LEFTSTICK: button = 8; break;
+            case SDL_CONTROLLER_BUTTON_RIGHTSTICK: button = 9; break;
+            case SDL_CONTROLLER_BUTTON_DPAD_UP: button = 10; break;
+            case SDL_CONTROLLER_BUTTON_DPAD_DOWN: button = 12; break;
+            case SDL_CONTROLLER_BUTTON_DPAD_LEFT: button = 13; break;
+            case SDL_CONTROLLER_BUTTON_DPAD_RIGHT: button = 11; break;
+            case SDL_CONTROLLER_BUTTON_GUIDE: button = 16; break;
+            default: button = -1; break;
+            }
+
+            if (button == -1) break;
+            if (button == 10) hid_device_move_hatswitch(iface, 0, 0, ie->state ? -1 : +1);
+            if (button == 12) hid_device_move_hatswitch(iface, 0, 0, ie->state ? +1 : -1);
+            if (button == 13) hid_device_move_hatswitch(iface, 0, ie->state ? -1 : +1, 0);
+            if (button == 11) hid_device_move_hatswitch(iface, 0, ie->state ? +1 : -1, 0);
+            hid_device_set_button(iface, button, ie->state);
+            bus_event_queue_input_report(&event_queue, iface, state->report_buf, state->report_len);
+            break;
+        }
+        case SDL_CONTROLLERAXISMOTION:
+        {
+            SDL_ControllerAxisEvent *ie = &event->caxis;
+
+            if (ie->axis == SDL_CONTROLLER_AXIS_LEFTY || ie->axis == SDL_CONTROLLER_AXIS_RIGHTY)
+                ie->value = -ie->value - 1; /* match XUSB / GIP protocol */
+
+            hid_device_set_abs_axis(iface, ie->axis, ie->value);
+            bus_event_queue_input_report(&event_queue, iface, state->report_buf, state->report_len);
+            break;
+        }
+        default:
+            ERR("TODO: Process Report (%x)\n",event->type);
+    }
+
+    check_device_effects_state(impl);
+    return FALSE;
+}
+
+static void sdl_add_device(unsigned int index)
+{
+    struct device_desc desc =
+    {
+        .input = -1,
+        .manufacturer = {'S','D','L',0},
+        .serialnumber = {'0','0','0','0',0},
+    };
+    struct sdl_device *impl;
+
+    SDL_Joystick* joystick;
+    SDL_JoystickID id;
+    SDL_JoystickType joystick_type;
+    SDL_GameController *controller = NULL;
+    const char *product, *sdl_serial;
+    char buffer[ARRAY_SIZE(desc.product)];
+    int axis_count, axis_offset;
+
+    if ((joystick = pSDL_JoystickOpen(index)) == NULL)
+    {
+        WARN("Unable to open sdl device %i: %s\n", index, pSDL_GetError());
+        return;
+    }
+
+    joystick_type = pSDL_JoystickGetType(joystick);
+    if (options->map_controllers && pSDL_IsGameController(index)
+            && joystick_type != SDL_JOYSTICK_TYPE_WHEEL
+            && joystick_type != SDL_JOYSTICK_TYPE_FLIGHT_STICK)
+        controller = pSDL_GameControllerOpen(index);
+
+    if (controller) product = pSDL_GameControllerName(controller);
+    else product = pSDL_JoystickName(joystick);
+    if (!product) product = "Joystick";
+
+    id = pSDL_JoystickInstanceID(joystick);
+
+    if (pSDL_JoystickGetProductVersion != NULL) {
+        desc.vid = pSDL_JoystickGetVendor(joystick);
+        desc.pid = pSDL_JoystickGetProduct(joystick);
+        desc.version = pSDL_JoystickGetProductVersion(joystick);
+    }
+    else
+    {
+        desc.vid = 0x01;
+        desc.pid = pSDL_JoystickInstanceID(joystick) + 1;
+        desc.version = 0;
+    }
+
+    if (pSDL_JoystickGetSerial && (sdl_serial = pSDL_JoystickGetSerial(joystick)))
+        ntdll_umbstowcs(sdl_serial, strlen(sdl_serial) + 1, desc.serialnumber, ARRAY_SIZE(desc.serialnumber));
+
+    if (controller)
+    {
+        desc.is_gamepad = TRUE;
+        axis_count = 6;
+    }
+    else
+    {
+        int button_count = pSDL_JoystickNumButtons(joystick);
+        axis_count = pSDL_JoystickNumAxes(joystick);
+        desc.is_gamepad = (axis_count == 6  && button_count >= 14);
+    }
+
+    axis_offset = 0;
+    do
+    {
+        NTSTATUS status;
+
+        if (!axis_offset) strcpy(buffer, product);
+        else snprintf(buffer, ARRAY_SIZE(buffer), "%s %d", product, axis_offset / 6);
+        ntdll_umbstowcs(buffer, strlen(buffer) + 1, desc.product, ARRAY_SIZE(desc.product));
+
+        TRACE("%s id %d, axis_offset %u, desc %s.\n", controller ? "controller" : "joystick", id, axis_offset, debugstr_device_desc(&desc));
+
+        if (!(impl = hid_device_create(&sdl_device_vtbl, sizeof(struct sdl_device)))) return;
+        list_add_tail(&device_list, &impl->unix_device.entry);
+        impl->sdl_joystick = joystick;
+        impl->sdl_controller = controller;
+        impl->id = id;
+        impl->axis_offset = axis_offset;
+
+        if (impl->sdl_controller) status = build_controller_report_descriptor(&impl->unix_device);
+        else status = build_joystick_report_descriptor(&impl->unix_device, &desc);
+        if (status)
+        {
+            list_remove(&impl->unix_device.entry);
+            impl->unix_device.vtbl->destroy(&impl->unix_device);
+            return;
+        }
+
+        bus_event_queue_device_created(&event_queue, &impl->unix_device, &desc);
+        axis_offset += (options->split_controllers ? 6 : axis_count);
+    }
+    while (axis_offset < axis_count);
+}
+
+static void process_device_event(SDL_Event *event)
+{
+    struct sdl_device *impl;
+    SDL_JoystickID id;
+
+    TRACE("Received action %x\n", event->type);
+
+    pthread_mutex_lock(&sdl_cs);
+
+    if (event->type == SDL_JOYDEVICEADDED)
+        sdl_add_device(((SDL_JoyDeviceEvent *)event)->which);
+    else if (event->type == SDL_JOYDEVICEREMOVED)
+    {
+        id = ((SDL_JoyDeviceEvent *)event)->which;
+        impl = find_device_from_id(id);
+        if (impl) bus_event_queue_device_removed(&event_queue, &impl->unix_device);
+        else WARN("Failed to find device with id %d\n", id);
+    }
+    else if (event->type == SDL_JOYAXISMOTION && options->split_controllers)
+    {
+        id = event->jaxis.which;
+        impl = find_device_from_id_and_axis(id, event->jaxis.axis);
+        if (!impl) WARN("Failed to find device with id %d for axis %d\n", id, event->jaxis.axis);
+        else if (!impl->started) WARN("Device %p with id %d is stopped, ignoring event %#x\n", impl, id, event->type);
+        else
+        {
+            event->jaxis.axis -= impl->axis_offset;
+            set_report_from_joystick_event(impl, event);
+        }
+    }
+    else if (event->type >= SDL_JOYAXISMOTION && event->type <= SDL_JOYBUTTONUP)
+    {
+        id = ((SDL_JoyButtonEvent *)event)->which;
+        impl = find_device_from_id(id);
+        if (!impl) WARN("Failed to find device with id %d\n", id);
+        else if (!impl->started) WARN("Device %p with id %d is stopped, ignoring event %#x\n", impl, id, event->type);
+        else set_report_from_joystick_event(impl, event);
+    }
+    else if (event->type >= SDL_CONTROLLERAXISMOTION && event->type <= SDL_CONTROLLERBUTTONUP)
+    {
+        id = ((SDL_ControllerButtonEvent *)event)->which;
+        impl = find_device_from_id(id);
+        if (!impl) WARN("Failed to find device with id %d\n", id);
+        else if (!impl->started) WARN("Device %p with id %d is stopped, ignoring event %#x\n", impl, id, event->type);
+        else set_report_from_controller_event(impl, event);
+    }
+
+    pthread_mutex_unlock(&sdl_cs);
+}
+
+NTSTATUS sdl_bus_init(void *args)
+{
+    const char *mapping;
+    int i;
+
+    TRACE("args %p\n", args);
+
+    options = (struct bus_options *)args;
+
+    if (!(sdl_handle = dlopen(SONAME_LIBSDL2, RTLD_NOW)))
+    {
+        WARN("could not load %s\n", SONAME_LIBSDL2);
+        return STATUS_UNSUCCESSFUL;
+    }
+#define LOAD_FUNCPTR(f)                          \
+    if ((p##f = dlsym(sdl_handle, #f)) == NULL)  \
+    {                                            \
+        WARN("could not find symbol %s\n", #f);  \
+        goto failed;                             \
+    }
+    LOAD_FUNCPTR(SDL_GetError);
+    LOAD_FUNCPTR(SDL_Init);
+    LOAD_FUNCPTR(SDL_JoystickClose);
+    LOAD_FUNCPTR(SDL_JoystickEventState);
+    LOAD_FUNCPTR(SDL_JoystickGetGUID);
+    LOAD_FUNCPTR(SDL_JoystickGetGUIDString);
+    LOAD_FUNCPTR(SDL_JoystickInstanceID);
+    LOAD_FUNCPTR(SDL_JoystickName);
+    LOAD_FUNCPTR(SDL_JoystickNumAxes);
+    LOAD_FUNCPTR(SDL_JoystickOpen);
+    LOAD_FUNCPTR(SDL_WaitEventTimeout);
+    LOAD_FUNCPTR(SDL_JoystickNumButtons);
+    LOAD_FUNCPTR(SDL_JoystickNumBalls);
+    LOAD_FUNCPTR(SDL_JoystickNumHats);
+    LOAD_FUNCPTR(SDL_JoystickGetAxis);
+    LOAD_FUNCPTR(SDL_JoystickGetHat);
+    LOAD_FUNCPTR(SDL_IsGameController);
+    LOAD_FUNCPTR(SDL_GameControllerClose);
+    LOAD_FUNCPTR(SDL_GameControllerGetAxis);
+    LOAD_FUNCPTR(SDL_GameControllerGetButton);
+    LOAD_FUNCPTR(SDL_GameControllerName);
+    LOAD_FUNCPTR(SDL_GameControllerOpen);
+    LOAD_FUNCPTR(SDL_GameControllerEventState);
+    LOAD_FUNCPTR(SDL_HapticClose);
+    LOAD_FUNCPTR(SDL_HapticDestroyEffect);
+    LOAD_FUNCPTR(SDL_HapticGetEffectStatus);
+    LOAD_FUNCPTR(SDL_HapticNewEffect);
+    LOAD_FUNCPTR(SDL_HapticNumAxes);
+    LOAD_FUNCPTR(SDL_HapticOpenFromJoystick);
+    LOAD_FUNCPTR(SDL_HapticPause);
+    LOAD_FUNCPTR(SDL_HapticQuery);
+    LOAD_FUNCPTR(SDL_HapticRumbleInit);
+    LOAD_FUNCPTR(SDL_HapticRumblePlay);
+    LOAD_FUNCPTR(SDL_HapticRumbleStop);
+    LOAD_FUNCPTR(SDL_HapticRumbleSupported);
+    LOAD_FUNCPTR(SDL_HapticRunEffect);
+    LOAD_FUNCPTR(SDL_HapticSetGain);
+    LOAD_FUNCPTR(SDL_HapticSetAutocenter);
+    LOAD_FUNCPTR(SDL_HapticStopAll);
+    LOAD_FUNCPTR(SDL_HapticStopEffect);
+    LOAD_FUNCPTR(SDL_HapticUnpause);
+    LOAD_FUNCPTR(SDL_HapticUpdateEffect);
+    LOAD_FUNCPTR(SDL_JoystickIsHaptic);
+    LOAD_FUNCPTR(SDL_GameControllerAddMapping);
+    LOAD_FUNCPTR(SDL_RegisterEvents);
+    LOAD_FUNCPTR(SDL_PushEvent);
+    LOAD_FUNCPTR(SDL_GetTicks);
+#undef LOAD_FUNCPTR
+    pSDL_JoystickRumble = dlsym(sdl_handle, "SDL_JoystickRumble");
+    pSDL_JoystickRumbleTriggers = dlsym(sdl_handle, "SDL_JoystickRumbleTriggers");
+    pSDL_JoystickGetProduct = dlsym(sdl_handle, "SDL_JoystickGetProduct");
+    pSDL_JoystickGetProductVersion = dlsym(sdl_handle, "SDL_JoystickGetProductVersion");
+    pSDL_JoystickGetVendor = dlsym(sdl_handle, "SDL_JoystickGetVendor");
+    pSDL_JoystickGetType = dlsym(sdl_handle, "SDL_JoystickGetType");
+    pSDL_JoystickGetSerial = dlsym(sdl_handle, "SDL_JoystickGetSerial");
+
+    if (pSDL_Init(SDL_INIT_GAMECONTROLLER | SDL_INIT_HAPTIC) < 0)
+    {
+        ERR("could not init SDL: %s\n", pSDL_GetError());
+        goto failed;
+    }
+
+    if ((quit_event = pSDL_RegisterEvents(1)) == -1)
+    {
+        ERR("error registering quit event\n");
+        goto failed;
+    }
+
+    pSDL_JoystickEventState(SDL_ENABLE);
+    pSDL_GameControllerEventState(SDL_ENABLE);
+
+    /* Process mappings */
+    if (pSDL_GameControllerAddMapping)
+    {
+        if ((mapping = getenv("SDL_GAMECONTROLLERCONFIG")))
+        {
+            TRACE("Setting environment mapping %s\n", debugstr_a(mapping));
+            if (pSDL_GameControllerAddMapping(mapping) < 0)
+                WARN("Failed to add environment mapping %s\n", pSDL_GetError());
+        }
+        else for (i = 0; i < options->mappings_count; ++i)
+        {
+            TRACE("Setting registry mapping %s\n", debugstr_a(options->mappings[i]));
+            if (pSDL_GameControllerAddMapping(options->mappings[i]) < 0)
+                WARN("Failed to add registry mapping %s\n", pSDL_GetError());
+        }
+    }
+
+    return STATUS_SUCCESS;
+
+failed:
+    dlclose(sdl_handle);
+    sdl_handle = NULL;
+    return STATUS_UNSUCCESSFUL;
+}
+
+NTSTATUS sdl_bus_wait(void *args)
+{
+    struct bus_event *result = args;
+    SDL_Event event;
+
+    /* cleanup previously returned event */
+    bus_event_cleanup(result);
+
+    do
+    {
+        if (bus_event_queue_pop(&event_queue, result)) return STATUS_PENDING;
+        if (pSDL_WaitEventTimeout(&event, 10) != 0) process_device_event(&event);
+        else check_all_devices_effects_state();
+    } while (event.type != quit_event);
+
+    TRACE("SDL main loop exiting\n");
+    bus_event_queue_destroy(&event_queue);
+    dlclose(sdl_handle);
+    sdl_handle = NULL;
+    return STATUS_SUCCESS;
+}
+
+NTSTATUS sdl_bus_stop(void *args)
+{
+    SDL_Event event;
+
+    if (!sdl_handle) return STATUS_SUCCESS;
+
+    event.type = quit_event;
+    if (pSDL_PushEvent(&event) != 1)
+    {
+        ERR("error pushing quit event\n");
+        return STATUS_UNSUCCESSFUL;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+#else
+
+NTSTATUS sdl_bus_init(void *args)
+{
+    WARN("SDL support not compiled in!\n");
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+NTSTATUS sdl_bus_wait(void *args)
+{
+    WARN("SDL support not compiled in!\n");
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+NTSTATUS sdl_bus_stop(void *args)
+{
+    WARN("SDL support not compiled in!\n");
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+#endif /* SONAME_LIBSDL2 */
diff -ruN --show-c-function dlls/winebus.sys/bus_udev.c dlls/winebus.sys/bus_udev.c
--- dlls/winebus.sys/bus_udev.c	2025-10-10 10:17:47.517032094 -0700
+++ dlls/winebus.sys/bus_udev.c	2025-10-10 12:03:54.190058968 -0700
@@ -25,6 +25,7 @@
 #include "config.h"
 #include <errno.h>
 #include <fcntl.h>
+#include <limits.h>
 #include <stdarg.h>
 #include <stdlib.h>
 #include <stdio.h>
@@ -472,6 +473,302 @@ static const struct raw_device_vtbl hidr
 
 #define test_bit(arr,bit) (((BYTE*)(arr))[(bit)>>3]&(1<<((bit)&7)))
 
+/* Minimal compatibility with code taken from steam-runtime-tools */
+typedef int gboolean;
+#define g_debug(fmt, ...) TRACE(fmt "\n", ## __VA_ARGS__)
+#define G_N_ELEMENTS(arr) (sizeof(arr)/sizeof(arr[0]))
+
+typedef enum
+{
+  SRT_INPUT_DEVICE_TYPE_FLAGS_JOYSTICK = (1 << 0),
+  SRT_INPUT_DEVICE_TYPE_FLAGS_ACCELEROMETER = (1 << 1),
+  SRT_INPUT_DEVICE_TYPE_FLAGS_KEYBOARD = (1 << 2),
+  SRT_INPUT_DEVICE_TYPE_FLAGS_HAS_KEYS = (1 << 3),
+  SRT_INPUT_DEVICE_TYPE_FLAGS_MOUSE = (1 << 4),
+  SRT_INPUT_DEVICE_TYPE_FLAGS_TOUCHPAD = (1 << 5),
+  SRT_INPUT_DEVICE_TYPE_FLAGS_TOUCHSCREEN = (1 << 6),
+  SRT_INPUT_DEVICE_TYPE_FLAGS_TABLET = (1 << 7),
+  SRT_INPUT_DEVICE_TYPE_FLAGS_TABLET_PAD = (1 << 8),
+  SRT_INPUT_DEVICE_TYPE_FLAGS_POINTING_STICK = (1 << 9),
+  SRT_INPUT_DEVICE_TYPE_FLAGS_SWITCH = (1 << 10),
+  SRT_INPUT_DEVICE_TYPE_FLAGS_NONE = 0
+} SrtInputDeviceTypeFlags;
+
+#define BITS_PER_LONG           (sizeof (unsigned long) * CHAR_BIT)
+#define LONGS_FOR_BITS(x)       ((((x)-1)/BITS_PER_LONG)+1)
+typedef struct
+{
+  unsigned long ev[LONGS_FOR_BITS (EV_MAX)];
+  unsigned long keys[LONGS_FOR_BITS (KEY_MAX)];
+  unsigned long abs[LONGS_FOR_BITS (ABS_MAX)];
+  unsigned long rel[LONGS_FOR_BITS (REL_MAX)];
+  unsigned long ff[LONGS_FOR_BITS (FF_MAX)];
+  unsigned long props[LONGS_FOR_BITS (INPUT_PROP_MAX)];
+} SrtEvdevCapabilities;
+
+static gboolean
+_srt_get_caps_from_evdev (int fd,
+                          unsigned int type,
+                          unsigned long *bitmask,
+                          size_t bitmask_len_longs)
+{
+  size_t bitmask_len_bytes = bitmask_len_longs * sizeof (*bitmask);
+
+  memset (bitmask, 0, bitmask_len_bytes);
+
+  if (ioctl (fd, EVIOCGBIT (type, bitmask_len_bytes), bitmask) < 0)
+    return FALSE;
+
+  return TRUE;
+}
+
+static gboolean
+_srt_evdev_capabilities_set_from_evdev (SrtEvdevCapabilities *caps,
+                                        int fd)
+{
+  if (_srt_get_caps_from_evdev (fd, 0, caps->ev, G_N_ELEMENTS (caps->ev)))
+    {
+      _srt_get_caps_from_evdev (fd, EV_KEY, caps->keys, G_N_ELEMENTS (caps->keys));
+      _srt_get_caps_from_evdev (fd, EV_ABS, caps->abs, G_N_ELEMENTS (caps->abs));
+      _srt_get_caps_from_evdev (fd, EV_REL, caps->rel, G_N_ELEMENTS (caps->rel));
+      _srt_get_caps_from_evdev (fd, EV_FF, caps->ff, G_N_ELEMENTS (caps->ff));
+      ioctl (fd, EVIOCGPROP (sizeof (caps->props)), caps->props);
+      return TRUE;
+    }
+
+  memset (caps, 0, sizeof (*caps));
+  return FALSE;
+}
+
+#define JOYSTICK_ABS_AXES \
+  ((1 << ABS_X) | (1 << ABS_Y) \
+   | (1 << ABS_RX) | (1 << ABS_RY) \
+   | (1 << ABS_THROTTLE) | (1 << ABS_RUDDER) \
+   | (1 << ABS_WHEEL) | (1 << ABS_GAS) | (1 << ABS_BRAKE) \
+   | (1 << ABS_HAT0X) | (1 << ABS_HAT0Y) \
+   | (1 << ABS_HAT1X) | (1 << ABS_HAT1Y) \
+   | (1 << ABS_HAT2X) | (1 << ABS_HAT2Y) \
+   | (1 << ABS_HAT3X) | (1 << ABS_HAT3Y))
+
+static const unsigned int first_mouse_button = BTN_MOUSE;
+static const unsigned int last_mouse_button = BTN_JOYSTICK - 1;
+
+static const unsigned int first_joystick_button = BTN_JOYSTICK;
+static const unsigned int last_joystick_button = BTN_GAMEPAD - 1;
+
+static const unsigned int first_gamepad_button = BTN_GAMEPAD;
+static const unsigned int last_gamepad_button = BTN_DIGI - 1;
+
+static const unsigned int first_dpad_button = BTN_DPAD_UP;
+static const unsigned int last_dpad_button = BTN_DPAD_RIGHT;
+
+static const unsigned int first_extra_joystick_button = BTN_TRIGGER_HAPPY;
+static const unsigned int last_extra_joystick_button = BTN_TRIGGER_HAPPY40;
+
+SrtInputDeviceTypeFlags
+_srt_evdev_capabilities_guess_type (const SrtEvdevCapabilities *caps)
+{
+  SrtInputDeviceTypeFlags flags = SRT_INPUT_DEVICE_TYPE_FLAGS_NONE;
+  unsigned int i;
+  gboolean has_joystick_axes = FALSE;
+  gboolean has_joystick_buttons = FALSE;
+
+  /* Some properties let us be fairly sure about a device */
+  if (test_bit (caps->props, INPUT_PROP_ACCELEROMETER))
+    {
+      g_debug ("INPUT_PROP_ACCELEROMETER => is accelerometer");
+      flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_ACCELEROMETER;
+    }
+
+  if (test_bit (caps->props, INPUT_PROP_POINTING_STICK))
+    {
+      g_debug ("INPUT_PROP_POINTING_STICK => is pointing stick");
+      flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_POINTING_STICK;
+    }
+
+  if (test_bit (caps->props, INPUT_PROP_BUTTONPAD)
+      || test_bit (caps->props, INPUT_PROP_TOPBUTTONPAD))
+    {
+      g_debug ("INPUT_PROP_[TOP]BUTTONPAD => is touchpad");
+      flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_TOUCHPAD;
+    }
+
+  /* Devices with a stylus or pen are assumed to be graphics tablets */
+  if (test_bit (caps->keys, BTN_STYLUS)
+      || test_bit (caps->keys, BTN_TOOL_PEN))
+    {
+      g_debug ("Stylus or pen => is tablet");
+      flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_TABLET;
+    }
+
+  /* Devices that accept a finger touch are assumed to be touchpads or
+   * touchscreens.
+   *
+   * In Steam we mostly only care about these as a way to
+   * reject non-joysticks, so we're not very precise here yet.
+   *
+   * SDL assumes that TOUCH means a touchscreen and FINGER
+   * means a touchpad. */
+  if (flags == SRT_INPUT_DEVICE_TYPE_FLAGS_NONE
+      && (test_bit (caps->keys, BTN_TOOL_FINGER)
+          || test_bit (caps->keys, BTN_TOUCH)
+          || test_bit (caps->props, INPUT_PROP_SEMI_MT)))
+    {
+      g_debug ("Finger or touch or semi-MT => is touchpad or touchscreen");
+
+      if (test_bit (caps->props, INPUT_PROP_POINTER))
+        flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_TOUCHPAD;
+      else
+        flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_TOUCHSCREEN;
+    }
+
+  /* Devices with mouse buttons are ... probably mice? */
+  if (flags == SRT_INPUT_DEVICE_TYPE_FLAGS_NONE)
+    {
+      for (i = first_mouse_button; i <= last_mouse_button; i++)
+        {
+          if (test_bit (caps->keys, i))
+            {
+              g_debug ("Mouse button => mouse");
+              flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_MOUSE;
+            }
+        }
+    }
+
+  if (flags == SRT_INPUT_DEVICE_TYPE_FLAGS_NONE)
+    {
+      for (i = ABS_X; i < ABS_Z; i++)
+        {
+          if (!test_bit (caps->abs, i))
+            break;
+        }
+
+      /* If it has 3 axes and no buttons it's probably an accelerometer. */
+      if (i == ABS_Z && !test_bit (caps->ev, EV_KEY))
+        {
+          g_debug ("3 left axes and no buttons => accelerometer");
+          flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_ACCELEROMETER;
+        }
+
+      /* Same for RX..RZ (e.g. Wiimote) */
+      for (i = ABS_RX; i < ABS_RZ; i++)
+        {
+          if (!test_bit (caps->abs, i))
+            break;
+        }
+
+      if (i == ABS_RZ && !test_bit (caps->ev, EV_KEY))
+        {
+          g_debug ("3 right axes and no buttons => accelerometer");
+          flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_ACCELEROMETER;
+        }
+    }
+
+  /* Bits 1 to 31 are ESC, numbers and Q to D, which SDL and udev both
+   * consider to be enough to count as a fully-functioned keyboard. */
+  if ((caps->keys[0] & 0xfffffffe) == 0xfffffffe)
+    {
+      g_debug ("First few keys => keyboard");
+      flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_KEYBOARD;
+    }
+
+  /* If we have *any* keys, consider it to be something a bit
+   * keyboard-like. Bits 0 to 63 are all keyboard keys.
+   * Make sure we stop before reaching KEY_UP which is sometimes
+   * used on game controller mappings, e.g. for the Wiimote. */
+  for (i = 0; i < (64 / BITS_PER_LONG); i++)
+    {
+      if (caps->keys[i] != 0)
+        flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_HAS_KEYS;
+    }
+
+  if (caps->abs[0] & JOYSTICK_ABS_AXES)
+    has_joystick_axes = TRUE;
+
+  /* Flight stick buttons */
+  for (i = first_joystick_button; i <= last_joystick_button; i++)
+    {
+      if (test_bit (caps->keys, i))
+        has_joystick_buttons = TRUE;
+    }
+
+  /* Gamepad buttons (Xbox, PS3, etc.) */
+  for (i = first_gamepad_button; i <= last_gamepad_button; i++)
+    {
+      if (test_bit (caps->keys, i))
+        has_joystick_buttons = TRUE;
+    }
+
+  /* Gamepad digital dpad */
+  for (i = first_dpad_button; i <= last_dpad_button; i++)
+    {
+      if (test_bit (caps->keys, i))
+        has_joystick_buttons = TRUE;
+    }
+
+  /* Steering wheel gear-change buttons */
+  for (i = BTN_GEAR_DOWN; i <= BTN_GEAR_UP; i++)
+    {
+      if (test_bit (caps->keys, i))
+        has_joystick_buttons = TRUE;
+    }
+
+  /* Reserved space for extra game-controller buttons, e.g. on Corsair
+   * gaming keyboards */
+  for (i = first_extra_joystick_button; i <= last_extra_joystick_button; i++)
+    {
+      if (test_bit (caps->keys, i))
+        has_joystick_buttons = TRUE;
+    }
+
+  if (test_bit (caps->keys, last_mouse_button))
+    {
+      /* Mice with a very large number of buttons can apparently
+       * overflow into the joystick-button space, but they're still not
+       * joysticks. */
+      has_joystick_buttons = FALSE;
+    }
+
+  /* TODO: Do we want to consider BTN_0 up to BTN_9 to be joystick buttons?
+   * libmanette and SDL look for BTN_1, udev does not.
+   *
+   * They're used by some game controllers, like BTN_1 and BTN_2 for the
+   * Wiimote, BTN_1..BTN_9 for the SpaceTec SpaceBall and BTN_0..BTN_3
+   * for Playstation dance pads, but they're also used by
+   * non-game-controllers like Logitech mice. For now we entirely ignore
+   * these buttons: they are not evidence that it's a joystick, but
+   * neither are they evidence that it *isn't* a joystick. */
+
+  /* We consider it to be a joystick if there is some evidence that it is,
+   * and no evidence that it's something else.
+   *
+   * Unlike SDL, we accept devices with only axes and no buttons as a
+   * possible joystick, unless they have X/Y/Z axes in which case we
+   * assume they're accelerometers. */
+  if ((has_joystick_buttons || has_joystick_axes)
+      && (flags == SRT_INPUT_DEVICE_TYPE_FLAGS_NONE))
+    {
+      g_debug ("Looks like a joystick");
+      flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_JOYSTICK;
+    }
+
+  /* If we have *any* keys below BTN_MISC, consider it to be something
+   * a bit keyboard-like, but don't rule out *also* being considered
+   * to be a joystick (again for e.g. the Wiimote). */
+  for (i = 0; i < (BTN_MISC / BITS_PER_LONG); i++)
+    {
+      if (caps->keys[i] != 0)
+        flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_HAS_KEYS;
+    }
+
+  /* Also non-exclusive: don't rule out a device being a joystick and
+   * having a switch */
+  if (test_bit (caps->ev, EV_SW))
+    flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_SWITCH;
+
+  return flags;
+}
+
 static const USAGE_AND_PAGE *what_am_I(struct udev_device *dev, int fd)
 {
     static const USAGE_AND_PAGE Unknown     = {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = 0};
@@ -482,6 +779,7 @@ static const USAGE_AND_PAGE *what_am_I(s
     static const USAGE_AND_PAGE Tablet      = {.UsagePage = HID_USAGE_PAGE_DIGITIZER, .Usage = HID_USAGE_DIGITIZER_PEN};
     static const USAGE_AND_PAGE Touchscreen = {.UsagePage = HID_USAGE_PAGE_DIGITIZER, .Usage = HID_USAGE_DIGITIZER_TOUCH_SCREEN};
     static const USAGE_AND_PAGE Touchpad    = {.UsagePage = HID_USAGE_PAGE_DIGITIZER, .Usage = HID_USAGE_DIGITIZER_TOUCH_PAD};
+    SrtEvdevCapabilities caps;
 
     struct udev_device *parent = dev;
 
@@ -506,6 +804,33 @@ static const USAGE_AND_PAGE *what_am_I(s
         parent = udev_device_get_parent_with_subsystem_devtype(parent, "input", NULL);
     }
 
+    /* In a container, udev properties might not be available. Fall back to deriving the device
+     * type from the fd's evdev capabilities. */
+    if (_srt_evdev_capabilities_set_from_evdev (&caps, fd))
+    {
+        SrtInputDeviceTypeFlags guessed_type;
+
+        guessed_type = _srt_evdev_capabilities_guess_type (&caps);
+
+        if (guessed_type & (SRT_INPUT_DEVICE_TYPE_FLAGS_MOUSE
+                            | SRT_INPUT_DEVICE_TYPE_FLAGS_POINTING_STICK))
+            return &Mouse;
+        else if (guessed_type & SRT_INPUT_DEVICE_TYPE_FLAGS_KEYBOARD)
+            return &Keyboard;
+        else if (guessed_type & SRT_INPUT_DEVICE_TYPE_FLAGS_JOYSTICK)
+            return &Gamepad;
+        else if (guessed_type & SRT_INPUT_DEVICE_TYPE_FLAGS_HAS_KEYS)
+            return &Keypad;
+        else if (guessed_type & SRT_INPUT_DEVICE_TYPE_FLAGS_TOUCHPAD)
+            return &Touchpad;
+        else if (guessed_type & SRT_INPUT_DEVICE_TYPE_FLAGS_TOUCHSCREEN)
+            return &Touchscreen;
+        else if (guessed_type & SRT_INPUT_DEVICE_TYPE_FLAGS_TABLET)
+            return &Tablet;
+
+        /* Mapped to Unknown: ACCELEROMETER, TABLET_PAD, SWITCH. */
+    }
+
     return &Unknown;
 }
 
@@ -1179,8 +1504,10 @@ static NTSTATUS hidraw_device_create(str
 
     desc.is_hidraw = TRUE;
     if (!desc.product[0] && ioctl(fd, HIDIOCGRAWNAME(sizeof(buffer) - 1), buffer) >= 0)
+    {
+        if (sscanf(buffer, "Microsoft X-Box 360 pad %u", &desc.input) != 1) desc.input = -1;
         ntdll_umbstowcs(buffer, strlen(buffer) + 1, desc.product, ARRAY_SIZE(desc.product));
-
+    }
     if (!desc.manufacturer[0]) memcpy(desc.manufacturer, hidraw, sizeof(hidraw));
     if (!desc.serialnumber[0]) memcpy(desc.serialnumber, zeros, sizeof(zeros));
 
@@ -1266,7 +1593,13 @@ static NTSTATUS lnxev_device_create(stru
         impl->button_map[i] = ++impl->button_count;
     }
 
-    if (is_xbox_gamepad(desc.vid, desc.pid)) desc.is_gamepad = TRUE;
+    if (sscanf(info.name, "Microsoft X-Box 360 pad %u", &desc.input) != 1) desc.input = -1;
+    if (desc.vid == 0x28de && desc.pid == 0x11ff)
+    {
+        desc.is_gamepad = TRUE;
+        desc.version = 0; /* keep version fixed as 0 so we can hardcode it in ntdll rawinput pipe redirection */
+    }
+    else if (is_xbox_gamepad(desc.vid, desc.pid)) desc.is_gamepad = TRUE;
     else if (axis_count == 6 && button_count >= (impl->hat_count ? 10 : 14)) desc.is_gamepad = TRUE;
 
     if ((impl->is_gamepad = desc.is_gamepad))
@@ -1372,6 +1705,21 @@ static void udev_add_device(struct udev_
         return;
     }
 
+    if (desc.vid == 0x28de && desc.pid == 0x11ff && !strcmp(subsystem, "input"))
+        TRACE("evdev %s: detected steam input virtual controller\n", debugstr_a(devnode));
+    else if (is_sdl_ignored_device(desc.vid, desc.pid))
+    {
+        TRACE("evdev %s: ignoring %s, in SDL ignore list\n", debugstr_a(devnode), debugstr_device_desc(&desc));
+        close(fd);
+        return;
+    }
+    else if (!strcmp(subsystem, "input"))
+    {
+        TRACE("evdev %s: deferring %s to a different backend\n", debugstr_a(devnode), debugstr_device_desc(&desc));
+        close(fd);
+        return;
+    }
+
     if ((desc.is_hidraw = !strcmp(subsystem, "hidraw")) && !hidraw_device_create(dev, fd, devnode, desc)) return;
     if (!strcmp(subsystem, "input") && !lnxev_device_create(dev, fd, devnode, desc)) return;
     close(fd);
@@ -1743,6 +2091,12 @@ NTSTATUS udev_bus_init(void *args)
         goto error;
     }
 
+    if (access("/run/pressure-vessel", R_OK) || access("/.flatpak-info", R_OK))
+    {
+        TRACE("Container detected, bypassing udevd by default\n");
+        disable_udevd = TRUE;
+    }
+
 #ifdef HAVE_SYS_INOTIFY_H
     if (disable_udevd) monitor_fd = create_inotify();
     if (monitor_fd < 0) disable_udevd = FALSE;
diff -ruN --show-c-function dlls/winebus.sys/bus_udev.c.orig dlls/winebus.sys/bus_udev.c.orig
--- dlls/winebus.sys/bus_udev.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ dlls/winebus.sys/bus_udev.c.orig	2025-10-10 12:03:48.305205171 -0700
@@ -0,0 +1,1865 @@
+/*
+ * Plug and Play support for hid devices found through udev
+ *
+ * Copyright 2016 CodeWeavers, Aric Stewart
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+#include <errno.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <unistd.h>
+#include <poll.h>
+#include <sys/ioctl.h>
+#ifdef HAVE_LIBUDEV_H
+# include <libudev.h>
+#endif
+#ifdef HAVE_LINUX_HIDRAW_H
+# include <linux/hidraw.h>
+#endif
+#ifdef HAVE_SYS_INOTIFY_H
+# include <sys/inotify.h>
+#endif
+#include <limits.h>
+
+#ifdef HAVE_LINUX_INPUT_H
+# include <linux/input.h>
+# undef SW_MAX
+# if defined(EVIOCGBIT) && defined(EV_ABS) && defined(BTN_PINKIE)
+#  define HAS_PROPER_INPUT_HEADER
+# endif
+# ifndef SYN_DROPPED
+#  define SYN_DROPPED 3
+# endif
+#endif
+
+#ifndef BUS_BLUETOOTH
+# define BUS_BLUETOOTH 5
+#endif
+
+#include <pthread.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winbase.h"
+#include "winnls.h"
+#include "winternl.h"
+#include "ddk/wdm.h"
+#include "ddk/hidtypes.h"
+#include "ddk/hidsdi.h"
+
+#include "wine/debug.h"
+#include "wine/hid.h"
+#include "wine/unixlib.h"
+
+#ifdef HAS_PROPER_INPUT_HEADER
+# include "hidusage.h"
+#endif
+
+#include "unix_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(hid);
+
+#ifdef HAVE_UDEV
+
+static pthread_mutex_t udev_cs = PTHREAD_MUTEX_INITIALIZER;
+
+static struct udev *udev_context = NULL;
+static struct udev_monitor *udev_monitor;
+static int deviceloop_control[2];
+static struct list event_queue = LIST_INIT(event_queue);
+static struct list device_list = LIST_INIT(device_list);
+static const struct bus_options *options;
+
+struct base_device
+{
+    struct unix_device unix_device;
+    void (*read_report)(struct unix_device *iface);
+    BOOL started;
+
+    struct udev_device *udev_device;
+    char devnode[MAX_PATH];
+    int device_fd;
+};
+
+static inline struct base_device *impl_from_unix_device(struct unix_device *iface)
+{
+    return CONTAINING_RECORD(iface, struct base_device, unix_device);
+}
+
+struct hidraw_device
+{
+    struct base_device base;
+};
+
+static inline struct hidraw_device *hidraw_impl_from_unix_device(struct unix_device *iface)
+{
+    return CONTAINING_RECORD(impl_from_unix_device(iface), struct hidraw_device, base);
+}
+
+#ifdef HAS_PROPER_INPUT_HEADER
+
+static const USAGE_AND_PAGE absolute_usages[ABS_CNT] =
+{
+    {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_X},              /* ABS_X */
+    {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_Y},              /* ABS_Y */
+    {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_Z},              /* ABS_Z */
+    {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_RX},             /* ABS_RX */
+    {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_RY},             /* ABS_RY */
+    {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_RZ},             /* ABS_RZ */
+    {.UsagePage = HID_USAGE_PAGE_SIMULATION, .Usage = HID_USAGE_SIMULATION_THROTTLE},    /* ABS_THROTTLE */
+    {.UsagePage = HID_USAGE_PAGE_SIMULATION, .Usage = HID_USAGE_SIMULATION_RUDDER},      /* ABS_RUDDER */
+    {.UsagePage = HID_USAGE_PAGE_GENERIC,    .Usage = HID_USAGE_GENERIC_WHEEL},          /* ABS_WHEEL */
+    {.UsagePage = HID_USAGE_PAGE_SIMULATION, .Usage = HID_USAGE_SIMULATION_ACCELERATOR}, /* ABS_GAS */
+    {.UsagePage = HID_USAGE_PAGE_SIMULATION, .Usage = HID_USAGE_SIMULATION_BRAKE},       /* ABS_BRAKE */
+    {0},
+    {0},
+    {0},
+    {0},
+    {0},
+    {0},                                                                                 /* ABS_HAT0X */
+    {0},                                                                                 /* ABS_HAT0Y */
+    {0},                                                                                 /* ABS_HAT1X */
+    {0},                                                                                 /* ABS_HAT1Y */
+    {0},                                                                                 /* ABS_HAT2X */
+    {0},                                                                                 /* ABS_HAT2Y */
+    {0},                                                                                 /* ABS_HAT3X */
+    {0},                                                                                 /* ABS_HAT3Y */
+    {.UsagePage = HID_USAGE_PAGE_DIGITIZER,  .Usage = HID_USAGE_DIGITIZER_TIP_PRESSURE}, /* ABS_PRESSURE */
+    {0},                                                                                 /* ABS_DISTANCE */
+    {.UsagePage = HID_USAGE_PAGE_DIGITIZER,  .Usage = HID_USAGE_DIGITIZER_X_TILT},       /* ABS_TILT_X */
+    {.UsagePage = HID_USAGE_PAGE_DIGITIZER,  .Usage = HID_USAGE_DIGITIZER_Y_TILT},       /* ABS_TILT_Y */
+    {0},                                                                                 /* ABS_TOOL_WIDTH */
+    {0},
+    {0},
+    {0},
+    {.UsagePage = HID_USAGE_PAGE_CONSUMER,   .Usage = HID_USAGE_CONSUMER_VOLUME},        /* ABS_VOLUME */
+};
+
+static const USAGE_AND_PAGE relative_usages[REL_CNT] =
+{
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_X},     /* REL_X */
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_Y},     /* REL_Y */
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_Z},     /* REL_Z */
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_RX},    /* REL_RX */
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_RY},    /* REL_RY */
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_RZ},    /* REL_RZ */
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_SLIDER},/* REL_HWHEEL */
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_DIAL},  /* REL_DIAL */
+    {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_WHEEL}, /* REL_WHEEL */
+    {0},                                                                     /* REL_MISC */
+};
+
+struct lnxev_info
+{
+    struct input_id id;
+    char name[MAX_PATH];
+    char uniq[MAX_PATH];
+    BYTE abs[(ABS_CNT + 7) / 8];
+    BYTE rel[(REL_CNT + 7) / 8];
+    BYTE key[(KEY_CNT + 7) / 8];
+    BYTE ff[(FF_CNT + 7) / 8];
+};
+
+struct lnxev_device
+{
+    struct base_device base;
+
+    LONG abs_min[ABS_CNT];
+    LONG abs_max[ABS_CNT];
+    BYTE abs_map[ABS_CNT];
+    BYTE rel_map[REL_CNT];
+    BYTE hat_map[8];
+    BYTE button_map[KEY_CNT];
+    int hat_count;
+    int button_count;
+    BOOL is_gamepad;
+
+    pthread_cond_t haptics_cond;
+    pthread_t haptics_thread;
+    struct ff_effect haptics;
+
+    int effect_ids[256];
+    LONG effect_flags;
+};
+
+static inline struct lnxev_device *lnxev_impl_from_unix_device(struct unix_device *iface)
+{
+    return CONTAINING_RECORD(impl_from_unix_device(iface), struct lnxev_device, base);
+}
+
+#endif /* HAS_PROPER_INPUT_HEADER */
+
+#define MAX_DEVICES 128
+static int close_fds[MAX_DEVICES];
+static struct pollfd poll_fds[MAX_DEVICES];
+static struct base_device *poll_devs[MAX_DEVICES];
+static int close_count, poll_count;
+
+static void stop_polling_device(struct unix_device *iface)
+{
+    struct base_device *impl = impl_from_unix_device(iface);
+    int i;
+
+    if (impl->device_fd == -1) return; /* already removed */
+    if (!impl->started) return; /* not started */
+    impl->started = FALSE;
+
+    for (i = 2; i < poll_count; ++i)
+        if (poll_fds[i].fd == impl->device_fd) break;
+
+    if (i == poll_count)
+        ERR("could not find poll entry matching device %p fd\n", iface);
+    else
+    {
+        poll_count--;
+        poll_fds[i] = poll_fds[poll_count];
+        poll_devs[i] = poll_devs[poll_count];
+        close_fds[close_count++] = impl->device_fd;
+        impl->device_fd = -1;
+    }
+}
+
+static void start_polling_device(struct unix_device *iface)
+{
+    struct base_device *impl = impl_from_unix_device(iface);
+
+    if (poll_count >= ARRAY_SIZE(poll_fds))
+        ERR("could not start polling device %p, too many fds\n", iface);
+    else
+    {
+        poll_devs[poll_count] = impl;
+        poll_fds[poll_count].fd = impl->device_fd;
+        poll_fds[poll_count].events = POLLIN;
+        poll_fds[poll_count].revents = 0;
+        poll_count++;
+
+        write(deviceloop_control[1], "u", 1);
+        impl->started = TRUE;
+    }
+}
+
+static struct base_device *find_device_from_fd(int fd)
+{
+    int i;
+
+    for (i = 2; i < poll_count; ++i) if (poll_fds[i].fd == fd) break;
+    if (i < poll_count) return  poll_devs[i];
+
+    return NULL;
+}
+
+static struct base_device *find_device_from_devnode(const char *path)
+{
+    struct base_device *impl;
+
+    LIST_FOR_EACH_ENTRY(impl, &device_list, struct base_device, unix_device.entry)
+        if (!strcmp(impl->devnode, path)) return impl;
+
+    return NULL;
+}
+
+static void hidraw_device_destroy(struct unix_device *iface)
+{
+    struct hidraw_device *impl = hidraw_impl_from_unix_device(iface);
+
+    udev_device_unref(impl->base.udev_device);
+}
+
+static NTSTATUS hidraw_device_start(struct unix_device *iface)
+{
+    pthread_mutex_lock(&udev_cs);
+    start_polling_device(iface);
+    pthread_mutex_unlock(&udev_cs);
+    return STATUS_SUCCESS;
+}
+
+static void hidraw_device_stop(struct unix_device *iface)
+{
+    struct hidraw_device *impl = hidraw_impl_from_unix_device(iface);
+
+    pthread_mutex_lock(&udev_cs);
+    stop_polling_device(iface);
+    list_remove(&impl->base.unix_device.entry);
+    pthread_mutex_unlock(&udev_cs);
+}
+
+static NTSTATUS hidraw_device_get_report_descriptor(struct unix_device *iface, BYTE *buffer,
+                                                    UINT length, UINT *out_length)
+{
+#ifdef HAVE_LINUX_HIDRAW_H
+    struct hidraw_report_descriptor descriptor;
+    struct hidraw_device *impl = hidraw_impl_from_unix_device(iface);
+
+    if (ioctl(impl->base.device_fd, HIDIOCGRDESCSIZE, &descriptor.size) == -1)
+    {
+        WARN("ioctl(HIDIOCGRDESCSIZE) failed: %d %s\n", errno, strerror(errno));
+        return STATUS_UNSUCCESSFUL;
+    }
+
+    *out_length = descriptor.size;
+
+    if (length < descriptor.size)
+        return STATUS_BUFFER_TOO_SMALL;
+    if (!descriptor.size)
+        return STATUS_SUCCESS;
+
+    if (ioctl(impl->base.device_fd, HIDIOCGRDESC, &descriptor) == -1)
+    {
+        WARN("ioctl(HIDIOCGRDESC) failed: %d %s\n", errno, strerror(errno));
+        return STATUS_UNSUCCESSFUL;
+    }
+
+    memcpy(buffer, descriptor.value, descriptor.size);
+    return STATUS_SUCCESS;
+#else
+    return STATUS_NOT_IMPLEMENTED;
+#endif
+}
+
+static void hidraw_device_read_report(struct unix_device *iface)
+{
+    struct hidraw_device *impl = hidraw_impl_from_unix_device(iface);
+    BYTE report_buffer[1024], *buff = report_buffer;
+
+    int size = read(impl->base.device_fd, report_buffer, sizeof(report_buffer));
+    if (size == -1)
+        TRACE("Read failed. Likely an unplugged device %d %s\n", errno, strerror(errno));
+    else if (size == 0)
+        TRACE("Failed to read report\n");
+    else
+        bus_event_queue_input_report(&event_queue, iface, buff, size);
+}
+
+static void hidraw_device_set_output_report(struct unix_device *iface, HID_XFER_PACKET *packet, IO_STATUS_BLOCK *io)
+{
+    struct hidraw_device *impl = hidraw_impl_from_unix_device(iface);
+    unsigned int length = packet->reportBufferLen;
+    BYTE buffer[8192];
+    int count = 0;
+
+    if ((buffer[0] = packet->reportId))
+        count = write(impl->base.device_fd, packet->reportBuffer, length);
+    else if (length > sizeof(buffer) - 1)
+        ERR("id %d length %u >= 8192, cannot write\n", packet->reportId, length);
+    else
+    {
+        memcpy(buffer + 1, packet->reportBuffer, length);
+        count = write(impl->base.device_fd, buffer, length + 1);
+    }
+
+    if (count > 0)
+    {
+        io->Information = count;
+        io->Status = STATUS_SUCCESS;
+    }
+    else
+    {
+        ERR("id %d write failed error: %d %s\n", packet->reportId, errno, strerror(errno));
+        io->Information = 0;
+        io->Status = STATUS_UNSUCCESSFUL;
+    }
+}
+
+static void hidraw_device_get_feature_report(struct unix_device *iface, HID_XFER_PACKET *packet,
+                                             IO_STATUS_BLOCK *io)
+{
+#if defined(HAVE_LINUX_HIDRAW_H) && defined(HIDIOCGFEATURE)
+    struct hidraw_device *impl = hidraw_impl_from_unix_device(iface);
+    unsigned int length = packet->reportBufferLen;
+    BYTE buffer[8192];
+    int count = 0;
+
+    if ((buffer[0] = packet->reportId) && length <= 0x1fff)
+        count = ioctl(impl->base.device_fd, HIDIOCGFEATURE(length), packet->reportBuffer);
+    else if (length > sizeof(buffer) - 1)
+        ERR("id %d length %u >= 8192, cannot read\n", packet->reportId, length);
+    else
+    {
+        count = ioctl(impl->base.device_fd, HIDIOCGFEATURE(length + 1), buffer);
+        memcpy(packet->reportBuffer, buffer + 1, length);
+    }
+
+    if (count > 0)
+    {
+        io->Information = count;
+        io->Status = STATUS_SUCCESS;
+    }
+    else
+    {
+        ERR("id %d read failed, error: %d %s\n", packet->reportId, errno, strerror(errno));
+        io->Information = 0;
+        io->Status = STATUS_UNSUCCESSFUL;
+    }
+#else
+    io->Information = 0;
+    io->Status = STATUS_NOT_IMPLEMENTED;
+#endif
+}
+
+static void hidraw_device_set_feature_report(struct unix_device *iface, HID_XFER_PACKET *packet,
+                                             IO_STATUS_BLOCK *io)
+{
+#if defined(HAVE_LINUX_HIDRAW_H) && defined(HIDIOCSFEATURE)
+    struct hidraw_device *impl = hidraw_impl_from_unix_device(iface);
+    unsigned int length = packet->reportBufferLen;
+    BYTE buffer[8192];
+    int count = 0;
+
+    if ((buffer[0] = packet->reportId) && length <= 0x1fff)
+        count = ioctl(impl->base.device_fd, HIDIOCSFEATURE(length), packet->reportBuffer);
+    else if (length > sizeof(buffer) - 1)
+        ERR("id %d length %u >= 8192, cannot write\n", packet->reportId, length);
+    else
+    {
+        memcpy(buffer + 1, packet->reportBuffer, length);
+        count = ioctl(impl->base.device_fd, HIDIOCSFEATURE(length + 1), buffer);
+    }
+
+    if (count > 0)
+    {
+        io->Information = count;
+        io->Status = STATUS_SUCCESS;
+    }
+    else
+    {
+        ERR("id %d write failed, error: %d %s\n", packet->reportId, errno, strerror(errno));
+        io->Information = 0;
+        io->Status = STATUS_UNSUCCESSFUL;
+    }
+#else
+    io->Information = 0;
+    io->Status = STATUS_NOT_IMPLEMENTED;
+#endif
+}
+
+static const struct raw_device_vtbl hidraw_device_vtbl =
+{
+    hidraw_device_destroy,
+    hidraw_device_start,
+    hidraw_device_stop,
+    hidraw_device_get_report_descriptor,
+    hidraw_device_set_output_report,
+    hidraw_device_get_feature_report,
+    hidraw_device_set_feature_report,
+};
+
+#ifdef HAS_PROPER_INPUT_HEADER
+
+#define test_bit(arr,bit) (((BYTE*)(arr))[(bit)>>3]&(1<<((bit)&7)))
+
+static const USAGE_AND_PAGE *what_am_I(struct udev_device *dev, int fd)
+{
+    static const USAGE_AND_PAGE Unknown     = {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = 0};
+    static const USAGE_AND_PAGE Mouse       = {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_MOUSE};
+    static const USAGE_AND_PAGE Keyboard    = {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_KEYBOARD};
+    static const USAGE_AND_PAGE Gamepad     = {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_GAMEPAD};
+    static const USAGE_AND_PAGE Keypad      = {.UsagePage = HID_USAGE_PAGE_GENERIC, .Usage = HID_USAGE_GENERIC_KEYPAD};
+    static const USAGE_AND_PAGE Tablet      = {.UsagePage = HID_USAGE_PAGE_DIGITIZER, .Usage = HID_USAGE_DIGITIZER_PEN};
+    static const USAGE_AND_PAGE Touchscreen = {.UsagePage = HID_USAGE_PAGE_DIGITIZER, .Usage = HID_USAGE_DIGITIZER_TOUCH_SCREEN};
+    static const USAGE_AND_PAGE Touchpad    = {.UsagePage = HID_USAGE_PAGE_DIGITIZER, .Usage = HID_USAGE_DIGITIZER_TOUCH_PAD};
+
+    struct udev_device *parent = dev;
+
+    /* Look to the parents until we get a clue */
+    while (parent)
+    {
+        if (udev_device_get_property_value(parent, "ID_INPUT_MOUSE"))
+            return &Mouse;
+        else if (udev_device_get_property_value(parent, "ID_INPUT_KEYBOARD"))
+            return &Keyboard;
+        else if (udev_device_get_property_value(parent, "ID_INPUT_JOYSTICK"))
+            return &Gamepad;
+        else if (udev_device_get_property_value(parent, "ID_INPUT_KEY"))
+            return &Keypad;
+        else if (udev_device_get_property_value(parent, "ID_INPUT_TOUCHPAD"))
+            return &Touchpad;
+        else if (udev_device_get_property_value(parent, "ID_INPUT_TOUCHSCREEN"))
+            return &Touchscreen;
+        else if (udev_device_get_property_value(parent, "ID_INPUT_TABLET"))
+            return &Tablet;
+
+        parent = udev_device_get_parent_with_subsystem_devtype(parent, "input", NULL);
+    }
+
+    return &Unknown;
+}
+
+static void set_abs_axis_value(struct unix_device *iface, int code, int value)
+{
+    struct lnxev_device *impl = lnxev_impl_from_unix_device(iface);
+
+    if (code < ABS_HAT0X || code > ABS_HAT3Y)
+    {
+        LONG min = impl->abs_min[code], range = impl->abs_max[code] - impl->abs_min[code];
+        if (!(code = impl->abs_map[code])) return;
+
+        if (impl->is_gamepad)
+        {
+            double scale = (code == 5 || code == 6 ? 32767.0 : 65535.0) / range;
+            value = (value - min) * scale - (code == 5 || code == 6 ? 0 : 32768);
+            if (code == 2 || code == 4) value = -value - 1; /* match XUSB / GIP protocol */
+        }
+
+        hid_device_set_abs_axis(iface, code - 1, value);
+    }
+    else if ((code - ABS_HAT0X) % 2)
+    {
+        if (!(code = impl->hat_map[code - ABS_HAT0X])) return;
+        if (impl->is_gamepad)
+        {
+            hid_device_set_button(iface, 10, value < 0);
+            hid_device_set_button(iface, 12, value > 0);
+        }
+        hid_device_set_hatswitch_y(iface, code - 1, value);
+    }
+    else
+    {
+        if (!(code = impl->hat_map[code - ABS_HAT0X])) return;
+        if (impl->is_gamepad)
+        {
+            hid_device_set_button(iface, 13, value < 0);
+            hid_device_set_button(iface, 11, value > 0);
+        }
+        hid_device_set_hatswitch_x(iface, code - 1, value);
+    }
+}
+
+static NTSTATUS build_report_descriptor(struct unix_device *iface, struct udev_device *dev, struct lnxev_info *info)
+{
+    struct input_absinfo abs_info[ABS_CNT];
+    USHORT count = 0;
+    USAGE usages[16];
+    int i;
+    struct lnxev_device *impl = lnxev_impl_from_unix_device(iface);
+    const USAGE_AND_PAGE device_usage = *what_am_I(dev, impl->base.device_fd);
+
+    if (!hid_device_begin_report_descriptor(iface, &device_usage))
+        return STATUS_NO_MEMORY;
+
+    if (impl->is_gamepad)
+    {
+        if (!hid_device_add_gamepad(iface))
+            return STATUS_NO_MEMORY;
+    }
+    else
+    {
+        if (!hid_device_begin_input_report(iface, &device_usage))
+            return STATUS_NO_MEMORY;
+
+        for (i = 0; i < ABS_CNT; i++)
+        {
+            LONG min = impl->abs_min[i], max = impl->abs_max[i];
+            USAGE_AND_PAGE usage = absolute_usages[i];
+            if (!impl->abs_map[i]) continue;
+            ioctl(impl->base.device_fd, EVIOCGABS(i), abs_info + i);
+            if (!hid_device_add_axes(iface, 1, usage.UsagePage, &usage.Usage, FALSE,
+                                     min, max))
+                return STATUS_NO_MEMORY;
+        }
+
+        for (i = 0; i < REL_CNT; i++)
+        {
+            USAGE_AND_PAGE usage = relative_usages[i];
+            if (!impl->rel_map[i]) continue;
+            if (!hid_device_add_axes(iface, 1, usage.UsagePage, &usage.Usage, TRUE,
+                                     INT32_MIN, INT32_MAX))
+                return STATUS_NO_MEMORY;
+        }
+
+        if (impl->hat_count && !hid_device_add_hatswitch(iface, impl->hat_count)) return STATUS_NO_MEMORY;
+        if (impl->button_count && !hid_device_add_buttons(iface, HID_USAGE_PAGE_BUTTON, 1, impl->button_count)) return STATUS_NO_MEMORY;
+
+        if (!hid_device_end_input_report(iface))
+            return STATUS_NO_MEMORY;
+    }
+
+    impl->haptics.id = -1;
+    for (i = 0; i < ARRAY_SIZE(impl->effect_ids); ++i) impl->effect_ids[i] = -1;
+
+    if (test_bit(info->ff, FF_RUMBLE) && !hid_device_add_haptics(iface))
+        return STATUS_NO_MEMORY;
+
+    for (i = 0; i < FF_MAX; ++i) if (test_bit(info->ff, i)) break;
+    if (i != FF_MAX)
+    {
+        if (test_bit(info->ff, FF_SINE)) usages[count++] = PID_USAGE_ET_SINE;
+        if (test_bit(info->ff, FF_SQUARE)) usages[count++] = PID_USAGE_ET_SQUARE;
+        if (test_bit(info->ff, FF_TRIANGLE)) usages[count++] = PID_USAGE_ET_TRIANGLE;
+        if (test_bit(info->ff, FF_SAW_UP)) usages[count++] = PID_USAGE_ET_SAWTOOTH_UP;
+        if (test_bit(info->ff, FF_SAW_DOWN)) usages[count++] = PID_USAGE_ET_SAWTOOTH_DOWN;
+        if (test_bit(info->ff, FF_SPRING)) usages[count++] = PID_USAGE_ET_SPRING;
+        if (test_bit(info->ff, FF_DAMPER)) usages[count++] = PID_USAGE_ET_DAMPER;
+        if (test_bit(info->ff, FF_INERTIA)) usages[count++] = PID_USAGE_ET_INERTIA;
+        if (test_bit(info->ff, FF_FRICTION)) usages[count++] = PID_USAGE_ET_FRICTION;
+        if (test_bit(info->ff, FF_CONSTANT)) usages[count++] = PID_USAGE_ET_CONSTANT_FORCE;
+        if (test_bit(info->ff, FF_RAMP)) usages[count++] = PID_USAGE_ET_RAMP;
+
+        if (!hid_device_add_physical(iface, usages, count, 2))
+            return STATUS_NO_MEMORY;
+    }
+
+    if (!hid_device_end_report_descriptor(iface))
+        return STATUS_NO_MEMORY;
+
+    /* Initialize axis in the report */
+    for (i = 0; i < ABS_CNT; i++)
+    {
+        USAGE_AND_PAGE usage = absolute_usages[i];
+        if (!usage.UsagePage || !usage.Usage) continue;
+        if (!test_bit(info->abs, i)) continue;
+        set_abs_axis_value(iface, i, abs_info[i].value);
+    }
+
+    return STATUS_SUCCESS;
+}
+
+static BOOL set_report_from_event(struct unix_device *iface, struct input_event *ie)
+{
+    struct hid_effect_state *effect_state = &iface->hid_physical.effect_state;
+    struct lnxev_device *impl = lnxev_impl_from_unix_device(iface);
+    ULONG effect_flags = InterlockedOr(&impl->effect_flags, 0);
+    unsigned int i, button;
+
+    switch (ie->type)
+    {
+#ifdef EV_SYN
+    case EV_SYN:
+        switch (ie->code)
+        {
+        case SYN_REPORT: return hid_device_sync_report(iface);
+        case SYN_DROPPED: hid_device_drop_report(iface); break;
+        }
+        return FALSE;
+#endif
+#ifdef EV_MSC
+    case EV_MSC:
+        return FALSE;
+#endif
+    case EV_KEY:
+        if (!(button = impl->button_map[ie->code])) return FALSE;
+        if (impl->is_gamepad && !impl->hat_count)
+        {
+            if (button == 11) hid_device_set_hatswitch_y(iface, 0, -1);
+            if (button == 13) hid_device_set_hatswitch_y(iface, 0, +1);
+            if (button == 14) hid_device_set_hatswitch_x(iface, 0, -1);
+            if (button == 12) hid_device_set_hatswitch_x(iface, 0, +1);
+        }
+        hid_device_set_button(iface, button - 1, ie->value);
+        return FALSE;
+    case EV_ABS:
+        set_abs_axis_value(iface, ie->code, ie->value);
+        return FALSE;
+    case EV_REL:
+        hid_device_set_rel_axis(iface, impl->rel_map[ie->code], ie->value);
+        return FALSE;
+    case EV_FF_STATUS:
+        for (i = 0; i < ARRAY_SIZE(impl->effect_ids); ++i) if (impl->effect_ids[i] == ie->code) break;
+        if (i == ARRAY_SIZE(impl->effect_ids)) return FALSE;
+
+        if (ie->value == FF_STATUS_PLAYING) effect_flags |= EFFECT_STATE_EFFECT_PLAYING;
+        hid_device_set_effect_state(iface, i, effect_flags);
+        bus_event_queue_input_report(&event_queue, iface, effect_state->report_buf, effect_state->report_len);
+        return FALSE;
+    default:
+        ERR("TODO: Process Report (%i, %i)\n",ie->type, ie->code);
+        return FALSE;
+    }
+}
+
+static void lnxev_device_destroy(struct unix_device *iface)
+{
+    struct lnxev_device *impl = lnxev_impl_from_unix_device(iface);
+    udev_device_unref(impl->base.udev_device);
+}
+
+static void *lnxev_device_haptics_thread(void *args)
+{
+    struct lnxev_device *impl = lnxev_impl_from_unix_device(args);
+    struct ff_effect effect = {0};
+
+    pthread_mutex_lock(&udev_cs);
+
+    for (;;)
+    {
+        while (!memcmp(&effect, &impl->haptics, sizeof(effect)))
+            pthread_cond_wait(&impl->haptics_cond, &udev_cs);
+        if (impl->haptics.type == (uint16_t)-1) break;
+
+        effect = impl->haptics;
+        pthread_mutex_unlock(&udev_cs);
+
+        if (effect.type && (effect.id == -1 || ioctl(impl->base.device_fd, EVIOCSFF, &effect) == -1))
+        {
+            effect.id = -1;
+            ioctl(impl->base.device_fd, EVIOCSFF, &effect);
+        }
+
+        if (effect.id != -1)
+        {
+            struct input_event event = {.type = EV_FF, .code = effect.id, .value = !!effect.type};
+            write(impl->base.device_fd, &event, sizeof(event));
+        }
+
+        pthread_mutex_lock(&udev_cs);
+        impl->haptics.id = effect.id;
+    }
+
+    pthread_mutex_unlock(&udev_cs);
+    return NULL;
+}
+
+static NTSTATUS lnxev_device_start(struct unix_device *iface)
+{
+    struct lnxev_device *impl = lnxev_impl_from_unix_device(iface);
+
+    pthread_mutex_lock(&udev_cs);
+    start_polling_device(iface);
+    impl->haptics.type = 0;
+    pthread_mutex_unlock(&udev_cs);
+
+    pthread_cond_init(&impl->haptics_cond, NULL);
+    pthread_create(&impl->haptics_thread, NULL, lnxev_device_haptics_thread, iface);
+    return STATUS_SUCCESS;
+}
+
+static void lnxev_device_stop(struct unix_device *iface)
+{
+    struct lnxev_device *impl = lnxev_impl_from_unix_device(iface);
+
+    pthread_mutex_lock(&udev_cs);
+    stop_polling_device(iface);
+    list_remove(&impl->base.unix_device.entry);
+    impl->haptics.type = -1;
+    pthread_mutex_unlock(&udev_cs);
+    pthread_cond_signal(&impl->haptics_cond);
+
+    pthread_join(impl->haptics_thread, NULL);
+    pthread_cond_destroy(&impl->haptics_cond);
+}
+
+static void lnxev_device_read_report(struct unix_device *iface)
+{
+    struct hid_device_state *state = &iface->hid_device_state;
+    struct lnxev_device *impl = lnxev_impl_from_unix_device(iface);
+    struct input_event ie;
+    int size;
+
+    size = read(impl->base.device_fd, &ie, sizeof(ie));
+    if (size == -1)
+        TRACE("Read failed. Likely an unplugged device\n");
+    else if (size == 0)
+        TRACE("Failed to read report\n");
+    else if (set_report_from_event(iface, &ie))
+        bus_event_queue_input_report(&event_queue, iface, state->report_buf, state->report_len);
+}
+
+static NTSTATUS lnxev_device_haptics_start(struct unix_device *iface, UINT duration_ms,
+                                           USHORT rumble_intensity, USHORT buzz_intensity,
+                                           USHORT left_intensity, USHORT right_intensity)
+{
+    struct lnxev_device *impl = lnxev_impl_from_unix_device(iface);
+
+    TRACE("iface %p, duration_ms %u, rumble_intensity %u, buzz_intensity %u, left_intensity %u, right_intensity %u.\n",
+          iface, duration_ms, rumble_intensity, buzz_intensity, left_intensity, right_intensity);
+
+    pthread_mutex_lock(&udev_cs);
+    impl->haptics.type = FF_RUMBLE;
+    impl->haptics.replay.length = duration_ms;
+    impl->haptics.u.rumble.strong_magnitude = rumble_intensity;
+    impl->haptics.u.rumble.weak_magnitude = buzz_intensity;
+    pthread_mutex_unlock(&udev_cs);
+    pthread_cond_signal(&impl->haptics_cond);
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS lnxev_device_haptics_stop(struct unix_device *iface)
+{
+    struct lnxev_device *impl = lnxev_impl_from_unix_device(iface);
+
+    TRACE("iface %p.\n", iface);
+
+    pthread_mutex_lock(&udev_cs);
+    impl->haptics.type = 0;
+    impl->haptics.replay.length = 0;
+    impl->haptics.u.rumble.strong_magnitude = 0;
+    impl->haptics.u.rumble.weak_magnitude = 0;
+    pthread_mutex_unlock(&udev_cs);
+    pthread_cond_signal(&impl->haptics_cond);
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS lnxev_device_physical_effect_run(struct lnxev_device *impl, BYTE index,
+                                                 int iterations)
+{
+    struct input_event ie =
+    {
+        .type = EV_FF,
+        .value = iterations,
+    };
+
+    if (impl->effect_ids[index] < 0) return STATUS_UNSUCCESSFUL;
+    ie.code = impl->effect_ids[index];
+
+    if (write(impl->base.device_fd, &ie, sizeof(ie)) == -1)
+    {
+        WARN("couldn't stop effect, write failed %d %s\n", errno, strerror(errno));
+        return STATUS_UNSUCCESSFUL;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS lnxev_device_physical_device_control(struct unix_device *iface, USAGE control)
+{
+    struct lnxev_device *impl = lnxev_impl_from_unix_device(iface);
+    unsigned int i;
+
+    TRACE("iface %p, control %#04x.\n", iface, control);
+
+    switch (control)
+    {
+    case PID_USAGE_DC_ENABLE_ACTUATORS:
+    {
+        struct input_event ie =
+        {
+            .type = EV_FF,
+            .code = FF_GAIN,
+            .value = 0xffff,
+        };
+        if (write(impl->base.device_fd, &ie, sizeof(ie)) == -1)
+            WARN("write failed %d %s\n", errno, strerror(errno));
+        else
+            InterlockedOr(&impl->effect_flags, EFFECT_STATE_ACTUATORS_ENABLED);
+        return STATUS_SUCCESS;
+    }
+    case PID_USAGE_DC_DISABLE_ACTUATORS:
+    {
+        struct input_event ie =
+        {
+            .type = EV_FF,
+            .code = FF_GAIN,
+            .value = 0,
+        };
+        if (write(impl->base.device_fd, &ie, sizeof(ie)) == -1)
+            WARN("write failed %d %s\n", errno, strerror(errno));
+        else
+            InterlockedAnd(&impl->effect_flags, ~EFFECT_STATE_ACTUATORS_ENABLED);
+        return STATUS_SUCCESS;
+    }
+    case PID_USAGE_DC_STOP_ALL_EFFECTS:
+        for (i = 0; i < ARRAY_SIZE(impl->effect_ids); ++i)
+        {
+            if (impl->effect_ids[i] < 0) continue;
+            lnxev_device_physical_effect_run(impl, i, 0);
+        }
+        return STATUS_SUCCESS;
+    case PID_USAGE_DC_DEVICE_RESET:
+        for (i = 0; i < ARRAY_SIZE(impl->effect_ids); ++i)
+        {
+            if (impl->effect_ids[i] < 0) continue;
+            if (ioctl(impl->base.device_fd, EVIOCRMFF, impl->effect_ids[i]) == -1)
+                WARN("couldn't free effect, EVIOCRMFF ioctl failed: %d %s\n", errno, strerror(errno));
+            impl->effect_ids[i] = -1;
+        }
+        return STATUS_SUCCESS;
+    case PID_USAGE_DC_DEVICE_PAUSE:
+        WARN("device pause not supported\n");
+        InterlockedOr(&impl->effect_flags, EFFECT_STATE_DEVICE_PAUSED);
+        return STATUS_NOT_SUPPORTED;
+    case PID_USAGE_DC_DEVICE_CONTINUE:
+        WARN("device continue not supported\n");
+        InterlockedAnd(&impl->effect_flags, ~EFFECT_STATE_DEVICE_PAUSED);
+        return STATUS_NOT_SUPPORTED;
+    }
+
+    return STATUS_NOT_SUPPORTED;
+}
+
+static NTSTATUS lnxev_device_physical_device_set_gain(struct unix_device *iface, BYTE percent)
+{
+    struct lnxev_device *impl = lnxev_impl_from_unix_device(iface);
+    struct input_event ie =
+    {
+        .type = EV_FF,
+        .code = FF_GAIN,
+        .value = 0xffff * percent / 100,
+    };
+
+    TRACE("iface %p, percent %#x.\n", iface, percent);
+
+    if (write(impl->base.device_fd, &ie, sizeof(ie)) == -1)
+        WARN("write failed %d %s\n", errno, strerror(errno));
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS lnxev_device_physical_effect_control(struct unix_device *iface, BYTE index,
+                                                     USAGE control, BYTE iterations)
+{
+    struct lnxev_device *impl = lnxev_impl_from_unix_device(iface);
+    NTSTATUS status;
+
+    TRACE("iface %p, index %u, control %04x, iterations %u.\n", iface, index, control, iterations);
+
+    switch (control)
+    {
+    case PID_USAGE_OP_EFFECT_START_SOLO:
+        if ((status = lnxev_device_physical_device_control(iface, PID_USAGE_DC_STOP_ALL_EFFECTS)))
+            return status;
+        /* fallthrough */
+    case PID_USAGE_OP_EFFECT_START:
+        return lnxev_device_physical_effect_run(impl, index, iterations);
+    case PID_USAGE_OP_EFFECT_STOP:
+        return lnxev_device_physical_effect_run(impl, index, 0);
+    }
+
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS set_effect_type_from_usage(struct ff_effect *effect, USAGE type)
+{
+    switch (type)
+    {
+    case PID_USAGE_ET_SINE:
+        effect->type = FF_PERIODIC;
+        effect->u.periodic.waveform = FF_SINE;
+        return STATUS_SUCCESS;
+    case PID_USAGE_ET_SQUARE:
+        effect->type = FF_PERIODIC;
+        effect->u.periodic.waveform = FF_SQUARE;
+        return STATUS_SUCCESS;
+    case PID_USAGE_ET_TRIANGLE:
+        effect->type = FF_PERIODIC;
+        effect->u.periodic.waveform = FF_TRIANGLE;
+        return STATUS_SUCCESS;
+    case PID_USAGE_ET_SAWTOOTH_UP:
+        effect->type = FF_PERIODIC;
+        effect->u.periodic.waveform = FF_SAW_UP;
+        return STATUS_SUCCESS;
+    case PID_USAGE_ET_SAWTOOTH_DOWN:
+        effect->type = FF_PERIODIC;
+        effect->u.periodic.waveform = FF_SAW_DOWN;
+        return STATUS_SUCCESS;
+    case PID_USAGE_ET_SPRING:
+        effect->type = FF_SPRING;
+        return STATUS_SUCCESS;
+    case PID_USAGE_ET_DAMPER:
+        effect->type = FF_DAMPER;
+        return STATUS_SUCCESS;
+    case PID_USAGE_ET_INERTIA:
+        effect->type = FF_INERTIA;
+        return STATUS_SUCCESS;
+    case PID_USAGE_ET_FRICTION:
+        effect->type = FF_FRICTION;
+        return STATUS_SUCCESS;
+    case PID_USAGE_ET_CONSTANT_FORCE:
+        effect->type = FF_CONSTANT;
+        return STATUS_SUCCESS;
+    case PID_USAGE_ET_RAMP:
+        effect->type = FF_RAMP;
+        return STATUS_SUCCESS;
+    case PID_USAGE_ET_CUSTOM_FORCE_DATA:
+        effect->type = FF_CUSTOM;
+        return STATUS_SUCCESS;
+    default:
+        return STATUS_NOT_SUPPORTED;
+    }
+}
+
+static NTSTATUS lnxev_device_physical_effect_update(struct unix_device *iface, BYTE index,
+                                                    struct effect_params *params)
+{
+    struct lnxev_device *impl = lnxev_impl_from_unix_device(iface);
+    struct ff_effect effect = {.id = impl->effect_ids[index]};
+    int i;
+    NTSTATUS status;
+
+    TRACE("iface %p, index %u, params %p.\n", iface, index, params);
+
+    if (params->effect_type == PID_USAGE_UNDEFINED) return STATUS_SUCCESS;
+    if ((status = set_effect_type_from_usage(&effect, params->effect_type))) return status;
+
+    effect.replay.length = (params->duration == 0xffff ? 0 : params->duration);
+    effect.replay.delay = params->start_delay;
+    effect.trigger.button = params->trigger_button;
+    effect.trigger.interval = params->trigger_repeat_interval;
+
+    /* Linux FF only supports polar direction, and the first direction we get from PID
+     * is in polar coordinate space already. */
+    effect.direction = params->direction[0] * 0x800 / 1125;
+
+    switch (params->effect_type)
+    {
+    case PID_USAGE_ET_SINE:
+    case PID_USAGE_ET_SQUARE:
+    case PID_USAGE_ET_TRIANGLE:
+    case PID_USAGE_ET_SAWTOOTH_UP:
+    case PID_USAGE_ET_SAWTOOTH_DOWN:
+        effect.u.periodic.period = params->periodic.period;
+        effect.u.periodic.magnitude = (params->periodic.magnitude * params->gain_percent) / 100;
+        effect.u.periodic.offset = params->periodic.offset;
+        effect.u.periodic.phase = params->periodic.phase * 0x800 / 1125;
+        effect.u.periodic.envelope.attack_length = params->envelope.attack_time;
+        effect.u.periodic.envelope.attack_level = params->envelope.attack_level;
+        effect.u.periodic.envelope.fade_length = params->envelope.fade_time;
+        effect.u.periodic.envelope.fade_level = params->envelope.fade_level;
+        break;
+
+    case PID_USAGE_ET_SPRING:
+    case PID_USAGE_ET_DAMPER:
+    case PID_USAGE_ET_INERTIA:
+    case PID_USAGE_ET_FRICTION:
+        for (i = 0; i < max(params->condition_count, 2); i++)
+        {
+            effect.u.condition[i].right_saturation = params->condition[i].positive_saturation;
+            effect.u.condition[i].left_saturation = params->condition[i].negative_saturation;
+            effect.u.condition[i].right_coeff = params->condition[i].positive_coefficient;
+            effect.u.condition[i].left_coeff = params->condition[i].negative_coefficient;
+            effect.u.condition[i].deadband = params->condition[i].dead_band;
+            effect.u.condition[i].center = params->condition[i].center_point_offset;
+        }
+        /* Testing MS Sidewinder 2 indicates unspecified paramater blocks are full strength */
+        for (; i < 2; i++)
+        {
+            effect.u.condition[i].right_saturation = 65535;
+            effect.u.condition[i].left_saturation = 65535;
+            effect.u.condition[i].right_coeff = 32767;
+            effect.u.condition[i].left_coeff = 32767;
+        }
+        break;
+
+    case PID_USAGE_ET_CONSTANT_FORCE:
+        effect.u.constant.level = (params->constant_force.magnitude * params->gain_percent) / 100;
+        effect.u.constant.envelope.attack_length = params->envelope.attack_time;
+        effect.u.constant.envelope.attack_level = params->envelope.attack_level;
+        effect.u.constant.envelope.fade_length = params->envelope.fade_time;
+        effect.u.constant.envelope.fade_level = params->envelope.fade_level;
+        break;
+
+    case PID_USAGE_ET_RAMP:
+        effect.u.ramp.start_level = (params->ramp_force.ramp_start * params->gain_percent) / 100;
+        effect.u.ramp.end_level = (params->ramp_force.ramp_end * params->gain_percent) / 100;
+        effect.u.ramp.envelope.attack_length = params->envelope.attack_time;
+        effect.u.ramp.envelope.attack_level = params->envelope.attack_level;
+        effect.u.ramp.envelope.fade_length = params->envelope.fade_time;
+        effect.u.ramp.envelope.fade_level = params->envelope.fade_level;
+        break;
+
+    case PID_USAGE_ET_CUSTOM_FORCE_DATA:
+        FIXME("not implemented!\n");
+        break;
+    }
+
+    if (ioctl(impl->base.device_fd, EVIOCSFF, &effect) != -1)
+        impl->effect_ids[index] = effect.id;
+    else
+    {
+        WARN("couldn't create effect, EVIOCSFF ioctl failed: %d %s\n", errno, strerror(errno));
+        return STATUS_UNSUCCESSFUL;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+static const struct hid_device_vtbl lnxev_device_vtbl =
+{
+    lnxev_device_destroy,
+    lnxev_device_start,
+    lnxev_device_stop,
+    lnxev_device_haptics_start,
+    lnxev_device_haptics_stop,
+    lnxev_device_physical_device_control,
+    lnxev_device_physical_device_set_gain,
+    lnxev_device_physical_effect_control,
+    lnxev_device_physical_effect_update,
+};
+#endif /* HAS_PROPER_INPUT_HEADER */
+
+static void get_device_subsystem_info(struct udev_device *dev, const char *subsystem, const char *devtype,
+                                      struct device_desc *desc, int *bus)
+{
+    struct udev_device *parent = NULL;
+    const char *ptr, *next, *tmp;
+    char buffer[MAX_PATH];
+
+    if (!(parent = udev_device_get_parent_with_subsystem_devtype(dev, subsystem, devtype))) return;
+
+    if ((next = udev_device_get_sysattr_value(parent, "uevent")))
+    {
+        while ((ptr = next) && *ptr)
+        {
+            if ((next = strchr(next, '\n'))) next += 1;
+            else next = ptr + strlen(ptr);
+            TRACE("%s uevent %s\n", subsystem, debugstr_an(ptr, next - ptr - 1));
+
+            if (!strncmp(ptr, "HID_UNIQ=", 9))
+            {
+                if (desc->serialnumber[0]) continue;
+                if (sscanf(ptr, "HID_UNIQ=%256[^\n]", buffer) == 1)
+                    ntdll_umbstowcs(buffer, strlen(buffer) + 1, desc->serialnumber, ARRAY_SIZE(desc->serialnumber));
+            }
+            if (!strncmp(ptr, "HID_NAME=", 9))
+            {
+                if (desc->product[0]) continue;
+                if (sscanf(ptr, "HID_NAME=%256[^\n]", buffer) == 1)
+                    ntdll_umbstowcs(buffer, strlen(buffer) + 1, desc->product, ARRAY_SIZE(desc->product));
+            }
+            if (!strncmp(ptr, "HID_PHYS=", 9) || !strncmp(ptr, "PHYS=\"", 6))
+            {
+                if (!(tmp = strstr(ptr, "/input")) || tmp >= next) continue;
+                if (desc->input == -1) sscanf(tmp, "/input%d\n", &desc->input);
+            }
+            if (!strncmp(ptr, "HID_ID=", 7))
+            {
+                if (*bus || desc->vid || desc->pid) continue;
+                sscanf(ptr, "HID_ID=%x:%x:%x\n", bus, &desc->vid, &desc->pid);
+            }
+
+            if (!strcmp(subsystem, "input"))
+            {
+                if (!strncmp(ptr, "PRODUCT=", 8))
+                    sscanf(ptr, "PRODUCT=%x/%x/%x/%x\n", bus, &desc->vid, &desc->pid, &desc->version);
+            }
+
+            if (!strcmp(subsystem, "usb") && *bus != BUS_BLUETOOTH)
+            {
+                if (!strncmp(ptr, "PRODUCT=", 8))
+                    sscanf(ptr, "PRODUCT=%x/%x/%x\n", &desc->vid, &desc->pid, &desc->version);
+            }
+        }
+    }
+
+    if (!strcmp(subsystem, "usb") && *bus != BUS_BLUETOOTH)
+    {
+        if ((tmp = udev_device_get_sysattr_value(parent, "manufacturer")))
+            ntdll_umbstowcs(tmp, strlen(tmp) + 1, desc->manufacturer, ARRAY_SIZE(desc->manufacturer));
+
+        if ((tmp = udev_device_get_sysattr_value(parent, "product")))
+            ntdll_umbstowcs(tmp, strlen(tmp) + 1, desc->product, ARRAY_SIZE(desc->product));
+
+        if ((tmp = udev_device_get_sysattr_value(parent, "serial")))
+            ntdll_umbstowcs(tmp, strlen(tmp) + 1, desc->serialnumber, ARRAY_SIZE(desc->serialnumber));
+    }
+}
+
+static NTSTATUS hidraw_device_create(struct udev_device *dev, int fd, const char *devnode, struct device_desc desc)
+{
+#ifdef HAVE_LINUX_HIDRAW_H
+    static const WCHAR hidraw[] = {'h','i','d','r','a','w',0};
+    static const WCHAR zeros[] = {'0','0','0','0',0};
+    struct base_device *impl;
+    char buffer[MAX_PATH];
+
+    desc.is_hidraw = TRUE;
+    if (!desc.product[0] && ioctl(fd, HIDIOCGRAWNAME(sizeof(buffer) - 1), buffer) >= 0)
+        ntdll_umbstowcs(buffer, strlen(buffer) + 1, desc.product, ARRAY_SIZE(desc.product));
+
+    if (!desc.manufacturer[0]) memcpy(desc.manufacturer, hidraw, sizeof(hidraw));
+    if (!desc.serialnumber[0]) memcpy(desc.serialnumber, zeros, sizeof(zeros));
+
+    if (!(impl = raw_device_create(&hidraw_device_vtbl, sizeof(struct hidraw_device))))
+        return STATUS_NO_MEMORY;
+    list_add_tail(&device_list, &impl->unix_device.entry);
+    impl->read_report = hidraw_device_read_report;
+    impl->udev_device = udev_device_ref(dev);
+    strcpy(impl->devnode, devnode);
+    impl->device_fd = fd;
+
+    TRACE("dev %p, node %s, desc %s.\n", dev, debugstr_a(devnode), debugstr_device_desc(&desc));
+    bus_event_queue_device_created(&event_queue, &impl->unix_device, &desc);
+    return STATUS_SUCCESS;
+#else
+    return STATUS_NOT_SUPPORTED;
+#endif
+}
+
+static NTSTATUS lnxev_device_create(struct udev_device *dev, int fd, const char *devnode, struct device_desc desc)
+{
+#ifdef HAS_PROPER_INPUT_HEADER
+    static const WCHAR evdev[] = {'e','v','d','e','v',0};
+    static const WCHAR zeros[] = {'0','0','0','0',0};
+    int axis_count = 0, button_count = 0;
+    struct lnxev_info info = {0};
+    struct lnxev_device *impl;
+
+    if (ioctl(fd, EVIOCGID, &info.id) == -1) memset(&info.id, 0, sizeof(info.id));
+    if (ioctl(fd, EVIOCGNAME(sizeof(info.name) - 1), info.name) == -1) memset(info.name, 0, sizeof(info.name));
+    if (ioctl(fd, EVIOCGUNIQ(sizeof(info.uniq) - 1), info.uniq) == -1) memset(info.uniq, 0, sizeof(info.uniq));
+    if (ioctl(fd, EVIOCGBIT(EV_ABS, sizeof(info.abs)), info.abs) == -1) memset(info.abs, 0, sizeof(info.abs));
+    if (ioctl(fd, EVIOCGBIT(EV_REL, sizeof(info.rel)), info.rel) == -1) memset(info.rel, 0, sizeof(info.rel));
+    if (ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(info.key)), info.key) == -1) memset(info.key, 0, sizeof(info.key));
+    if (ioctl(fd, EVIOCGBIT(EV_FF, sizeof(info.ff)), info.ff) == -1) memset(info.ff, 0, sizeof(info.ff));
+
+    if (!desc.vid) desc.vid = info.id.vendor;
+    if (!desc.pid) desc.pid = info.id.product;
+    if (!desc.version) desc.version = info.id.version;
+    if (!desc.manufacturer[0]) memcpy(desc.manufacturer, evdev, sizeof(evdev));
+    if (!desc.product[0]) ntdll_umbstowcs(info.name, strlen(info.name) + 1, desc.product, ARRAY_SIZE(desc.product));
+    if (!desc.serialnumber[0]) ntdll_umbstowcs(info.uniq, strlen(info.uniq) + 1, desc.serialnumber, ARRAY_SIZE(desc.serialnumber));
+    if (!desc.serialnumber[0]) memcpy(desc.serialnumber, zeros, sizeof(zeros));
+
+    if (!(impl = hid_device_create(&lnxev_device_vtbl, sizeof(struct lnxev_device))))
+        return STATUS_NO_MEMORY;
+    list_add_tail(&device_list, &impl->base.unix_device.entry);
+    impl->base.read_report = lnxev_device_read_report;
+    impl->base.udev_device = udev_device_ref(dev);
+    strcpy(impl->base.devnode, devnode);
+    impl->base.device_fd = fd;
+
+    for (int i = 0; i < ABS_CNT; i++)
+    {
+        USAGE_AND_PAGE usage = absolute_usages[i];
+        struct input_absinfo abs;
+        if (!usage.UsagePage || !usage.Usage) continue;
+        if (!test_bit(info.abs, i)) continue;
+        ioctl(fd, EVIOCGABS(i), &abs);
+        impl->abs_map[i] = ++axis_count;
+        impl->abs_min[i] = abs.minimum;
+        impl->abs_max[i] = abs.maximum;
+    }
+
+    for (int i = 0, count = 0; i < REL_CNT; i++)
+    {
+        USAGE_AND_PAGE usage = relative_usages[i];
+        if (!usage.UsagePage || !usage.Usage) continue;
+        if (!test_bit(info.rel, i)) continue;
+        impl->rel_map[i] = ++count;
+    }
+
+    for (int i = ABS_HAT0X; i <= ABS_HAT3X; i += 2)
+    {
+        if (!test_bit(info.abs, i)) continue;
+        impl->hat_map[i - ABS_HAT0X] = ++impl->hat_count;
+        impl->hat_map[i - ABS_HAT0X + 1] = impl->hat_count;
+    }
+
+    for (int i = BTN_MISC; i < KEY_MAX; i++)
+    {
+        if (!test_bit(info.key, i)) continue;
+        impl->button_map[i] = ++impl->button_count;
+    }
+
+    if (is_xbox_gamepad(desc.vid, desc.pid)) desc.is_gamepad = TRUE;
+    else if (axis_count == 6 && button_count >= (impl->hat_count ? 10 : 14)) desc.is_gamepad = TRUE;
+
+    if ((impl->is_gamepad = desc.is_gamepad))
+    {
+        static const int gamepad_axes[] = {1, 2, 5, 3, 4, 6};
+        static const UINT gamepad_buttons[] =
+        {
+            BTN_A,
+            BTN_B,
+            BTN_X,
+            BTN_Y,
+            BTN_TL,
+            BTN_TR,
+            BTN_SELECT,
+            BTN_START,
+            BTN_THUMBL,
+            BTN_THUMBR,
+            BTN_MODE,
+            BTN_C,
+            BTN_Z,
+            BTN_TL2,
+            BTN_TR2,
+        };
+
+        memset(impl->abs_map, 0, sizeof(impl->abs_map));
+        memset(impl->button_map, 0, sizeof(impl->button_map));
+        impl->button_count = 0;
+
+        for (int i = 0, count = 0; i < ABS_CNT; i++)
+        {
+            USAGE_AND_PAGE usage = absolute_usages[i];
+            if (!usage.UsagePage || !usage.Usage) continue;
+            if (!test_bit(info.abs, i)) continue;
+            impl->abs_map[i] = gamepad_axes[count++];
+        }
+
+        for (int i = 0; i < ARRAY_SIZE(gamepad_buttons); i++)
+        {
+            int button = gamepad_buttons[i];
+            if (!test_bit(info.key, button)) continue;
+            if (impl->button_count > (impl->hat_count ? 10 : 14)) break;
+            impl->button_map[button] = ++impl->button_count;
+            if (impl->hat_count && impl->button_count == 11) impl->button_map[button] = 17;
+        }
+
+        for (int i = BTN_MISC; i < KEY_MAX; i++)
+        {
+            if (i >= BTN_GAMEPAD && i < BTN_DIGI) continue;
+            if (impl->button_count > (impl->hat_count ? 10 : 14)) break;
+            if (!test_bit(info.key, i)) continue;
+            impl->button_map[i] = ++impl->button_count;
+            if (impl->hat_count && impl->button_count == 11) impl->button_map[i] = 17;
+        }
+    }
+
+    if (build_report_descriptor(&impl->base.unix_device, impl->base.udev_device, &info))
+    {
+        list_remove(&impl->base.unix_device.entry);
+        impl->base.unix_device.vtbl->destroy(&impl->base.unix_device);
+    }
+    else
+    {
+        TRACE("dev %p, node %s, desc %s.\n", dev, debugstr_a(devnode), debugstr_device_desc(&desc));
+        bus_event_queue_device_created(&event_queue, &impl->base.unix_device, &desc);
+    }
+
+    return STATUS_SUCCESS;
+#else
+    return STATUS_NOT_SUPPORTED;
+#endif
+}
+
+static void udev_add_device(struct udev_device *dev, int fd)
+{
+    struct device_desc desc = { .input = -1 };
+    const char *subsystem, *devnode;
+    int bus = 0;
+
+    if (!(devnode = udev_device_get_devnode(dev)))
+    {
+        if (fd >= 0) close(fd);
+        return;
+    }
+
+    if (fd < 0 && (fd = open(devnode, O_RDWR)) == -1)
+    {
+        WARN("Unable to open udev device %s: %s\n", debugstr_a(devnode), strerror(errno));
+        return;
+    }
+
+    TRACE("udev %s syspath %s\n", debugstr_a(devnode), udev_device_get_syspath(dev));
+
+    get_device_subsystem_info(dev, "hid", NULL, &desc, &bus);
+    get_device_subsystem_info(dev, "input", NULL, &desc, &bus);
+    get_device_subsystem_info(dev, "usb", "usb_device", &desc, &bus);
+    if (bus == BUS_BLUETOOTH) desc.bus_type = BUS_TYPE_BLUETOOTH;
+    else if (bus == BUS_USB) desc.bus_type = BUS_TYPE_USB;
+
+    if (!(subsystem = udev_device_get_subsystem(dev)))
+    {
+        WARN("udev_device_get_subsystem failed for %s.\n", debugstr_a(devnode));
+        close(fd);
+        return;
+    }
+
+    if ((desc.is_hidraw = !strcmp(subsystem, "hidraw")) && !hidraw_device_create(dev, fd, devnode, desc)) return;
+    if (!strcmp(subsystem, "input") && !lnxev_device_create(dev, fd, devnode, desc)) return;
+    close(fd);
+}
+
+#ifdef HAVE_SYS_INOTIFY_H
+static int dev_watch = -1;
+#ifdef HAS_PROPER_INPUT_HEADER
+static int devinput_watch = -1;
+#endif
+
+static void maybe_add_devnode(const char *base, const char *dir, const char *subsystem)
+{
+    char *syspath = NULL, devnode[MAX_PATH], syslink[MAX_PATH];
+    struct udev_device *dev = NULL;
+    const char *udev_devnode;
+    int fd = -1;
+
+    TRACE("Considering %s/%s...\n", dir, base);
+
+    snprintf(devnode, sizeof(devnode), "%s/%s", dir, base);
+    if ((fd = open(devnode, O_RDWR)) < 0)
+    {
+        /* When using inotify monitoring, quietly ignore device nodes that we cannot read,
+         * without emitting a warning.
+         *
+         * We can expect that a significant number of device nodes will be permanently
+         * unreadable, such as the device nodes for keyboards and mice. We can also expect
+         * that joysticks and game controllers will be temporarily unreadable until udevd
+         * chmods them; we'll get another chance to open them when their attributes change. */
+        TRACE("Unable to open %s, ignoring: %s\n", debugstr_a(devnode), strerror(errno));
+        return;
+    }
+
+    snprintf(syslink, sizeof(syslink), "/sys/class/%s/%s", subsystem, base);
+    TRACE("Resolving real path to %s\n", debugstr_a(syslink));
+
+    if (!(syspath = realpath(syslink, NULL)))
+    {
+        WARN("Unable to resolve path \"%s\" for \"%s/%s\": %s\n",
+             debugstr_a(syslink), dir, base, strerror(errno));
+        goto error;
+    }
+
+    TRACE("Creating udev_device for %s\n", syspath);
+    if (!(dev = udev_device_new_from_syspath(udev_context, syspath)))
+    {
+        WARN("failed to create udev device from syspath %s\n", syspath);
+        goto error;
+    }
+
+    if (!(udev_devnode = udev_device_get_devnode(dev)) || strcmp(devnode, udev_devnode) != 0)
+    {
+        WARN("Tried to get udev device for \"%s\" but device node of \"%s\" -> \"%s\" is \"%s\"\n",
+             debugstr_a(devnode), debugstr_a(syslink), debugstr_a(syspath), debugstr_a(udev_devnode));
+        goto error;
+    }
+
+    TRACE("Adding device for %s\n", syspath);
+    udev_add_device(dev, fd);
+    udev_device_unref(dev);
+    return;
+
+error:
+    if (dev) udev_device_unref(dev);
+    free(syspath);
+    close(fd);
+}
+
+static void build_initial_deviceset_direct(void)
+{
+    struct dirent *dent;
+    int n, len;
+    DIR *dir;
+
+    if (!options->disable_hidraw)
+    {
+        TRACE("Initial enumeration of /dev/hidraw*\n");
+        if (!(dir = opendir("/dev"))) WARN("Unable to open /dev: %s\n", strerror(errno));
+        else
+        {
+            for (dent = readdir(dir); dent; dent = readdir(dir))
+            {
+                if (sscanf(dent->d_name, "hidraw%u%n", &n, &len) != 1 || len != strlen(dent->d_name))
+                    WARN("ignoring %s, name doesn't match hidraw%%u\n", debugstr_a(dent->d_name));
+                else
+                    maybe_add_devnode(dent->d_name, "/dev", "hidraw");
+            }
+            closedir(dir);
+        }
+    }
+#ifdef HAS_PROPER_INPUT_HEADER
+    if (!options->disable_input)
+    {
+        TRACE("Initial enumeration of /dev/input/event*\n");
+        if (!(dir = opendir("/dev/input"))) WARN("Unable to open /dev/input: %s\n", strerror(errno));
+        else
+        {
+            for (dent = readdir(dir); dent; dent = readdir(dir))
+            {
+                if (sscanf(dent->d_name, "event%u%n", &n, &len) != 1 || len != strlen(dent->d_name))
+                    WARN("ignoring %s, name doesn't match event%%u\n", debugstr_a(dent->d_name));
+                else
+                    maybe_add_devnode(dent->d_name, "/dev/input", "input");
+            }
+            closedir(dir);
+        }
+    }
+#endif
+}
+
+static int create_inotify(void)
+{
+    int systems = 0, fd, flags = IN_CREATE | IN_DELETE | IN_MOVE | IN_ATTRIB;
+
+    if ((fd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC)) < 0)
+    {
+        WARN("Unable to get inotify fd\n");
+        return fd;
+    }
+
+    if (!options->disable_hidraw)
+    {
+        /* We need to watch for attribute changes in addition to
+         * creation, because when a device is first created, it has
+         * permissions that we can't read. When udev chmods it to
+         * something that we maybe *can* read, we'll get an
+         * IN_ATTRIB event to tell us. */
+        dev_watch = inotify_add_watch(fd, "/dev", flags);
+        if (dev_watch < 0) WARN("Unable to initialize inotify for /dev: %s\n", strerror(errno));
+        else systems++;
+    }
+#ifdef HAS_PROPER_INPUT_HEADER
+    if (!options->disable_input)
+    {
+        devinput_watch = inotify_add_watch(fd, "/dev/input", flags);
+        if (devinput_watch < 0) WARN("Unable to initialize inotify for /dev/input: %s\n", strerror(errno));
+        else systems++;
+    }
+#endif
+    if (systems == 0)
+    {
+        WARN("No subsystems added to monitor\n");
+        close(fd);
+        return -1;
+    }
+
+    return fd;
+}
+
+static void maybe_remove_devnode(const char *base, const char *dir)
+{
+    struct base_device *impl;
+    char devnode[MAX_PATH];
+
+    snprintf(devnode, sizeof(devnode), "%s/%s", dir, base);
+    impl = find_device_from_devnode(devnode);
+    if (impl) bus_event_queue_device_removed(&event_queue, &impl->unix_device);
+    else WARN("failed to find device for path %s\n", devnode);
+}
+
+static void process_inotify_event(int fd)
+{
+    union
+    {
+        struct inotify_event event;
+        char storage[4096];
+        char enough_for_inotify[sizeof(struct inotify_event) + NAME_MAX + 1];
+    } buf;
+    ssize_t bytes;
+    int n, len;
+
+    if ((bytes = read(fd, &buf, sizeof(buf))) < 0)
+        WARN("read failed: %u %s\n", errno, strerror(errno));
+    else while (bytes > 0)
+    {
+        if (buf.event.len > 0)
+        {
+            if (buf.event.wd == dev_watch)
+            {
+                if (sscanf(buf.event.name, "hidraw%u%n", &n, &len) != 1 || len != strlen(buf.event.name))
+                    WARN("ignoring %s, name doesn't match hidraw%%u\n", debugstr_a(buf.event.name));
+                else if (buf.event.mask & (IN_DELETE | IN_MOVED_FROM))
+                    maybe_remove_devnode(buf.event.name, "/dev");
+                else if (buf.event.mask & (IN_CREATE | IN_MOVED_TO))
+                    maybe_add_devnode(buf.event.name, "/dev", "hidraw");
+                else if (buf.event.mask & IN_ATTRIB)
+                {
+                    maybe_remove_devnode(buf.event.name, "/dev");
+                    maybe_add_devnode(buf.event.name, "/dev", "hidraw");
+                }
+            }
+#ifdef HAS_PROPER_INPUT_HEADER
+            else if (buf.event.wd == devinput_watch)
+            {
+                if (sscanf(buf.event.name, "event%u%n", &n, &len) != 1 || len != strlen(buf.event.name))
+                    WARN("ignoring %s, name doesn't match event%%u\n", debugstr_a(buf.event.name));
+                else if (buf.event.mask & (IN_DELETE | IN_MOVED_FROM))
+                    maybe_remove_devnode(buf.event.name, "/dev/input");
+                else if (buf.event.mask & (IN_CREATE | IN_MOVED_TO))
+                    maybe_add_devnode(buf.event.name, "/dev/input", "input");
+                else if (buf.event.mask & IN_ATTRIB)
+                {
+                    maybe_remove_devnode(buf.event.name, "/dev/input");
+                    maybe_add_devnode(buf.event.name, "/dev/input", "input");
+                }
+            }
+#endif
+        }
+
+        len = sizeof(struct inotify_event) + buf.event.len;
+        bytes -= len;
+        if (bytes > 0) memmove(&buf.storage[0], &buf.storage[len], bytes);
+    }
+}
+#endif /* HAVE_SYS_INOTIFY_H */
+
+static void build_initial_deviceset_udevd(void)
+{
+    struct udev_enumerate *enumerate;
+    struct udev_list_entry *devices, *dev_list_entry;
+
+    enumerate = udev_enumerate_new(udev_context);
+    if (!enumerate)
+    {
+        WARN("Unable to create udev enumeration object\n");
+        return;
+    }
+
+    if (!options->disable_hidraw)
+        if (udev_enumerate_add_match_subsystem(enumerate, "hidraw") < 0)
+            WARN("Failed to add subsystem 'hidraw' to enumeration\n");
+#ifdef HAS_PROPER_INPUT_HEADER
+    if (!options->disable_input)
+    {
+        if (udev_enumerate_add_match_subsystem(enumerate, "input") < 0)
+            WARN("Failed to add subsystem 'input' to enumeration\n");
+    }
+#endif
+
+    if (udev_enumerate_scan_devices(enumerate) < 0)
+        WARN("Enumeration scan failed\n");
+
+    devices = udev_enumerate_get_list_entry(enumerate);
+    udev_list_entry_foreach(dev_list_entry, devices)
+    {
+        struct udev_device *dev;
+        const char *path;
+
+        path = udev_list_entry_get_name(dev_list_entry);
+        if ((dev = udev_device_new_from_syspath(udev_context, path)))
+        {
+            udev_add_device(dev, -1);
+            udev_device_unref(dev);
+        }
+    }
+
+    udev_enumerate_unref(enumerate);
+}
+
+static struct udev_monitor *create_monitor(int *fd)
+{
+    struct udev_monitor *monitor;
+    int systems = 0;
+
+    monitor = udev_monitor_new_from_netlink(udev_context, "udev");
+    if (!monitor)
+    {
+        WARN("Unable to get udev monitor object\n");
+        return NULL;
+    }
+
+    if (!options->disable_hidraw)
+    {
+        if (udev_monitor_filter_add_match_subsystem_devtype(monitor, "hidraw", NULL) < 0)
+            WARN("Failed to add 'hidraw' subsystem to monitor\n");
+        else
+            systems++;
+    }
+#ifdef HAS_PROPER_INPUT_HEADER
+    if (!options->disable_input)
+    {
+        if (udev_monitor_filter_add_match_subsystem_devtype(monitor, "input", NULL) < 0)
+            WARN("Failed to add 'input' subsystem to monitor\n");
+        else
+            systems++;
+    }
+#endif
+    if (systems == 0)
+    {
+        WARN("No subsystems added to monitor\n");
+        goto error;
+    }
+
+    if (udev_monitor_enable_receiving(monitor) < 0)
+        goto error;
+
+    if ((*fd = udev_monitor_get_fd(monitor)) >= 0)
+        return monitor;
+
+error:
+    WARN("Failed to start monitoring\n");
+    udev_monitor_unref(monitor);
+    return NULL;
+}
+
+static void process_monitor_event(struct udev_monitor *monitor)
+{
+    struct base_device *impl;
+    struct udev_device *dev;
+    const char *action, *devnode, *syspath;
+
+    dev = udev_monitor_receive_device(monitor);
+    if (!dev)
+    {
+        ERR("Failed to get device that has changed\n");
+        return;
+    }
+
+    action = udev_device_get_action(dev);
+    syspath = udev_device_get_syspath(dev);
+    devnode = udev_device_get_devnode(dev);
+    TRACE("Received action %s for udev device %s (%p) devnode %s\n",
+          debugstr_a(action), debugstr_a(syspath), dev, debugstr_a(devnode));
+
+    if (!syspath)
+        ERR("udev device %p does not have syspath!\n", dev);
+    else if (!action)
+        ERR("event for udev device %s does not have any action!\n", syspath);
+    else if (!devnode)
+    {
+        /* Pretty normal case, not all devices have associated
+         * devnodes. For example root input devices do not, but
+         * related/child mouse and event devices do.
+         */
+        TRACE("udev device %s does not have devnode, ignoring\n", syspath);
+    }
+    else if (strcmp(action, "remove"))
+        udev_add_device(dev, -1);
+    else
+    {
+        impl = find_device_from_devnode(devnode);
+        if (impl) bus_event_queue_device_removed(&event_queue, &impl->unix_device);
+        else WARN("failed to find device for udev device %p\n", dev);
+    }
+
+    udev_device_unref(dev);
+}
+
+NTSTATUS udev_bus_init(void *args)
+{
+    int monitor_fd = -1;
+    BOOL disable_udevd;
+
+    TRACE("args %p\n", args);
+
+    options = (struct bus_options *)args;
+    disable_udevd = options->disable_udevd;
+
+    if (pipe(deviceloop_control) != 0)
+    {
+        ERR("UDEV control pipe creation failed\n");
+        return STATUS_UNSUCCESSFUL;
+    }
+
+    if (!(udev_context = udev_new()))
+    {
+        ERR("UDEV object creation failed\n");
+        goto error;
+    }
+
+#ifdef HAVE_SYS_INOTIFY_H
+    if (disable_udevd) monitor_fd = create_inotify();
+    if (monitor_fd < 0) disable_udevd = FALSE;
+#else
+    if (disable_udevd) ERR("inotify support not compiled in!\n");
+    disable_udevd = FALSE;
+#endif
+
+    if (monitor_fd < 0 && !(udev_monitor = create_monitor(&monitor_fd)))
+    {
+        ERR("UDEV monitor creation failed\n");
+        goto error;
+    }
+
+    if (monitor_fd < 0) goto error;
+
+    poll_fds[0].fd = monitor_fd;
+    poll_fds[0].events = POLLIN;
+    poll_fds[0].revents = 0;
+    poll_fds[1].fd = deviceloop_control[0];
+    poll_fds[1].events = POLLIN;
+    poll_fds[1].revents = 0;
+    poll_count = 2;
+
+    if (!disable_udevd) build_initial_deviceset_udevd();
+#ifdef HAVE_SYS_INOTIFY_H
+    else build_initial_deviceset_direct();
+#endif
+
+    return STATUS_SUCCESS;
+
+error:
+    if (udev_monitor) udev_monitor_unref(udev_monitor);
+    if (udev_context) udev_unref(udev_context);
+    udev_context = NULL;
+    close(deviceloop_control[0]);
+    close(deviceloop_control[1]);
+    return STATUS_UNSUCCESSFUL;
+}
+
+NTSTATUS udev_bus_wait(void *args)
+{
+    struct bus_event *result = args;
+    struct pollfd pfd[MAX_DEVICES];
+    struct base_device *impl;
+    char ctrl = 0;
+    int i, count;
+
+    /* cleanup previously returned event */
+    bus_event_cleanup(result);
+
+    while (ctrl != 'q')
+    {
+        if (bus_event_queue_pop(&event_queue, result)) return STATUS_PENDING;
+
+        pthread_mutex_lock(&udev_cs);
+        while (close_count--) close(close_fds[close_count]);
+        memcpy(pfd, poll_fds, poll_count * sizeof(*pfd));
+        count = poll_count;
+        close_count = 0;
+        pthread_mutex_unlock(&udev_cs);
+
+        while (poll(pfd, count, -1) <= 0) {}
+
+        pthread_mutex_lock(&udev_cs);
+        if (pfd[0].revents)
+        {
+            if (udev_monitor) process_monitor_event(udev_monitor);
+#ifdef HAVE_SYS_INOTIFY_H
+            else process_inotify_event(pfd[0].fd);
+#endif
+        }
+        if (pfd[1].revents) read(deviceloop_control[0], &ctrl, 1);
+        for (i = 2; i < count; ++i)
+        {
+            if (!pfd[i].revents) continue;
+            impl = find_device_from_fd(pfd[i].fd);
+            if (impl) impl->read_report(&impl->unix_device);
+        }
+        pthread_mutex_unlock(&udev_cs);
+    }
+
+    TRACE("UDEV main loop exiting\n");
+    bus_event_queue_destroy(&event_queue);
+    if (udev_monitor) udev_monitor_unref(udev_monitor);
+    udev_unref(udev_context);
+    udev_context = NULL;
+    close(deviceloop_control[0]);
+    close(deviceloop_control[1]);
+    return STATUS_SUCCESS;
+}
+
+NTSTATUS udev_bus_stop(void *args)
+{
+    if (!udev_context) return STATUS_SUCCESS;
+    write(deviceloop_control[1], "q", 1);
+    return STATUS_SUCCESS;
+}
+
+#else
+
+NTSTATUS udev_bus_init(void *args)
+{
+    WARN("UDEV support not compiled in!\n");
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+NTSTATUS udev_bus_wait(void *args)
+{
+    WARN("UDEV support not compiled in!\n");
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+NTSTATUS udev_bus_stop(void *args)
+{
+    WARN("UDEV support not compiled in!\n");
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+#endif /* HAVE_UDEV */
diff -ruN --show-c-function dlls/winebus.sys/main.c dlls/winebus.sys/main.c
--- dlls/winebus.sys/main.c	2025-10-10 10:17:47.517032094 -0700
+++ dlls/winebus.sys/main.c	2025-10-10 12:03:54.188583351 -0700
@@ -441,6 +441,17 @@ static DEVICE_OBJECT *bus_find_unix_devi
     return NULL;
 }
 
+static DEVICE_OBJECT *bus_find_device_from_vid_pid(const BOOL is_hidraw, struct device_desc *desc)
+{
+    struct device_extension *ext;
+
+    LIST_FOR_EACH_ENTRY(ext, &device_list, struct device_extension, entry)
+        if (ext->desc.is_hidraw == is_hidraw && ext->desc.vid == desc->vid &&
+            ext->desc.pid == desc->pid) return ext->device;
+
+    return NULL;
+}
+
 static void bus_unlink_hid_device(DEVICE_OBJECT *device)
 {
     struct device_extension *ext = (struct device_extension *)device->DeviceExtension;
@@ -505,14 +516,32 @@ static DWORD check_bus_option(const WCHA
     return default_value;
 }
 
+static const WCHAR *wcscasestr(const WCHAR *search, const WCHAR *needle)
+{
+    UNICODE_STRING search_str, needle_str;
+
+    RtlInitUnicodeString(&search_str, search);
+    RtlInitUnicodeString(&needle_str, needle);
+
+    while (needle_str.Length <= search_str.Length)
+    {
+        if (!RtlCompareUnicodeString(&search_str, &needle_str, TRUE)) return search_str.Buffer;
+        search_str.Length -= sizeof(WCHAR);
+        search_str.Buffer += 1;
+    }
+
+    return NULL;
+}
+
 static BOOL is_hidraw_enabled(WORD vid, WORD pid, const USAGE_AND_PAGE *usages, UINT buttons)
 {
     char buffer[FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data[1024])];
     KEY_VALUE_PARTIAL_INFORMATION *info = (KEY_VALUE_PARTIAL_INFORMATION *)buffer;
     struct device_options *device;
-    WCHAR vidpid[MAX_PATH], *tmp;
+    WCHAR vidpid[MAX_PATH], *tmp, value[1024];
     BOOL prefer_hidraw = FALSE;
     UNICODE_STRING str;
+    SIZE_T len;
     DWORD size;
 
     if (options.disable_hidraw) return FALSE;
@@ -530,6 +559,27 @@ static BOOL is_hidraw_enabled(WORD vid,
         WARN("Ignoring unsupported %04X:%04X hidraw touchscreen\n", vid, pid);
         return FALSE;
     }
+
+    if (!RtlQueryEnvironmentVariable(NULL, L"PROTON_DISABLE_HIDRAW", 20, value, ARRAY_SIZE(value) - 1, &len))
+    {
+        value[len] = 0;
+        if (!wcscmp(value, L"1")) return FALSE;
+        swprintf(vidpid, ARRAY_SIZE(vidpid), L"0x%04X/0x%04X", vid, pid);
+        if (wcscasestr(value, vidpid)) return FALSE;
+    }
+    if (!RtlQueryEnvironmentVariable(NULL, L"PROTON_ENABLE_HIDRAW", 20, value, ARRAY_SIZE(value) - 1, &len))
+    {
+        value[len] = 0;
+        if (!wcscmp(value, L"1")) return TRUE;
+        swprintf(vidpid, ARRAY_SIZE(vidpid), L"0x%04X/0x%04X", vid, pid);
+        if (wcscasestr(value, vidpid)) return TRUE;
+    }
+
+    if (usages->UsagePage == HID_USAGE_PAGE_DIGITIZER)
+    {
+        WARN("Ignoring unsupported %04X:%04X hidraw touchscreen\n", vid, pid);
+        return FALSE;
+    }
     if (usages->UsagePage != HID_USAGE_PAGE_GENERIC) return TRUE;
     if (usages->Usage == HID_USAGE_GENERIC_MOUSE || usages->Usage == HID_USAGE_GENERIC_KEYBOARD)
     {
@@ -961,7 +1011,7 @@ static DWORD CALLBACK bus_main_thread(vo
             UINT buttons;
 
             usages = get_device_usages(event->device, &buttons);
-            if (!desc.is_hidraw != !is_hidraw_enabled(desc.vid, desc.pid, &usages, buttons))
+            if (desc.is_hidraw && !is_hidraw_enabled(desc.vid, desc.pid, &usages, buttons))
             {
                 struct device_remove_params params = {.device = event->device};
                 WARN("ignoring %shidraw device %04x:%04x with usages %04x:%04x\n", desc.is_hidraw ? "" : "non-",
@@ -969,11 +1019,27 @@ static DWORD CALLBACK bus_main_thread(vo
                 winebus_call(device_remove, &params);
                 break;
             }
+            else if (desc.is_hidraw)
+            {
+                RtlEnterCriticalSection(&device_list_cs);
+                if ((device = bus_find_device_from_vid_pid(!desc.is_hidraw, &event->device_created.desc)))
+                    bus_unlink_hid_device(device);
+                device = bus_create_hid_device(&event->device_created.desc, event->device);
+                RtlLeaveCriticalSection(&device_list_cs);
+            }
+            else
+            {
+                RtlEnterCriticalSection(&device_list_cs);
+                if (bus_find_device_from_vid_pid(!desc.is_hidraw, &event->device_created.desc)) device = NULL;
+                else device = bus_create_hid_device(&event->device_created.desc, event->device);
+                RtlLeaveCriticalSection(&device_list_cs);
+            }
+
 
-            TRACE("creating %shidraw device %04x:%04x with usages %04x:%04x\n", desc.is_hidraw ? "" : "non-",
-                  desc.vid, desc.pid, usages.UsagePage, usages.Usage);
+            if (device)
+                TRACE("creating %shidraw device %04x:%04x with usages %04x:%04x\n", desc.is_hidraw ? "" : "non-",
+                      desc.vid, desc.pid, usages.UsagePage, usages.Usage);
 
-            device = bus_create_hid_device(&event->device_created.desc, event->device);
             if (device) IoInvalidateDeviceRelations(bus_pdo, BusRelations);
             else
             {
@@ -1288,8 +1354,8 @@ static NTSTATUS fdo_pnp_dispatch(DEVICE_
         mouse_device_create();
         keyboard_device_create();
 
-        if (!sdl_driver_init()) options.disable_input = TRUE;
         udev_driver_init();
+        if (!sdl_driver_init()) options.disable_input = TRUE;
         iohid_driver_init();
 
         irp->IoStatus.Status = STATUS_SUCCESS;
diff -ruN --show-c-function dlls/winebus.sys/unix_private.h dlls/winebus.sys/unix_private.h
--- dlls/winebus.sys/unix_private.h	2025-10-10 10:17:47.517032094 -0700
+++ dlls/winebus.sys/unix_private.h	2025-10-10 12:03:54.182621859 -0700
@@ -269,4 +269,6 @@ extern void hid_device_drop_report(struc
 
 extern void hid_device_set_effect_state(struct unix_device *iface, BYTE index, BYTE flags);
 
+extern BOOL is_sdl_ignored_device(WORD vid, WORD pid);
+
 #endif /* __WINEBUS_UNIX_PRIVATE_H */
diff -ruN --show-c-function dlls/winebus.sys/unix_private.h.orig dlls/winebus.sys/unix_private.h.orig
--- dlls/winebus.sys/unix_private.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ dlls/winebus.sys/unix_private.h.orig	2025-10-10 12:03:48.305205171 -0700
@@ -0,0 +1,272 @@
+/*
+ * Copyright 2021 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINEBUS_UNIX_PRIVATE_H
+#define __WINEBUS_UNIX_PRIVATE_H
+
+#include <stdarg.h>
+
+#include <windef.h>
+#include <winbase.h>
+#include <winternl.h>
+#include <ddk/hidsdi.h>
+
+#include "unixlib.h"
+
+#include "wine/list.h"
+#include "wine/hid.h"
+
+struct effect_periodic
+{
+    UINT16 magnitude;
+    INT16 offset;
+    UINT16 phase;
+    UINT16 period;
+};
+
+struct effect_envelope
+{
+    UINT16 attack_level;
+    UINT16 fade_level;
+    UINT16 attack_time;
+    UINT16 fade_time;
+};
+
+struct effect_condition
+{
+    INT16 center_point_offset;
+    INT16 positive_coefficient;
+    INT16 negative_coefficient;
+    UINT16 positive_saturation;
+    UINT16 negative_saturation;
+    UINT16 dead_band;
+};
+
+struct effect_constant_force
+{
+    INT16 magnitude;
+};
+
+struct effect_ramp_force
+{
+    INT16 ramp_start;
+    INT16 ramp_end;
+};
+
+struct effect_params
+{
+    USAGE effect_type;
+    UINT16 duration;
+    UINT16 trigger_repeat_interval;
+    UINT16 sample_period;
+    UINT16 start_delay;
+    BYTE trigger_button;
+    BOOL axis_enabled[MAX_PID_AXES];
+    BOOL direction_enabled;
+    UINT16 direction[MAX_PID_AXES];
+    BYTE gain_percent;
+    BYTE condition_count;
+    /* only for periodic, constant or ramp forces */
+    struct effect_envelope envelope;
+    union
+    {
+        struct effect_periodic periodic;
+        struct effect_condition condition[MAX_PID_AXES];
+        struct effect_constant_force constant_force;
+        struct effect_ramp_force ramp_force;
+    };
+};
+
+struct unix_device;
+
+struct raw_device_vtbl
+{
+    void (*destroy)(struct unix_device *iface);
+    NTSTATUS (*start)(struct unix_device *iface);
+    void (*stop)(struct unix_device *iface);
+    NTSTATUS (*get_report_descriptor)(struct unix_device *iface, BYTE *buffer, UINT length, UINT *out_length);
+    void (*set_output_report)(struct unix_device *iface, HID_XFER_PACKET *packet, IO_STATUS_BLOCK *io);
+    void (*get_feature_report)(struct unix_device *iface, HID_XFER_PACKET *packet, IO_STATUS_BLOCK *io);
+    void (*set_feature_report)(struct unix_device *iface, HID_XFER_PACKET *packet, IO_STATUS_BLOCK *io);
+};
+
+struct hid_device_vtbl
+{
+    void (*destroy)(struct unix_device *iface);
+    NTSTATUS (*start)(struct unix_device *iface);
+    void (*stop)(struct unix_device *iface);
+    NTSTATUS (*haptics_start)(struct unix_device *iface, UINT duration_ms,
+                              USHORT rumble_intensity, USHORT buzz_intensity,
+                              USHORT left_intensity, USHORT right_intensity);
+    NTSTATUS (*haptics_stop)(struct unix_device *iface);
+    NTSTATUS (*physical_device_control)(struct unix_device *iface, USAGE control);
+    NTSTATUS (*physical_device_set_gain)(struct unix_device *iface, BYTE percent);
+    NTSTATUS (*physical_effect_control)(struct unix_device *iface, BYTE index, USAGE control, BYTE iterations);
+    NTSTATUS (*physical_effect_update)(struct unix_device *iface, BYTE index, struct effect_params *params);
+};
+
+struct hid_report_descriptor
+{
+    BYTE *data;
+    SIZE_T size;
+    SIZE_T max_size;
+    BYTE next_report_id[3];
+};
+
+#pragma pack(push,1)
+struct hid_haptics_feature
+{
+    WORD waveform;
+    WORD duration;
+    UINT cutoff_time_ms;
+};
+
+struct hid_haptics_features
+{
+    struct hid_haptics_feature rumble;
+    struct hid_haptics_feature buzz;
+    struct hid_haptics_feature left;
+    struct hid_haptics_feature right;
+};
+#pragma pack(pop)
+
+struct hid_haptics
+{
+    struct hid_haptics_features features;
+    BYTE features_report;
+    BYTE intensity_report;
+};
+
+/* must match the order and number of usages in the
+ * PID_USAGE_STATE_REPORT report */
+enum effect_state_flags
+{
+    EFFECT_STATE_DEVICE_PAUSED = 0x01,
+    EFFECT_STATE_ACTUATORS_ENABLED = 0x02,
+    EFFECT_STATE_EFFECT_PLAYING = 0x04,
+};
+
+struct hid_effect_state
+{
+    USHORT report_len;
+    BYTE *report_buf;
+    BYTE id;
+};
+
+struct hid_physical
+{
+    USAGE effect_types[32];
+    struct effect_params effect_params[256];
+
+    BYTE device_control_report;
+    BYTE device_gain_report;
+    BYTE effect_control_report;
+    BYTE effect_update_report;
+    BYTE set_periodic_report;
+    BYTE set_envelope_report;
+    BYTE set_condition_report;
+    BYTE set_constant_force_report;
+    BYTE set_ramp_force_report;
+
+    struct hid_effect_state effect_state;
+    USHORT axes_count;
+};
+
+struct hid_device_state
+{
+    ULONG bit_size;
+    USAGE_AND_PAGE abs_axis_usages[32];
+    USHORT abs_axis_start;
+    USHORT abs_axis_count;
+    USHORT rel_axis_start;
+    USHORT rel_axis_count;
+    USHORT hatswitch_start;
+    USHORT hatswitch_count;
+    USHORT button_start;
+    USHORT button_count;
+    USHORT report_len;
+    BYTE *report_buf;
+    BYTE *last_report_buf;
+    BOOL dropped;
+    BYTE id;
+};
+
+struct unix_device
+{
+    const struct raw_device_vtbl *vtbl;
+    struct list entry;
+    LONG ref;
+
+    const struct hid_device_vtbl *hid_vtbl;
+    struct hid_report_descriptor hid_report_descriptor;
+    struct hid_device_state hid_device_state;
+    struct hid_haptics hid_haptics;
+    struct hid_physical hid_physical;
+};
+
+extern void *raw_device_create(const struct raw_device_vtbl *vtbl, SIZE_T size);
+extern void *hid_device_create(const struct hid_device_vtbl *vtbl, SIZE_T size);
+
+extern NTSTATUS sdl_bus_init(void *);
+extern NTSTATUS sdl_bus_wait(void *);
+extern NTSTATUS sdl_bus_stop(void *);
+
+extern NTSTATUS udev_bus_init(void *);
+extern NTSTATUS udev_bus_wait(void *);
+extern NTSTATUS udev_bus_stop(void *);
+
+extern NTSTATUS iohid_bus_init(void *);
+extern NTSTATUS iohid_bus_wait(void *);
+extern NTSTATUS iohid_bus_stop(void *);
+
+extern void bus_event_cleanup(struct bus_event *event);
+extern void bus_event_queue_destroy(struct list *queue);
+extern BOOL bus_event_queue_device_removed(struct list *queue, struct unix_device *device);
+extern BOOL bus_event_queue_device_created(struct list *queue, struct unix_device *device, struct device_desc *desc);
+extern BOOL bus_event_queue_input_report(struct list *queue, struct unix_device *device,
+                                         BYTE *report, USHORT length);
+extern BOOL bus_event_queue_pop(struct list *queue, struct bus_event *event);
+
+extern BOOL hid_device_begin_report_descriptor(struct unix_device *iface, const USAGE_AND_PAGE *device_usage);
+extern BOOL hid_device_end_report_descriptor(struct unix_device *iface);
+
+extern BOOL hid_device_begin_input_report(struct unix_device *iface, const USAGE_AND_PAGE *physical_usage);
+extern BOOL hid_device_end_input_report(struct unix_device *iface);
+extern BOOL hid_device_add_buttons(struct unix_device *iface, USAGE usage_page,
+                                   USAGE usage_min, USAGE usage_max);
+extern BOOL hid_device_add_hatswitch(struct unix_device *iface, INT count);
+extern BOOL hid_device_add_axes(struct unix_device *iface, BYTE count, USAGE usage_page,
+                                const USAGE *usages, BOOL rel, LONG min, LONG max);
+
+extern BOOL hid_device_add_gamepad(struct unix_device *iface);
+extern BOOL hid_device_add_haptics(struct unix_device *iface);
+extern BOOL hid_device_add_physical(struct unix_device *iface, USAGE *usages, USHORT count, USHORT axes_count);
+
+extern BOOL hid_device_set_abs_axis(struct unix_device *iface, ULONG index, LONG value);
+extern BOOL hid_device_set_rel_axis(struct unix_device *iface, ULONG index, LONG value);
+extern BOOL hid_device_set_button(struct unix_device *iface, ULONG index, BOOL is_set);
+extern BOOL hid_device_set_hatswitch_x(struct unix_device *iface, ULONG index, LONG new_x);
+extern BOOL hid_device_set_hatswitch_y(struct unix_device *iface, ULONG index, LONG new_y);
+extern BOOL hid_device_move_hatswitch(struct unix_device *iface, ULONG index, LONG x, LONG y);
+
+extern BOOL hid_device_sync_report(struct unix_device *iface);
+extern void hid_device_drop_report(struct unix_device *iface);
+
+extern void hid_device_set_effect_state(struct unix_device *iface, BYTE index, BYTE flags);
+
+#endif /* __WINEBUS_UNIX_PRIVATE_H */
diff -ruN --show-c-function dlls/xinput1_1/Makefile.in dlls/xinput1_1/Makefile.in
--- dlls/xinput1_1/Makefile.in	2025-10-10 10:17:47.568387805 -0700
+++ dlls/xinput1_1/Makefile.in	2025-10-10 12:03:54.188727214 -0700
@@ -1,3 +1,4 @@
+EXTRADEFS = -DXINPUT_VER=1
 MODULE    = xinput1_1.dll
 IMPORTS   = hid setupapi advapi32 user32
 PARENTSRC = ../xinput1_3
diff -ruN --show-c-function dlls/xinput1_2/Makefile.in dlls/xinput1_2/Makefile.in
--- dlls/xinput1_2/Makefile.in	2025-10-10 10:17:47.568490580 -0700
+++ dlls/xinput1_2/Makefile.in	2025-10-10 12:03:54.188762632 -0700
@@ -1,3 +1,4 @@
+EXTRADEFS = -DXINPUT_VER=2
 MODULE    = xinput1_2.dll
 IMPORTS   = hid setupapi advapi32 user32
 PARENTSRC = ../xinput1_3
diff -ruN --show-c-function dlls/xinput1_3/main.c dlls/xinput1_3/main.c
--- dlls/xinput1_3/main.c	2025-10-10 10:17:47.568676563 -0700
+++ dlls/xinput1_3/main.c	2025-10-10 12:03:54.189866532 -0700
@@ -54,7 +54,6 @@ WINE_DEFAULT_DEBUG_CHANNEL(xinput);
 struct xinput_controller
 {
     CRITICAL_SECTION crit;
-    XINPUT_CAPABILITIES caps;
     XINPUT_STATE state;
     XINPUT_GAMEPAD last_keystroke;
     XINPUT_VIBRATION vibration;
@@ -122,19 +121,7 @@ static struct xinput_controller controll
 static HMODULE xinput_instance;
 static HANDLE start_event;
 static HANDLE update_event;
-
-static BOOL find_opened_device(const WCHAR *device_path, int *free_slot)
-{
-    int i;
-
-    *free_slot = XUSER_MAX_COUNT;
-    for (i = XUSER_MAX_COUNT; i > 0; i--)
-    {
-        if (!controllers[i - 1].device) *free_slot = i - 1;
-        else if (!wcsicmp(device_path, controllers[i - 1].device_path)) return TRUE;
-    }
-    return FALSE;
-}
+static HANDLE steam_overlay_event;
 
 static void check_value_caps(struct xinput_controller *controller, USHORT usage, HIDP_VALUE_CAPS *caps)
 {
@@ -210,7 +197,6 @@ static void check_waveform_caps(struct x
 static BOOL controller_check_caps(struct xinput_controller *controller, HANDLE device, PHIDP_PREPARSED_DATA preparsed)
 {
     USHORT caps_count = 0, waveform_caps_count = 0;
-    XINPUT_CAPABILITIES *caps = &controller->caps;
     HIDP_LINK_COLLECTION_NODE *collections;
     HIDP_VALUE_CAPS waveform_caps[8];
     HIDP_BUTTON_CAPS *button_caps;
@@ -219,9 +205,6 @@ static BOOL controller_check_caps(struct
     int i, u, button_count = 0;
     NTSTATUS status;
 
-    /* Count buttons */
-    memset(caps, 0, sizeof(XINPUT_CAPABILITIES));
-
     if (!(button_caps = malloc(sizeof(*button_caps) * controller->hid.caps.NumberInputButtonCaps))) return FALSE;
     status = HidP_GetButtonCaps(HidP_Input, button_caps, &controller->hid.caps.NumberInputButtonCaps, preparsed);
     if (status != HIDP_STATUS_SUCCESS) WARN("HidP_GetButtonCaps returned %#lx\n", status);
@@ -235,9 +218,7 @@ static BOOL controller_check_caps(struct
             button_count = max(button_count, button_caps[i].NotRange.Usage);
     }
     free(button_caps);
-    if (button_count < 11)
-        WARN("Too few buttons, continuing anyway\n");
-    caps->Gamepad.wButtons = 0xffff;
+    if (button_count < 11) WARN("Too few buttons, continuing anyway\n");
 
     if (!(value_caps = malloc(sizeof(*value_caps) * controller->hid.caps.NumberInputValueCaps))) return FALSE;
     status = HidP_GetValueCaps(HidP_Input, value_caps, &controller->hid.caps.NumberInputValueCaps, preparsed);
@@ -252,20 +233,11 @@ static BOOL controller_check_caps(struct
     free(value_caps);
 
     if (!controller->hid.lt_caps.UsagePage) WARN("Missing axis LeftTrigger\n");
-    else caps->Gamepad.bLeftTrigger = (1u << (sizeof(caps->Gamepad.bLeftTrigger) + 1)) - 1;
     if (!controller->hid.rt_caps.UsagePage) WARN("Missing axis RightTrigger\n");
-    else caps->Gamepad.bRightTrigger = (1u << (sizeof(caps->Gamepad.bRightTrigger) + 1)) - 1;
     if (!controller->hid.lx_caps.UsagePage) WARN("Missing axis ThumbLX\n");
-    else caps->Gamepad.sThumbLX = (1u << (sizeof(caps->Gamepad.sThumbLX) + 1)) - 1;
     if (!controller->hid.ly_caps.UsagePage) WARN("Missing axis ThumbLY\n");
-    else caps->Gamepad.sThumbLY = (1u << (sizeof(caps->Gamepad.sThumbLY) + 1)) - 1;
     if (!controller->hid.rx_caps.UsagePage) WARN("Missing axis ThumbRX\n");
-    else caps->Gamepad.sThumbRX = (1u << (sizeof(caps->Gamepad.sThumbRX) + 1)) - 1;
     if (!controller->hid.ry_caps.UsagePage) WARN("Missing axis ThumbRY\n");
-    else caps->Gamepad.sThumbRY = (1u << (sizeof(caps->Gamepad.sThumbRY) + 1)) - 1;
-
-    caps->Type = XINPUT_DEVTYPE_GAMEPAD;
-    caps->SubType = XINPUT_DEVSUBTYPE_GAMEPAD;
 
     collections_count = controller->hid.caps.NumberLinkCollectionNodes;
     if (!(collections = malloc(sizeof(*collections) * controller->hid.caps.NumberLinkCollectionNodes))) return FALSE;
@@ -285,14 +257,6 @@ static BOOL controller_check_caps(struct
     for (i = 0; i < waveform_caps_count; ++i) check_waveform_caps(controller, device, preparsed, collections, waveform_caps + i);
     free(collections);
 
-    if (controller->hid.haptics_rumble_caps.UsagePage ||
-        controller->hid.haptics_buzz_caps.UsagePage)
-    {
-        caps->Flags |= XINPUT_CAPS_FFB_SUPPORTED;
-        caps->Vibration.wLeftMotorSpeed = 255;
-        caps->Vibration.wRightMotorSpeed = 255;
-    }
-
     return TRUE;
 }
 
@@ -306,7 +270,7 @@ static DWORD HID_set_state(struct xinput
     NTSTATUS status;
     BYTE report_id;
 
-    if (!(controller->caps.Flags & XINPUT_CAPS_FFB_SUPPORTED)) return ERROR_SUCCESS;
+    if (!controller->hid.haptics_rumble_caps.UsagePage && !controller->hid.haptics_buzz_caps.UsagePage) return ERROR_SUCCESS;
 
     update_rumble = (controller->vibration.wLeftMotorSpeed != state->wLeftMotorSpeed);
     controller->vibration.wLeftMotorSpeed = state->wLeftMotorSpeed;
@@ -337,7 +301,40 @@ static DWORD HID_set_state(struct xinput
     return ERROR_SUCCESS;
 }
 
-static void controller_destroy(struct xinput_controller *controller, BOOL already_removed);
+static void controller_disable(struct xinput_controller *controller)
+{
+    XINPUT_VIBRATION state = {0};
+
+    if (!controller->enabled) return;
+    HID_set_state(controller, &state);
+    controller->enabled = FALSE;
+
+    CancelIoEx(controller->device, &controller->hid.read_ovl);
+    WaitForSingleObject(controller->hid.read_ovl.hEvent, INFINITE);
+    SetEvent(update_event);
+}
+
+static void controller_destroy(struct xinput_controller *controller, BOOL already_removed)
+{
+    EnterCriticalSection(&controller->crit);
+
+    if (controller->device)
+    {
+        TRACE("removing device %s from index %Iu\n", debugstr_w(controller->device_path), controller - controllers);
+
+        if (!already_removed) controller_disable(controller);
+        CloseHandle(controller->device);
+        controller->device = NULL;
+
+        free(controller->hid.input_report_buf);
+        free(controller->hid.output_report_buf);
+        free(controller->hid.feature_report_buf);
+        HidD_FreePreparsedData(controller->hid.preparsed);
+        memset(&controller->hid, 0, sizeof(controller->hid));
+    }
+
+    LeaveCriticalSection(&controller->crit);
+}
 
 static void controller_enable(struct xinput_controller *controller)
 {
@@ -347,7 +344,7 @@ static void controller_enable(struct xin
     BOOL ret;
 
     if (controller->enabled) return;
-    if (controller->caps.Flags & XINPUT_CAPS_FFB_SUPPORTED) HID_set_state(controller, &state);
+    HID_set_state(controller, &state);
     controller->enabled = TRUE;
 
     memset(&controller->hid.read_ovl, 0, sizeof(controller->hid.read_ovl));
@@ -357,19 +354,6 @@ static void controller_enable(struct xin
     else SetEvent(update_event);
 }
 
-static void controller_disable(struct xinput_controller *controller)
-{
-    XINPUT_VIBRATION state = {0};
-
-    if (!controller->enabled) return;
-    if (controller->caps.Flags & XINPUT_CAPS_FFB_SUPPORTED) HID_set_state(controller, &state);
-    controller->enabled = FALSE;
-
-    CancelIoEx(controller->device, &controller->hid.read_ovl);
-    WaitForSingleObject(controller->hid.read_ovl.hEvent, INFINITE);
-    SetEvent(update_event);
-}
-
 static BOOL controller_init(struct xinput_controller *controller, PHIDP_PREPARSED_DATA preparsed,
                             HIDP_CAPS *caps, HANDLE device, const WCHAR *device_path)
 {
@@ -453,17 +437,13 @@ static BOOL device_is_overridden(HANDLE
     return disable;
 }
 
-static BOOL try_add_device(const WCHAR *device_path)
+static BOOL open_device_at_index(const WCHAR *device_path, int index)
 {
     SP_DEVICE_INTERFACE_DATA iface = {sizeof(iface)};
     PHIDP_PREPARSED_DATA preparsed;
     HIDP_CAPS caps;
     NTSTATUS status;
     HANDLE device;
-    int i;
-
-    if (find_opened_device(device_path, &i)) return TRUE; /* already opened */
-    if (i == XUSER_MAX_COUNT) return FALSE; /* no more slots */
 
     device = CreateFileW(device_path, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING, NULL);
@@ -481,16 +461,53 @@ static BOOL try_add_device(const WCHAR *
         WARN("ignoring HID device, unsupported usage %04x:%04x\n", caps.UsagePage, caps.Usage);
     else if (device_is_overridden(device))
         WARN("ignoring HID device, overridden for dinput\n");
-    else if (!controller_init(&controllers[i], preparsed, &caps, device, device_path))
+    else if (!controller_init(&controllers[index], preparsed, &caps, device, device_path))
         WARN("ignoring HID device, failed to initialize\n");
     else
+    {
+        TRACE("opened device %s at index %u\n", debugstr_w(device_path), index);
         return TRUE;
+    }
 
     CloseHandle(device);
     HidD_FreePreparsedData(preparsed);
     return TRUE;
 }
 
+static BOOL find_opened_device(const WCHAR *device_path, int *free_slot)
+{
+    int i;
+
+    *free_slot = XUSER_MAX_COUNT;
+    for (i = XUSER_MAX_COUNT; i > 0; i--)
+    {
+        if (!controllers[i - 1].device) *free_slot = i - 1;
+        else if (!wcsicmp(device_path, controllers[i - 1].device_path)) return TRUE;
+    }
+
+    /* CW-Bug-Id: #23185 Emulate Steam Input native hooks for native SDL */
+    if ((swscanf(device_path, L"\\\\?\\hid#vid_28de&pid_11ff&xi_%02u#", &i) == 1 ||
+         swscanf(device_path, L"\\\\?\\HID#VID_28DE&PID_11FF&XI_%02u#", &i) == 1) &&
+        i < XUSER_MAX_COUNT && *free_slot != i)
+    {
+        controller_destroy(&controllers[i], TRUE);
+        if (*free_slot != XUSER_MAX_COUNT) open_device_at_index(controllers[i].device_path, *free_slot);
+        *free_slot = i;
+    }
+
+    return FALSE;
+}
+
+static BOOL try_add_device(const WCHAR *device_path)
+{
+    SP_DEVICE_INTERFACE_DATA iface = {sizeof(iface)};
+    int i;
+
+    if (find_opened_device(device_path, &i)) return TRUE; /* already opened */
+    if (i == XUSER_MAX_COUNT) return FALSE; /* no more slots */
+    return open_device_at_index(device_path, i);
+}
+
 static void try_remove_device(const WCHAR *device_path)
 {
     int i;
@@ -525,26 +542,6 @@ static void update_controller_list(void)
     SetupDiDestroyDeviceInfoList(set);
 }
 
-static void controller_destroy(struct xinput_controller *controller, BOOL already_removed)
-{
-    EnterCriticalSection(&controller->crit);
-
-    if (controller->device)
-    {
-        if (!already_removed) controller_disable(controller);
-        CloseHandle(controller->device);
-        controller->device = NULL;
-
-        free(controller->hid.input_report_buf);
-        free(controller->hid.output_report_buf);
-        free(controller->hid.feature_report_buf);
-        HidD_FreePreparsedData(controller->hid.preparsed);
-        memset(&controller->hid, 0, sizeof(controller->hid));
-    }
-
-    LeaveCriticalSection(&controller->crit);
-}
-
 static LONG sign_extend(ULONG value, const HIDP_VALUE_CAPS *caps)
 {
     UINT sign = 1 << (caps->BitSize - 1);
@@ -749,6 +746,8 @@ static BOOL WINAPI start_update_thread_o
     if (!GetModuleHandleExW(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, (void*)hid_update_thread_proc, &module))
         WARN("Failed to increase module's reference count, error: %lu\n", GetLastError());
 
+    steam_overlay_event = CreateEventA(NULL, TRUE, FALSE, "__wine_steamclient_GameOverlayActivated");
+
     start_event = CreateEventA(NULL, FALSE, FALSE, NULL);
     if (!start_event) ERR("failed to create start event, error %lu\n", GetLastError());
 
@@ -835,7 +834,8 @@ DWORD WINAPI DECLSPEC_HOTPATCH XInputSet
     if (index >= XUSER_MAX_COUNT) return ERROR_BAD_ARGUMENTS;
     if (!controller_lock(&controllers[index])) return ERROR_DEVICE_NOT_CONNECTED;
 
-    ret = HID_set_state(&controllers[index], vibration);
+    if (WaitForSingleObject(steam_overlay_event, 0) == WAIT_OBJECT_0) ret = ERROR_SUCCESS;
+    else ret = HID_set_state(&controllers[index], vibration);
 
     controller_unlock(&controllers[index]);
 
@@ -853,7 +853,9 @@ static DWORD xinput_get_state(DWORD inde
     if (index >= XUSER_MAX_COUNT) return ERROR_BAD_ARGUMENTS;
     if (!controller_lock(&controllers[index])) return ERROR_DEVICE_NOT_CONNECTED;
 
-    *state = controllers[index].state;
+    if (WaitForSingleObject(steam_overlay_event, 0) == WAIT_OBJECT_0) memset(state, 0, sizeof(*state));
+    else *state = controllers[index].state;
+
     controller_unlock(&controllers[index]);
 
     return ERROR_SUCCESS;
@@ -1129,6 +1131,10 @@ DWORD WINAPI DECLSPEC_HOTPATCH XInputGet
 
 DWORD WINAPI DECLSPEC_HOTPATCH XInputGetCapabilitiesEx(DWORD unk, DWORD index, DWORD flags, XINPUT_CAPABILITIES_EX *caps)
 {
+    static const UINT XINPUT_BUTTONS_ALL = XINPUT_GAMEPAD_DPAD_UP | XINPUT_GAMEPAD_DPAD_DOWN | XINPUT_GAMEPAD_DPAD_LEFT | XINPUT_GAMEPAD_DPAD_RIGHT
+                                         | XINPUT_GAMEPAD_START | XINPUT_GAMEPAD_BACK | XINPUT_GAMEPAD_LEFT_THUMB | XINPUT_GAMEPAD_RIGHT_THUMB
+                                         | XINPUT_GAMEPAD_LEFT_SHOULDER | XINPUT_GAMEPAD_RIGHT_SHOULDER
+                                         | XINPUT_GAMEPAD_A | XINPUT_GAMEPAD_B | XINPUT_GAMEPAD_X | XINPUT_GAMEPAD_Y;
     HIDD_ATTRIBUTES attr;
     DWORD ret = ERROR_SUCCESS;
 
@@ -1140,16 +1146,44 @@ DWORD WINAPI DECLSPEC_HOTPATCH XInputGet
 
     if (!controller_lock(&controllers[index])) return ERROR_DEVICE_NOT_CONNECTED;
 
-    if (flags & XINPUT_FLAG_GAMEPAD && controllers[index].caps.SubType != XINPUT_DEVSUBTYPE_GAMEPAD)
-        ret = ERROR_DEVICE_NOT_CONNECTED;
-    else if (!HidD_GetAttributes(controllers[index].device, &attr))
+    if (!HidD_GetAttributes(controllers[index].device, &attr))
         ret = ERROR_DEVICE_NOT_CONNECTED;
     else
     {
-        caps->Capabilities = controllers[index].caps;
+        memset(caps, 0, sizeof(*caps));
+
+#if XINPUT_VER >= 4
+        caps->Capabilities.Type = XINPUT_DEVTYPE_GAMEPAD;
+#endif
+        caps->Capabilities.SubType = XINPUT_DEVSUBTYPE_GAMEPAD;
+#if XINPUT_VER >= 4
+        caps->Capabilities.Flags |= XINPUT_CAPS_PMD_SUPPORTED;
+#endif
+#if XINPUT_VER >= 3
+        caps->Capabilities.Flags |= XINPUT_CAPS_VOICE_SUPPORTED;
+#endif
+
+        caps->Capabilities.Gamepad.wButtons = XINPUT_BUTTONS_ALL;
+        caps->Capabilities.Gamepad.bLeftTrigger = 0xff;
+        caps->Capabilities.Gamepad.bRightTrigger = 0xff;
+        caps->Capabilities.Gamepad.sThumbLX = ~0x3f;
+        caps->Capabilities.Gamepad.sThumbLY = ~0x3f;
+        caps->Capabilities.Gamepad.sThumbRX = ~0x3f;
+        caps->Capabilities.Gamepad.sThumbRY = ~0x3f;
+        caps->Capabilities.Vibration.wLeftMotorSpeed = 0xff;
+        caps->Capabilities.Vibration.wRightMotorSpeed = 0xff;
+
         caps->VendorId = attr.VendorID;
         caps->ProductId = attr.ProductID;
         caps->VersionNumber = attr.VersionNumber;
+
+        /* CW-Bug-Id: #23185 Emulate Steam Input native hooks for native SDL */
+        if (attr.VendorID == 0x28de && attr.ProductID == 0x11ff)
+        {
+            caps->Capabilities.Type = XINPUT_DEVTYPE_GAMEPAD;
+            caps->Capabilities.Flags = XINPUT_CAPS_WIRELESS;
+            caps->unk2 = index;
+        }
     }
 
     controller_unlock(&controllers[index]);
diff -ruN --show-c-function dlls/xinput1_3/Makefile.in dlls/xinput1_3/Makefile.in
--- dlls/xinput1_3/Makefile.in	2025-10-10 10:17:47.568587975 -0700
+++ dlls/xinput1_3/Makefile.in	2025-10-10 12:03:54.188794382 -0700
@@ -1,3 +1,4 @@
+EXTRADEFS = -DXINPUT_VER=3
 MODULE    = xinput1_3.dll
 IMPORTLIB = xinput
 IMPORTS   = hid setupapi advapi32 user32
diff -ruN --show-c-function dlls/xinput1_4/Makefile.in dlls/xinput1_4/Makefile.in
--- dlls/xinput1_4/Makefile.in	2025-10-10 10:17:47.568824924 -0700
+++ dlls/xinput1_4/Makefile.in	2025-10-10 12:03:54.189126965 -0700
@@ -1,3 +1,4 @@
+EXTRADEFS = -DXINPUT_VER=4
 MODULE    = xinput1_4.dll
 IMPORTS   = hid setupapi advapi32 user32
 PARENTSRC = ../xinput1_3
diff -ruN --show-c-function dlls/xinput9_1_0/main.c dlls/xinput9_1_0/main.c
--- dlls/xinput9_1_0/main.c	2025-10-10 10:17:47.569086401 -0700
+++ dlls/xinput9_1_0/main.c	2025-10-10 12:03:54.189171870 -0700
@@ -70,12 +70,27 @@ static BOOL WINAPI init_xinput1_4_funcs(
     return TRUE;
 }
 
-DWORD WINAPI DECLSPEC_HOTPATCH XInputGetCapabilities(DWORD index, DWORD flags, XINPUT_CAPABILITIES *capabilities)
+DWORD WINAPI DECLSPEC_HOTPATCH XInputGetCapabilities(DWORD index, DWORD flags, XINPUT_CAPABILITIES *caps)
 {
+    DWORD ret;
+
     InitOnceExecuteOnce(&init_xinput1_4_once, init_xinput1_4_funcs, NULL, NULL);
 
     if (!pXInputGetCapabilities) return ERROR_DEVICE_NOT_CONNECTED;
-    return pXInputGetCapabilities(index, flags, capabilities);
+    if (!(ret = pXInputGetCapabilities(index, flags, caps)))
+    {
+        caps->Flags = XINPUT_CAPS_VOICE_SUPPORTED;
+        caps->Gamepad.bLeftTrigger = !!caps->Gamepad.bLeftTrigger;
+        caps->Gamepad.bRightTrigger = !!caps->Gamepad.bRightTrigger;
+        caps->Gamepad.sThumbLX = !!caps->Gamepad.sThumbLX;
+        caps->Gamepad.sThumbLY = !!caps->Gamepad.sThumbLY;
+        caps->Gamepad.sThumbRX = !!caps->Gamepad.sThumbRX;
+        caps->Gamepad.sThumbRY = !!caps->Gamepad.sThumbRY;
+        caps->Vibration.wLeftMotorSpeed = !!caps->Vibration.wLeftMotorSpeed;
+        caps->Vibration.wRightMotorSpeed = !!caps->Vibration.wRightMotorSpeed;
+    }
+
+    return ret;
 }
 
 DWORD WINAPI DECLSPEC_HOTPATCH XInputGetDSoundAudioDeviceGuids(DWORD index, GUID *render_guid, GUID *capture_guid)
Binary files .git/index and .git/index differ
diff -ruN --show-c-function .git/logs/HEAD .git/logs/HEAD
--- .git/logs/HEAD	2025-10-10 10:17:49.477579329 -0700
+++ .git/logs/HEAD	2025-10-10 12:03:50.104253267 -0700
@@ -1,3 +1,3 @@
-0000000000000000000000000000000000000000 2827471c57299793d8e0868679184f8d762a5309 Vincent <vincent@ryzendesktop.(none)> 1760116667 -0700	clone: from /home/vincent/Downloads/wine-tkg-git/wine-tkg-git/wine-git
-2827471c57299793d8e0868679184f8d762a5309 01269452e0fbb1f081d506bd64996590a553e2b9 Vincent <vincent@ryzendesktop.(none)> 1760116669 -0700	checkout: moving from master to makepkg
-01269452e0fbb1f081d506bd64996590a553e2b9 01269452e0fbb1f081d506bd64996590a553e2b9 Vincent <vincent@ryzendesktop.(none)> 1760116669 -0700	reset: moving to HEAD
+0000000000000000000000000000000000000000 2827471c57299793d8e0868679184f8d762a5309 Vincent <vincent@ryzendesktop.(none)> 1760123027 -0700	clone: from /home/vincent/Downloads/wine-tkg-git/wine-tkg-git/wine-git
+2827471c57299793d8e0868679184f8d762a5309 01269452e0fbb1f081d506bd64996590a553e2b9 Vincent <vincent@ryzendesktop.(none)> 1760123029 -0700	checkout: moving from master to makepkg
+01269452e0fbb1f081d506bd64996590a553e2b9 01269452e0fbb1f081d506bd64996590a553e2b9 Vincent <vincent@ryzendesktop.(none)> 1760123030 -0700	reset: moving to HEAD
diff -ruN --show-c-function .git/logs/refs/heads/makepkg .git/logs/refs/heads/makepkg
--- .git/logs/refs/heads/makepkg	2025-10-10 10:17:49.311790981 -0700
+++ .git/logs/refs/heads/makepkg	2025-10-10 12:03:49.846697010 -0700
@@ -1 +1 @@
-0000000000000000000000000000000000000000 01269452e0fbb1f081d506bd64996590a553e2b9 Vincent <vincent@ryzendesktop.(none)> 1760116669 -0700	branch: Created from wine-10.16
+0000000000000000000000000000000000000000 01269452e0fbb1f081d506bd64996590a553e2b9 Vincent <vincent@ryzendesktop.(none)> 1760123029 -0700	branch: Created from wine-10.16
diff -ruN --show-c-function .git/logs/refs/heads/master .git/logs/refs/heads/master
--- .git/logs/refs/heads/master	2025-10-10 10:17:47.046005634 -0700
+++ .git/logs/refs/heads/master	2025-10-10 12:03:47.829476422 -0700
@@ -1 +1 @@
-0000000000000000000000000000000000000000 2827471c57299793d8e0868679184f8d762a5309 Vincent <vincent@ryzendesktop.(none)> 1760116667 -0700	clone: from /home/vincent/Downloads/wine-tkg-git/wine-tkg-git/wine-git
+0000000000000000000000000000000000000000 2827471c57299793d8e0868679184f8d762a5309 Vincent <vincent@ryzendesktop.(none)> 1760123027 -0700	clone: from /home/vincent/Downloads/wine-tkg-git/wine-tkg-git/wine-git
diff -ruN --show-c-function .git/logs/refs/remotes/origin/HEAD .git/logs/refs/remotes/origin/HEAD
--- .git/logs/refs/remotes/origin/HEAD	2025-10-10 10:17:47.045233770 -0700
+++ .git/logs/refs/remotes/origin/HEAD	2025-10-10 12:03:47.828677682 -0700
@@ -1 +1 @@
-0000000000000000000000000000000000000000 2827471c57299793d8e0868679184f8d762a5309 Vincent <vincent@ryzendesktop.(none)> 1760116667 -0700	clone: from /home/vincent/Downloads/wine-tkg-git/wine-tkg-git/wine-git
+0000000000000000000000000000000000000000 2827471c57299793d8e0868679184f8d762a5309 Vincent <vincent@ryzendesktop.(none)> 1760123027 -0700	clone: from /home/vincent/Downloads/wine-tkg-git/wine-tkg-git/wine-git
Binary files .git/objects/04/b561de2ece53bc0858533b68c96607c437e488 and .git/objects/04/b561de2ece53bc0858533b68c96607c437e488 differ
Binary files .git/objects/17/92e9e2ddb66273c833149c8c7bba7b2a1d3456 and .git/objects/17/92e9e2ddb66273c833149c8c7bba7b2a1d3456 differ
Binary files .git/objects/21/de22161e4456c11107d3b9c6f4809ab03e0628 and .git/objects/21/de22161e4456c11107d3b9c6f4809ab03e0628 differ
Binary files .git/objects/25/4bac01bf5fc9c9b5a16d2527b6c77a8e9abcd4 and .git/objects/25/4bac01bf5fc9c9b5a16d2527b6c77a8e9abcd4 differ
Binary files .git/objects/25/ddb68e4c1bb0a71f754cb4358cd7edafb57954 and .git/objects/25/ddb68e4c1bb0a71f754cb4358cd7edafb57954 differ
Binary files .git/objects/41/31106d43d7de52ecf7648f45b17cdff353c975 and .git/objects/41/31106d43d7de52ecf7648f45b17cdff353c975 differ
Binary files .git/objects/43/3dfcf949d17bff50149b74244c0018e6a00ab1 and .git/objects/43/3dfcf949d17bff50149b74244c0018e6a00ab1 differ
Binary files .git/objects/48/2f75d0f7e460d4a03ad3eccc9a160b1a3f8c8c and .git/objects/48/2f75d0f7e460d4a03ad3eccc9a160b1a3f8c8c differ
Binary files .git/objects/57/00da4f43ec5523e2458d6966ac21a98d5dbfd4 and .git/objects/57/00da4f43ec5523e2458d6966ac21a98d5dbfd4 differ
Binary files .git/objects/62/365f0b32314627b7375345eb0aa0d387b906ea and .git/objects/62/365f0b32314627b7375345eb0aa0d387b906ea differ
Binary files .git/objects/6e/fb9acd07b32967a1b3e50e863e0003e4fcf952 and .git/objects/6e/fb9acd07b32967a1b3e50e863e0003e4fcf952 differ
Binary files .git/objects/77/0937e76129fc8e948cd4664bab48397f2ee3a7 and .git/objects/77/0937e76129fc8e948cd4664bab48397f2ee3a7 differ
Binary files .git/objects/7d/c406dd85a9b2cb2c21c881d02c6e5bf4977964 and .git/objects/7d/c406dd85a9b2cb2c21c881d02c6e5bf4977964 differ
Binary files .git/objects/8a/17c1f7cec5966745fad1ebd0c4ae264a1ae09c and .git/objects/8a/17c1f7cec5966745fad1ebd0c4ae264a1ae09c differ
Binary files .git/objects/a8/c71b40ca896c6cd7f021e465e9a6e1eb51dc05 and .git/objects/a8/c71b40ca896c6cd7f021e465e9a6e1eb51dc05 differ
Binary files .git/objects/aa/d8d97e21d8eddb079449e8c3d6cacb2d1756fd and .git/objects/aa/d8d97e21d8eddb079449e8c3d6cacb2d1756fd differ
Binary files .git/objects/b2/2f8e63294084b366ffe9a2c9be5dc2fe7f1fae and .git/objects/b2/2f8e63294084b366ffe9a2c9be5dc2fe7f1fae differ
Binary files .git/objects/ba/36971df489f1d1982fd1d100f1695dd4ffd249 and .git/objects/ba/36971df489f1d1982fd1d100f1695dd4ffd249 differ
Binary files .git/objects/dc/3c54e6498750d841647c3ef3d6eae32bf60577 and .git/objects/dc/3c54e6498750d841647c3ef3d6eae32bf60577 differ
Binary files .git/objects/f4/533301652aa5e69210693667249884b77607d4 and .git/objects/f4/533301652aa5e69210693667249884b77607d4 differ
diff -ruN --show-c-function programs/services/services.c programs/services/services.c
--- programs/services/services.c	2025-10-10 10:17:47.786634768 -0700
+++ programs/services/services.c	2025-10-10 12:03:54.188203879 -0700
@@ -1030,15 +1030,23 @@ found:
 
     if (!environment && OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_DUPLICATE, &token))
     {
-        WCHAR val[16];
-        CreateEnvironmentBlock(&environment, token, FALSE);
-        if (GetEnvironmentVariableW( L"WINEBOOTSTRAPMODE", val, ARRAY_SIZE(val) ))
+        static const WCHAR *preserve[] =
         {
-            UNICODE_STRING name = RTL_CONSTANT_STRING(L"WINEBOOTSTRAPMODE");
-            UNICODE_STRING value;
+            L"WINEBOOTSTRAPMODE",
+            L"WINEBUSCONFIG",
+        };
+        WCHAR buffer[1024];
 
-            RtlInitUnicodeString( &value, val );
-            RtlSetEnvironmentVariable( (WCHAR **)&environment, &name, &value );
+        CreateEnvironmentBlock(&environment, token, FALSE);
+        for (size_t i = 0; i < ARRAY_SIZE(preserve); i++)
+        {
+            if (GetEnvironmentVariableW( preserve[i], buffer, ARRAY_SIZE(buffer) ))
+            {
+                UNICODE_STRING value, name;
+                RtlInitUnicodeString( &name, preserve[i] );
+                RtlInitUnicodeString( &value, buffer );
+                RtlSetEnvironmentVariable( (WCHAR **)&environment, &name, &value );
+            }
         }
         CloseHandle(token);
     }

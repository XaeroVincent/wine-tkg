diff -ruN --show-c-function vanilla-1017/configure protonvulkan-1017/configure
--- vanilla-1017/configure	2025-10-21 17:44:47.290026993 -0700
+++ protonvulkan-1017/configure	2025-10-21 17:23:46.636875701 -0700
@@ -1426,6 +1426,7 @@ enable_serialui
 enable_setupapi
 enable_sfc
 enable_sfc_os
+enable_sharedgpures_sys
 enable_shcore
 enable_shdoclc
 enable_shdocvw
@@ -22981,6 +22982,7 @@ wine_fn_config_makefile dlls/setupapi/te
 wine_fn_config_makefile dlls/setupx.dll16 enable_win16
 wine_fn_config_makefile dlls/sfc enable_sfc
 wine_fn_config_makefile dlls/sfc_os enable_sfc_os
+wine_fn_config_makefile dlls/sharedgpures.sys enable_sharedgpures_sys
 wine_fn_config_makefile dlls/shcore enable_shcore
 wine_fn_config_makefile dlls/shcore/tests enable_tests
 wine_fn_config_makefile dlls/shdoclc enable_shdoclc
diff -ruN --show-c-function vanilla-1017/configure.ac protonvulkan-1017/configure.ac
--- vanilla-1017/configure.ac	2025-10-21 20:56:16.464249113 -0700
+++ protonvulkan-1017/configure.ac	2025-10-21 21:15:57.310866950 -0700
@@ -3158,6 +3158,7 @@ WINE_CONFIG_MAKEFILE(dlls/setupapi/tests
 WINE_CONFIG_MAKEFILE(dlls/setupx.dll16)
 WINE_CONFIG_MAKEFILE(dlls/sfc)
 WINE_CONFIG_MAKEFILE(dlls/sfc_os)
+WINE_CONFIG_MAKEFILE(dlls/sharedgpures.sys)
 WINE_CONFIG_MAKEFILE(dlls/shcore)
 WINE_CONFIG_MAKEFILE(dlls/shcore/tests)
 WINE_CONFIG_MAKEFILE(dlls/shdoclc)
diff -ruN --show-c-function vanilla-1017/dlls/ntdll/unix/server.c protonvulkan-1017/dlls/ntdll/unix/server.c
--- vanilla-1017/dlls/ntdll/unix/server.c	2025-10-21 17:44:35.922771491 -0700
+++ protonvulkan-1017/dlls/ntdll/unix/server.c	2025-10-21 17:23:40.571124542 -0700
@@ -939,7 +939,7 @@ unsigned int server_queue_process_apc( H
  *
  * Send a file descriptor to the server.
  */
-void CDECL wine_server_send_fd( int fd )
+void wine_server_send_fd( int fd )
 {
     struct send_fd data;
     struct msghdr msghdr;
diff -ruN --show-c-function vanilla-1017/dlls/ntdll/unix/unix_private.h protonvulkan-1017/dlls/ntdll/unix/unix_private.h
--- vanilla-1017/dlls/ntdll/unix/unix_private.h	2025-10-21 17:44:35.924771537 -0700
+++ protonvulkan-1017/dlls/ntdll/unix/unix_private.h	2025-10-21 17:23:40.571263926 -0700
@@ -233,6 +233,7 @@ extern unsigned int server_queue_process
                                               union apc_result *result );
 extern int server_get_unix_fd( HANDLE handle, unsigned int wanted_access, int *unix_fd,
                                int *needs_close, enum server_fd_type *type, unsigned int *options );
+extern void wine_server_send_fd( int fd );
 extern int wine_server_receive_fd( obj_handle_t *handle );
 extern void process_exit_wrapper( int status ) DECLSPEC_NORETURN;
 extern size_t server_init_process(void);
diff -ruN --show-c-function vanilla-1017/dlls/ntoskrnl.exe/ntoskrnl.c protonvulkan-1017/dlls/ntoskrnl.exe/ntoskrnl.c
--- vanilla-1017/dlls/ntoskrnl.exe/ntoskrnl.c	2025-10-21 17:44:35.926181403 -0700
+++ protonvulkan-1017/dlls/ntoskrnl.exe/ntoskrnl.c	2025-10-21 17:23:40.567378798 -0700
@@ -258,6 +258,15 @@ POBJECT_TYPE WINAPI ObGetObjectType( voi
     return header->type;
 }
 
+static const WCHAR section_type_name[] = {'S','e','c','t','i','o','n',0};
+
+static struct _OBJECT_TYPE section_type =
+{
+    section_type_name
+};
+
+static POBJECT_TYPE p_section_type = &section_type;
+
 static const POBJECT_TYPE *known_types[] =
 {
     &ExEventObjectType,
@@ -267,7 +276,8 @@ static const POBJECT_TYPE *known_types[]
     &IoFileObjectType,
     &PsProcessType,
     &PsThreadType,
-    &SeTokenObjectType
+    &SeTokenObjectType,
+    &p_section_type,
 };
 
 DECLARE_CRITICAL_SECTION(handle_map_cs);
diff -ruN --show-c-function vanilla-1017/dlls/sharedgpures.sys/Makefile.in protonvulkan-1017/dlls/sharedgpures.sys/Makefile.in
--- vanilla-1017/dlls/sharedgpures.sys/Makefile.in	1969-12-31 16:00:00.000000000 -0800
+++ protonvulkan-1017/dlls/sharedgpures.sys/Makefile.in	2025-10-21 17:23:41.148923839 -0700
@@ -0,0 +1,7 @@
+MODULE    = sharedgpures.sys
+IMPORTS   = ntoskrnl
+EXTRADLLFLAGS = -Wl,--subsystem,native
+
+SOURCES = \
+	shared_resource.c \
+	sharedgpures.sys.spec
diff -ruN --show-c-function vanilla-1017/dlls/sharedgpures.sys/sharedgpures.sys.spec protonvulkan-1017/dlls/sharedgpures.sys/sharedgpures.sys.spec
--- vanilla-1017/dlls/sharedgpures.sys/sharedgpures.sys.spec	1969-12-31 16:00:00.000000000 -0800
+++ protonvulkan-1017/dlls/sharedgpures.sys/sharedgpures.sys.spec	2025-10-21 17:23:40.637536623 -0700
@@ -0,0 +1 @@
+# nothing to export
diff -ruN --show-c-function vanilla-1017/dlls/sharedgpures.sys/shared_resource.c protonvulkan-1017/dlls/sharedgpures.sys/shared_resource.c
--- vanilla-1017/dlls/sharedgpures.sys/shared_resource.c	1969-12-31 16:00:00.000000000 -0800
+++ protonvulkan-1017/dlls/sharedgpures.sys/shared_resource.c	2025-10-21 17:23:40.646467585 -0700
@@ -0,0 +1,518 @@
+#include <stdarg.h>
+
+#define NONAMELESSUNION
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winbase.h"
+#include "winternl.h"
+#include "winioctl.h"
+
+#include "ddk/wdm.h"
+
+#include "wine/debug.h"
+#include "wine/list.h"
+#include "wine/server.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(sharedgpures);
+
+static DRIVER_OBJECT *sharedgpures_driver;
+
+struct shared_resource
+{
+    unsigned int ref_count;
+    void *unix_resource;
+    WCHAR *name;
+    void *metadata;
+    SIZE_T metadata_size;
+    void **object_pool;
+    unsigned int object_pool_count;
+    UINT64 resource_size;
+};
+
+static struct shared_resource *resource_pool;
+static unsigned int resource_pool_size;
+
+/* TODO: If/when ntoskrnl gets support for referencing user handles directly, remove this function */
+static void *reference_client_handle(obj_handle_t handle)
+{
+    HANDLE client_process, kernel_handle;
+    OBJECT_ATTRIBUTES attr;
+    void *object = NULL;
+    CLIENT_ID cid;
+
+    attr.Length = sizeof(OBJECT_ATTRIBUTES);
+    attr.RootDirectory = 0;
+    attr.Attributes = OBJ_KERNEL_HANDLE;
+    attr.ObjectName = NULL;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    cid.UniqueProcess = PsGetCurrentProcessId();
+    cid.UniqueThread = 0;
+
+    if (NtOpenProcess(&client_process, PROCESS_ALL_ACCESS, &attr, &cid) != STATUS_SUCCESS)
+        return NULL;
+
+    if (NtDuplicateObject(client_process, wine_server_ptr_handle(handle), NtCurrentProcess(), &kernel_handle,
+                               0, OBJ_KERNEL_HANDLE, DUPLICATE_SAME_ACCESS) != STATUS_SUCCESS)
+    {
+        NtClose(client_process);
+        return NULL;
+    }
+
+    ObReferenceObjectByHandle(kernel_handle, 0, NULL, KernelMode, &object, NULL);
+
+    NtClose(client_process);
+    NtClose(kernel_handle);
+
+    return object;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_CREATE           CTL_CODE(FILE_DEVICE_VIDEO, 0, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+struct shared_resource_create
+{
+    UINT64 resource_size;
+    obj_handle_t unix_handle;
+    WCHAR name[1];
+};
+
+static NTSTATUS shared_resource_create(struct shared_resource **res, void *buff, SIZE_T insize, IO_STATUS_BLOCK *iosb)
+{
+    struct shared_resource_create *input = buff;
+    void *unix_resource;
+    unsigned int i;
+    LPWSTR name;
+
+    if (insize < sizeof(*input))
+        return STATUS_INFO_LENGTH_MISMATCH;
+
+    if (input->name[ ((insize - offsetof(struct shared_resource_create, name)) / sizeof(WCHAR)) - 1 ])
+        return STATUS_INVALID_PARAMETER;
+
+    if (!(unix_resource = reference_client_handle(input->unix_handle)))
+        return STATUS_INVALID_HANDLE;
+
+    if (insize == sizeof(*input))
+        name = NULL;
+    else
+    {
+        name = ExAllocatePoolWithTag(NonPagedPool, insize - offsetof(struct shared_resource_create, name), 0);
+        wcscpy(name, &input->name[0]);
+    }
+
+    for (i = 0; i < resource_pool_size; i++)
+        if (!resource_pool[i].ref_count)
+            break;
+
+    if (i == resource_pool_size)
+    {
+        struct shared_resource *expanded_pool =
+            ExAllocatePoolWithTag(NonPagedPool, sizeof(struct shared_resource) * (resource_pool_size + 1024), 0);
+
+        if (resource_pool)
+        {
+            memcpy(expanded_pool, resource_pool, resource_pool_size * sizeof(struct shared_resource));
+            ExFreePoolWithTag(resource_pool, 0);
+        }
+
+        memset(&expanded_pool[resource_pool_size], 0, 1024 * sizeof (struct shared_resource));
+
+        resource_pool = expanded_pool;
+        resource_pool_size += 1024;
+    }
+
+    *res = &resource_pool[i];
+    (*res)->ref_count = 1;
+    (*res)->unix_resource = unix_resource;
+    (*res)->name = name;
+    (*res)->resource_size = input->resource_size;
+
+    iosb->Information = 0;
+    return STATUS_SUCCESS;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_OPEN             CTL_CODE(FILE_DEVICE_VIDEO, 1, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+struct shared_resource_open
+{
+    obj_handle_t kmt_handle;
+    WCHAR name[1];
+};
+
+struct shared_resource_info
+{
+    UINT64 resource_size;
+};
+
+static unsigned int kmt_to_index(obj_handle_t kmt)
+{
+    if (!(kmt & 0x40000000) || (kmt - 2) % 4)
+        return -1;
+    return (((unsigned int) kmt & ~0x40000000) - 2) / 4;
+}
+
+static NTSTATUS shared_resource_open(struct shared_resource **res, void *buff, SIZE_T insize, IO_STATUS_BLOCK *iosb)
+{
+    struct shared_resource_open *input = buff;
+    unsigned int i;
+
+    if (insize < sizeof(*input))
+        return STATUS_INFO_LENGTH_MISMATCH;
+
+    if (input->kmt_handle)
+    {
+        if (kmt_to_index(input->kmt_handle) >= resource_pool_size)
+            return STATUS_INVALID_HANDLE;
+
+        *res = &resource_pool[kmt_to_index(input->kmt_handle)];
+    }
+    else
+    {
+        if (input->name[ ((insize - offsetof(struct shared_resource_open, name)) / sizeof(WCHAR)) - 1 ])
+            return STATUS_INVALID_PARAMETER;
+
+        /* name lookup */
+        for (i = 0; i < resource_pool_size; i++)
+        {
+            if (resource_pool[i].name && !wcscmp(resource_pool[i].name, input->name))
+            {
+                *res = &resource_pool[i];
+                break;
+            }
+        }
+        if (i == resource_pool_size)
+            return STATUS_OBJECT_NAME_NOT_FOUND;
+    }
+
+    (*res)->ref_count++;
+    iosb->Information = 0;
+    return STATUS_SUCCESS;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_GETKMT           CTL_CODE(FILE_DEVICE_VIDEO, 2, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+static obj_handle_t index_to_kmt(unsigned int idx)
+{
+    return (idx * 4 + 2) | 0x40000000;
+}
+
+static NTSTATUS shared_resource_getkmt(struct shared_resource *res, void *buff, SIZE_T outsize, IO_STATUS_BLOCK *iosb)
+{
+    if (outsize < sizeof(unsigned int))
+        return STATUS_INFO_LENGTH_MISMATCH;
+
+    *((unsigned int *)buff) = index_to_kmt(res - resource_pool);
+
+    iosb->Information = sizeof(unsigned int);
+    return STATUS_SUCCESS;
+}
+
+/* TODO: If/when ntoskrnl gets support for opening user handles directly, remove this function */
+static obj_handle_t open_client_handle(void *object)
+{
+    HANDLE client_process, kernel_handle, handle = NULL;
+    OBJECT_ATTRIBUTES attr;
+    CLIENT_ID cid;
+
+    attr.Length = sizeof(OBJECT_ATTRIBUTES);
+    attr.RootDirectory = 0;
+    attr.Attributes = OBJ_KERNEL_HANDLE;
+    attr.ObjectName = NULL;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    cid.UniqueProcess = PsGetCurrentProcessId();
+    cid.UniqueThread = 0;
+
+    if (NtOpenProcess(&client_process, PROCESS_ALL_ACCESS, &attr, &cid) != STATUS_SUCCESS)
+        return 0;
+
+    if (ObOpenObjectByPointer(object, 0, NULL, GENERIC_ALL, NULL, KernelMode, &kernel_handle) != STATUS_SUCCESS)
+    {
+        NtClose(client_process);
+        return 0;
+    }
+
+    NtDuplicateObject(NtCurrentProcess(), kernel_handle, client_process, &handle,
+                        0, 0, DUPLICATE_SAME_ACCESS);
+
+    NtClose(client_process);
+    NtClose(kernel_handle);
+
+    return wine_server_obj_handle(handle);
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_GET_UNIX_RESOURCE           CTL_CODE(FILE_DEVICE_VIDEO, 3, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+static NTSTATUS shared_resource_get_unix_resource(struct shared_resource *res, void *buff, SIZE_T outsize, IO_STATUS_BLOCK *iosb)
+{
+    if (outsize < sizeof(obj_handle_t))
+        return STATUS_INFO_LENGTH_MISMATCH;
+
+    *((obj_handle_t *)buff) = open_client_handle(res->unix_resource);
+
+    iosb->Information = sizeof(obj_handle_t);
+    return STATUS_SUCCESS;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_SET_METADATA           CTL_CODE(FILE_DEVICE_VIDEO, 4, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+static NTSTATUS shared_resource_set_metadata(struct shared_resource *res, void *buff, SIZE_T insize, IO_STATUS_BLOCK *iosb)
+{
+    res->metadata = ExAllocatePoolWithTag(NonPagedPool, insize, 0);
+    memcpy(res->metadata, buff, insize);
+    res->metadata_size = insize;
+
+    iosb->Information = 0;
+    return STATUS_SUCCESS;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_GET_METADATA           CTL_CODE(FILE_DEVICE_VIDEO, 5, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+static NTSTATUS shared_resource_get_metadata(struct shared_resource *res, void *buff, SIZE_T outsize, IO_STATUS_BLOCK *iosb)
+{
+    if (!res->metadata)
+        return STATUS_NOT_FOUND;
+
+    if (res->metadata_size > outsize)
+        return STATUS_BUFFER_TOO_SMALL;
+
+    memcpy(buff, res->metadata, res->metadata_size);
+    iosb->Information = res->metadata_size;
+    return STATUS_SUCCESS;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_SET_OBJECT           CTL_CODE(FILE_DEVICE_VIDEO, 6, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+struct shared_resource_set_object
+{
+    unsigned int index;
+    obj_handle_t handle;
+};
+
+static NTSTATUS shared_resource_set_object(struct shared_resource *res, void *buff, SIZE_T insize, IO_STATUS_BLOCK *iosb)
+{
+    struct shared_resource_set_object *params = buff;
+    void *object;
+
+    if (insize < sizeof(*params))
+        return STATUS_INFO_LENGTH_MISMATCH;
+
+    if (!(object = reference_client_handle(params->handle)))
+        return STATUS_INVALID_HANDLE;
+
+    if (params->index >= res->object_pool_count)
+    {
+        void **expanded_pool = ExAllocatePoolWithTag(NonPagedPool, (params->index + 1) * sizeof(void *), 0);
+
+        if (res->object_pool)
+        {
+            memcpy(expanded_pool, res->object_pool, res->object_pool_count * sizeof(void *));
+            ExFreePoolWithTag(res->object_pool, 0);
+        }
+
+        memset(&expanded_pool[res->object_pool_count], 0, (params->index + 1 - res->object_pool_count) * sizeof (void *));
+
+        res->object_pool = expanded_pool;
+        res->object_pool_count = params->index + 1;
+    }
+
+    if (res->object_pool[params->index])
+        ObDereferenceObject(res->object_pool[params->index]);
+
+    res->object_pool[params->index] = object;
+
+    iosb->Information = 0;
+    return STATUS_SUCCESS;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_GET_OBJECT           CTL_CODE(FILE_DEVICE_VIDEO, 6, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+static NTSTATUS shared_resource_get_object(struct shared_resource *res, void *buff, SIZE_T insize, SIZE_T outsize, IO_STATUS_BLOCK *iosb)
+{
+    unsigned int index;
+
+    if (insize < sizeof(unsigned int) || outsize < sizeof(obj_handle_t))
+        return STATUS_INFO_LENGTH_MISMATCH;
+
+    index = *(unsigned int *)buff;
+
+    if (index >= res->object_pool_count || !res->object_pool[index])
+        return STATUS_INVALID_PARAMETER;
+
+    *((obj_handle_t *)buff) = open_client_handle(res->object_pool[index]);
+
+    iosb->Information = sizeof(obj_handle_t);
+    return STATUS_SUCCESS;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_GET_INFO CTL_CODE(FILE_DEVICE_VIDEO, 7, METHOD_BUFFERED, FILE_READ_ACCESS)
+static NTSTATUS shared_resource_get_info(struct shared_resource *res, void *buff, SIZE_T outsize, IO_STATUS_BLOCK *iosb)
+{
+    struct shared_resource_info *info = buff;
+
+    if (sizeof(*info) > outsize)
+        return STATUS_BUFFER_TOO_SMALL;
+
+    info->resource_size = res->resource_size;
+    iosb->Information = sizeof(*info);
+    return STATUS_SUCCESS;
+}
+
+
+static NTSTATUS WINAPI dispatch_create(DEVICE_OBJECT *device, IRP *irp)
+{
+    irp->IoStatus.u.Status = STATUS_SUCCESS;
+    IoCompleteRequest(irp, IO_NO_INCREMENT);
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS WINAPI dispatch_close(DEVICE_OBJECT *device, IRP *irp)
+{
+    IO_STACK_LOCATION *stack = IoGetCurrentIrpStackLocation(irp);
+    struct shared_resource *res = &resource_pool[ (UINT_PTR) stack->FileObject->FsContext ];
+
+    TRACE("Freeing shared resouce %p.\n", res);
+
+    if (res)
+    {
+        res->ref_count--;
+        if (!res->ref_count)
+        {
+            if (res->unix_resource)
+            {
+                /* TODO: see if its possible to destroy the object here (unlink?) */
+                ObDereferenceObject(res->unix_resource);
+                res->unix_resource = NULL;
+            }
+            if (res->metadata)
+            {
+                ExFreePoolWithTag(res->metadata, 0);
+                res->metadata = NULL;
+            }
+            if (res->object_pool)
+            {
+                unsigned int i;
+                for (i = 0; i < res->object_pool_count; i++)
+                {
+                    if (res->object_pool[i])
+                        ObDereferenceObject(res->object_pool[i]);
+                }
+                ExFreePoolWithTag(res->object_pool, 0);
+                res->object_pool = NULL;
+                res->object_pool_count = 0;
+            }
+        }
+    }
+
+    irp->IoStatus.u.Status = STATUS_SUCCESS;
+    IoCompleteRequest(irp, IO_NO_INCREMENT);
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS WINAPI dispatch_ioctl(DEVICE_OBJECT *device, IRP *irp)
+{
+    IO_STACK_LOCATION *stack = IoGetCurrentIrpStackLocation( irp );
+    struct shared_resource *res = &resource_pool[ (UINT_PTR) stack->FileObject->FsContext ];
+    NTSTATUS status;
+
+    TRACE( "ioctl %#lx insize %lu outsize %lu\n",
+           stack->Parameters.DeviceIoControl.IoControlCode,
+           stack->Parameters.DeviceIoControl.InputBufferLength,
+           stack->Parameters.DeviceIoControl.OutputBufferLength );
+
+    switch (stack->Parameters.DeviceIoControl.IoControlCode)
+    {
+        case IOCTL_SHARED_GPU_RESOURCE_CREATE:
+            status = shared_resource_create( &res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.InputBufferLength,
+                                      &irp->IoStatus );
+            break;
+        case IOCTL_SHARED_GPU_RESOURCE_OPEN:
+            status = shared_resource_open( &res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.InputBufferLength,
+                                      &irp->IoStatus );
+            break;
+        case IOCTL_SHARED_GPU_RESOURCE_GETKMT:
+            status = shared_resource_getkmt( res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.OutputBufferLength,
+                                      &irp->IoStatus );
+            break;
+        case IOCTL_SHARED_GPU_RESOURCE_GET_UNIX_RESOURCE:
+            status = shared_resource_get_unix_resource( res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.OutputBufferLength,
+                                      &irp->IoStatus );
+            break;
+        case IOCTL_SHARED_GPU_RESOURCE_SET_METADATA:
+            status = shared_resource_set_metadata( res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.InputBufferLength,
+                                      &irp->IoStatus );
+            break;
+        case IOCTL_SHARED_GPU_RESOURCE_GET_METADATA:
+            status = shared_resource_get_metadata( res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.OutputBufferLength,
+                                      &irp->IoStatus );
+            break;
+        case IOCTL_SHARED_GPU_RESOURCE_SET_OBJECT:
+            status = shared_resource_set_object( res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.InputBufferLength,
+                                      &irp->IoStatus );
+            break;
+        case IOCTL_SHARED_GPU_RESOURCE_GET_OBJECT:
+            status = shared_resource_get_object( res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.InputBufferLength,
+                                      stack->Parameters.DeviceIoControl.OutputBufferLength,
+                                      &irp->IoStatus);
+            break;
+        case IOCTL_SHARED_GPU_RESOURCE_GET_INFO:
+            status = shared_resource_get_info( res,
+                                      irp->AssociatedIrp.SystemBuffer,
+                                      stack->Parameters.DeviceIoControl.OutputBufferLength,
+                                      &irp->IoStatus );
+            break;
+    default:
+        FIXME( "ioctl %#lx not supported\n", stack->Parameters.DeviceIoControl.IoControlCode );
+        status = STATUS_NOT_SUPPORTED;
+        break;
+    }
+
+    if (!status)
+        stack->FileObject->FsContext = (void *)(UINT_PTR)(res - resource_pool);
+
+    irp->IoStatus.u.Status = status;
+    IoCompleteRequest( irp, IO_NO_INCREMENT );
+    return status;
+}
+
+NTSTATUS WINAPI DriverEntry( DRIVER_OBJECT *driver, UNICODE_STRING *path )
+{
+    static const WCHAR device_nameW[] = L"\\Device\\SharedGpuResource";
+    static const WCHAR link_nameW[] = L"\\??\\SharedGpuResource";
+    UNICODE_STRING device_name, link_name;
+    DEVICE_OBJECT *device;
+    NTSTATUS status;
+
+    sharedgpures_driver = driver;
+
+    driver->MajorFunction[IRP_MJ_CREATE] = dispatch_create;
+    driver->MajorFunction[IRP_MJ_CLOSE] = dispatch_close;
+    driver->MajorFunction[IRP_MJ_DEVICE_CONTROL] = dispatch_ioctl;
+
+    RtlInitUnicodeString(&device_name, device_nameW);
+    RtlInitUnicodeString(&link_name, link_nameW);
+
+    if ((status = IoCreateDevice(driver, 0, &device_name, 0, 0, FALSE, &device)))
+        return status;
+
+    return IoCreateSymbolicLink(&link_name, &device_name);
+}
diff -ruN --show-c-function vanilla-1017/dlls/vulkan-1/tests/vulkan.c protonvulkan-1017/dlls/vulkan-1/tests/vulkan.c
--- vanilla-1017/dlls/vulkan-1/tests/vulkan.c	2025-10-21 17:44:36.037714896 -0700
+++ protonvulkan-1017/dlls/vulkan-1/tests/vulkan.c	2025-10-21 17:23:40.634924953 -0700
@@ -1154,8 +1154,9 @@ static void import_memory(VkDevice vk_de
         import_handle_info.name = L"wine_test_buffer_export_name";
 
         vr = vkAllocateMemory(vk_device, &alloc_info, NULL, &memory);
-        ok(vr == VK_SUCCESS, "vkAllocateMemory failed, VkResult %d.\n", vr);
-        vkFreeMemory(vk_device, memory, NULL);
+        todo_wine ok(vr == VK_SUCCESS, "vkAllocateMemory failed, VkResult %d.\n", vr);
+        if (vr == VK_SUCCESS)
+            vkFreeMemory(vk_device, memory, NULL);
     }
 }
 
diff -ruN --show-c-function vanilla-1017/dlls/vulkan-1/vulkan-1.spec protonvulkan-1017/dlls/vulkan-1/vulkan-1.spec
--- vanilla-1017/dlls/vulkan-1/vulkan-1.spec	2025-10-21 17:44:44.784970760 -0700
+++ protonvulkan-1017/dlls/vulkan-1/vulkan-1.spec	2025-10-21 17:23:44.107978203 -0700
@@ -276,3 +276,5 @@
 @ stdcall vkUpdateDescriptorSets(ptr long ptr long ptr) winevulkan.vkUpdateDescriptorSets
 @ stdcall vkWaitForFences(ptr long ptr long int64) winevulkan.vkWaitForFences
 @ stdcall vkWaitSemaphores(ptr ptr int64) winevulkan.vkWaitSemaphores
+@ stdcall wine_vkAcquireKeyedMutex(ptr int64 int64 long) winevulkan.wine_vkAcquireKeyedMutex
+@ stdcall wine_vkReleaseKeyedMutex(ptr int64 int64) winevulkan.wine_vkReleaseKeyedMutex
diff -ruN --show-c-function vanilla-1017/dlls/win32u/d3dkmt.c protonvulkan-1017/dlls/win32u/d3dkmt.c
--- vanilla-1017/dlls/win32u/d3dkmt.c	2025-10-21 17:44:36.800791257 -0700
+++ protonvulkan-1017/dlls/win32u/d3dkmt.c	2025-10-21 17:23:40.584190225 -0700
@@ -180,16 +180,13 @@ static NTSTATUS d3dkmt_object_alloc( UIN
 }
 
 /* create a global D3DKMT object, either with a global handle or later shareable */
-static NTSTATUS d3dkmt_object_create( struct d3dkmt_object *object, int fd, BOOL shared, const void *runtime, UINT runtime_size )
+static NTSTATUS d3dkmt_object_create( struct d3dkmt_object *object, BOOL shared, const void *runtime, UINT runtime_size )
 {
     NTSTATUS status;
 
-    if (fd >= 0) wine_server_send_fd( fd );
-
     SERVER_START_REQ( d3dkmt_object_create )
     {
         req->type = object->type;
-        req->fd = fd;
         if (runtime_size) wine_server_add_data( req, runtime, runtime_size );
         status = wine_server_call( req );
         object->handle = wine_server_ptr_handle( reply->handle );
@@ -205,21 +202,23 @@ static NTSTATUS d3dkmt_object_create( st
     return status;
 }
 
-static NTSTATUS d3dkmt_object_update( struct d3dkmt_object *object, const void *runtime, UINT runtime_size )
+static NTSTATUS d3dkmt_object_update( enum d3dkmt_type type, D3DKMT_HANDLE global, HANDLE handle,
+                                      const void *runtime, UINT runtime_size )
 {
     NTSTATUS status;
 
     SERVER_START_REQ( d3dkmt_object_update )
     {
-        req->type = object->type;
-        req->global = object->global;
+        req->type = type;
+        req->global = global;
+        req->handle = wine_server_obj_handle( handle );
         if (runtime_size) wine_server_add_data( req, runtime, runtime_size );
         status = wine_server_call( req );
     }
     SERVER_END_REQ;
 
-    if (status) WARN( "Failed to update object %#x/%p global %#x, status %#x\n", object->local, object, object->global, status );
-    else TRACE( "Updated object %#x/%p global %#x\n", object->local, object, object->global );
+    if (status) WARN( "Failed to update global object %#x/%p, status %#x\n", global, handle, status );
+    else TRACE( "Updated global object %#x/%p\n", global, handle );
     return status;
 }
 
@@ -456,18 +455,19 @@ NTSTATUS WINAPI NtGdiDdDDIOpenAdapterFro
  */
 NTSTATUS WINAPI NtGdiDdDDIEscape( const D3DKMT_ESCAPE *desc )
 {
+    HANDLE shared;
+
     switch (desc->Type)
     {
     case D3DKMT_ESCAPE_UPDATE_RESOURCE_WINE:
-    {
-        struct d3dkmt_resource *resource;
-
         TRACE( "D3DKMT_ESCAPE_UPDATE_RESOURCE_WINE hContext %#x, pPrivateDriverData %p, PrivateDriverDataSize %#x\n",
                desc->hContext, desc->pPrivateDriverData, desc->PrivateDriverDataSize );
 
-        if (!(resource = get_d3dkmt_object( desc->hContext, D3DKMT_RESOURCE ))) return STATUS_INVALID_PARAMETER;
-        return d3dkmt_object_update( &resource->obj, desc->pPrivateDriverData, desc->PrivateDriverDataSize );
-    }
+        if (is_d3dkmt_global( desc->hContext )) shared = NULL;
+        else shared = UlongToHandle( desc->hContext );
+
+        return d3dkmt_object_update( D3DKMT_RESOURCE, shared ? 0 : desc->hContext, shared,
+                                     desc->pPrivateDriverData, desc->PrivateDriverDataSize );
 
     default:
         FIXME( "(%p): stub\n", desc );
@@ -715,7 +715,7 @@ NTSTATUS WINAPI NtGdiDdDDIQueryVideoMemo
                  !(properties2.memoryProperties.memoryHeaps[i].flags & VK_MEMORY_HEAP_DEVICE_LOCAL_BIT)))
             {
                 desc->Budget += budget.heapBudget[i];
-                desc->CurrentUsage += min( budget.heapBudget[i], budget.heapUsage[i] );
+                desc->CurrentUsage += budget.heapUsage[i];
             }
         }
         desc->AvailableForReservation = desc->Budget / 2;
@@ -1053,7 +1053,7 @@ NTSTATUS WINAPI NtGdiDdDDICreateAllocati
         if ((status = d3dkmt_object_alloc( sizeof(*allocation), D3DKMT_ALLOCATION, (void **)&allocation ))) goto failed;
 
         if (!params->Flags.CreateShared) status = alloc_object_handle( &resource->obj );
-        else status = d3dkmt_object_create( &resource->obj, -1, params->Flags.NtSecuritySharing,
+        else status = d3dkmt_object_create( &resource->obj, params->Flags.NtSecuritySharing,
                                             params->pPrivateRuntimeData, params->PrivateRuntimeDataSize );
         if (status) goto failed;
 
@@ -1372,7 +1372,7 @@ NTSTATUS WINAPI NtGdiDdDDICreateKeyedMut
     if (!params) return STATUS_INVALID_PARAMETER;
 
     if ((status = d3dkmt_object_alloc( sizeof(*mutex), D3DKMT_MUTEX, (void **)&mutex ))) return status;
-    if ((status = d3dkmt_object_create( mutex, -1, params->Flags.NtSecuritySharing,
+    if ((status = d3dkmt_object_create( mutex, params->Flags.NtSecuritySharing,
                                         params->pPrivateRuntimeData, params->PrivateRuntimeDataSize )))
         goto failed;
 
@@ -1511,7 +1511,7 @@ NTSTATUS WINAPI NtGdiDdDDICreateSynchron
 
     if ((status = d3dkmt_object_alloc( sizeof(*sync), D3DKMT_SYNC, (void **)&sync ))) return status;
     if (!params->Info.Flags.Shared) status = alloc_object_handle( sync );
-    else status = d3dkmt_object_create( sync, -1, params->Info.Flags.NtSecuritySharing, NULL, 0 );
+    else status = d3dkmt_object_create( sync, params->Info.Flags.NtSecuritySharing, NULL, 0 );
     if (status) goto failed;
 
     if (params->Info.Flags.Shared) params->Info.SharedHandle = sync->shared ? 0 : sync->global;
@@ -1666,141 +1666,4 @@ NTSTATUS WINAPI NtGdiDdDDIDestroySynchro
     d3dkmt_object_free( sync );
 
     return STATUS_SUCCESS;
-}
-
-/* get a locally opened D3DKMT object host-specific fd */
-int d3dkmt_object_get_fd( D3DKMT_HANDLE local )
-{
-    struct d3dkmt_object *object;
-    NTSTATUS status;
-    int fd;
-
-    TRACE( "local %#x\n", local );
-
-    if (!(object = get_d3dkmt_object( local, -1 ))) return -1;
-    if ((status = wine_server_handle_to_fd( object->handle, GENERIC_ALL, &fd, NULL )))
-    {
-        WARN( "Failed to receive object %p/%#x fd, status %#x\n", object, local, status );
-        return -1;
-    }
-
-    return fd;
-}
-
-/* create a D3DKMT global or shared resource from a host-specific fd */
-D3DKMT_HANDLE d3dkmt_create_resource( int fd, D3DKMT_HANDLE *global )
-{
-    struct d3dkmt_resource *resource = NULL;
-    struct d3dkmt_object *allocation = NULL;
-    NTSTATUS status;
-
-    TRACE( "fd %d, global %p\n", fd, global );
-
-    if ((status = d3dkmt_object_alloc( sizeof(*resource), D3DKMT_RESOURCE, (void **)&resource ))) goto failed;
-    if ((status = d3dkmt_object_alloc( sizeof(*allocation), D3DKMT_ALLOCATION, (void **)&allocation ))) goto failed;
-    if ((status = d3dkmt_object_create( &resource->obj, fd, !global, NULL, 0 ))) goto failed;
-
-    if ((status = alloc_object_handle( allocation ))) goto failed;
-    resource->allocation = allocation->local;
-
-    if (global) *global = resource->obj.global;
-    return resource->obj.local;
-
-failed:
-    WARN( "Failed to create resource, status %#x\n", status );
-    if (allocation) d3dkmt_object_free( allocation );
-    if (resource) d3dkmt_object_free( &resource->obj );
-    return 0;
-}
-
-/* open a D3DKMT global or shared resource */
-D3DKMT_HANDLE d3dkmt_open_resource( D3DKMT_HANDLE global, HANDLE shared )
-{
-    struct d3dkmt_object *allocation = NULL;
-    struct d3dkmt_resource *resource = NULL;
-    NTSTATUS status;
-    UINT dummy = 0;
-
-    TRACE( "global %#x, shared %p\n", global, shared );
-
-    if ((status = d3dkmt_object_alloc( sizeof(*resource), D3DKMT_RESOURCE, (void **)&resource ))) goto failed;
-    if ((status = d3dkmt_object_alloc( sizeof(*allocation), D3DKMT_ALLOCATION, (void **)&allocation ))) goto failed;
-    if ((status = d3dkmt_object_open( &resource->obj, global, shared, NULL, &dummy ))) goto failed;
-
-    if ((status = alloc_object_handle( allocation ))) goto failed;
-    resource->allocation = allocation->local;
-
-    return resource->obj.local;
-
-failed:
-    WARN( "Failed to open resource, status %#x\n", status );
-    if (allocation) d3dkmt_object_free( allocation );
-    if (resource) d3dkmt_object_free( &resource->obj );
-    return 0;
-}
-
-/* destroy a locally opened D3DKMT resource */
-NTSTATUS d3dkmt_destroy_resource( D3DKMT_HANDLE local )
-{
-    struct d3dkmt_resource *resource;
-    struct d3dkmt_object *allocation;
-
-    TRACE( "local %#x\n", local );
-
-    if (!(resource = get_d3dkmt_object( local, D3DKMT_RESOURCE ))) return STATUS_INVALID_PARAMETER;
-    if ((allocation = get_d3dkmt_object( resource->allocation, D3DKMT_RESOURCE ))) d3dkmt_object_free( allocation );
-    d3dkmt_object_free( &resource->obj );
-
-    return STATUS_SUCCESS;
-}
-
-/* create a D3DKMT global or shared sync */
-D3DKMT_HANDLE d3dkmt_create_sync( int fd, D3DKMT_HANDLE *global )
-{
-    struct d3dkmt_object *sync = NULL;
-    NTSTATUS status;
-
-    TRACE( "global %p\n", global );
-
-    if ((status = d3dkmt_object_alloc( sizeof(*sync), D3DKMT_SYNC, (void **)&sync ))) goto failed;
-    if ((status = d3dkmt_object_create( sync, fd, !global, NULL, 0 ))) goto failed;
-    if (global) *global = sync->global;
-    return sync->local;
-
-failed:
-    WARN( "Failed to create sync, status %#x\n", status );
-    if (sync) d3dkmt_object_free( sync );
-    return 0;
-}
-
-/* open a D3DKMT global or shared sync */
-D3DKMT_HANDLE d3dkmt_open_sync( D3DKMT_HANDLE global, HANDLE shared )
-{
-    struct d3dkmt_object *sync = NULL;
-    NTSTATUS status;
-    UINT dummy = 0;
-
-    TRACE( "global %#x, shared %p\n", global, shared );
-
-    if ((status = d3dkmt_object_alloc( sizeof(*sync), D3DKMT_SYNC, (void **)&sync ))) goto failed;
-    if ((status = d3dkmt_object_open( sync, global, shared, NULL, &dummy ))) goto failed;
-    return sync->local;
-
-failed:
-    WARN( "Failed to open sync, status %#x\n", status );
-    if (sync) d3dkmt_object_free( sync );
-    return 0;
-}
-
-/* destroy a locally opened D3DKMT sync */
-NTSTATUS d3dkmt_destroy_sync( D3DKMT_HANDLE local )
-{
-    struct d3dkmt_object *sync;
-
-    TRACE( "local %#x\n", local );
-
-    if (!(sync = get_d3dkmt_object( local, D3DKMT_SYNC ))) return STATUS_INVALID_PARAMETER;
-    d3dkmt_object_free( sync );
-
-    return STATUS_SUCCESS;
 }
diff -ruN --show-c-function vanilla-1017/dlls/win32u/tests/d3dkmt.c protonvulkan-1017/dlls/win32u/tests/d3dkmt.c
--- vanilla-1017/dlls/win32u/tests/d3dkmt.c	2025-10-21 17:44:36.802791302 -0700
+++ protonvulkan-1017/dlls/win32u/tests/d3dkmt.c	2025-10-21 17:23:40.584533845 -0700
@@ -455,7 +455,8 @@ static void get_d3dkmt_resource_desc( LU
     D3DKMT_HANDLE resource;
     NTSTATUS status;
 
-    ok_ptr( handle, !=, NULL );
+    todo_wine ok_ptr( handle, !=, NULL );
+    if (!handle) return;
 
     open_adapter.AdapterLuid = luid;
     status = D3DKMTOpenAdapterFromLuid(&open_adapter);
@@ -479,7 +480,7 @@ static void get_d3dkmt_resource_desc( LU
         status = D3DKMTQueryResourceInfo( &query );
         ok_nt( STATUS_SUCCESS, status );
         if (size) ok_u4( query.PrivateRuntimeDataSize, ==, size );
-        else ok( query.PrivateRuntimeDataSize == 0 || query.PrivateRuntimeDataSize == 0x68 /* NVIDIA */, "got %#x\n", query.PrivateRuntimeDataSize );
+        else todo_wine ok( query.PrivateRuntimeDataSize == 0 || query.PrivateRuntimeDataSize == 0x68 /* NVIDIA */, "got %#x\n", query.PrivateRuntimeDataSize );
         ok_u4( query.TotalPrivateDriverDataSize, <, sizeof(driver_data) );
         ok_u4( query.ResourcePrivateDriverDataSize, <, sizeof(driver_data) );
         ok_u4( query.NumAllocations, ==, 1 );
@@ -500,7 +501,7 @@ static void get_d3dkmt_resource_desc( LU
         ok_nt( STATUS_SUCCESS, status );
         check_d3dkmt_local( open.hResource, NULL );
         if (size) ok_u4( open.PrivateRuntimeDataSize, ==, size );
-        else ok( open.PrivateRuntimeDataSize == 0 || open.PrivateRuntimeDataSize == 0x68 /* NVIDIA */, "got %#x\n", open.PrivateRuntimeDataSize );
+        else todo_wine ok( open.PrivateRuntimeDataSize == 0 || open.PrivateRuntimeDataSize == 0x68 /* NVIDIA */, "got %#x\n", open.PrivateRuntimeDataSize );
         ok_u4( open.TotalPrivateDriverDataBufferSize, <, sizeof(driver_data) );
         ok_u4( open.ResourcePrivateDriverDataSize, <, sizeof(driver_data) );
         ok_u4( open.NumAllocations, ==, 1 );
@@ -518,7 +519,7 @@ static void get_d3dkmt_resource_desc( LU
         status = D3DKMTQueryResourceInfoFromNtHandle( &query_nt );
         ok_nt( STATUS_SUCCESS, status );
         if (size) ok_u4( query_nt.PrivateRuntimeDataSize, ==, size );
-        else ok( query_nt.PrivateRuntimeDataSize == 0 || query_nt.PrivateRuntimeDataSize == 0x68 /* NVIDIA */, "got %#x\n", query_nt.PrivateRuntimeDataSize );
+        else todo_wine ok( query_nt.PrivateRuntimeDataSize == 0 || query_nt.PrivateRuntimeDataSize == 0x68 /* NVIDIA */, "got %#x\n", query_nt.PrivateRuntimeDataSize );
         ok_u4( query_nt.TotalPrivateDriverDataSize, <, sizeof(driver_data) );
         ok_u4( query_nt.ResourcePrivateDriverDataSize, <, sizeof(driver_data) );
         ok_u4( query_nt.NumAllocations, ==, 1 );
@@ -539,7 +540,7 @@ static void get_d3dkmt_resource_desc( LU
         ok_nt( STATUS_SUCCESS, status );
         check_d3dkmt_local( open_nt.hResource, NULL );
         if (size) ok_u4( open_nt.PrivateRuntimeDataSize, ==, size );
-        else ok( open_nt.PrivateRuntimeDataSize == 0 || open_nt.PrivateRuntimeDataSize == 0x68 /* NVIDIA */, "got %#x\n", open_nt.PrivateRuntimeDataSize );
+        else todo_wine ok( open_nt.PrivateRuntimeDataSize == 0 || open_nt.PrivateRuntimeDataSize == 0x68 /* NVIDIA */, "got %#x\n", open_nt.PrivateRuntimeDataSize );
         ok_u4( open_nt.TotalPrivateDriverDataBufferSize, <, sizeof(driver_data) );
         ok_u4( open_nt.ResourcePrivateDriverDataSize, <, sizeof(driver_data) );
         ok_u4( open_nt.NumAllocations, ==, 1 );
@@ -1422,6 +1423,7 @@ static void test_D3DKMTQueryVideoMemoryI
         query_memory_info.PhysicalAdapterIndex = 0;
         query_memory_info.MemorySegmentGroup = groups[i];
         status = D3DKMTQueryVideoMemoryInfo( &query_memory_info );
+        todo_wine_if( status == STATUS_INVALID_PARAMETER ) /* fails on Wine without a Vulkan adapter */
         ok( status == STATUS_SUCCESS, "Got unexpected return code %#lx.\n", status );
         ok( query_memory_info.Budget >= query_memory_info.AvailableForReservation,
             "Unexpected budget %I64u and reservation %I64u.\n", query_memory_info.Budget,
@@ -3330,7 +3332,6 @@ static struct vulkan_device *create_vulk
     struct vulkan_device *dev;
     float priority = 0.0f;
     uint32_t count;
-    BOOL is_wow64;
     VkResult vr;
 
     dev = calloc( 1, sizeof(*dev) );
@@ -3362,12 +3363,12 @@ static struct vulkan_device *create_vulk
 
         winetest_push_context( "export" );
         types = get_vulkan_external_image_types( dev->instance, physical_devices[i], VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR );
-        ok( !(~types & expect_export_types), "got types %#x\n", types );
+        todo_wine ok( !(~types & expect_export_types), "got types %#x\n", types );
         winetest_pop_context();
 
         winetest_push_context( "import" );
         types = get_vulkan_external_image_types( dev->instance, physical_devices[i], VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR );
-        ok( !(~types & expect_import_types), "got types %#x\n", types );
+        todo_wine ok( !(~types & expect_import_types), "got types %#x\n", types );
         winetest_pop_context();
     }
 
@@ -3396,18 +3397,15 @@ static struct vulkan_device *create_vulk
 
     p_vkCreateDevice = (void *)p_vkGetInstanceProcAddr( dev->instance, "vkCreateDevice" );
     vr = p_vkCreateDevice( dev->physical_device, &create_info, NULL, &dev->device );
-    /* currently fails on llvmpipe on WOW64 without placed memory */
-    todo_wine_if(IsWow64Process(GetCurrentProcess(), &is_wow64) && is_wow64 && vr == VK_ERROR_EXTENSION_NOT_PRESENT)
-    ok_vk( VK_SUCCESS, vr );
-    if (vr != VK_SUCCESS)
+    todo_wine ok_vk( VK_SUCCESS, vr );
+    todo_wine ok_ptr( dev->device, !=, VK_NULL_HANDLE );
+    if (dev->device == VK_NULL_HANDLE)
     {
-        PFN_vkDestroyInstance p_vkDestroyInstance;
-        p_vkDestroyInstance = (void *)p_vkGetInstanceProcAddr( dev->instance, "vkDestroyInstance" );
+        PFN_vkDestroyInstance p_vkDestroyInstance = (void *)p_vkGetInstanceProcAddr( dev->instance, "vkDestroyInstance" );
         p_vkDestroyInstance( dev->instance, NULL );
         free( dev );
         return NULL;
     }
-    ok_ptr( dev->device, !=, VK_NULL_HANDLE );
 
     return dev;
 }
@@ -4835,18 +4833,17 @@ static void test_shared_resources(void)
         {
             hr = ID3D12Device_OpenSharedHandle( d3d12_imp, handle, &IID_ID3D12Resource, (void **)&import );
             ok_hr( S_OK, hr );
-            ok_ptr( import, !=, NULL );
             if (import) ok_ref( 0, IUnknown_Release( import ) );
 
             if (name)
             {
-                HANDLE other = 0;
+                HANDLE other;
 
                 hr = ID3D12Device_OpenSharedHandleByName( d3d12_imp, name, GENERIC_ALL, &other );
                 ok_hr( S_OK, hr );
                 hr = ID3D12Device_OpenSharedHandle( d3d12_imp, other, &IID_ID3D12Resource, (void **)&import );
                 ok_hr( S_OK, hr );
-                if (other) CloseHandle( other );
+                CloseHandle( other );
 
                 if (import) ok_ref( 0, IUnknown_Release( import ) );
             }
diff -ruN --show-c-function vanilla-1017/dlls/win32u/vulkan.c protonvulkan-1017/dlls/win32u/vulkan.c
--- vanilla-1017/dlls/win32u/vulkan.c	2025-10-21 17:44:36.048434800 -0700
+++ protonvulkan-1017/dlls/win32u/vulkan.c	2025-10-21 17:23:40.640565491 -0700
@@ -26,7 +26,6 @@
 
 #include <dlfcn.h>
 #include <pthread.h>
-#include <unistd.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -47,35 +46,6 @@ WINE_DECLARE_DEBUG_CHANNEL(fps);
 
 static const struct vulkan_driver_funcs *driver_funcs;
 
-static const UINT EXTERNAL_MEMORY_WIN32_BITS = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT |
-                                               VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
-                                               VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT |
-                                               VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT |
-                                               VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT |
-                                               VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT;
-static const UINT EXTERNAL_SEMAPHORE_WIN32_BITS = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT |
-                                                  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
-                                                  VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT;
-static const UINT EXTERNAL_FENCE_WIN32_BITS = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT |
-                                              VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
-
-struct device_memory
-{
-    struct vulkan_device_memory obj;
-    VkDeviceSize size;
-    void *vm_map;
-
-    D3DKMT_HANDLE local;
-    D3DKMT_HANDLE global;
-    HANDLE shared;
-};
-
-static inline struct device_memory *device_memory_from_handle( VkDeviceMemory handle )
-{
-    struct vulkan_device_memory *obj = vulkan_device_memory_from_handle( handle );
-    return CONTAINING_RECORD( obj, struct device_memory, obj );
-}
-
 struct surface
 {
     struct vulkan_surface obj;
@@ -102,760 +72,6 @@ static struct swapchain *swapchain_from_
     return CONTAINING_RECORD( obj, struct swapchain, obj );
 }
 
-struct semaphore
-{
-    struct vulkan_semaphore obj;
-    D3DKMT_HANDLE local;
-    D3DKMT_HANDLE global;
-    HANDLE shared;
-};
-
-static struct semaphore *semaphore_from_handle( VkSemaphore handle )
-{
-    struct vulkan_semaphore *obj = vulkan_semaphore_from_handle( handle );
-    return CONTAINING_RECORD( obj, struct semaphore, obj );
-}
-
-struct fence
-{
-    struct vulkan_fence obj;
-    D3DKMT_HANDLE local;
-    D3DKMT_HANDLE global;
-    HANDLE shared;
-};
-
-static struct fence *fence_from_handle( VkFence handle )
-{
-    struct vulkan_fence *obj = vulkan_fence_from_handle( handle );
-    return CONTAINING_RECORD( obj, struct fence, obj );
-}
-
-static VkResult allocate_external_host_memory( struct vulkan_device *device, VkMemoryAllocateInfo *alloc_info, uint32_t mem_flags,
-                                               VkImportMemoryHostPointerInfoEXT *import_info )
-{
-    struct vulkan_physical_device *physical_device = device->physical_device;
-    VkMemoryHostPointerPropertiesEXT props =
-    {
-        .sType = VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT,
-    };
-    uint32_t i, align = physical_device->external_memory_align - 1;
-    SIZE_T alloc_size = alloc_info->allocationSize;
-    static int once;
-    void *mapping = NULL;
-    VkResult res;
-
-    if (!once++) FIXME( "Using VK_EXT_external_memory_host\n" );
-
-    if (NtAllocateVirtualMemory( GetCurrentProcess(), &mapping, zero_bits, &alloc_size, MEM_COMMIT, PAGE_READWRITE ))
-    {
-        ERR( "NtAllocateVirtualMemory failed\n" );
-        return VK_ERROR_OUT_OF_HOST_MEMORY;
-    }
-
-    if ((res = device->p_vkGetMemoryHostPointerPropertiesEXT( device->host.device, VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT,
-                                                              mapping, &props )))
-    {
-        ERR( "vkGetMemoryHostPointerPropertiesEXT failed: %d\n", res );
-        return res;
-    }
-
-    if (!(props.memoryTypeBits & (1u << alloc_info->memoryTypeIndex)))
-    {
-        /* If requested memory type is not allowed to use external memory, try to find a supported compatible type. */
-        uint32_t mask = mem_flags & ~VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
-        for (i = 0; i < physical_device->memory_properties.memoryTypeCount; i++)
-        {
-            if (!(props.memoryTypeBits & (1u << i))) continue;
-            if ((physical_device->memory_properties.memoryTypes[i].propertyFlags & mask) != mask) continue;
-
-            TRACE( "Memory type not compatible with host memory, using %u instead\n", i );
-            alloc_info->memoryTypeIndex = i;
-            break;
-        }
-        if (i == physical_device->memory_properties.memoryTypeCount)
-        {
-            FIXME( "Not found compatible memory type\n" );
-            alloc_size = 0;
-            NtFreeVirtualMemory( GetCurrentProcess(), &mapping, &alloc_size, MEM_RELEASE );
-        }
-    }
-
-    if (props.memoryTypeBits & (1u << alloc_info->memoryTypeIndex))
-    {
-        import_info->sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT;
-        import_info->handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT;
-        import_info->pHostPointer = mapping;
-        import_info->pNext = alloc_info->pNext;
-        alloc_info->pNext = import_info;
-        alloc_info->allocationSize = (alloc_info->allocationSize + align) & ~align;
-    }
-
-    return VK_SUCCESS;
-}
-
-static VkExternalMemoryHandleTypeFlagBits get_host_external_memory_type(void)
-{
-    const char *host_extension = driver_funcs->p_get_host_extension( "VK_KHR_external_memory_win32" );
-    if (!strcmp( host_extension, "VK_KHR_external_memory_fd" )) return VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
-    if (!strcmp( host_extension, "VK_EXT_external_memory_dma_buf" )) return VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
-    return 0;
-}
-
-static VkExternalSemaphoreHandleTypeFlagBits get_host_external_semaphore_type(void)
-{
-    const char *host_extension = driver_funcs->p_get_host_extension( "VK_KHR_external_semaphore_win32" );
-    if (!strcmp( host_extension, "VK_KHR_external_semaphore_fd" )) return VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
-    if (!strcmp( host_extension, "VK_KHR_external_semaphore_capabilities" )) return VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
-    return 0;
-}
-
-static VkExternalFenceHandleTypeFlagBits get_host_external_fence_type(void)
-{
-    const char *host_extension = driver_funcs->p_get_host_extension( "VK_KHR_external_fence_win32" );
-    if (!strcmp( host_extension, "VK_KHR_external_fence_fd" )) return VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT;
-    if (!strcmp( host_extension, "VK_KHR_external_fence_capabilities" )) return VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT;
-    return 0;
-}
-
-static void init_shared_resource_path( const WCHAR *name, UNICODE_STRING *str )
-{
-    UINT len = wcslen( name );
-    char buffer[MAX_PATH];
-
-    snprintf( buffer, ARRAY_SIZE(buffer), "\\Sessions\\%u\\BaseNamedObjects\\",
-              NtCurrentTeb()->Peb->SessionId );
-    str->MaximumLength = asciiz_to_unicode( str->Buffer, buffer );
-    str->Length = str->MaximumLength - sizeof(WCHAR);
-
-    memcpy( str->Buffer + str->Length / sizeof(WCHAR), name, (len + 1) * sizeof(WCHAR) );
-    str->MaximumLength += len * sizeof(WCHAR);
-    str->Length += len * sizeof(WCHAR);
-}
-
-static HANDLE create_shared_resource_handle( D3DKMT_HANDLE local, const VkExportMemoryWin32HandleInfoKHR *info )
-{
-    SECURITY_DESCRIPTOR *security = info->pAttributes ? info->pAttributes->lpSecurityDescriptor : NULL;
-    WCHAR bufferW[MAX_PATH * 2];
-    UNICODE_STRING name = {.Buffer = bufferW};
-    OBJECT_ATTRIBUTES attr;
-    NTSTATUS status;
-    HANDLE shared;
-
-    if (info->name) init_shared_resource_path( info->name, &name );
-    InitializeObjectAttributes( &attr, info->name ? &name : NULL, OBJ_CASE_INSENSITIVE, NULL, security );
-
-    if (!(status = NtGdiDdDDIShareObjects( 1, &local, &attr, info->dwAccess, &shared ))) return shared;
-    WARN( "Failed to share resource %#x, status %#x\n", local, status );
-    return NULL;
-}
-
-static HANDLE open_shared_resource_from_name( const WCHAR *name )
-{
-    D3DKMT_OPENNTHANDLEFROMNAME open_name = {0};
-    WCHAR bufferW[MAX_PATH * 2];
-    UNICODE_STRING name_str = {.Buffer = bufferW};
-    OBJECT_ATTRIBUTES attr;
-    NTSTATUS status;
-
-    init_shared_resource_path( name, &name_str );
-    InitializeObjectAttributes( &attr, &name_str, OBJ_OPENIF, NULL, NULL );
-
-    open_name.dwDesiredAccess = GENERIC_ALL;
-    open_name.pObjAttrib = &attr;
-    status = NtGdiDdDDIOpenNtHandleFromName( &open_name );
-    if (status) WARN( "Failed to open %s, status %#x\n", debugstr_w( name ), status );
-    return open_name.hNtHandle;
-}
-
-static VkResult win32u_vkAllocateMemory( VkDevice client_device, const VkMemoryAllocateInfo *client_alloc_info,
-                                         const VkAllocationCallbacks *allocator, VkDeviceMemory *ret )
-{
-    VkImportMemoryFdInfoKHR fd_info = {.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR};
-    VkMemoryAllocateInfo *alloc_info = (VkMemoryAllocateInfo *)client_alloc_info; /* cast away const, chain has been copied in the thunks */
-    VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)alloc_info;
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct vulkan_physical_device *physical_device = device->physical_device;
-    struct vulkan_instance *instance = device->physical_device->instance;
-    VkImportMemoryHostPointerInfoEXT host_pointer_info, *pointer_info = NULL;
-    VkExportMemoryWin32HandleInfoKHR export_win32 = {.dwAccess = GENERIC_ALL};
-    VkImportMemoryWin32HandleInfoKHR *import_win32 = NULL;
-    VkExportMemoryAllocateInfo *export_info = NULL;
-    VkDeviceMemory host_device_memory;
-    struct device_memory *memory;
-    BOOL nt_shared = FALSE;
-    uint32_t mem_flags;
-    void *mapping = NULL;
-    VkResult res;
-
-    for (next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
-    {
-        switch ((*next)->sType)
-        {
-        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV: break;
-        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
-            export_info = (VkExportMemoryAllocateInfo *)*next;
-            if (!(export_info->handleTypes & EXTERNAL_MEMORY_WIN32_BITS))
-                FIXME( "Unsupported handle types %#x\n", export_info->handleTypes );
-            else
-            {
-                nt_shared = !(export_info->handleTypes & (VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
-                                                          VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT));
-                export_info->handleTypes = get_host_external_memory_type();
-            }
-            break;
-        case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
-            export_win32 = *(VkExportMemoryWin32HandleInfoKHR *)*next;
-            *next = (*next)->pNext; next = &prev;
-            break;
-        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
-            pointer_info = (VkImportMemoryHostPointerInfoEXT *)*next;
-            break;
-        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
-            import_win32 = (VkImportMemoryWin32HandleInfoKHR *)*next;
-            *next = (*next)->pNext; next = &prev;
-            break;
-        case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO: break;
-        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO: break;
-        case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM: break;
-        case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO: break;
-        case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT: break;
-        default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
-        }
-    }
-
-    /* For host visible memory, we try to use VK_EXT_external_memory_host on wow64 to ensure that mapped pointer is 32-bit. */
-    mem_flags = physical_device->memory_properties.memoryTypes[alloc_info->memoryTypeIndex].propertyFlags;
-    if (physical_device->external_memory_align && (mem_flags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) && !pointer_info &&
-        (res = allocate_external_host_memory( device, alloc_info, mem_flags, &host_pointer_info )))
-        return res;
-
-    if (!(memory = calloc( 1, sizeof(*memory) ))) return VK_ERROR_OUT_OF_HOST_MEMORY;
-
-    if (import_win32)
-    {
-        switch (import_win32->handleType)
-        {
-        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
-        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT:
-            memory->global = PtrToUlong( import_win32->handle );
-            memory->local = d3dkmt_open_resource( memory->global, NULL );
-            break;
-        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
-        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT:
-        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT:
-        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT:
-        {
-            HANDLE shared = import_win32->handle;
-            if (import_win32->name && !(shared = open_shared_resource_from_name( import_win32->name ))) break;
-            memory->local = d3dkmt_open_resource( 0, shared );
-            if (shared && shared != import_win32->handle) NtClose( shared );
-            break;
-        }
-        default:
-            FIXME( "Unsupported handle type %#x\n", import_win32->handleType );
-            break;
-        }
-
-        if ((fd_info.fd = d3dkmt_object_get_fd( memory->local )) < 0)
-        {
-            free( memory );
-            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
-        }
-
-        fd_info.handleType = get_host_external_memory_type();
-        fd_info.pNext = alloc_info->pNext;
-        alloc_info->pNext = &fd_info;
-    }
-
-    if ((res = device->p_vkAllocateMemory( device->host.device, alloc_info, NULL, &host_device_memory )))
-    {
-        if (memory->local) d3dkmt_destroy_resource( memory->local );
-        free( memory );
-        return res;
-    }
-
-    if (export_info)
-    {
-        if (!memory->local)
-        {
-            VkMemoryGetFdInfoKHR get_fd_info = {.sType = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR, .memory = host_device_memory};
-            int fd = -1;
-
-            switch ((get_fd_info.handleType = get_host_external_memory_type()))
-            {
-            case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT:
-            case VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT:
-                if ((res = device->p_vkGetMemoryFdKHR( device->host.device, &get_fd_info, &fd ))) goto failed;
-                break;
-            default:
-                FIXME( "Unsupported handle type %#x\n", get_fd_info.handleType );
-                break;
-            }
-
-            memory->local = d3dkmt_create_resource( fd, nt_shared ? NULL : &memory->global );
-            close( fd );
-
-            if (!memory->local) goto failed;
-        }
-        if (nt_shared && !(memory->shared = create_shared_resource_handle( memory->local, &export_win32 ))) goto failed;
-    }
-
-    vulkan_object_init( &memory->obj.obj, host_device_memory );
-    memory->size = alloc_info->allocationSize;
-    memory->vm_map = mapping;
-    instance->p_insert_object( instance, &memory->obj.obj );
-
-    *ret = memory->obj.client.device_memory;
-    return VK_SUCCESS;
-
-failed:
-    WARN( "Failed to allocate memory, res %d\n", res );
-    device->p_vkFreeMemory( device->host.device, host_device_memory, NULL );
-    if (memory->local) d3dkmt_destroy_resource( memory->local );
-    free( memory );
-    return VK_ERROR_OUT_OF_HOST_MEMORY;
-}
-
-static void win32u_vkFreeMemory( VkDevice client_device, VkDeviceMemory client_memory, const VkAllocationCallbacks *allocator )
-{
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct vulkan_physical_device *physical_device = device->physical_device;
-    struct vulkan_instance *instance = device->physical_device->instance;
-    struct device_memory *memory;
-
-    if (!client_memory) return;
-    memory = device_memory_from_handle( client_memory );
-
-    if (memory->vm_map && !physical_device->external_memory_align)
-    {
-        const VkMemoryUnmapInfoKHR info =
-        {
-            .sType = VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR,
-            .memory = memory->obj.host.device_memory,
-            .flags = VK_MEMORY_UNMAP_RESERVE_BIT_EXT,
-        };
-        device->p_vkUnmapMemory2KHR( device->host.device, &info );
-    }
-
-    device->p_vkFreeMemory( device->host.device, memory->obj.host.device_memory, NULL );
-    instance->p_remove_object( instance, &memory->obj.obj );
-
-    if (memory->vm_map)
-    {
-        SIZE_T alloc_size = 0;
-        NtFreeVirtualMemory( GetCurrentProcess(), &memory->vm_map, &alloc_size, MEM_RELEASE );
-    }
-
-    if (memory->shared) NtClose( memory->shared );
-    if (memory->local) d3dkmt_destroy_resource( memory->local );
-    free( memory );
-}
-
-static VkResult win32u_vkGetMemoryWin32HandleKHR( VkDevice client_device, const VkMemoryGetWin32HandleInfoKHR *handle_info, HANDLE *handle )
-{
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct device_memory *memory = device_memory_from_handle( handle_info->memory );
-
-    TRACE( "device %p, handle_info %p, handle %p\n", device, handle_info, handle );
-
-    switch (handle_info->handleType)
-    {
-    case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
-    case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT:
-        TRACE( "Returning global D3DKMT handle %#x\n", memory->global );
-        *handle = UlongToPtr( memory->global );
-        return VK_SUCCESS;
-
-    case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
-    case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT:
-    case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT:
-    case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT:
-        NtDuplicateObject( NtCurrentProcess(), memory->shared, NtCurrentProcess(), handle, 0, 0, DUPLICATE_SAME_ATTRIBUTES | DUPLICATE_SAME_ACCESS );
-        TRACE( "Returning NT shared handle %p -> %p\n", memory->shared, *handle );
-        return VK_SUCCESS;
-
-    default:
-        FIXME( "Unsupported handle type %#x\n", handle_info->handleType );
-        return VK_ERROR_INCOMPATIBLE_DRIVER;
-    }
-}
-
-static BOOL is_d3dkmt_global( D3DKMT_HANDLE handle )
-{
-    return (handle & 0xc0000000) && (handle & 0x3f) == 2;
-}
-
-static VkResult win32u_vkGetMemoryWin32HandlePropertiesKHR( VkDevice client_device, VkExternalMemoryHandleTypeFlagBits handle_type, HANDLE handle,
-                                                            VkMemoryWin32HandlePropertiesKHR *handle_properties )
-{
-    static const UINT d3dkmt_type_bits = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT | VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT;
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-
-    TRACE( "device %p, handle_type %#x, handle %p, handle_properties %p\n", device, handle_type, handle, handle_properties );
-
-    if (is_d3dkmt_global( HandleToULong( handle ) )) handle_properties->memoryTypeBits = d3dkmt_type_bits;
-    else handle_properties->memoryTypeBits = EXTERNAL_MEMORY_WIN32_BITS & ~d3dkmt_type_bits;
-
-    return VK_SUCCESS;
-}
-
-static VkResult win32u_vkMapMemory2KHR( VkDevice client_device, const VkMemoryMapInfoKHR *map_info, void **data )
-{
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct vulkan_physical_device *physical_device = device->physical_device;
-    struct device_memory *memory = device_memory_from_handle( map_info->memory );
-    VkMemoryMapInfoKHR info = *map_info;
-    VkMemoryMapPlacedInfoEXT placed_info =
-    {
-        .sType = VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT,
-    };
-    VkResult res;
-
-    info.memory = memory->obj.host.device_memory;
-    if (memory->vm_map)
-    {
-        *data = (char *)memory->vm_map + info.offset;
-        TRACE( "returning %p\n", *data );
-        return VK_SUCCESS;
-    }
-
-    if (physical_device->map_placed_align)
-    {
-        SIZE_T alloc_size = memory->size;
-
-        placed_info.pNext = info.pNext;
-        info.pNext = &placed_info;
-        info.offset = 0;
-        info.size = VK_WHOLE_SIZE;
-        info.flags |= VK_MEMORY_MAP_PLACED_BIT_EXT;
-
-        if (NtAllocateVirtualMemory( GetCurrentProcess(), &placed_info.pPlacedAddress, zero_bits,
-                                     &alloc_size, MEM_COMMIT, PAGE_READWRITE ))
-        {
-            ERR( "NtAllocateVirtualMemory failed\n" );
-            return VK_ERROR_OUT_OF_HOST_MEMORY;
-        }
-    }
-
-    if (device->p_vkMapMemory2KHR)
-        res = device->p_vkMapMemory2KHR( device->host.device, &info, data );
-    else
-    {
-        if (info.pNext) FIXME( "struct extension chain not implemented!\n" );
-        res = device->p_vkMapMemory( device->host.device, info.memory, info.offset, info.size, info.flags, data );
-    }
-
-    if (placed_info.pPlacedAddress)
-    {
-        if (res != VK_SUCCESS)
-        {
-            SIZE_T alloc_size = 0;
-            ERR( "vkMapMemory2EXT failed: %d\n", res );
-            NtFreeVirtualMemory( GetCurrentProcess(), &placed_info.pPlacedAddress, &alloc_size, MEM_RELEASE );
-            return res;
-        }
-        memory->vm_map = placed_info.pPlacedAddress;
-        *data = (char *)memory->vm_map + map_info->offset;
-        TRACE( "Using placed mapping %p\n", memory->vm_map );
-    }
-
-#ifdef _WIN64
-    if (NtCurrentTeb()->WowTebOffset && res == VK_SUCCESS && (UINT_PTR)*data >> 32)
-    {
-        FIXME( "returned mapping %p does not fit 32-bit pointer\n", *data );
-        device->p_vkUnmapMemory( device->host.device, memory->obj.host.device_memory );
-        *data = NULL;
-        res = VK_ERROR_OUT_OF_HOST_MEMORY;
-    }
-#endif
-
-    return res;
-}
-
-static VkResult win32u_vkMapMemory( VkDevice client_device, VkDeviceMemory client_memory, VkDeviceSize offset,
-                                    VkDeviceSize size, VkMemoryMapFlags flags, void **data )
-{
-    const VkMemoryMapInfoKHR info =
-    {
-        .sType = VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR,
-        .flags = flags,
-        .memory = client_memory,
-        .offset = offset,
-        .size = size,
-    };
-
-    return win32u_vkMapMemory2KHR( client_device, &info, data );
-}
-
-static VkResult win32u_vkUnmapMemory2KHR( VkDevice client_device, const VkMemoryUnmapInfoKHR *unmap_info )
-{
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct vulkan_physical_device *physical_device = device->physical_device;
-    struct device_memory *memory = device_memory_from_handle( unmap_info->memory );
-    VkMemoryUnmapInfoKHR info;
-    VkResult res;
-
-    if (memory->vm_map && physical_device->external_memory_align) return VK_SUCCESS;
-
-    if (!device->p_vkUnmapMemory2KHR)
-    {
-        if (unmap_info->pNext || memory->vm_map) FIXME( "Not implemented\n" );
-        device->p_vkUnmapMemory( device->host.device, memory->obj.host.device_memory );
-        return VK_SUCCESS;
-    }
-
-    info = *unmap_info;
-    info.memory = memory->obj.host.device_memory;
-    if (memory->vm_map) info.flags |= VK_MEMORY_UNMAP_RESERVE_BIT_EXT;
-
-    res = device->p_vkUnmapMemory2KHR( device->host.device, &info );
-
-    if (res == VK_SUCCESS && memory->vm_map)
-    {
-        SIZE_T size = 0;
-        NtFreeVirtualMemory( GetCurrentProcess(), &memory->vm_map, &size, MEM_RELEASE );
-        memory->vm_map = NULL;
-    }
-    return res;
-}
-
-static void win32u_vkUnmapMemory( VkDevice client_device, VkDeviceMemory client_memory )
-{
-    const VkMemoryUnmapInfoKHR info =
-    {
-        .sType = VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR,
-        .memory = client_memory,
-    };
-
-    win32u_vkUnmapMemory2KHR( client_device, &info );
-}
-
-static VkResult win32u_vkCreateBuffer( VkDevice client_device, const VkBufferCreateInfo *create_info,
-                                       const VkAllocationCallbacks *allocator, VkBuffer *buffer )
-{
-    VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)create_info; /* cast away const, chain has been copied in the thunks */
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct vulkan_physical_device *physical_device = device->physical_device;
-    VkExternalMemoryBufferCreateInfo host_external_info, *external_info = NULL;
-
-    for (next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
-    {
-        switch ((*next)->sType)
-        {
-        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT: break;
-        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO: break;
-        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO: break;
-        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: break;
-        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
-            external_info = (VkExternalMemoryBufferCreateInfo *)*next;
-            if (!(external_info->handleTypes & EXTERNAL_MEMORY_WIN32_BITS))
-                FIXME( "Unsupported handle types %#x\n", external_info->handleTypes );
-            else
-                external_info->handleTypes = get_host_external_memory_type();
-            break;
-        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT: break;
-        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR: break;
-        default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
-        }
-    }
-
-    if (physical_device->external_memory_align && !external_info)
-    {
-        host_external_info.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
-        host_external_info.pNext = create_info->pNext;
-        host_external_info.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT;
-        ((VkBufferCreateInfo *)create_info)->pNext = &host_external_info; /* cast away const, it has been copied in the thunks */
-    }
-
-    return device->p_vkCreateBuffer( device->host.device, create_info, NULL, buffer );
-}
-
-static void win32u_vkGetDeviceBufferMemoryRequirements( VkDevice client_device, const VkDeviceBufferMemoryRequirements *buffer_requirements,
-                                                        VkMemoryRequirements2 *memory_requirements )
-{
-    VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)buffer_requirements->pCreateInfo; /* cast away const, chain has been copied in the thunks */
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    VkExternalMemoryBufferCreateInfo *external_info;
-
-    TRACE( "device %p, buffer_requirements %p, memory_requirements %p\n", device, buffer_requirements, memory_requirements );
-
-    for (next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
-    {
-        switch ((*next)->sType)
-        {
-        case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT: break;
-        case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO: break;
-        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO: break;
-        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV: break;
-        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
-            external_info = (VkExternalMemoryBufferCreateInfo *)*next;
-            if (!(external_info->handleTypes & EXTERNAL_MEMORY_WIN32_BITS))
-                FIXME( "Unsupported handle types %#x\n", external_info->handleTypes );
-            else
-                external_info->handleTypes = get_host_external_memory_type();
-            break;
-        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT: break;
-        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR: break;
-        default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
-        }
-    }
-
-    device->p_vkGetDeviceBufferMemoryRequirements( device->host.device, buffer_requirements, memory_requirements );
-}
-
-static void win32u_vkGetPhysicalDeviceExternalBufferProperties( VkPhysicalDevice client_physical_device, const VkPhysicalDeviceExternalBufferInfo *client_buffer_info,
-                                                                VkExternalBufferProperties *buffer_properties )
-{
-    VkPhysicalDeviceExternalBufferInfo *buffer_info = (VkPhysicalDeviceExternalBufferInfo *)client_buffer_info; /* cast away const, it has been copied in the thunks */
-    struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle( client_physical_device );
-    struct vulkan_instance *instance = physical_device->instance;
-    VkExternalMemoryHandleTypeFlagBits handle_type = 0;
-
-    TRACE( "physical_device %p, buffer_info %p, buffer_properties %p\n", physical_device, buffer_info, buffer_properties );
-
-    handle_type = buffer_info->handleType;
-    if (handle_type & EXTERNAL_MEMORY_WIN32_BITS) buffer_info->handleType = get_host_external_memory_type();
-
-    instance->p_vkGetPhysicalDeviceExternalBufferProperties( physical_device->host.physical_device, buffer_info, buffer_properties );
-    buffer_properties->externalMemoryProperties.compatibleHandleTypes = handle_type;
-    buffer_properties->externalMemoryProperties.exportFromImportedHandleTypes = handle_type;
-}
-
-static VkResult win32u_vkCreateImage( VkDevice client_device, const VkImageCreateInfo *create_info,
-                                      const VkAllocationCallbacks *allocator, VkImage *image )
-{
-    VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)create_info; /* cast away const, chain has been copied in the thunks */
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct vulkan_physical_device *physical_device = device->physical_device;
-    VkExternalMemoryImageCreateInfo host_external_info, *external_info = NULL;
-
-    for (next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
-    {
-        switch ((*next)->sType)
-        {
-        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: break;
-        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
-            external_info = (VkExternalMemoryImageCreateInfo *)*next;
-            if (!(external_info->handleTypes & EXTERNAL_MEMORY_WIN32_BITS))
-                FIXME( "Unsupported handle types %#x\n", external_info->handleTypes );
-            else
-                external_info->handleTypes = get_host_external_memory_type();
-            break;
-        case VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA: break;
-        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT: break;
-        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO: break;
-        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO: break;
-        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR: break;
-        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT: break;
-        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV: break;
-        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR: break;
-        default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
-        }
-    }
-
-    if (physical_device->external_memory_align && !external_info)
-    {
-        host_external_info.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
-        host_external_info.pNext = create_info->pNext;
-        host_external_info.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT;
-        ((VkImageCreateInfo *)create_info)->pNext = &host_external_info; /* cast away const, it has been copied in the thunks */
-    }
-
-    return device->p_vkCreateImage( device->host.device, create_info, NULL, image );
-}
-
-static void win32u_vkGetDeviceImageMemoryRequirements( VkDevice client_device, const VkDeviceImageMemoryRequirements *image_requirements,
-                                                       VkMemoryRequirements2 *memory_requirements )
-{
-    VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)image_requirements->pCreateInfo; /* cast away const, chain has been copied in the thunks */
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    VkExternalMemoryImageCreateInfo *external_info;
-
-    TRACE( "device %p, image_requirements %p, memory_requirements %p\n", device, image_requirements, memory_requirements );
-
-    for (next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
-    {
-        switch ((*next)->sType)
-        {
-        case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV: break;
-        case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
-            external_info = (VkExternalMemoryImageCreateInfo *)*next;
-            if (!(external_info->handleTypes & EXTERNAL_MEMORY_WIN32_BITS))
-                FIXME( "Unsupported handle types %#x\n", external_info->handleTypes );
-            else
-                external_info->handleTypes = get_host_external_memory_type();
-            break;
-        case VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA: break;
-        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT: break;
-        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO: break;
-        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO: break;
-        case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR: break;
-        case VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT: break;
-        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV: break;
-        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR: break;
-        default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
-        }
-    }
-
-    device->p_vkGetDeviceImageMemoryRequirements( device->host.device, image_requirements, memory_requirements );
-}
-
-static VkResult win32u_vkGetPhysicalDeviceImageFormatProperties2( VkPhysicalDevice client_physical_device, const VkPhysicalDeviceImageFormatInfo2 *format_info,
-                                                                  VkImageFormatProperties2 *format_properties )
-{
-    VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)format_info; /* cast away const, chain has been copied in the thunks */
-    struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle( client_physical_device );
-    struct vulkan_instance *instance = physical_device->instance;
-    VkExternalMemoryHandleTypeFlagBits handle_type = 0;
-    VkResult res;
-
-    TRACE( "physical_device %p, format_info %p, format_properties %p\n", physical_device, format_info, format_properties );
-
-    for (next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
-    {
-        switch ((*next)->sType)
-        {
-        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT: break;
-        case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO: break;
-        case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO: break;
-        case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV: break;
-        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
-        {
-            VkPhysicalDeviceExternalImageFormatInfo *external_info = (VkPhysicalDeviceExternalImageFormatInfo *)*next;
-            handle_type = external_info->handleType;
-            if (handle_type & EXTERNAL_MEMORY_WIN32_BITS) external_info->handleType = get_host_external_memory_type();
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT: break;
-        case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR: break;
-        default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
-        }
-    }
-
-    res = instance->p_vkGetPhysicalDeviceImageFormatProperties2( physical_device->host.physical_device, format_info, format_properties );
-    for (prev = (VkBaseOutStructure *)format_properties, next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
-    {
-        switch ((*next)->sType)
-        {
-        case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
-        {
-            VkExternalImageFormatProperties *props = (VkExternalImageFormatProperties *)*next;
-            props->externalMemoryProperties.compatibleHandleTypes = handle_type;
-            props->externalMemoryProperties.exportFromImportedHandleTypes = handle_type;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT: break;
-        case VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY: break;
-        case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT: break;
-        case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES: break;
-        case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD: break;
-        default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
-        }
-    }
-
-    return res;
-}
-
 static VkResult win32u_vkCreateWin32SurfaceKHR( VkInstance client_instance, const VkWin32SurfaceCreateInfoKHR *create_info,
                                                 const VkAllocationCallbacks *allocator, VkSurfaceKHR *ret )
 {
@@ -1158,7 +374,7 @@ static VkResult win32u_vkCreateSwapchain
      */
     if (NtUserGetClientRect( surface->hwnd, &client_rect, NtUserGetWinMonitorDpi( surface->hwnd, MDT_RAW_DPI ) ) &&
         !extents_equals( &create_info_host.imageExtent, &client_rect ) &&
-        physical_device->has_surface_maintenance1 && physical_device->has_swapchain_maintenance1)
+        physical_device->has_swapchain_maintenance1)
     {
         scaling.scalingBehavior = VK_PRESENT_SCALING_STRETCH_BIT_EXT;
         create_info_host.pNext = &scaling;
@@ -1200,8 +416,7 @@ void win32u_vkDestroySwapchainKHR( VkDev
 static VkResult win32u_vkAcquireNextImage2KHR( VkDevice client_device, const VkAcquireNextImageInfoKHR *acquire_info,
                                                uint32_t *image_index )
 {
-    struct vulkan_semaphore *semaphore = acquire_info->semaphore ? vulkan_semaphore_from_handle( acquire_info->semaphore ) : NULL;
-    struct vulkan_fence *fence = acquire_info->fence ? vulkan_fence_from_handle( acquire_info->fence ) : NULL;
+    struct vulkan_semaphore *semaphore = vulkan_semaphore_from_handle( acquire_info->semaphore );
     struct swapchain *swapchain = swapchain_from_handle( acquire_info->swapchain );
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
     VkAcquireNextImageInfoKHR acquire_info_host = *acquire_info;
@@ -1211,7 +426,7 @@ static VkResult win32u_vkAcquireNextImag
 
     acquire_info_host.swapchain = swapchain->obj.host.swapchain;
     acquire_info_host.semaphore = semaphore ? semaphore->host.semaphore : 0;
-    acquire_info_host.fence = fence ? fence->host.fence : 0;
+
     res = device->p_vkAcquireNextImage2KHR( device->host.device, &acquire_info_host, image_index );
 
     if (!res && NtUserGetClientRect( surface->hwnd, &client_rect, NtUserGetDpiForWindow( surface->hwnd ) ) &&
@@ -1226,19 +441,17 @@ static VkResult win32u_vkAcquireNextImag
 }
 
 static VkResult win32u_vkAcquireNextImageKHR( VkDevice client_device, VkSwapchainKHR client_swapchain, uint64_t timeout,
-                                              VkSemaphore client_semaphore, VkFence client_fence, uint32_t *image_index )
+                                              VkSemaphore client_semaphore, VkFence fence, uint32_t *image_index )
 {
-    struct vulkan_semaphore *semaphore = client_semaphore ? vulkan_semaphore_from_handle( client_semaphore ) : NULL;
-    struct vulkan_fence *fence = client_fence ? vulkan_fence_from_handle( client_fence ) : NULL;
     struct swapchain *swapchain = swapchain_from_handle( client_swapchain );
     struct vulkan_device *device = vulkan_device_from_handle( client_device );
     struct surface *surface = swapchain->surface;
+    struct vulkan_semaphore *semaphore = vulkan_semaphore_from_handle( client_semaphore );
     RECT client_rect;
     VkResult res;
 
     res = device->p_vkAcquireNextImageKHR( device->host.device, swapchain->obj.host.swapchain, timeout,
-                                              semaphore ? semaphore->host.semaphore : 0, fence ? fence->host.fence : 0,
-                                              image_index );
+                                           semaphore ? semaphore->host.semaphore : 0, fence, image_index );
 
     if (!res && NtUserGetClientRect( surface->hwnd, &client_rect, NtUserGetDpiForWindow( surface->hwnd ) ) &&
         !extents_equals( &swapchain->extents, &client_rect ))
@@ -1251,42 +464,57 @@ static VkResult win32u_vkAcquireNextImag
     return res;
 }
 
-static VkResult win32u_vkQueuePresentKHR( VkQueue client_queue, const VkPresentInfoKHR *client_present_info )
+static VkResult win32u_vkQueuePresentKHR( VkQueue client_queue, const VkPresentInfoKHR *present_info )
 {
-    VkPresentInfoKHR *present_info = (VkPresentInfoKHR *)client_present_info; /* cast away const, it has been copied in the thunks */
     struct vulkan_queue *queue = vulkan_queue_from_handle( client_queue );
     VkSwapchainKHR swapchains_buffer[16], *swapchains = swapchains_buffer;
+    VkPresentInfoKHR present_info_host = *present_info;
     struct vulkan_device *device = queue->device;
-    const VkSwapchainKHR *client_swapchains;
+    struct vulkan_semaphore *semaphore;
+    VkSemaphore *semaphores = NULL;
     VkResult res;
+    UINT i;
 
     TRACE( "queue %p, present_info %p\n", queue, present_info );
 
+    if (present_info->waitSemaphoreCount)
+    {
+        semaphores = malloc( present_info->waitSemaphoreCount * sizeof(*semaphores) );
+        for (i = 0; i < present_info->waitSemaphoreCount; ++i)
+        {
+            semaphore = vulkan_semaphore_from_handle(present_info->pWaitSemaphores[i]);
+
+            if (semaphore->d3d12_fence)
+            {
+                FIXME("Waiting on D3D12-Fence compatible timeline semaphore not supported.\n");
+                free( semaphores );
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            }
+            semaphores[i] = semaphore->host.semaphore;
+        }
+        present_info_host.pWaitSemaphores = semaphores;
+    }
+
     if (present_info->swapchainCount > ARRAY_SIZE(swapchains_buffer) &&
         !(swapchains = malloc( present_info->swapchainCount * sizeof(*swapchains) )))
-        return VK_ERROR_OUT_OF_HOST_MEMORY;
-
-    for (uint32_t i = 0; i < present_info->waitSemaphoreCount; i++)
     {
-        VkSemaphore *semaphores = (VkSemaphore *)present_info->pWaitSemaphores; /* cast away const, it has been copied in the thunks */
-        struct vulkan_semaphore *semaphore = vulkan_semaphore_from_handle( semaphores[i] );
-        semaphores[i] = semaphore->host.semaphore;
+        free( semaphores );
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
     }
 
-    for (uint32_t i = 0; i < present_info->swapchainCount; i++)
+    for (i = 0; i < present_info->swapchainCount; i++)
     {
         struct swapchain *swapchain = swapchain_from_handle( present_info->pSwapchains[i] );
         swapchains[i] = swapchain->obj.host.swapchain;
     }
 
-    client_swapchains = present_info->pSwapchains;
-    present_info->pSwapchains = swapchains;
+    present_info_host.pSwapchains = swapchains;
 
-    res = device->p_vkQueuePresentKHR( queue->host.queue, present_info );
+    res = device->p_vkQueuePresentKHR( queue->host.queue, &present_info_host );
 
-    for (uint32_t i = 0; i < present_info->swapchainCount; i++)
+    for (i = 0; i < present_info->swapchainCount; i++)
     {
-        struct swapchain *swapchain = swapchain_from_handle( client_swapchains[i] );
+        struct swapchain *swapchain = swapchain_from_handle( present_info->pSwapchains[i] );
         VkResult swapchain_res = present_info->pResults ? present_info->pResults[i] : res;
         struct surface *surface = swapchain->surface;
         RECT client_rect;
@@ -1312,6 +540,7 @@ static VkResult win32u_vkQueuePresentKHR
     }
 
     if (swapchains != swapchains_buffer) free( swapchains );
+    free( semaphores );
 
     if (TRACE_ON( fps ))
     {
@@ -1337,626 +566,29 @@ static VkResult win32u_vkQueuePresentKHR
     return res;
 }
 
-static VkResult win32u_vkQueueSubmit( VkQueue client_queue, uint32_t count, const VkSubmitInfo *submits, VkFence client_fence )
-{
-    struct vulkan_fence *fence = client_fence ? vulkan_fence_from_handle( client_fence ) : NULL;
-    struct vulkan_queue *queue = vulkan_queue_from_handle( client_queue );
-    struct vulkan_device *device = queue->device;
-
-    TRACE( "queue %p, count %u, submits %p, fence %p\n", queue, count, submits, fence );
-
-    for (uint32_t i = 0; i < count; i++)
-    {
-        VkSubmitInfo *submit = (VkSubmitInfo *)submits + i; /* cast away const, chain has been copied in the thunks */
-        VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)submit;
-
-        for (uint32_t j = 0; j < submit->commandBufferCount; j++)
-        {
-            VkCommandBuffer *command_buffers = (VkCommandBuffer *)submit->pCommandBuffers; /* cast away const, chain has been copied in the thunks */
-            struct vulkan_command_buffer *command_buffer = vulkan_command_buffer_from_handle( command_buffers[j] );
-            command_buffers[j] = command_buffer->host.command_buffer;
-        }
-
-        for (uint32_t j = 0; j < submit->waitSemaphoreCount; j++)
-        {
-            VkSemaphore *semaphores = (VkSemaphore *)submit->pWaitSemaphores; /* cast away const, it has been copied in the thunks */
-            struct vulkan_semaphore *semaphore = vulkan_semaphore_from_handle( semaphores[j] );
-            semaphores[j] = semaphore->host.semaphore;
-        }
-
-        for (uint32_t j = 0; j < submit->signalSemaphoreCount; j++)
-        {
-            VkSemaphore *semaphores = (VkSemaphore *)submit->pSignalSemaphores; /* cast away const, it has been copied in the thunks */
-            struct vulkan_semaphore *semaphore = vulkan_semaphore_from_handle( semaphores[j] );
-            semaphores[j] = semaphore->host.semaphore;
-        }
-
-        for (next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
-        {
-            switch ((*next)->sType)
-            {
-            case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
-                FIXME( "VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR not implemented!\n" );
-                *next = (*next)->pNext; next = &prev;
-                break;
-            case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO: break;
-            case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT: break;
-            case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM: break;
-            case VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV: break;
-            case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR: break;
-            case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO: break;
-            case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO: break;
-            case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
-                FIXME( "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR not implemented!\n" );
-                *next = (*next)->pNext; next = &prev;
-                break;
-            default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
-            }
-        }
-    }
-
-    return device->p_vkQueueSubmit( queue->host.queue, count, submits, fence ? fence->host.fence : 0 );
-}
-
-static VkResult win32u_vkQueueSubmit2( VkQueue client_queue, uint32_t count, const VkSubmitInfo2 *submits, VkFence client_fence )
-{
-    struct vulkan_fence *fence = client_fence ? vulkan_fence_from_handle( client_fence ) : NULL;
-    struct vulkan_queue *queue = vulkan_queue_from_handle( client_queue );
-    struct vulkan_device *device = queue->device;
-
-    TRACE( "queue %p, count %u, submits %p, fence %p\n", queue, count, submits, fence );
-
-    for (uint32_t i = 0; i < count; i++)
-    {
-        VkSubmitInfo2 *submit = (VkSubmitInfo2 *)submits + i; /* cast away const, chain has been copied in the thunks */
-        VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)submit;
-
-        for (uint32_t j = 0; j < submit->commandBufferInfoCount; j++)
-        {
-            VkCommandBufferSubmitInfoKHR *command_buffer_infos = (VkCommandBufferSubmitInfoKHR *)submit->pCommandBufferInfos; /* cast away const, chain has been copied in the thunks */
-            struct vulkan_command_buffer *command_buffer = vulkan_command_buffer_from_handle( command_buffer_infos[j].commandBuffer );
-            command_buffer_infos[j].commandBuffer = command_buffer->host.command_buffer;
-            if (command_buffer_infos->pNext) FIXME( "Unhandled struct chain\n" );
-        }
-
-        for (uint32_t j = 0; j < submit->waitSemaphoreInfoCount; j++)
-        {
-            VkSemaphoreSubmitInfo *semaphore_infos = (VkSemaphoreSubmitInfo *)submit->pWaitSemaphoreInfos; /* cast away const, it has been copied in the thunks */
-            struct vulkan_semaphore *semaphore = vulkan_semaphore_from_handle( semaphore_infos[j].semaphore );
-            semaphore_infos[j].semaphore = semaphore->host.semaphore;
-            if (semaphore_infos->pNext) FIXME( "Unhandled struct chain\n" );
-        }
-
-        for (uint32_t j = 0; j < submit->signalSemaphoreInfoCount; j++)
-        {
-            VkSemaphoreSubmitInfo *semaphore_infos = (VkSemaphoreSubmitInfo *)submit->pSignalSemaphoreInfos; /* cast away const, it has been copied in the thunks */
-            struct vulkan_semaphore *semaphore = vulkan_semaphore_from_handle( semaphore_infos[j].semaphore );
-            semaphore_infos[j].semaphore = semaphore->host.semaphore;
-            if (semaphore_infos->pNext) FIXME( "Unhandled struct chain\n" );
-        }
-
-        for (next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
-        {
-            switch ((*next)->sType)
-            {
-            case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT: break;
-            case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM: break;
-            case VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV: break;
-            case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR: break;
-            case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
-                FIXME( "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR not implemented!\n" );
-                *next = (*next)->pNext; next = &prev;
-                break;
-            default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
-            }
-        }
-    }
-
-    return device->p_vkQueueSubmit2( queue->host.queue, count, submits, fence ? fence->host.fence : 0 );
-}
-
-static HANDLE create_shared_semaphore_handle( D3DKMT_HANDLE local, const VkExportSemaphoreWin32HandleInfoKHR *info )
-{
-    SECURITY_DESCRIPTOR *security = info->pAttributes ? info->pAttributes->lpSecurityDescriptor : NULL;
-    WCHAR bufferW[MAX_PATH * 2];
-    UNICODE_STRING name = {.Buffer = bufferW};
-    OBJECT_ATTRIBUTES attr;
-    NTSTATUS status;
-    HANDLE shared;
-
-    if (info->name) init_shared_resource_path( info->name, &name );
-    InitializeObjectAttributes( &attr, info->name ? &name : NULL, OBJ_CASE_INSENSITIVE, NULL, security );
-
-    if (!(status = NtGdiDdDDIShareObjects( 1, &local, &attr, info->dwAccess, &shared ))) return shared;
-    WARN( "Failed to share resource %#x, status %#x\n", local, status );
-    return NULL;
-}
-
-static HANDLE open_shared_semaphore_from_name( const WCHAR *name )
-{
-    D3DKMT_OPENSYNCOBJECTNTHANDLEFROMNAME open_name = {0};
-    WCHAR bufferW[MAX_PATH * 2];
-    UNICODE_STRING name_str = {.Buffer = bufferW};
-    OBJECT_ATTRIBUTES attr;
-    NTSTATUS status;
-
-    init_shared_resource_path( name, &name_str );
-    InitializeObjectAttributes( &attr, &name_str, OBJ_OPENIF, NULL, NULL );
-
-    open_name.dwDesiredAccess = GENERIC_ALL;
-    open_name.pObjAttrib = &attr;
-    status = NtGdiDdDDIOpenSyncObjectNtHandleFromName( &open_name );
-    if (status) WARN( "Failed to open %s, status %#x\n", debugstr_w( name ), status );
-    return open_name.hNtHandle;
-}
-
-static VkResult win32u_vkCreateSemaphore( VkDevice client_device, const VkSemaphoreCreateInfo *client_create_info,
-                                          const VkAllocationCallbacks *allocator, VkSemaphore *ret )
-{
-    VkSemaphoreCreateInfo *create_info = (VkSemaphoreCreateInfo *)client_create_info; /* cast away const, chain has been copied in the thunks */
-    VkExportSemaphoreWin32HandleInfoKHR export_win32 = {.dwAccess = GENERIC_ALL};
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)create_info;
-    struct vulkan_instance *instance = device->physical_device->instance;
-    VkExportSemaphoreCreateInfoKHR *export_info = NULL;
-    struct semaphore *semaphore;
-    VkSemaphore host_semaphore;
-    BOOL nt_shared = FALSE;
-    VkResult res;
-
-    TRACE( "device %p, create_info %p, allocator %p, ret %p\n", device, create_info, allocator, ret );
-
-    for (next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
-    {
-        switch ((*next)->sType)
-        {
-        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
-            export_info = (VkExportSemaphoreCreateInfoKHR *)*next;
-            if (!(export_info->handleTypes & EXTERNAL_SEMAPHORE_WIN32_BITS))
-                FIXME( "Unsupported handle types %#x\n", export_info->handleTypes );
-            else
-            {
-                nt_shared = !(export_info->handleTypes & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT);
-                export_info->handleTypes = get_host_external_semaphore_type();
-            }
-            *next = (*next)->pNext; next = &prev;
-            break;
-        case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
-            export_win32 = *(VkExportSemaphoreWin32HandleInfoKHR *)*next;
-            *next = (*next)->pNext; next = &prev;
-            break;
-        case VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV: break;
-        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO: break;
-        default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
-        }
-    }
-
-    if (!(semaphore = calloc( 1, sizeof(*semaphore) ))) return VK_ERROR_OUT_OF_HOST_MEMORY;
-
-    if ((res = device->p_vkCreateSemaphore( device->host.device, create_info, NULL /* allocator */, &host_semaphore )))
-    {
-        free( semaphore );
-        return res;
-    }
-
-    if (export_info)
-    {
-        VkSemaphoreGetFdInfoKHR fd_info = {.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR, .semaphore = host_semaphore};
-        int fd = -1;
-
-        switch ((fd_info.handleType = get_host_external_semaphore_type()))
-        {
-        case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT:
-            if ((res = device->p_vkGetSemaphoreFdKHR( device->host.device, &fd_info, &fd ))) goto failed;
-            break;
-        default:
-            FIXME( "Unsupported handle type %#x\n", fd_info.handleType );
-            break;
-        }
-
-        if (!(semaphore->local = d3dkmt_create_sync( fd, nt_shared ? NULL : &semaphore->global ))) goto failed;
-        if (nt_shared && !(semaphore->shared = create_shared_semaphore_handle( semaphore->local, &export_win32 ))) goto failed;
-    }
-
-    vulkan_object_init( &semaphore->obj.obj, host_semaphore );
-    instance->p_insert_object( instance, &semaphore->obj.obj );
-
-    *ret = semaphore->obj.client.semaphore;
-    return res;
-
-failed:
-    WARN( "Failed to create semaphore, res %d\n", res );
-    device->p_vkDestroySemaphore( device->host.device, host_semaphore, NULL );
-    if (semaphore->local) d3dkmt_destroy_sync( semaphore->local );
-    free( semaphore );
-    return VK_ERROR_OUT_OF_HOST_MEMORY;
-}
-
-static void win32u_vkDestroySemaphore( VkDevice client_device, VkSemaphore client_semaphore, const VkAllocationCallbacks *allocator )
-{
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct semaphore *semaphore = semaphore_from_handle( client_semaphore );
-    struct vulkan_instance *instance = device->physical_device->instance;
-
-    TRACE( "device %p, semaphore %p, allocator %p\n", device, semaphore, allocator );
-
-    if (!client_semaphore) return;
-
-    device->p_vkDestroySemaphore( device->host.device, semaphore->obj.host.semaphore, NULL /* allocator */ );
-    instance->p_remove_object( instance, &semaphore->obj.obj );
-
-    if (semaphore->shared) NtClose( semaphore->shared );
-    if (semaphore->local) d3dkmt_destroy_sync( semaphore->local );
-    free( semaphore );
-}
-
-static VkResult win32u_vkGetSemaphoreWin32HandleKHR( VkDevice client_device, const VkSemaphoreGetWin32HandleInfoKHR *handle_info, HANDLE *handle )
-{
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct semaphore *semaphore = semaphore_from_handle( handle_info->semaphore );
-
-    TRACE( "device %p, handle_info %p, handle %p\n", device, handle_info, handle );
-
-    switch (handle_info->handleType)
-    {
-    case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
-        TRACE( "Returning global D3DKMT handle %#x\n", semaphore->global );
-        *handle = UlongToPtr( semaphore->global );
-        return VK_SUCCESS;
-
-    case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT:
-    case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT:
-        NtDuplicateObject( NtCurrentProcess(), semaphore->shared, NtCurrentProcess(), handle, 0, 0, DUPLICATE_SAME_ATTRIBUTES | DUPLICATE_SAME_ACCESS );
-        TRACE( "Returning NT shared handle %p -> %p\n", semaphore->shared, *handle );
-        return VK_SUCCESS;
-
-    default:
-        FIXME( "Unsupported handle type %#x\n", handle_info->handleType );
-        return VK_ERROR_INCOMPATIBLE_DRIVER;
-    }
-}
-
-static VkResult win32u_vkImportSemaphoreWin32HandleKHR( VkDevice client_device, const VkImportSemaphoreWin32HandleInfoKHR *handle_info )
-{
-    VkImportSemaphoreFdInfoKHR fd_info = {.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR};
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct semaphore *semaphore = semaphore_from_handle( handle_info->semaphore );
-    D3DKMT_HANDLE local, global = 0;
-    VkResult res = VK_SUCCESS;
-    HANDLE shared = NULL;
-
-    TRACE( "device %p, handle_info %p\n", device, handle_info );
-
-    switch (handle_info->handleType)
-    {
-    case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
-        global = PtrToUlong( handle_info->handle );
-        if (!(local = d3dkmt_open_sync( global, NULL ))) return VK_ERROR_INVALID_EXTERNAL_HANDLE;
-        break;
-    case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT:
-    case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT:
-        if (handle_info->name && !(shared = open_shared_semaphore_from_name( handle_info->name )))
-            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
-        else if (!(shared = handle_info->handle) || NtDuplicateObject( NtCurrentProcess(), shared, NtCurrentProcess(), &shared,
-                                                                       0, 0, DUPLICATE_SAME_ATTRIBUTES | DUPLICATE_SAME_ACCESS ))
-            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
-
-        if (!(local = d3dkmt_open_sync( 0, shared )))
-        {
-            NtClose( shared );
-            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
-        }
-        break;
-    default:
-        FIXME( "Unsupported handle type %#x\n", handle_info->handleType );
-        return VK_ERROR_INVALID_EXTERNAL_HANDLE;
-    }
-
-    if ((fd_info.fd = d3dkmt_object_get_fd( local )) < 0) res = VK_ERROR_INVALID_EXTERNAL_HANDLE;
-    else
-    {
-        fd_info.handleType = get_host_external_semaphore_type();
-        fd_info.semaphore = semaphore->obj.host.semaphore;
-        fd_info.flags = handle_info->flags;
-        res = device->p_vkImportSemaphoreFdKHR( device->host.device, &fd_info );
-    }
-
-    if (res || handle_info->flags & VK_SEMAPHORE_IMPORT_TEMPORARY_BIT)
-    {
-        /* FIXME: Should we still keep the temporary handles for vkGetSemaphoreWin32HandleKHR? */
-        if (shared) NtClose( shared );
-        d3dkmt_destroy_sync( local );
-    }
-    else
-    {
-        if (semaphore->shared) NtClose( semaphore->shared );
-        if (semaphore->local) d3dkmt_destroy_sync( semaphore->local );
-        semaphore->shared = shared;
-        semaphore->global = global;
-        semaphore->local = local;
-    }
-    return res;
-}
-
-static void win32u_vkGetPhysicalDeviceExternalSemaphoreProperties( VkPhysicalDevice client_physical_device, const VkPhysicalDeviceExternalSemaphoreInfo *client_semaphore_info,
-                                                                   VkExternalSemaphoreProperties *semaphore_properties )
-{
-    VkPhysicalDeviceExternalSemaphoreInfo *semaphore_info = (VkPhysicalDeviceExternalSemaphoreInfo *)client_semaphore_info; /* cast away const, it has been copied in the thunks */
-    struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle( client_physical_device );
-    struct vulkan_instance *instance = physical_device->instance;
-    VkExternalSemaphoreHandleTypeFlagBits handle_type;
-
-    TRACE( "physical_device %p, semaphore_info %p, semaphore_properties %p\n", physical_device, semaphore_info, semaphore_properties );
-
-    handle_type = semaphore_info->handleType;
-    if (semaphore_info->handleType & EXTERNAL_SEMAPHORE_WIN32_BITS) semaphore_info->handleType = get_host_external_semaphore_type();
-
-    instance->p_vkGetPhysicalDeviceExternalSemaphoreProperties( physical_device->host.physical_device, semaphore_info, semaphore_properties );
-    semaphore_properties->compatibleHandleTypes = handle_type;
-    semaphore_properties->exportFromImportedHandleTypes = handle_type;
-}
-
-static VkResult win32u_vkCreateFence( VkDevice client_device, const VkFenceCreateInfo *client_create_info, const VkAllocationCallbacks *allocator, VkFence *ret )
-{
-    VkFenceCreateInfo *create_info = (VkFenceCreateInfo *)client_create_info; /* cast away const, chain has been copied in the thunks */
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    VkExportSemaphoreWin32HandleInfoKHR export_win32 = {.dwAccess = GENERIC_ALL};
-    VkBaseOutStructure **next, *prev = (VkBaseOutStructure *)create_info;
-    struct vulkan_instance *instance = device->physical_device->instance;
-    VkExportFenceCreateInfoKHR *export_info = NULL;
-    BOOL nt_shared = FALSE;
-    struct fence *fence;
-    VkFence host_fence;
-    VkResult res;
-
-    TRACE( "device %p, create_info %p, allocator %p, ret %p\n", device, create_info, allocator, ret );
-
-    for (next = &prev->pNext; *next; prev = *next, next = &(*next)->pNext)
-    {
-        switch ((*next)->sType)
-        {
-        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
-            export_info = (VkExportFenceCreateInfoKHR *)*next;
-            if (!(export_info->handleTypes & EXTERNAL_FENCE_WIN32_BITS))
-                FIXME( "Unsupported handle types %#x\n", export_info->handleTypes );
-            else
-            {
-                nt_shared = !(export_info->handleTypes & VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT);
-                export_info->handleTypes = get_host_external_fence_type();
-            }
-            *next = (*next)->pNext; next = &prev;
-            break;
-        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
-        {
-            VkExportFenceWin32HandleInfoKHR *fence_win32 = (VkExportFenceWin32HandleInfoKHR *)*next;
-            export_win32.pAttributes = fence_win32->pAttributes;
-            export_win32.dwAccess = fence_win32->dwAccess;
-            export_win32.name = fence_win32->name;
-            *next = (*next)->pNext; next = &prev;
-            break;
-        }
-        default: FIXME( "Unhandled sType %u.\n", (*next)->sType ); break;
-        }
-    }
-
-    if (!(fence = calloc( 1, sizeof(*fence) ))) return VK_ERROR_OUT_OF_HOST_MEMORY;
-
-    if ((res = device->p_vkCreateFence( device->host.device, create_info, NULL /* allocator */, &host_fence )))
-    {
-        free( fence );
-        return res;
-    }
-
-    if (export_info)
-    {
-        VkFenceGetFdInfoKHR fd_info = {.sType = VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR, .fence = host_fence};
-        int fd = -1;
-
-        switch ((fd_info.handleType = get_host_external_fence_type()))
-        {
-        case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT:
-            if ((res = device->p_vkGetFenceFdKHR( device->host.device, &fd_info, &fd ))) goto failed;
-            break;
-        default:
-            FIXME( "Unsupported handle type %#x\n", fd_info.handleType );
-            break;
-        }
-
-        if (!(fence->local = d3dkmt_create_sync( fd, nt_shared ? NULL : &fence->global ))) goto failed;
-        if (nt_shared && !(fence->shared = create_shared_semaphore_handle( fence->local, &export_win32 ))) goto failed;
-    }
-
-    vulkan_object_init( &fence->obj.obj, host_fence );
-    instance->p_insert_object( instance, &fence->obj.obj );
-
-    *ret = fence->obj.client.fence;
-    return res;
-
-failed:
-    WARN( "Failed to create fence, res %d\n", res );
-    device->p_vkDestroyFence( device->host.device, host_fence, NULL );
-    if (fence->local) d3dkmt_destroy_sync( fence->local );
-    free( fence );
-    return VK_ERROR_OUT_OF_HOST_MEMORY;
-}
-
-static void win32u_vkDestroyFence( VkDevice client_device, VkFence client_fence, const VkAllocationCallbacks *allocator )
+static const char *win32u_get_host_surface_extension(void)
 {
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct fence *fence = fence_from_handle( client_fence );
-    struct vulkan_instance *instance = device->physical_device->instance;
-
-    TRACE( "device %p, fence %p, allocator %p\n", device, fence, allocator );
-
-    if (!client_fence) return;
-
-    device->p_vkDestroyFence( device->host.device, fence->obj.host.fence, NULL /* allocator */ );
-    instance->p_remove_object( instance, &fence->obj.obj );
-
-    if (fence->shared) NtClose( fence->shared );
-    if (fence->local) d3dkmt_destroy_sync( fence->local );
-    free( fence );
-}
-
-static VkResult win32u_vkGetFenceWin32HandleKHR( VkDevice client_device, const VkFenceGetWin32HandleInfoKHR *handle_info, HANDLE *handle )
-{
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct fence *fence = fence_from_handle( handle_info->fence );
-
-    TRACE( "device %p, handle_info %p, handle %p\n", device, handle_info, handle );
-
-    switch (handle_info->handleType)
-    {
-    case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
-        TRACE( "Returning global D3DKMT handle %#x\n", fence->global );
-        *handle = UlongToPtr( fence->global );
-        return VK_SUCCESS;
-
-    case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT:
-        NtDuplicateObject( NtCurrentProcess(), fence->shared, NtCurrentProcess(), handle, 0, 0, DUPLICATE_SAME_ATTRIBUTES | DUPLICATE_SAME_ACCESS );
-        TRACE( "Returning NT shared handle %p -> %p\n", fence->shared, *handle );
-        return VK_SUCCESS;
-
-    default:
-        FIXME( "Unsupported handle type %#x\n", handle_info->handleType );
-        return VK_ERROR_INCOMPATIBLE_DRIVER;
-    }
-}
-
-static VkResult win32u_vkImportFenceWin32HandleKHR( VkDevice client_device, const VkImportFenceWin32HandleInfoKHR *handle_info )
-{
-    VkImportFenceFdInfoKHR fd_info = {.sType = VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR};
-    struct vulkan_device *device = vulkan_device_from_handle( client_device );
-    struct fence *fence = fence_from_handle( handle_info->fence );
-    D3DKMT_HANDLE local, global = 0;
-    HANDLE shared = NULL;
-    VkResult res;
-
-    TRACE( "device %p, handle_info %p\n", device, handle_info );
-
-    switch (handle_info->handleType)
-    {
-    case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
-        global = PtrToUlong( handle_info->handle );
-        if (!(local = d3dkmt_open_sync( global, NULL ))) return VK_ERROR_INVALID_EXTERNAL_HANDLE;
-        break;
-    case VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT:
-        if (handle_info->name && !(shared = open_shared_semaphore_from_name( handle_info->name )))
-            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
-        else if (!(shared = handle_info->handle) || NtDuplicateObject( NtCurrentProcess(), shared, NtCurrentProcess(), &shared,
-                                                                       0, 0, DUPLICATE_SAME_ATTRIBUTES | DUPLICATE_SAME_ACCESS ))
-            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
-
-        if (!(local = d3dkmt_open_sync( 0, shared )))
-        {
-            NtClose( shared );
-            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
-        }
-        break;
-    default:
-        FIXME( "Unsupported handle type %#x\n", handle_info->handleType );
-        return VK_ERROR_INVALID_EXTERNAL_HANDLE;
-    }
-
-    if ((fd_info.fd = d3dkmt_object_get_fd( local )) < 0) res = VK_ERROR_INVALID_EXTERNAL_HANDLE;
-    else
-    {
-        fd_info.handleType = get_host_external_fence_type();
-        fd_info.fence = fence->obj.host.fence;
-        fd_info.flags = handle_info->flags;
-        res = device->p_vkImportFenceFdKHR( device->host.device, &fd_info );
-    }
-
-    if (res || handle_info->flags & VK_FENCE_IMPORT_TEMPORARY_BIT)
-    {
-        /* FIXME: Should we still keep the temporary handles for vkGetFenceWin32HandleKHR? */
-        if (shared) NtClose( shared );
-        d3dkmt_destroy_sync( local );
-    }
-    else
-    {
-        if (fence->shared) NtClose( fence->shared );
-        if (fence->local) d3dkmt_destroy_sync( fence->local );
-        fence->shared = shared;
-        fence->global = global;
-        fence->local = local;
-    }
-    return VK_SUCCESS;
-}
-
-static void win32u_vkGetPhysicalDeviceExternalFenceProperties( VkPhysicalDevice client_physical_device, const VkPhysicalDeviceExternalFenceInfo *client_fence_info,
-                                                               VkExternalFenceProperties *fence_properties )
-{
-    VkPhysicalDeviceExternalFenceInfo *fence_info = (VkPhysicalDeviceExternalFenceInfo *)client_fence_info; /* cast away const, it has been copied in the thunks */
-    struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle( client_physical_device );
-    struct vulkan_instance *instance = physical_device->instance;
-    VkExternalFenceHandleTypeFlagBits handle_type;
-
-    TRACE( "physical_device %p, fence_info %p, fence_properties %p\n", physical_device, fence_info, fence_properties );
-
-    handle_type = fence_info->handleType;
-    if (fence_info->handleType & EXTERNAL_FENCE_WIN32_BITS) fence_info->handleType = get_host_external_fence_type();
-
-    instance->p_vkGetPhysicalDeviceExternalFenceProperties( physical_device->host.physical_device, fence_info, fence_properties );
-    fence_properties->compatibleHandleTypes = handle_type;
-    fence_properties->exportFromImportedHandleTypes = handle_type;
-}
-
-static const char *win32u_get_host_extension( const char *name )
-{
-    return driver_funcs->p_get_host_extension( name );
+    return driver_funcs->p_get_host_surface_extension();
 }
 
 static struct vulkan_funcs vulkan_funcs =
 {
-    .p_vkAcquireNextImage2KHR = win32u_vkAcquireNextImage2KHR,
-    .p_vkAcquireNextImageKHR = win32u_vkAcquireNextImageKHR,
-    .p_vkAllocateMemory = win32u_vkAllocateMemory,
-    .p_vkCreateBuffer = win32u_vkCreateBuffer,
-    .p_vkCreateFence = win32u_vkCreateFence,
-    .p_vkCreateImage = win32u_vkCreateImage,
-    .p_vkCreateSemaphore = win32u_vkCreateSemaphore,
-    .p_vkCreateSwapchainKHR = win32u_vkCreateSwapchainKHR,
     .p_vkCreateWin32SurfaceKHR = win32u_vkCreateWin32SurfaceKHR,
-    .p_vkDestroyFence = win32u_vkDestroyFence,
-    .p_vkDestroySemaphore = win32u_vkDestroySemaphore,
     .p_vkDestroySurfaceKHR = win32u_vkDestroySurfaceKHR,
-    .p_vkDestroySwapchainKHR = win32u_vkDestroySwapchainKHR,
-    .p_vkFreeMemory = win32u_vkFreeMemory,
-    .p_vkGetDeviceBufferMemoryRequirements = win32u_vkGetDeviceBufferMemoryRequirements,
-    .p_vkGetDeviceBufferMemoryRequirementsKHR = win32u_vkGetDeviceBufferMemoryRequirements,
-    .p_vkGetDeviceImageMemoryRequirements = win32u_vkGetDeviceImageMemoryRequirements,
-    .p_vkGetFenceWin32HandleKHR = win32u_vkGetFenceWin32HandleKHR,
-    .p_vkGetMemoryWin32HandleKHR = win32u_vkGetMemoryWin32HandleKHR,
-    .p_vkGetMemoryWin32HandlePropertiesKHR = win32u_vkGetMemoryWin32HandlePropertiesKHR,
-    .p_vkGetPhysicalDeviceExternalBufferProperties = win32u_vkGetPhysicalDeviceExternalBufferProperties,
-    .p_vkGetPhysicalDeviceExternalBufferPropertiesKHR = win32u_vkGetPhysicalDeviceExternalBufferProperties,
-    .p_vkGetPhysicalDeviceExternalFenceProperties = win32u_vkGetPhysicalDeviceExternalFenceProperties,
-    .p_vkGetPhysicalDeviceExternalFencePropertiesKHR = win32u_vkGetPhysicalDeviceExternalFenceProperties,
-    .p_vkGetPhysicalDeviceExternalSemaphoreProperties = win32u_vkGetPhysicalDeviceExternalSemaphoreProperties,
-    .p_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR = win32u_vkGetPhysicalDeviceExternalSemaphoreProperties,
-    .p_vkGetPhysicalDeviceImageFormatProperties2 = win32u_vkGetPhysicalDeviceImageFormatProperties2,
-    .p_vkGetPhysicalDeviceImageFormatProperties2KHR = win32u_vkGetPhysicalDeviceImageFormatProperties2,
-    .p_vkGetPhysicalDevicePresentRectanglesKHR = win32u_vkGetPhysicalDevicePresentRectanglesKHR,
     .p_vkGetPhysicalDeviceProperties2 = win32u_vkGetPhysicalDeviceProperties2,
     .p_vkGetPhysicalDeviceProperties2KHR = win32u_vkGetPhysicalDeviceProperties2KHR,
-    .p_vkGetPhysicalDeviceSurfaceCapabilities2KHR = win32u_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
     .p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = win32u_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
-    .p_vkGetPhysicalDeviceSurfaceFormats2KHR = win32u_vkGetPhysicalDeviceSurfaceFormats2KHR,
+    .p_vkGetPhysicalDeviceSurfaceCapabilities2KHR = win32u_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
+    .p_vkGetPhysicalDevicePresentRectanglesKHR = win32u_vkGetPhysicalDevicePresentRectanglesKHR,
     .p_vkGetPhysicalDeviceSurfaceFormatsKHR = win32u_vkGetPhysicalDeviceSurfaceFormatsKHR,
+    .p_vkGetPhysicalDeviceSurfaceFormats2KHR = win32u_vkGetPhysicalDeviceSurfaceFormats2KHR,
     .p_vkGetPhysicalDeviceWin32PresentationSupportKHR = win32u_vkGetPhysicalDeviceWin32PresentationSupportKHR,
-    .p_vkGetSemaphoreWin32HandleKHR = win32u_vkGetSemaphoreWin32HandleKHR,
-    .p_vkImportFenceWin32HandleKHR = win32u_vkImportFenceWin32HandleKHR,
-    .p_vkImportSemaphoreWin32HandleKHR = win32u_vkImportSemaphoreWin32HandleKHR,
-    .p_vkMapMemory = win32u_vkMapMemory,
-    .p_vkMapMemory2KHR = win32u_vkMapMemory2KHR,
+    .p_vkCreateSwapchainKHR = win32u_vkCreateSwapchainKHR,
+    .p_vkDestroySwapchainKHR = win32u_vkDestroySwapchainKHR,
+    .p_vkAcquireNextImage2KHR = win32u_vkAcquireNextImage2KHR,
+    .p_vkAcquireNextImageKHR = win32u_vkAcquireNextImageKHR,
     .p_vkQueuePresentKHR = win32u_vkQueuePresentKHR,
-    .p_vkQueueSubmit = win32u_vkQueueSubmit,
-    .p_vkQueueSubmit2 = win32u_vkQueueSubmit2,
-    .p_vkQueueSubmit2KHR = win32u_vkQueueSubmit2,
-    .p_vkUnmapMemory = win32u_vkUnmapMemory,
-    .p_vkUnmapMemory2KHR = win32u_vkUnmapMemory2KHR,
-    .p_get_host_extension = win32u_get_host_extension,
+    .p_get_host_surface_extension = win32u_get_host_surface_extension,
 };
 
 static VkResult nulldrv_vulkan_surface_create( HWND hwnd, const struct vulkan_instance *instance, VkSurfaceKHR *surface,
@@ -1980,20 +612,16 @@ static VkBool32 nulldrv_get_physical_dev
     return VK_TRUE;
 }
 
-static const char *nulldrv_get_host_extension( const char *name )
+static const char *nulldrv_get_host_surface_extension(void)
 {
-    if (!strcmp( name, "VK_KHR_win32_surface" )) return "VK_EXT_headless_surface";
-    if (!strcmp( name, "VK_KHR_external_memory_win32" )) return "VK_KHR_external_memory_fd";
-    if (!strcmp( name, "VK_KHR_external_semaphore_win32" )) return "VK_KHR_external_semaphore_fd";
-    if (!strcmp( name, "VK_KHR_external_fence_win32" )) return "VK_KHR_external_fence_fd";
-    return name;
+    return "VK_EXT_headless_surface";
 }
 
 static const struct vulkan_driver_funcs nulldrv_funcs =
 {
     .p_vulkan_surface_create = nulldrv_vulkan_surface_create,
     .p_get_physical_device_presentation_support = nulldrv_get_physical_device_presentation_support,
-    .p_get_host_extension = nulldrv_get_host_extension,
+    .p_get_host_surface_extension = nulldrv_get_host_surface_extension,
 };
 
 static void vulkan_driver_init(void)
@@ -2008,7 +636,7 @@ static void vulkan_driver_init(void)
     }
 
     if (status == STATUS_NOT_IMPLEMENTED) driver_funcs = &nulldrv_funcs;
-    else vulkan_funcs.p_get_host_extension = driver_funcs->p_get_host_extension;
+    else vulkan_funcs.p_get_host_surface_extension = driver_funcs->p_get_host_surface_extension;
 }
 
 static void vulkan_driver_load(void)
@@ -2030,17 +658,17 @@ static VkBool32 lazydrv_get_physical_dev
     return driver_funcs->p_get_physical_device_presentation_support( physical_device, queue );
 }
 
-static const char *lazydrv_get_host_extension( const char *name )
+static const char *lazydrv_get_host_surface_extension(void)
 {
     vulkan_driver_load();
-    return driver_funcs->p_get_host_extension( name );
+    return driver_funcs->p_get_host_surface_extension();
 }
 
 static const struct vulkan_driver_funcs lazydrv_funcs =
 {
     .p_vulkan_surface_create = lazydrv_vulkan_surface_create,
     .p_get_physical_device_presentation_support = lazydrv_get_physical_device_presentation_support,
-    .p_get_host_extension = lazydrv_get_host_extension,
+    .p_get_host_surface_extension = lazydrv_get_host_surface_extension,
 };
 
 static void vulkan_init_once(void)
diff -ruN --show-c-function vanilla-1017/dlls/win32u/win32u_private.h protonvulkan-1017/dlls/win32u/win32u_private.h
--- vanilla-1017/dlls/win32u/win32u_private.h	2025-10-21 17:44:36.048774328 -0700
+++ protonvulkan-1017/dlls/win32u/win32u_private.h	2025-10-21 17:23:40.585358264 -0700
@@ -206,16 +206,6 @@ extern void free_vulkan_gpu( struct vulk
 extern BOOL get_vulkan_uuid_from_luid( const LUID *luid, GUID *uuid );
 extern BOOL get_luid_from_vulkan_uuid( const GUID *uuid, LUID *luid, UINT32 *node_mask );
 
-extern int d3dkmt_object_get_fd( D3DKMT_HANDLE local );
-
-extern D3DKMT_HANDLE d3dkmt_create_resource( int fd, D3DKMT_HANDLE *global );
-extern D3DKMT_HANDLE d3dkmt_open_resource( D3DKMT_HANDLE global, HANDLE shared );
-extern NTSTATUS d3dkmt_destroy_resource( D3DKMT_HANDLE local );
-
-extern D3DKMT_HANDLE d3dkmt_create_sync( int fd, D3DKMT_HANDLE *global );
-extern D3DKMT_HANDLE d3dkmt_open_sync( D3DKMT_HANDLE global, HANDLE shared );
-extern NTSTATUS d3dkmt_destroy_sync( D3DKMT_HANDLE local );
-
 /* winstation.c */
 
 struct object_lock
diff -ruN --show-c-function vanilla-1017/dlls/winemac.drv/vulkan.c protonvulkan-1017/dlls/winemac.drv/vulkan.c
--- vanilla-1017/dlls/winemac.drv/vulkan.c	2025-10-21 17:44:36.078775004 -0700
+++ protonvulkan-1017/dlls/winemac.drv/vulkan.c	2025-10-21 17:23:40.585433025 -0700
@@ -99,17 +99,16 @@ static VkBool32 macdrv_get_physical_devi
 }
 
 static const char *host_surface_extension = "VK_MVK_macos_surface";
-static const char *macdrv_get_host_extension(const char *name)
+static const char *macdrv_get_host_surface_extension(void)
 {
-    if (!strcmp( name, "VK_KHR_win32_surface" )) return host_surface_extension;
-    return name;
+    return host_surface_extension;
 }
 
 static const struct vulkan_driver_funcs macdrv_vulkan_driver_funcs =
 {
     .p_vulkan_surface_create = macdrv_vulkan_surface_create,
     .p_get_physical_device_presentation_support = macdrv_get_physical_device_presentation_support,
-    .p_get_host_extension = macdrv_get_host_extension,
+    .p_get_host_surface_extension = macdrv_get_host_surface_extension,
 };
 
 UINT macdrv_VulkanInit(UINT version, void *vulkan_handle, const struct vulkan_driver_funcs **driver_funcs)
diff -ruN --show-c-function vanilla-1017/dlls/winevulkan/loader_thunks.c protonvulkan-1017/dlls/winevulkan/loader_thunks.c
--- vanilla-1017/dlls/winevulkan/loader_thunks.c	2025-10-21 17:44:44.782970715 -0700
+++ protonvulkan-1017/dlls/winevulkan/loader_thunks.c	2025-10-21 17:23:44.105834905 -0700
@@ -5015,18 +5015,6 @@ VkResult WINAPI vkGetFenceStatus(VkDevic
     return params.result;
 }
 
-VkResult WINAPI vkGetFenceWin32HandleKHR(VkDevice device, const VkFenceGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle)
-{
-    struct vkGetFenceWin32HandleKHR_params params;
-    NTSTATUS status;
-    params.device = device;
-    params.pGetWin32HandleInfo = pGetWin32HandleInfo;
-    params.pHandle = pHandle;
-    status = UNIX_CALL(vkGetFenceWin32HandleKHR, &params);
-    assert(!status && "vkGetFenceWin32HandleKHR");
-    return params.result;
-}
-
 VkResult WINAPI vkGetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer, uint32_t *pPropertiesCount, VkTilePropertiesQCOM *pProperties)
 {
     struct vkGetFramebufferTilePropertiesQCOM_params params;
@@ -5248,6 +5236,31 @@ void WINAPI vkGetLatencyTimingsNV(VkDevi
     assert(!status && "vkGetLatencyTimingsNV");
 }
 
+VkResult WINAPI vkGetMemoryFdKHR(VkDevice device, const VkMemoryGetFdInfoKHR *pGetFdInfo, int *pFd)
+{
+    struct vkGetMemoryFdKHR_params params;
+    NTSTATUS status;
+    params.device = device;
+    params.pGetFdInfo = pGetFdInfo;
+    params.pFd = pFd;
+    status = UNIX_CALL(vkGetMemoryFdKHR, &params);
+    assert(!status && "vkGetMemoryFdKHR");
+    return params.result;
+}
+
+VkResult WINAPI vkGetMemoryFdPropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR *pMemoryFdProperties)
+{
+    struct vkGetMemoryFdPropertiesKHR_params params;
+    NTSTATUS status;
+    params.device = device;
+    params.handleType = handleType;
+    params.fd = fd;
+    params.pMemoryFdProperties = pMemoryFdProperties;
+    status = UNIX_CALL(vkGetMemoryFdPropertiesKHR, &params);
+    assert(!status && "vkGetMemoryFdPropertiesKHR");
+    return params.result;
+}
+
 VkResult WINAPI vkGetMemoryHostPointerPropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHostPointer, VkMemoryHostPointerPropertiesEXT *pMemoryHostPointerProperties)
 {
     struct vkGetMemoryHostPointerPropertiesEXT_params params;
@@ -6254,6 +6267,18 @@ VkResult WINAPI vkGetSemaphoreCounterVal
     return params.result;
 }
 
+VkResult WINAPI vkGetSemaphoreFdKHR(VkDevice device, const VkSemaphoreGetFdInfoKHR *pGetFdInfo, int *pFd)
+{
+    struct vkGetSemaphoreFdKHR_params params;
+    NTSTATUS status;
+    params.device = device;
+    params.pGetFdInfo = pGetFdInfo;
+    params.pFd = pFd;
+    status = UNIX_CALL(vkGetSemaphoreFdKHR, &params);
+    assert(!status && "vkGetSemaphoreFdKHR");
+    return params.result;
+}
+
 VkResult WINAPI vkGetSemaphoreWin32HandleKHR(VkDevice device, const VkSemaphoreGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle)
 {
     struct vkGetSemaphoreWin32HandleKHR_params params;
@@ -6390,14 +6415,14 @@ VkResult WINAPI vkGetVideoSessionMemoryR
     return params.result;
 }
 
-VkResult WINAPI vkImportFenceWin32HandleKHR(VkDevice device, const VkImportFenceWin32HandleInfoKHR *pImportFenceWin32HandleInfo)
+VkResult WINAPI vkImportSemaphoreFdKHR(VkDevice device, const VkImportSemaphoreFdInfoKHR *pImportSemaphoreFdInfo)
 {
-    struct vkImportFenceWin32HandleKHR_params params;
+    struct vkImportSemaphoreFdKHR_params params;
     NTSTATUS status;
     params.device = device;
-    params.pImportFenceWin32HandleInfo = pImportFenceWin32HandleInfo;
-    status = UNIX_CALL(vkImportFenceWin32HandleKHR, &params);
-    assert(!status && "vkImportFenceWin32HandleKHR");
+    params.pImportSemaphoreFdInfo = pImportSemaphoreFdInfo;
+    status = UNIX_CALL(vkImportSemaphoreFdKHR, &params);
+    assert(!status && "vkImportSemaphoreFdKHR");
     return params.result;
 }
 
@@ -7163,6 +7188,31 @@ VkResult WINAPI vkWriteMicromapsProperti
     return params.result;
 }
 
+VkResult WINAPI wine_vkAcquireKeyedMutex(VkDevice device, VkDeviceMemory memory, uint64_t key, uint32_t timeout_ms)
+{
+    struct wine_vkAcquireKeyedMutex_params params;
+    NTSTATUS status;
+    params.device = device;
+    params.memory = memory;
+    params.key = key;
+    params.timeout_ms = timeout_ms;
+    status = UNIX_CALL(wine_vkAcquireKeyedMutex, &params);
+    assert(!status && "wine_vkAcquireKeyedMutex");
+    return params.result;
+}
+
+VkResult WINAPI wine_vkReleaseKeyedMutex(VkDevice device, VkDeviceMemory memory, uint64_t key)
+{
+    struct wine_vkReleaseKeyedMutex_params params;
+    NTSTATUS status;
+    params.device = device;
+    params.memory = memory;
+    params.key = key;
+    status = UNIX_CALL(wine_vkReleaseKeyedMutex, &params);
+    assert(!status && "wine_vkReleaseKeyedMutex");
+    return params.result;
+}
+
 static const struct vulkan_func vk_device_dispatch_table[] =
 {
     {"vkAcquireNextImage2KHR", vkAcquireNextImage2KHR},
@@ -7633,7 +7683,6 @@ static const struct vulkan_func vk_devic
     {"vkGetEncodedVideoSessionParametersKHR", vkGetEncodedVideoSessionParametersKHR},
     {"vkGetEventStatus", vkGetEventStatus},
     {"vkGetFenceStatus", vkGetFenceStatus},
-    {"vkGetFenceWin32HandleKHR", vkGetFenceWin32HandleKHR},
     {"vkGetFramebufferTilePropertiesQCOM", vkGetFramebufferTilePropertiesQCOM},
     {"vkGetGeneratedCommandsMemoryRequirementsEXT", vkGetGeneratedCommandsMemoryRequirementsEXT},
     {"vkGetGeneratedCommandsMemoryRequirementsNV", vkGetGeneratedCommandsMemoryRequirementsNV},
@@ -7653,6 +7702,8 @@ static const struct vulkan_func vk_devic
     {"vkGetImageViewHandleNVX", vkGetImageViewHandleNVX},
     {"vkGetImageViewOpaqueCaptureDescriptorDataEXT", vkGetImageViewOpaqueCaptureDescriptorDataEXT},
     {"vkGetLatencyTimingsNV", vkGetLatencyTimingsNV},
+    {"vkGetMemoryFdKHR", vkGetMemoryFdKHR},
+    {"vkGetMemoryFdPropertiesKHR", vkGetMemoryFdPropertiesKHR},
     {"vkGetMemoryHostPointerPropertiesEXT", vkGetMemoryHostPointerPropertiesEXT},
     {"vkGetMemoryWin32HandleKHR", vkGetMemoryWin32HandleKHR},
     {"vkGetMemoryWin32HandlePropertiesKHR", vkGetMemoryWin32HandlePropertiesKHR},
@@ -7683,6 +7734,7 @@ static const struct vulkan_func vk_devic
     {"vkGetSamplerOpaqueCaptureDescriptorDataEXT", vkGetSamplerOpaqueCaptureDescriptorDataEXT},
     {"vkGetSemaphoreCounterValue", vkGetSemaphoreCounterValue},
     {"vkGetSemaphoreCounterValueKHR", vkGetSemaphoreCounterValueKHR},
+    {"vkGetSemaphoreFdKHR", vkGetSemaphoreFdKHR},
     {"vkGetSemaphoreWin32HandleKHR", vkGetSemaphoreWin32HandleKHR},
     {"vkGetShaderBinaryDataEXT", vkGetShaderBinaryDataEXT},
     {"vkGetShaderInfoAMD", vkGetShaderInfoAMD},
@@ -7694,7 +7746,7 @@ static const struct vulkan_func vk_devic
     {"vkGetTensorViewOpaqueCaptureDescriptorDataARM", vkGetTensorViewOpaqueCaptureDescriptorDataARM},
     {"vkGetValidationCacheDataEXT", vkGetValidationCacheDataEXT},
     {"vkGetVideoSessionMemoryRequirementsKHR", vkGetVideoSessionMemoryRequirementsKHR},
-    {"vkImportFenceWin32HandleKHR", vkImportFenceWin32HandleKHR},
+    {"vkImportSemaphoreFdKHR", vkImportSemaphoreFdKHR},
     {"vkImportSemaphoreWin32HandleKHR", vkImportSemaphoreWin32HandleKHR},
     {"vkInitializePerformanceApiINTEL", vkInitializePerformanceApiINTEL},
     {"vkInvalidateMappedMemoryRanges", vkInvalidateMappedMemoryRanges},
@@ -7759,6 +7811,8 @@ static const struct vulkan_func vk_devic
     {"vkWaitSemaphoresKHR", vkWaitSemaphoresKHR},
     {"vkWriteAccelerationStructuresPropertiesKHR", vkWriteAccelerationStructuresPropertiesKHR},
     {"vkWriteMicromapsPropertiesEXT", vkWriteMicromapsPropertiesEXT},
+    {"wine_vkAcquireKeyedMutex", wine_vkAcquireKeyedMutex},
+    {"wine_vkReleaseKeyedMutex", wine_vkReleaseKeyedMutex},
 };
 
 static const struct vulkan_func vk_phys_dev_dispatch_table[] =
diff -ruN --show-c-function vanilla-1017/dlls/winevulkan/loader_thunks.h protonvulkan-1017/dlls/winevulkan/loader_thunks.h
--- vanilla-1017/dlls/winevulkan/loader_thunks.h	2025-10-21 17:44:44.778970625 -0700
+++ protonvulkan-1017/dlls/winevulkan/loader_thunks.h	2025-10-21 17:23:44.101834840 -0700
@@ -508,7 +508,6 @@ enum unix_call
     unix_vkGetEncodedVideoSessionParametersKHR,
     unix_vkGetEventStatus,
     unix_vkGetFenceStatus,
-    unix_vkGetFenceWin32HandleKHR,
     unix_vkGetFramebufferTilePropertiesQCOM,
     unix_vkGetGeneratedCommandsMemoryRequirementsEXT,
     unix_vkGetGeneratedCommandsMemoryRequirementsNV,
@@ -528,6 +527,8 @@ enum unix_call
     unix_vkGetImageViewHandleNVX,
     unix_vkGetImageViewOpaqueCaptureDescriptorDataEXT,
     unix_vkGetLatencyTimingsNV,
+    unix_vkGetMemoryFdKHR,
+    unix_vkGetMemoryFdPropertiesKHR,
     unix_vkGetMemoryHostPointerPropertiesEXT,
     unix_vkGetMemoryWin32HandleKHR,
     unix_vkGetMemoryWin32HandlePropertiesKHR,
@@ -612,6 +613,7 @@ enum unix_call
     unix_vkGetSamplerOpaqueCaptureDescriptorDataEXT,
     unix_vkGetSemaphoreCounterValue,
     unix_vkGetSemaphoreCounterValueKHR,
+    unix_vkGetSemaphoreFdKHR,
     unix_vkGetSemaphoreWin32HandleKHR,
     unix_vkGetShaderBinaryDataEXT,
     unix_vkGetShaderInfoAMD,
@@ -623,7 +625,7 @@ enum unix_call
     unix_vkGetTensorViewOpaqueCaptureDescriptorDataARM,
     unix_vkGetValidationCacheDataEXT,
     unix_vkGetVideoSessionMemoryRequirementsKHR,
-    unix_vkImportFenceWin32HandleKHR,
+    unix_vkImportSemaphoreFdKHR,
     unix_vkImportSemaphoreWin32HandleKHR,
     unix_vkInitializePerformanceApiINTEL,
     unix_vkInvalidateMappedMemoryRanges,
@@ -689,6 +691,8 @@ enum unix_call
     unix_vkWaitSemaphoresKHR,
     unix_vkWriteAccelerationStructuresPropertiesKHR,
     unix_vkWriteMicromapsPropertiesEXT,
+    unix_wine_vkAcquireKeyedMutex,
+    unix_wine_vkReleaseKeyedMutex,
     unix_count,
 };
 
@@ -4408,14 +4412,6 @@ struct vkGetFenceStatus_params
     VkResult result;
 };
 
-struct vkGetFenceWin32HandleKHR_params
-{
-    VkDevice device;
-    const VkFenceGetWin32HandleInfoKHR *pGetWin32HandleInfo;
-    HANDLE *pHandle;
-    VkResult result;
-};
-
 struct vkGetFramebufferTilePropertiesQCOM_params
 {
     VkDevice device;
@@ -4561,6 +4557,23 @@ struct vkGetLatencyTimingsNV_params
     VkGetLatencyMarkerInfoNV *pLatencyMarkerInfo;
 };
 
+struct vkGetMemoryFdKHR_params
+{
+    VkDevice device;
+    const VkMemoryGetFdInfoKHR *pGetFdInfo;
+    int *pFd;
+    VkResult result;
+};
+
+struct vkGetMemoryFdPropertiesKHR_params
+{
+    VkDevice device;
+    VkExternalMemoryHandleTypeFlagBits handleType;
+    int fd;
+    VkMemoryFdPropertiesKHR *pMemoryFdProperties;
+    VkResult result;
+};
+
 struct vkGetMemoryHostPointerPropertiesEXT_params
 {
     VkDevice device;
@@ -5231,6 +5244,14 @@ struct vkGetSemaphoreCounterValueKHR_par
     VkResult result;
 };
 
+struct vkGetSemaphoreFdKHR_params
+{
+    VkDevice device;
+    const VkSemaphoreGetFdInfoKHR *pGetFdInfo;
+    int *pFd;
+    VkResult result;
+};
+
 struct vkGetSemaphoreWin32HandleKHR_params
 {
     VkDevice device;
@@ -5323,10 +5344,10 @@ struct vkGetVideoSessionMemoryRequiremen
     VkResult result;
 };
 
-struct vkImportFenceWin32HandleKHR_params
+struct vkImportSemaphoreFdKHR_params
 {
     VkDevice device;
-    const VkImportFenceWin32HandleInfoKHR *pImportFenceWin32HandleInfo;
+    const VkImportSemaphoreFdInfoKHR *pImportSemaphoreFdInfo;
     VkResult result;
 };
 
@@ -5836,4 +5857,21 @@ struct vkWriteMicromapsPropertiesEXT_par
     VkResult result;
 };
 
+struct wine_vkAcquireKeyedMutex_params
+{
+    VkDevice device;
+    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
+    uint64_t DECLSPEC_ALIGN(8) key;
+    uint32_t timeout_ms;
+    VkResult result;
+};
+
+struct wine_vkReleaseKeyedMutex_params
+{
+    VkDevice device;
+    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
+    uint64_t DECLSPEC_ALIGN(8) key;
+    VkResult result;
+};
+
 #endif /* __WINE_VULKAN_LOADER_THUNKS_H */
diff -ruN --show-c-function vanilla-1017/dlls/winevulkan/make_vulkan protonvulkan-1017/dlls/winevulkan/make_vulkan
--- vanilla-1017/dlls/winevulkan/make_vulkan	2025-10-21 17:44:36.083775116 -0700
+++ protonvulkan-1017/dlls/winevulkan/make_vulkan	2025-10-21 17:23:40.648877783 -0700
@@ -96,6 +96,7 @@ UNSUPPORTED_EXTENSIONS = [
     "VK_AMD_display_native_hdr",
     "VK_EXT_full_screen_exclusive",
     "VK_GOOGLE_display_timing",
+    "VK_KHR_external_fence_win32",
     # Relates to external_semaphore and needs type conversions in bitflags.
     "VK_KHR_maintenance7", # Causes infinity recursion in struct convert code
     "VK_KHR_shared_presentable_image", # Needs WSI work.
@@ -106,9 +107,13 @@ UNSUPPORTED_EXTENSIONS = [
     "VK_NV_external_compute_queue", # Has a new dispatchable handle
 
     # Extensions for other platforms
+    "VK_EXT_external_memory_dma_buf",
+    "VK_EXT_image_drm_format_modifier",
     "VK_EXT_metal_objects",
     "VK_EXT_physical_device_drm",
     "VK_GOOGLE_surfaceless_query",
+    "VK_KHR_external_fence_fd",
+    "VK_EXT_external_memory_metal",
     "VK_SEC_amigo_profiling", # Angle specific.
 
     # Extensions which require callback handling
@@ -126,13 +131,7 @@ UNEXPOSED_EXTENSIONS = {
     "VK_EXT_map_memory_placed",
     "VK_EXT_headless_surface",
     # Extensions for other platforms
-    "VK_EXT_external_memory_dma_buf",
-    "VK_EXT_image_drm_format_modifier",
     "VK_EXT_metal_surface",
-    "VK_KHR_external_fence_fd",
-    "VK_KHR_external_memory_fd",
-    "VK_EXT_external_memory_metal",
-    "VK_KHR_external_semaphore_fd",
     "VK_KHR_wayland_surface",
     "VK_KHR_xlib_surface",
     "VK_MVK_macos_surface",
@@ -187,44 +186,63 @@ FUNCTION_OVERRIDES = {
 
     # Instance functions
     "vkCreateDevice" : {"extra_param" : "client_ptr"},
+    "vkGetPhysicalDeviceExternalBufferProperties" : {"dispatch" : True},
+    "vkGetPhysicalDeviceExternalFenceProperties" : {"dispatch" : False},
+    "vkGetPhysicalDeviceExternalSemaphoreProperties" : {"dispatch" : True},
 
     # Device functions
     "vkCreateCommandPool" : {"extra_param" : "client_ptr"},
     "vkGetDeviceProcAddr" : {"dispatch" : False},
+    "vkAllocateMemory" : {"dispatch" : True},
+    "vkGetSemaphoreCounterValue" : {"dispatch" : True},
+    "vkSignalSemaphore" : {"dispatch" : True},
+    "vkWaitSemaphores" : {"dispatch" : True},
+    "vkQueueBindSparse" : {"dispatch" : True},
+    "vkQueueSubmit" : {"dispatch" : True},
+    "vkQueueSubmit2" : {"dispatch" : True},
+    "vkDestroySemaphore" : {"dispatch" : True},
+
+    # VK_KHR_external_fence_capabilities
+    "vkGetPhysicalDeviceExternalFencePropertiesKHR" : {"dispatch" : False},
+
+    # VK_KHR_external_memory_capabilities
+    "vkGetPhysicalDeviceExternalBufferPropertiesKHR" : {"dispatch" : True},
+
+    # VK_KHR_external_semaphore_capabilities
+    "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR" : {"dispatch" : True},
+
+    # VK_KHR_external_semaphore_win32
+    "vkCreateSemaphore" : {"dispatch" : True },
+    "vkGetSemaphoreWin32HandleKHR" : {"dispatch" : True},
+    "vkImportSemaphoreWin32HandleKHR" : {"dispatch" : True},
+
+    # VK_KHR_external_memory_win32
+    "vkGetMemoryWin32HandleKHR" : {"dispatch" : True},
+    "vkGetMemoryWin32HandlePropertiesKHR" : {"dispatch" : True},
+
+    # VK_KHR_timeline_semaphore
+    "vkGetSemaphoreCounterValueKHR" : {"dispatch" : True},
+    "vkSignalSemaphoreKHR" : {"dispatch" : True},
+    "vkWaitSemaphoresKHR" : {"dispatch" : True},
+
+    # VK_KHR_synchronization2
+    "vkQueueSubmit2KHR" : {"dispatch" : True},
+
+    # Custom functions
+    "wine_vkAcquireKeyedMutex" : {"dispatch": True},
+    "wine_vkReleaseKeyedMutex" : {"dispatch": True},
 }
 
 # functions for which a user driver entry must be generated
 USER_DRIVER_FUNCS = {
     "vkAcquireNextImage2KHR",
     "vkAcquireNextImageKHR",
-    "vkAllocateMemory",
-    "vkCreateBuffer",
-    "vkCreateFence",
-    "vkCreateImage",
-    "vkCreateSemaphore",
     "vkCreateSwapchainKHR",
     "vkCreateWin32SurfaceKHR",
-    "vkDestroyFence",
-    "vkDestroySemaphore",
     "vkDestroySurfaceKHR",
     "vkDestroySwapchainKHR",
-    "vkFreeMemory",
-    "vkGetDeviceBufferMemoryRequirements",
-    "vkGetDeviceBufferMemoryRequirementsKHR",
-    "vkGetDeviceImageMemoryRequirements",
     "vkGetDeviceProcAddr",
-    "vkGetFenceWin32HandleKHR",
     "vkGetInstanceProcAddr",
-    "vkGetMemoryWin32HandleKHR",
-    "vkGetMemoryWin32HandlePropertiesKHR",
-    "vkGetPhysicalDeviceExternalBufferProperties",
-    "vkGetPhysicalDeviceExternalBufferPropertiesKHR",
-    "vkGetPhysicalDeviceExternalFenceProperties",
-    "vkGetPhysicalDeviceExternalFencePropertiesKHR",
-    "vkGetPhysicalDeviceExternalSemaphoreProperties",
-    "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR",
-    "vkGetPhysicalDeviceImageFormatProperties2",
-    "vkGetPhysicalDeviceImageFormatProperties2KHR",
     "vkGetPhysicalDevicePresentRectanglesKHR",
     "vkGetPhysicalDeviceProperties2",
     "vkGetPhysicalDeviceProperties2KHR",
@@ -233,34 +251,30 @@ USER_DRIVER_FUNCS = {
     "vkGetPhysicalDeviceSurfaceFormats2KHR",
     "vkGetPhysicalDeviceSurfaceFormatsKHR",
     "vkGetPhysicalDeviceWin32PresentationSupportKHR",
-    "vkGetSemaphoreWin32HandleKHR",
-    "vkImportFenceWin32HandleKHR",
-    "vkImportSemaphoreWin32HandleKHR",
-    "vkMapMemory",
-    "vkMapMemory2KHR",
     "vkQueuePresentKHR",
-    "vkQueueSubmit",
-    "vkQueueSubmit2",
-    "vkQueueSubmit2KHR",
-    "vkUnmapMemory",
-    "vkUnmapMemory2KHR",
 }
 
 # functions for which the unix thunk is manually implemented
 MANUAL_UNIX_THUNKS = {
     "vkAllocateCommandBuffers",
+    "vkAllocateMemory",
+    "vkCreateBuffer",
     "vkCreateCommandPool",
     "vkCreateDebugReportCallbackEXT",
     "vkCreateDebugUtilsMessengerEXT",
     "vkCreateDeferredOperationKHR",
     "vkCreateDevice",
+    "vkCreateImage",
     "vkCreateInstance",
+    "vkCreateSemaphore",
     "vkDestroyCommandPool",
     "vkDestroyDebugReportCallbackEXT",
     "vkDestroyDebugUtilsMessengerEXT",
     "vkDestroyDeferredOperationKHR",
     "vkDestroyDevice",
     "vkDestroyInstance",
+    "vkGetSemaphoreWin32HandleKHR",
+    "vkImportSemaphoreWin32HandleKHR",
     "vkEnumerateDeviceExtensionProperties",
     "vkEnumerateDeviceLayerProperties",
     "vkEnumerateInstanceExtensionProperties",
@@ -270,16 +284,43 @@ MANUAL_UNIX_THUNKS = {
     "vkEnumeratePhysicalDeviceGroupsKHR",
     "vkEnumeratePhysicalDevices",
     "vkFreeCommandBuffers",
+    "vkFreeMemory",
     "vkGetCalibratedTimestampsEXT",
     "vkGetCalibratedTimestampsKHR",
     "vkGetDeviceProcAddr",
+    "vkGetMemoryWin32HandleKHR",
+    "vkGetMemoryWin32HandlePropertiesKHR",
     "vkGetDeviceQueue",
     "vkGetDeviceQueue2",
     "vkGetInstanceProcAddr",
     "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT",
     "vkGetPhysicalDeviceCalibrateableTimeDomainsKHR",
+    "vkGetPhysicalDeviceExternalBufferProperties",
+    "vkGetPhysicalDeviceExternalBufferPropertiesKHR",
     "vkGetPhysicalDeviceExternalFenceProperties",
     "vkGetPhysicalDeviceExternalFencePropertiesKHR",
+    "vkGetPhysicalDeviceExternalSemaphoreProperties",
+    "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR",
+    "vkGetPhysicalDeviceImageFormatProperties2",
+    "vkGetPhysicalDeviceImageFormatProperties2KHR",
+    "vkMapMemory",
+    "vkMapMemory2KHR",
+    "vkUnmapMemory",
+    "vkUnmapMemory2KHR",
+    "vkGetSemaphoreCounterValue",
+    "vkSignalSemaphore",
+    "vkWaitSemaphores",
+    "vkQueueBindSparse",
+    "vkQueueSubmit",
+    "vkQueueSubmit2",
+    "vkDestroySemaphore",
+    "vkGetSemaphoreCounterValueKHR",
+    "vkSignalSemaphoreKHR",
+    "vkWaitSemaphoresKHR",
+    "vkQueueSubmit2KHR",
+    # Custom functions
+    "wine_vkAcquireKeyedMutex",
+    "wine_vkReleaseKeyedMutex",
 }
 
 # loader functions which are entirely manually implemented
@@ -304,24 +345,24 @@ MANUAL_LOADER_THUNKS = {
 }
 
 STRUCT_CHAIN_CONVERSIONS = {
-    # Force making copies of some struct chains
-    "VkMemoryAllocateInfo": {},
-    "VkBufferCreateInfo": {},
-    "VkImageCreateInfo": {},
-    "VkPhysicalDeviceExternalBufferInfo": {},
-    "VkPhysicalDeviceImageFormatInfo2": {},
-    "VkCommandBufferSubmitInfo": {},
-    "VkSemaphoreCreateInfo": {},
-    "VkSemaphoreSubmitInfo": {},
-    "VkFenceCreateInfo": {},
-    "VkSubmitInfo": {},
-    "VkSubmitInfo2": {},
-
     # Ignore to not confuse host loader.
-    "VkDeviceCreateInfo": {"strip": ["VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO"]},
-    "VkInstanceCreateInfo": {"strip": ["VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO"]},
+    "VkDeviceCreateInfo": ["VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO"],
+    "VkInstanceCreateInfo": ["VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO"],
+
+    # Structs which require pNext chain modification
+    "VkBufferCreateInfo": [],
+    "VkImageCreateInfo": [],
+    "VkMemoryAllocateInfo": [],
+    "VkPhysicalDeviceImageFormatInfo2": [],
+    "VkPhysicalDeviceExternalSemaphoreInfo": [],
+    "VkSemaphoreCreateInfo": [],
+    "VkSubmitInfo": [],
+    "VkSubmitInfo2": [],
+    "VkBindSparseInfo" : [],
 }
 
+STRUCT_COPY = {};
+
 # Some struct members are conditionally ignored and callers are free to leave them uninitialized.
 # We can't deduce that from XML, so we allow expressing it here.
 MEMBER_LENGTH_EXPRESSIONS = {
@@ -786,7 +827,14 @@ class VkFunction(object):
         proto += ", ".join([p.definition() for p in self.params])
 
         if is_thunk and self.extra_param:
-            proto += ", void *" + self.extra_param
+            extra_param_is_new = True
+            for p in self.params:
+                if p.name == self.extra_param:
+                    extra_param_is_new = False
+            if extra_param_is_new:
+                proto += ", void *" + self.extra_param
+            else:
+                proto += ", void *win_" + self.extra_param
 
         proto += ")"
         return proto
@@ -873,7 +921,7 @@ class VkFunction(object):
             if conv:
                 params += ", UlongToPtr({0}{1})".format(params_prefix, self.extra_param)
             else:
-                params += ", {0}{1}".format(params_prefix, self.extra_param)
+                params += ", (void *){0}{1}".format(params_prefix, self.extra_param)
 
         if self.name in MANUAL_UNIX_THUNKS:
             func_prefix = "wine_"
@@ -953,9 +1001,12 @@ class VkFunction(object):
         if conv:
             thunk += "    struct\n"
             thunk += "    {\n"
+            extra_param_is_new = True
             for p in self.params:
                 thunk += "        {0};\n".format(p.definition(conv=True, is_member=True))
-            if self.extra_param:
+                if p.name == self.extra_param:
+                    extra_param_is_new = False
+            if self.extra_param and extra_param_is_new:
                 thunk += "        PTR32 {0};\n".format(self.extra_param)
             if self.type != "void":
                 thunk += "        {0} result;\n".format(self.type)
@@ -1062,7 +1113,7 @@ class VkHandle(object):
             # Should only happen for VkInstance
             return "vulkan_instance_from_handle({0})".format(param)
         elif self.name == "VkCommandBuffer":
-            return "vulkan_command_buffer_from_handle({0})->device".format(param)
+            return "wine_cmd_buffer_from_handle({0})->device".format(param)
         elif self.name == "VkDevice":
             return "vulkan_device_from_handle({0})".format(param)
         elif self.name == "VkPhysicalDevice":
@@ -1101,7 +1152,7 @@ class VkHandle(object):
         """ Provide access to the host handle of a wrapped object. """
 
         if self.name == "VkCommandBuffer":
-            return "vulkan_command_buffer_from_handle({0})->host.command_buffer".format(name)
+            return "wine_cmd_buffer_from_handle({0})->host.command_buffer".format(name)
         if self.name == "VkCommandPool":
             return "wine_cmd_pool_from_handle({0})->host.command_pool".format(name)
         if self.name == "VkDebugUtilsMessengerEXT":
@@ -1115,7 +1166,9 @@ class VkHandle(object):
         if self.name == "VkInstance":
             return "vulkan_instance_from_handle({0})->host.instance".format(name)
         if self.name == "VkDeviceMemory":
-            return "vulkan_device_memory_from_handle({0})->host.device_memory".format(name)
+            return "wine_device_memory_from_handle({0})->host.device_memory".format(name)
+        if self.name == "VkSemaphore":
+            return "vulkan_semaphore_from_handle({0})->host.semaphore".format(name)
         if self.name == "VkPhysicalDevice":
             return "vulkan_physical_device_from_handle({0})->host.physical_device".format(name)
         if self.name == "VkQueue":
@@ -1124,11 +1177,6 @@ class VkHandle(object):
             return "vulkan_surface_from_handle({0})->host.surface".format(name)
         if self.name == "VkSwapchainKHR":
             return "vulkan_swapchain_from_handle({0})->host.swapchain".format(name)
-        if self.name == "VkSemaphore":
-            return "vulkan_semaphore_from_handle({0})->host.semaphore".format(name)
-        if self.name == "VkFence":
-            return "vulkan_fence_from_handle({0})->host.fence".format(name)
-
         if self.is_dispatchable():
             LOGGER.error("Unhandled host handle for: {0}".format(self.name))
         return None
@@ -1136,7 +1184,8 @@ class VkHandle(object):
     def unwrap_handle(self, name, unwrap):
         if unwrap == Unwrap.HOST:
             return self.host_handle(name)
-        assert unwrap != Unwrap.NONE
+        if unwrap == Unwrap.NONE:
+            return name
         return None
 
     def is_wrapped(self):
@@ -1225,7 +1274,7 @@ class VkVariable(object):
         return self.pointer and self.pointer.count('*') > 1
 
     def is_pointer_size(self):
-        if self.type in ["size_t", "HWND", "HINSTANCE", "HANDLE", "LPCWSTR"] or self.type.startswith("PFN"):
+        if self.type in ["size_t", "HWND", "HINSTANCE"] or self.type.startswith("PFN"):
             return True
         if self.is_handle() and self.handle.is_dispatchable():
             return True
@@ -1428,7 +1477,7 @@ class VkMember(VkVariable):
                         values=values, object_type=object_type, bit_width=bit_width, returnedonly=returnedonly,
                         parent=parent, selection=selection, selector=selector)
 
-    def copy(self, input, output, direction, conv, unwrap, parent_const, conversions):
+    def copy(self, input, output, direction, conv, unwrap, copy, parent_const, conversions):
         """ Helper method for use by conversion logic to generate a C-code statement to copy this member.
             - `conv` indicates whether the statement is in a struct alignment conversion path. """
 
@@ -1436,7 +1485,7 @@ class VkMember(VkVariable):
         suffix = convert_suffix(direction, win_type, unwrap, self.is_wrapped())
         is_const = self.is_const() if self.is_pointer() else parent_const
 
-        if self.needs_conversion(conv, unwrap, direction, False):
+        if self.needs_conversion(conv, unwrap, direction, False) and not copy:
             if self.is_dynamic_array():
                 # Array length is either a variable name (string) or an int.
                 count = self.get_dyn_array_len(input, conv)
@@ -1468,8 +1517,9 @@ class VkMember(VkVariable):
                     return "{0}{1} = {2} ? {3} : 0;\n".format(output, self.name, self.value(input, conv),
                         handle.unwrap_handle(self.value(input, conv), unwrap))
                 else:
-                    return "{0}{1} = {2};\n".format(output, self.name,
-                        handle.unwrap_handle(self.value(input, conv), unwrap))
+                    input_name = "{0}{1}".format(input, self.name)
+                    return "{0}{1} = {2} ? {3} : VK_NULL_HANDLE;\n".format(output, self.name,
+                        input_name, handle.unwrap_handle(self.value(input, conv), unwrap))
             elif self.is_generic_handle():
                 if direction == Direction.OUTPUT:
                     LOGGER.error("OUTPUT parameter {0}.{1} cannot be unwrapped".format(self.type, self.name))
@@ -1489,6 +1539,11 @@ class VkMember(VkVariable):
             for l in self.array_lens:
                 bytes_count = "{0} * ".format(l) + bytes_count
             return "memcpy({0}{1}, {2}{1}, {3});\n".format(output, self.name, input, bytes_count)
+        elif self.is_dynamic_array() and copy:
+            if self.type == "void":
+                return "MEMDUP_VOID(ctx, {0}{1}, {2}{1}, {3});\n".format(output, self.name, input, self.get_dyn_array_len(input, conv))
+            else:
+                return "MEMDUP(ctx, {0}{1}, {2}{1}, {3});\n".format(output, self.name, input, self.get_dyn_array_len(input, conv))
         elif conv and direction == Direction.OUTPUT and self.is_pointer():
             return "{0}{1} = PtrToUlong({2}{1});\n".format(output, self.name, input)
         elif conv and direction == Direction.INPUT and self.is_pointer():
@@ -1570,13 +1625,13 @@ class VkMember(VkVariable):
                 return True
 
         if self.is_handle():
-            if self.handle.is_wrapped() and self.is_dynamic_array():
+            if unwrap != Unwrap.NONE and self.handle.is_wrapped():
                 return True
-            if conv and self.handle.is_dispatchable() and self.is_static_array():
+            if conv and self.handle.is_dispatchable():
                 return True
-            return unwrap != Unwrap.NONE and self.handle.is_wrapped()
         elif self.is_generic_handle():
-            return unwrap != Unwrap.NONE
+            if unwrap != Unwrap.NONE:
+                return True
         elif self.is_struct() or self.is_union():
             if self.struct.needs_conversion(conv, unwrap, direction, is_const):
                 return True
@@ -2187,17 +2242,21 @@ class VkStruct(Sequence):
 
 
 class StructConversionFunction(object):
-    def __init__(self, struct, direction, conv, unwrap, const):
+    def __init__(self, struct, direction, conv, unwrap, const, copy=False):
         self.direction = direction
         self.operand = struct
         self.type = struct.name
         self.conv = conv
         self.unwrap = unwrap
         self.const = const
+        self.copy = copy
 
-        name = "convert_{0}_".format(self.type)
-        win_type = "win32" if self.conv else "win64"
-        name += convert_suffix(direction, win_type, unwrap, struct.is_wrapped())
+        if copy:
+            name = "copy_{0}".format(self.type)
+        else:
+            name = "convert_{0}_".format(self.type)
+            win_type = "win32" if self.conv else "win64"
+            name += convert_suffix(direction, win_type, unwrap, struct.is_wrapped())
         self.name = name
 
     def __eq__(self, other):
@@ -2229,7 +2288,7 @@ class StructConversionFunction(object):
 
         body = ""
 
-        if not self.conv:
+        if not self.conv and not self.copy:
             body += "#ifdef _WIN64\n"
 
         needs_alloc = self.direction != Direction.OUTPUT and self.operand.needs_alloc(self.conv, self.unwrap)
@@ -2239,8 +2298,11 @@ class StructConversionFunction(object):
         if self.direction == Direction.OUTPUT and self.const:
             win_type = "const " + win_type
 
-        if self.conv:
+        if self.copy:
+            body += "void {0}(".format(self.name)
+        else:
             body += "static void {0}(".format(self.name)
+        if self.conv:
 
             if self.direction == Direction.OUTPUT:
                 params = ["const {0} *in".format(self.type), "{0} *out".format(win_type)]
@@ -2257,8 +2319,6 @@ class StructConversionFunction(object):
             body += ")\n"
 
         else:
-            body += "static void {0}(".format(self.name)
-
             params = ["const {0} *in".format(self.type), "{0} *out".format(self.type)]
 
             # Generate parameter list
@@ -2271,8 +2331,6 @@ class StructConversionFunction(object):
 
         if self.direction == Direction.OUTPUT and not any([any([self.member_needs_copy(ext, m) for m in ext]) for ext in self.operand.struct_extensions]):
             needs_extensions = False
-        if len(self.operand.struct_extensions) == 0:
-            needs_extensions = False
 
         body += "{\n"
         if needs_extensions:
@@ -2303,7 +2361,7 @@ class StructConversionFunction(object):
                 body += " || ".join("selector == {}".format(s) for s in m.selection)
                 body += ")\n    "
 
-            body += "    " + m.copy("in->", "out->", self.direction, self.conv, self.unwrap, self.const, conversions)
+            body += "    " + m.copy("in->", "out->", self.direction, self.conv, self.unwrap, self.copy, self.const, conversions)
 
         if needs_extensions:
             if self.conv and self.direction == Direction.INPUT:
@@ -2316,11 +2374,13 @@ class StructConversionFunction(object):
 
             ident = "            "
 
-            if self.direction == Direction.INPUT and self.type in STRUCT_CHAIN_CONVERSIONS \
-                    and "strip" in STRUCT_CHAIN_CONVERSIONS[self.type]:
-                for i in STRUCT_CHAIN_CONVERSIONS[self.type]["strip"]:
+            if self.direction == Direction.INPUT and self.type in STRUCT_CHAIN_CONVERSIONS:
+                has_any_chain_conversions = False
+                for i in STRUCT_CHAIN_CONVERSIONS[self.type]:
                     body += "        case {0}:\n".format(i)
-                body += ident + "break;\n"
+                    has_any_chain_conversions = True
+                if has_any_chain_conversions:
+                    body += ident + "break;\n"
 
             for ext in self.operand.struct_extensions:
                 if not ext.required:
@@ -2330,6 +2390,8 @@ class StructConversionFunction(object):
                     continue
 
                 stype = next(x for x in ext.members if x.name == "sType").values
+                if self.type in STRUCT_CHAIN_CONVERSIONS and stype in STRUCT_CHAIN_CONVERSIONS[self.type]:
+                    continue
                 win_type = ext.name + "32" if self.conv and ext.needs_win32_type() else ext.name
                 if self.direction == Direction.INPUT:
                     in_type = "const " + win_type
@@ -2358,7 +2420,7 @@ class StructConversionFunction(object):
                     if m.name == "pNext":
                         copy_body += ident + "out_ext->pNext = NULL;\n"
                         continue
-                    copy_body += ident + m.copy("in_ext->", "out_ext->", self.direction, self.conv, Unwrap.HOST, self.const, conversions)
+                    copy_body += ident + m.copy("in_ext->", "out_ext->", self.direction, self.conv, Unwrap.HOST, self.copy, self.const, conversions)
 
                 # Generate the definition of "in_ext" if we need it
                 if "in_ext->" in copy_body:
@@ -2373,7 +2435,18 @@ class StructConversionFunction(object):
 
             body += "        default:\n"
             if self.direction == Direction.INPUT:
-                body += ident + "FIXME(\"Unhandled sType %u.\\n\", in_header->sType);\n"
+                body += ident + "if ((in_header->sType >> 16) == 0x7ead)\n"
+                body += ident + "{\n"
+                body += ident + "    VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);\n";
+                body += ident + "    memcpy(out_ext, in_header, 32);\n";
+                body += ident + "    out_ext->pNext = NULL;\n";
+                body += ident + "    out_header->pNext = (void *)out_ext;\n";
+                body += ident + "    out_header = (void *)out_ext;\n";
+                body += ident + "}\n"
+                body += ident + "else\n"
+                body += ident + "{\n"
+                body += ident + "    FIXME(\"Unhandled sType %u.\\n\", in_header->sType);\n"
+                body += ident + "}\n"
             body += "            break;\n"
             body += "        }\n"
             body += "    }\n"
@@ -2382,7 +2455,7 @@ class StructConversionFunction(object):
             body += "        FIXME(\"Unexpected pNext\\n\");\n"
 
         body += "}\n"
-        if not self.conv:
+        if not self.conv and not self.copy:
             body += "#endif /* _WIN64 */\n"
         body += "\n"
 
@@ -2894,9 +2967,13 @@ class VkGenerator(object):
 
             f.write("struct {0}_params\n".format(vk_func.name))
             f.write("{\n");
+            extra_param_is_new = True
             for p in vk_func.params:
                 f.write("    {0};\n".format(p.definition(is_member=True)))
-            if vk_func.extra_param:
+                if p.name == vk_func.extra_param:
+                    extra_param_is_new = False
+
+            if vk_func.extra_param and extra_param_is_new:
                 f.write("    void *{0};\n".format(vk_func.extra_param))
             if vk_func.type != "void":
                 f.write("    {0} result;\n".format(vk_func.type))
@@ -2989,7 +3066,7 @@ class VkGenerator(object):
         # Note: unions are stored in structs for dependency reasons,
         # see comment in parsing section.
         for struct in self.registry.structs:
-            if struct.required and struct.name != "SECURITY_ATTRIBUTES":
+            if struct.required:
                 LOGGER.debug("Generating struct: {0}".format(struct.name))
                 f.write(struct.definition(align=True))
                 f.write("\n")
@@ -3046,6 +3123,28 @@ class VkGenerator(object):
                 f.write(" \\\n    USE_VK_FUNC({0})".format(vk_func.name))
         f.write("\n\n")
 
+        f.write("typedef VkResult (*PFN_native_vkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *,\n")
+        f.write("                                                       void * (*)(VkInstance, const char *), void *);\n");
+        f.write("typedef VkResult (*PFN_native_vkCreateDevice)(VkPhysicalDevice, const VkDeviceCreateInfo *, const VkAllocationCallbacks *, VkDevice *,\n");
+        f.write("                                                     void * (*)(VkInstance, const char *), void *);\n\n");
+        f.write("typedef struct VkCreateInfoWineDeviceCallback {\n");
+        f.write("    VkStructureType             sType;\n");
+        f.write("    const void*                 pNext;\n");
+        f.write("    PFN_native_vkCreateDevice   native_create_callback;\n");
+        f.write("    void*                       context;\n");
+        f.write("} VkCreateInfoWineDeviceCallback;\n");
+
+        f.write("#define VK_STRUCTURE_TYPE_CREATE_INFO_WINE_DEVICE_CALLBACK 2125312001\n");
+
+        f.write("typedef struct VkCreateInfoWineInstanceCallback {\n");
+        f.write("    VkStructureType             sType;\n");
+        f.write("    const void*                 pNext;\n");
+        f.write("    PFN_native_vkCreateInstance native_create_callback;\n");
+        f.write("    void*                       context;\n");
+        f.write("} VkCreateInfoWineInstanceCallback;\n");
+
+        f.write("#define VK_STRUCTURE_TYPE_CREATE_INFO_WINE_INSTANCE_CALLBACK 2125312002\n");
+
         f.write("#endif /* __WINE_VULKAN_H */\n")
 
     def generate_vulkan_spec(self, f):
@@ -3128,7 +3227,10 @@ class VkRegistry(object):
         self.video_copyright = video_root.find('./comment').text
 
         root.extend(video_root)
-        root.extend(ET.parse("winevk.xml").getroot())
+
+        tree_custom = ET.parse("vk_custom.xml")
+        root_custom = tree_custom.getroot()
+        root.extend(root_custom)
 
         self._parse_enums(root)
         self._parse_types(root)
diff -ruN --show-c-function vanilla-1017/dlls/winevulkan/vk_custom.xml protonvulkan-1017/dlls/winevulkan/vk_custom.xml
--- vanilla-1017/dlls/winevulkan/vk_custom.xml	1969-12-31 16:00:00.000000000 -0800
+++ protonvulkan-1017/dlls/winevulkan/vk_custom.xml	2025-10-21 17:23:40.649096597 -0700
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<registry>
+    <commands>
+        <command successcodes="VK_SUCCESS,VK_TIMEOUT" errorcodes="VK_ERROR_UNKNOWN">
+            <proto><type>VkResult</type> <name>wine_vkAcquireKeyedMutex</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDeviceMemory</type> <name>memory</name></param>
+            <param><type>uint64_t</type> <name>key</name></param>
+            <param><type>uint32_t</type> <name>timeout_ms</name></param>
+        </command>
+        <command successcodes="VK_SUCCESS" errorcodes="VK_ERROR_UNKNOWN">
+            <proto><type>VkResult</type> <name>wine_vkReleaseKeyedMutex</name></proto>
+            <param><type>VkDevice</type> <name>device</name></param>
+            <param><type>VkDeviceMemory</type> <name>memory</name></param>
+            <param><type>uint64_t</type> <name>key</name></param>
+        </command>
+    </commands>
+    <feature api="vulkan,vulkansc" name="WINE_CUSTOM" comment="Wine custom functions.">
+        <require>
+            <command name="wine_vkAcquireKeyedMutex"/>
+            <command name="wine_vkReleaseKeyedMutex"/>
+        </require>
+    </feature>
+</registry>
diff -ruN --show-c-function vanilla-1017/dlls/winevulkan/vulkan.c protonvulkan-1017/dlls/winevulkan/vulkan.c
--- vanilla-1017/dlls/winevulkan/vulkan.c	2025-10-21 17:44:36.083775116 -0700
+++ protonvulkan-1017/dlls/winevulkan/vulkan.c	2025-10-21 17:23:40.652383564 -0700
@@ -23,6 +23,23 @@
 
 #include "config.h"
 #include <time.h>
+#include <unistd.h>
+#include <stdbool.h>
+#include <errno.h>
+#include <stdio.h>
+#include <assert.h>
+#include <limits.h>
+#ifdef HAVE_SYS_SYSCALL_H
+# include <sys/syscall.h>
+#endif
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winnt.h"
+#include "winioctl.h"
+#include "wine/server.h"
+#include "wine/list.h"
 
 #include "vulkan_private.h"
 #include "wine/vulkan_driver.h"
@@ -32,6 +49,8 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
 
+static int debug_level;
+
 static PFN_vkCreateInstance p_vkCreateInstance;
 static PFN_vkEnumerateInstanceVersion p_vkEnumerateInstanceVersion;
 static PFN_vkEnumerateInstanceExtensionProperties p_vkEnumerateInstanceExtensionProperties;
@@ -42,10 +61,16 @@ static struct wine_instance *wine_instan
     return CONTAINING_RECORD(object, struct wine_instance, obj);
 }
 
-static struct wine_device *wine_device_from_handle(VkDevice handle)
+static struct wine_phys_dev *wine_phys_dev_from_handle(VkPhysicalDevice handle)
+{
+    struct vulkan_physical_device *object = vulkan_physical_device_from_handle(handle);
+    return CONTAINING_RECORD(object, struct wine_phys_dev, obj);
+}
+
+static struct wine_semaphore *wine_semaphore_from_handle(VkSemaphore handle)
 {
-    struct vulkan_device *object = vulkan_device_from_handle(handle);
-    return CONTAINING_RECORD(object, struct wine_device, obj);
+    struct vulkan_semaphore *object = vulkan_semaphore_from_handle(handle);
+    return CONTAINING_RECORD(object, struct wine_semaphore, obj);
 }
 
 static void vulkan_object_init_ptr( struct vulkan_object *obj, UINT64 host_handle, struct vulkan_client_object *client )
@@ -84,6 +109,24 @@ static uint32_t wine_vk_count_struct_(vo
 
 const struct vulkan_funcs *vk_funcs;
 
+#define wine_vk_find_unlink_struct(s, t) wine_vk_find_unlink_struct_((void *)s, VK_STRUCTURE_TYPE_##t)
+static void *wine_vk_find_unlink_struct_(void *s, VkStructureType t)
+{
+    VkBaseInStructure *prev = s;
+    VkBaseInStructure *header;
+
+    for (header = (VkBaseInStructure *)prev->pNext; header; prev = header, header = (VkBaseInStructure *)header->pNext)
+    {
+        if (header->sType == t) {
+            prev->pNext = header->pNext;
+            header->pNext = NULL;
+            return header;
+        }
+    }
+
+    return NULL;
+}
+
 static int vulkan_object_compare(const void *key, const struct rb_entry *entry)
 {
     struct vulkan_object *object = RB_ENTRY_VALUE(entry, struct vulkan_object, entry);
@@ -158,6 +201,57 @@ static void append_debug_utils_object(co
     dst->object_name_len = append_string(object->pObjectName, strings, strings_len);
 }
 
+static void signal_timeline_sem(struct vulkan_device *device, VkSemaphore sem, UINT64 *value)
+{
+    /* May be called from native thread. */
+    struct VkSemaphoreSignalInfo info = { 0 };
+    VkResult res;
+
+    info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO;
+    info.semaphore = sem;
+    info.value = *value + 1;
+    __atomic_store_n(value, info.value, __ATOMIC_RELEASE);
+    if (device->physical_device->api_version < VK_API_VERSION_1_2 || device->physical_device->instance->api_version < VK_API_VERSION_1_2)
+        res = device->p_vkSignalSemaphoreKHR(device->host.device, &info);
+    else
+        res = device->p_vkSignalSemaphore(device->host.device, &info);
+    if (res != VK_SUCCESS)
+        fprintf(stderr, "err:winevulkan:signal_timeline_sem vkSignalSemaphore failed, res=%d.\n", res);
+}
+
+static VkResult wait_semaphores(struct vulkan_device *device, const VkSemaphoreWaitInfo *wait_info, uint64_t timeout)
+{
+    if (device->physical_device->api_version < VK_API_VERSION_1_2 || device->physical_device->instance->api_version < VK_API_VERSION_1_2)
+        return device->p_vkWaitSemaphoresKHR(device->host.device, wait_info, timeout);
+    return device->p_vkWaitSemaphores(device->host.device, wait_info, timeout);
+}
+
+static VkResult get_semaphore_value(struct vulkan_device *device, VkSemaphore sem, uint64_t *value)
+{
+    if (device->physical_device->api_version < VK_API_VERSION_1_2 || device->physical_device->instance->api_version < VK_API_VERSION_1_2)
+        return device->p_vkGetSemaphoreCounterValueKHR(device->host.device, sem, value);
+    return device->p_vkGetSemaphoreCounterValue(device->host.device, sem, value);
+}
+
+
+static void set_transient_client_handle(struct wine_instance *instance, uint64_t client_handle)
+{
+    uint64_t *handle = pthread_getspecific(instance->transient_object_handle);
+    if (!handle)
+    {
+        handle = malloc(sizeof(uint64_t));
+        pthread_setspecific(instance->transient_object_handle, handle);
+    }
+    *handle = client_handle;
+}
+
+static uint64_t get_transient_handle(struct wine_instance *instance)
+{
+    uint64_t *handle = pthread_getspecific(instance->transient_object_handle);
+    return handle && *handle;
+}
+
+
 static VkBool32 debug_utils_callback_conversion(VkDebugUtilsMessageSeverityFlagBitsEXT severity,
     VkDebugUtilsMessageTypeFlagsEXT message_types,
     const VkDebugUtilsMessengerCallbackDataEXT *callback_data,
@@ -168,6 +262,8 @@ static VkBool32 debug_utils_callback_con
     struct wine_debug_utils_messenger *object;
     struct debug_utils_object dummy_object, *objects;
     struct debug_utils_label dummy_label, *labels;
+    VkInstance instance;
+    struct wine_instance *wine_instance;
     UINT size, strings_len;
     char *ptr, *strings;
     ULONG ret_len;
@@ -177,13 +273,16 @@ static VkBool32 debug_utils_callback_con
     TRACE("%i, %u, %p, %p\n", severity, message_types, callback_data, user_data);
 
     object = user_data;
+    instance = object->instance->host.instance;
 
-    if (!object->instance->host.instance)
+    if (!instance)
     {
         /* instance wasn't yet created, this is a message from the host loader */
         return VK_FALSE;
     }
 
+    wine_instance = CONTAINING_RECORD(object->instance, struct wine_instance, obj);
+
     if ((address = callback_data->pNext))
     {
         if (address->sType != VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT) address = NULL;
@@ -241,6 +340,8 @@ static VkBool32 debug_utils_callback_con
         {
             objects[i].object_handle = client_handle_from_host(object->instance, objects[i].object_handle);
             if (!objects[i].object_handle)
+                objects[i].object_handle = get_transient_handle(wine_instance);
+            if (!objects[i].object_handle)
             {
                 WARN("handle conversion failed 0x%s\n", wine_dbgstr_longlong(callback_data->pObjects[i].objectHandle));
                 free(params);
@@ -317,26 +418,29 @@ static VkBool32 debug_report_callback_co
     return VK_FALSE;
 }
 
-static void vulkan_physical_device_cleanup(struct vulkan_physical_device *physical_device)
+static void wine_phys_dev_cleanup(struct wine_phys_dev *phys_dev)
 {
-    free(physical_device->extensions);
+    free(phys_dev->extensions);
 }
 
-static VkResult vulkan_physical_device_init(struct vulkan_physical_device *physical_device,
-        VkPhysicalDevice host_physical_device, VkPhysicalDevice client_physical_device,
-        struct vulkan_instance *instance)
+static VkResult wine_vk_physical_device_init(struct wine_phys_dev *object, VkPhysicalDevice host_physical_device,
+        VkPhysicalDevice client_physical_device, struct vulkan_instance *instance)
 {
     BOOL have_memory_placed = FALSE, have_map_memory2 = FALSE;
     uint32_t num_host_properties, num_properties = 0;
     VkExtensionProperties *host_properties = NULL;
-    BOOL have_external_memory_host = FALSE;
+    VkPhysicalDeviceProperties physdev_properties;
+    BOOL have_external_memory_host = FALSE, have_external_memory_fd = FALSE, have_external_semaphore_fd = FALSE;
     VkResult res;
     unsigned int i, j;
 
-    vulkan_object_init_ptr(&physical_device->obj, (UINT_PTR)host_physical_device, &client_physical_device->obj);
-    physical_device->instance = instance;
+    vulkan_object_init_ptr(&object->obj.obj, (UINT_PTR)host_physical_device, &client_physical_device->obj);
+    object->obj.instance = instance;
+
+    instance->p_vkGetPhysicalDeviceMemoryProperties(host_physical_device, &object->memory_properties);
 
-    instance->p_vkGetPhysicalDeviceMemoryProperties(host_physical_device, &physical_device->memory_properties);
+    instance->p_vkGetPhysicalDeviceProperties(host_physical_device, &physdev_properties);
+    object->obj.api_version = physdev_properties.apiVersion;
 
     res = instance->p_vkEnumerateDeviceExtensionProperties(host_physical_device,
             NULL, &num_host_properties, NULL);
@@ -366,12 +470,28 @@ static VkResult vulkan_physical_device_i
      */
     for (i = 0; i < num_host_properties; i++)
     {
-        if (!strcmp(host_properties[i].extensionName, vk_funcs->p_get_host_extension("VK_KHR_external_memory_win32"))
-                || !strcmp(host_properties[i].extensionName, vk_funcs->p_get_host_extension("VK_KHR_external_semaphore_win32"))
-                || !strcmp(host_properties[i].extensionName, vk_funcs->p_get_host_extension("VK_KHR_external_fence_win32"))
-                || wine_vk_device_extension_supported(host_properties[i].extensionName))
+        if (!strcmp(host_properties[i].extensionName, "VK_KHR_external_memory_fd"))
+        {
+            TRACE("Substituting VK_KHR_external_memory_fd for VK_KHR_external_memory_win32\n");
+
+            snprintf(host_properties[i].extensionName, sizeof(host_properties[i].extensionName),
+                    VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME);
+            host_properties[i].specVersion = VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION;
+            have_external_memory_fd = TRUE;
+        }
+        if (!strcmp(host_properties[i].extensionName, "VK_KHR_external_semaphore_fd"))
         {
-            TRACE("Enabling extension '%s' for physical device %p\n", host_properties[i].extensionName, physical_device);
+            TRACE("Substituting VK_KHR_external_semaphore_fd for VK_KHR_external_semaphore_win32\n");
+
+            snprintf(host_properties[i].extensionName, sizeof(host_properties[i].extensionName),
+                    VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME);
+            host_properties[i].specVersion = VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION;
+            have_external_semaphore_fd = TRUE;
+        }
+
+        if (wine_vk_device_extension_supported(host_properties[i].extensionName))
+        {
+            TRACE("Enabling extension '%s' for physical device %p\n", host_properties[i].extensionName, object);
             num_properties++;
         }
         else
@@ -382,22 +502,39 @@ static VkResult vulkan_physical_device_i
             have_external_memory_host = TRUE;
         else if (!strcmp(host_properties[i].extensionName, "VK_EXT_map_memory_placed"))
             have_memory_placed = TRUE;
-        else if (!strcmp(host_properties[i].extensionName, "VK_EXT_surface_maintenance1"))
-            physical_device->has_surface_maintenance1 = true;
         else if (!strcmp(host_properties[i].extensionName, "VK_EXT_swapchain_maintenance1"))
-            physical_device->has_swapchain_maintenance1 = true;
+            object->obj.has_swapchain_maintenance1 = true;
         else if (!strcmp(host_properties[i].extensionName, "VK_KHR_map_memory2"))
             have_map_memory2 = TRUE;
     }
 
-    TRACE("Host supported extensions %u, Wine supported extensions %u\n", num_host_properties, num_properties);
+    if (have_external_memory_fd && have_external_semaphore_fd)
+        ++num_properties; /* VK_KHR_win32_keyed_mutex */
 
-    if (!(physical_device->extensions = calloc(num_properties, sizeof(*physical_device->extensions))))
+    if (!(object->extensions = calloc(num_properties, sizeof(*object->extensions))))
     {
         ERR("Failed to allocate memory for device extensions!\n");
         goto err;
     }
 
+    for (i = 0, j = 0; i < num_host_properties; i++)
+    {
+        if (wine_vk_device_extension_supported(host_properties[i].extensionName))
+        {
+            object->extensions[j] = host_properties[i];
+            j++;
+        }
+    }
+    if (have_external_memory_fd && have_external_semaphore_fd)
+    {
+        strcpy(object->extensions[j].extensionName, VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME);
+        object->extensions[j].specVersion = VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION;
+        TRACE("Enabling extension '%s' for physical device %p\n", object->extensions[j].extensionName, object);
+        ++j;
+    }
+    object->extension_count = num_properties;
+    TRACE("Host supported extensions %u, Wine supported extensions %u\n", num_host_properties, num_properties);
+
     if (zero_bits && have_memory_placed && have_map_memory2)
     {
         VkPhysicalDeviceMapMemoryPlacedFeaturesEXT map_placed_feature =
@@ -424,12 +561,12 @@ static VkResult vulkan_physical_device_i
             };
 
             instance->p_vkGetPhysicalDeviceProperties2(host_physical_device, &props);
-            physical_device->map_placed_align = map_placed_props.minPlacedMemoryMapAlignment;
-            TRACE( "Using placed map with alignment %u\n", physical_device->map_placed_align );
+            object->map_placed_align = map_placed_props.minPlacedMemoryMapAlignment;
+            TRACE( "Using placed map with alignment %u\n", object->map_placed_align );
         }
     }
 
-    if (zero_bits && have_external_memory_host && !physical_device->map_placed_align)
+    if (zero_bits && have_external_memory_host && !object->map_placed_align)
     {
         VkPhysicalDeviceExternalMemoryHostPropertiesEXT host_mem_props =
         {
@@ -441,47 +578,17 @@ static VkResult vulkan_physical_device_i
             .pNext = &host_mem_props,
         };
         instance->p_vkGetPhysicalDeviceProperties2KHR(host_physical_device, &props);
-        physical_device->external_memory_align = host_mem_props.minImportedHostPointerAlignment;
-        if (physical_device->external_memory_align)
+        object->external_memory_align = host_mem_props.minImportedHostPointerAlignment;
+        if (object->external_memory_align)
             TRACE("Using VK_EXT_external_memory_host for memory mapping with alignment: %u\n",
-                  physical_device->external_memory_align);
-    }
-
-    for (i = 0, j = 0; i < num_host_properties; i++)
-    {
-        if (!strcmp(host_properties[i].extensionName, vk_funcs->p_get_host_extension("VK_KHR_external_memory_win32")))
-        {
-            if (zero_bits && !physical_device->map_placed_align)
-            {
-                WARN("Cannot export WOW64 memory without VK_EXT_map_memory_placed\n");
-                continue;
-            }
-            strcpy(physical_device->extensions[j].extensionName, "VK_KHR_external_memory_win32");
-            physical_device->extensions[j++].specVersion = VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION;
-        }
-        else if (!strcmp(host_properties[i].extensionName, vk_funcs->p_get_host_extension("VK_KHR_external_semaphore_win32")))
-        {
-            strcpy(physical_device->extensions[j].extensionName, "VK_KHR_external_semaphore_win32");
-            physical_device->extensions[j++].specVersion = VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION;
-        }
-        else if (!strcmp(host_properties[i].extensionName, vk_funcs->p_get_host_extension("VK_KHR_external_fence_win32")))
-        {
-            strcpy(physical_device->extensions[j].extensionName, "VK_KHR_external_fence_win32");
-            physical_device->extensions[j++].specVersion = VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION;
-        }
-        else if (wine_vk_device_extension_supported(host_properties[i].extensionName))
-        {
-            physical_device->extensions[j] = host_properties[i];
-            j++;
-        }
+                  object->external_memory_align);
     }
-    physical_device->extension_count = j;
 
     free(host_properties);
     return VK_SUCCESS;
 
 err:
-    vulkan_physical_device_cleanup(physical_device);
+    wine_phys_dev_cleanup(object);
     free(host_properties);
     return res;
 }
@@ -490,14 +597,14 @@ static void wine_vk_free_command_buffers
         struct wine_cmd_pool *pool, uint32_t count, const VkCommandBuffer *buffers)
 {
     struct vulkan_instance *instance = device->physical_device->instance;
-    struct vulkan_command_buffer *buffer;
+    struct wine_cmd_buffer *buffer;
     unsigned int i;
 
     for (i = 0; i < count; i++)
     {
         if (!buffers[i])
             continue;
-        buffer = vulkan_command_buffer_from_handle(buffers[i]);
+        buffer = wine_cmd_buffer_from_handle(buffers[i]);
         if (!buffer)
             continue;
 
@@ -509,11 +616,10 @@ static void wine_vk_free_command_buffers
     }
 }
 
-static void wine_vk_device_init_queues(struct wine_device *object, const VkDeviceQueueCreateInfo *info)
+static void wine_vk_device_init_queues(struct vulkan_device *device, const VkDeviceQueueCreateInfo *info)
 {
-    struct wine_queue *queues = object->queues + object->queue_count;
-    struct vulkan_device *device = &object->obj;
-    VkQueue client_queues = device->client.device->queues + object->queue_count;
+    struct vulkan_queue *queues = device->queues + device->queue_count;
+    VkQueue client_queues = device->client.device->queues + device->queue_count;
     VkDeviceQueueInfo2 queue_info;
     UINT i;
 
@@ -521,7 +627,7 @@ static void wine_vk_device_init_queues(s
 
     for (i = 0; i < info->queueCount; i++)
     {
-        struct wine_queue *queue = queues + i;
+        struct vulkan_queue *queue = queues + i;
         VkQueue host_queue, client_queue = client_queues + i;
 
         /* The Vulkan spec says:
@@ -543,80 +649,132 @@ static void wine_vk_device_init_queues(s
             device->p_vkGetDeviceQueue(device->host.device, info->queueFamilyIndex, i, &host_queue);
         }
 
-        vulkan_object_init_ptr(&queue->obj.obj, (UINT_PTR)host_queue, &client_queue->obj);
-        queue->obj.device = device;
+        vulkan_object_init_ptr(&queue->obj, (UINT_PTR)host_queue, &client_queue->obj);
+        queue->device = device;
         queue->family_index = info->queueFamilyIndex;
         queue->queue_index = i;
         queue->flags = info->flags;
 
-        TRACE("Got device %p queue %p, host_queue %p.\n", device, queue, queue->obj.host.queue);
+        TRACE("Got device %p queue %p, host_queue %p.\n", device, queue, queue->host.queue);
     }
 
-    object->queue_count += info->queueCount;
+    device->queue_count += info->queueCount;
 }
 
-static VkResult wine_vk_device_convert_create_info(struct vulkan_physical_device *physical_device, struct conversion_context *ctx,
-        const VkDeviceCreateInfo *src, VkDeviceCreateInfo *dst, struct wine_device *device)
+static char *cc_strdup(struct conversion_context *ctx, const char *s)
 {
-    bool has_swapchain_maintenance1 = false;
-    bool has_external_memory_host = false;
-    bool has_surface_maintenance1 = false;
-    bool has_map_memory_placed = false;
-    bool has_external_memory = false;
-    bool has_map_memory2 = false;
-    bool has_swapchain = false;
-    const char **extensions;
-    uint32_t count;
+    int len = strlen(s) + 1;
+    char *ret;
 
-    *dst = *src;
+    ret = conversion_context_alloc(ctx, len);
+    memcpy(ret, s, len);
+    return ret;
+}
 
-    /* Should be filtered out by loader as ICDs don't support layers. */
-    dst->enabledLayerCount = 0;
-    dst->ppEnabledLayerNames = NULL;
+static void parse_xr_extensions(struct conversion_context *ctx, const char **extra_extensions, unsigned int *extra_count)
+{
+    char *iter, *start;
 
-    count = src->enabledExtensionCount;
-    extensions = conversion_context_alloc(ctx, (count + 16) * sizeof(*extensions));
-    memcpy(extensions, dst->ppEnabledExtensionNames, count * sizeof(*extensions));
-    dst->ppEnabledExtensionNames = extensions;
+    iter = getenv("__WINE_OPENXR_VK_DEVICE_EXTENSIONS");
+    if (!iter) return;
+    iter = cc_strdup(ctx, iter);
 
-    for (const char **extension = extensions, **end = extension + count; extension < end; extension++)
+    TRACE("got var: %s\n", iter);
+    start = iter;
+    do
     {
-        if (!wine_vk_device_extension_supported(*extension))
+        if(*iter == ' ')
         {
-            WARN("Extension %s is not supported.\n", debugstr_a(*extension));
-            return VK_ERROR_EXTENSION_NOT_PRESENT;
+            *iter = 0;
+            extra_extensions[(*extra_count)++] = cc_strdup(ctx, start);
+            TRACE("added %s to list\n", extra_extensions[(*extra_count) - 1]);
+            iter++;
+            start = iter;
         }
-        if (!strcmp(*extension, "VK_EXT_map_memory_placed")) has_map_memory_placed = true;
-        if (!strcmp(*extension, "VK_KHR_map_memory2")) has_map_memory2 = true;
-        if (!strcmp(*extension, "VK_KHR_external_memory")) has_external_memory = true;
-        if (!strcmp(*extension, "VK_EXT_external_memory_host")) has_external_memory_host = true;
-        if (!strcmp(*extension, "VK_EXT_swapchain_maintenance1")) has_swapchain_maintenance1 = true;
-        if (!strcmp(*extension, "VK_EXT_surface_maintenance1")) has_surface_maintenance1 = true;
-        if (!strcmp(*extension, "VK_KHR_swapchain")) has_swapchain = true;
-        if (!strcmp(*extension, "VK_KHR_external_memory_win32"))
+        else if(*iter == 0)
         {
-            if (zero_bits && !physical_device->map_placed_align)
-            {
-                FIXME("Cannot export WOW64 memory without VK_EXT_map_memory_placed\n");
-                return VK_ERROR_EXTENSION_NOT_PRESENT;
-            }
-            device->has_external_memory_win32 = true;
-            *extension = vk_funcs->p_get_host_extension("VK_KHR_external_memory_win32");
-            if (!strcmp(*extension, "VK_EXT_external_memory_dma_buf")) extensions[count++] = "VK_KHR_external_memory_fd";
-        }
-        if (!strcmp(*extension, "VK_KHR_external_semaphore_win32"))
-        {
-            device->has_external_semaphore_win32 = true;
-            *extension = vk_funcs->p_get_host_extension("VK_KHR_external_semaphore_win32");
+            extra_extensions[(*extra_count)++] = cc_strdup(ctx, start);
+            TRACE("added %s to list\n", extra_extensions[(*extra_count) - 1]);
+            break;
         }
-        if (!strcmp(*extension, "VK_KHR_external_fence_win32"))
+        else
         {
-            device->has_external_fence_win32 = true;
-            *extension = vk_funcs->p_get_host_extension("VK_KHR_external_fence_win32");
+            iter++;
         }
+    } while (1);
+}
+
+static const char *find_extension(const char *const *extensions, uint32_t count, const char *ext)
+{
+    while (count--)
+    {
+        if (!strcmp(extensions[count], ext))
+            return extensions[count];
     }
+    return NULL;
+}
 
-    if (physical_device->map_placed_align)
+static VkResult wine_vk_device_convert_create_info(VkPhysicalDevice client_physical_device,
+        struct conversion_context *ctx, const VkDeviceCreateInfo *src, VkDeviceCreateInfo *dst,
+        struct vulkan_device *device)
+{
+    static const char *wine_xr_extension_name = "VK_WINE_openxr_device_extensions";
+    struct wine_phys_dev *phys_dev = wine_phys_dev_from_handle(client_physical_device);
+    const char *extra_extensions[65], * const*extensions = src->ppEnabledExtensionNames;
+    unsigned int i, extra_count = 0, extensions_count = src->enabledExtensionCount;
+    unsigned int j, remove_count = 0;
+    const char *remove_extensions[65];
+    VkBaseOutStructure *header;
+
+    *dst = *src;
+    if ((header = (VkBaseOutStructure *)dst->pNext) && header->sType == VK_STRUCTURE_TYPE_CREATE_INFO_WINE_DEVICE_CALLBACK)
+        dst->pNext = header->pNext;
+
+    /* Should be filtered out by loader as ICDs don't support layers. */
+    dst->enabledLayerCount = 0;
+    dst->ppEnabledLayerNames = NULL;
+
+    TRACE("Enabled %u extensions.\n", extensions_count);
+    for (i = 0; i < extensions_count; i++)
+    {
+        const char *extension_name = extensions[i];
+        TRACE("Extension %u: %s.\n", i, debugstr_a(extension_name));
+    }
+
+    if (find_extension(extensions, extensions_count, wine_xr_extension_name))
+    {
+        parse_xr_extensions(ctx, extra_extensions, &extra_count);
+        remove_extensions[remove_count++] = wine_xr_extension_name;
+    }
+
+    if (find_extension(extensions, extensions_count, "VK_KHR_external_memory_win32"))
+    {
+        extra_extensions[extra_count++] = "VK_KHR_external_memory_fd";
+        remove_extensions[remove_count++] = "VK_KHR_external_memory_win32";
+    }
+
+    if (find_extension(extensions, extensions_count, "VK_KHR_external_semaphore_win32"))
+    {
+        extra_extensions[extra_count++] = "VK_KHR_external_semaphore_fd";
+        remove_extensions[remove_count++] = "VK_KHR_external_semaphore_win32";
+    }
+
+    if (find_extension(extensions, extensions_count, "VK_KHR_win32_keyed_mutex"))
+    {
+        if (!find_extension(extensions, extensions_count, "VK_KHR_external_memory_win32"))
+            extra_extensions[extra_count++] = "VK_KHR_external_memory_fd";
+        if (!find_extension(extensions, extensions_count, "VK_KHR_external_semaphore_win32"))
+            extra_extensions[extra_count++] = "VK_KHR_external_semaphore_fd";
+        remove_extensions[remove_count++] = "VK_KHR_win32_keyed_mutex";
+        device->keyed_mutexes_enabled = TRUE;
+    }
+
+
+    if ((phys_dev->obj.api_version < VK_API_VERSION_1_2 || phys_dev->obj.instance->api_version < VK_API_VERSION_1_2)
+                && !find_extension(extensions, extensions_count, "VK_KHR_timeline_semaphore"))
+        extra_extensions[extra_count++] = "VK_KHR_timeline_semaphore";
+
+    if (phys_dev->map_placed_align)
     {
         VkPhysicalDeviceMapMemoryPlacedFeaturesEXT *map_placed_features;
         map_placed_features = conversion_context_alloc(ctx, sizeof(*map_placed_features));
@@ -627,28 +785,51 @@ static VkResult wine_vk_device_convert_c
         map_placed_features->memoryUnmapReserve = VK_TRUE;
         dst->pNext = map_placed_features;
 
-        if (!has_map_memory_placed) extensions[count++] = "VK_EXT_map_memory_placed";
-        if (!has_map_memory2) extensions[count++] = "VK_KHR_map_memory2";
-    }
-    else if (physical_device->external_memory_align)
-    {
-        if (!has_external_memory) extensions[count++] = "VK_KHR_external_memory";
-        if (!has_external_memory_host) extensions[count++] = "VK_EXT_external_memory_host";
+        if (!find_extension(extensions, extensions_count, "VK_EXT_map_memory_placed"))
+            extra_extensions[extra_count++] = "VK_EXT_map_memory_placed";
+        if (!find_extension(extensions, extensions_count, "VK_KHR_map_memory2"))
+            extra_extensions[extra_count++] = "VK_KHR_map_memory2";
+    }
+    else if (phys_dev->external_memory_align)
+    {
+        if (!find_extension(extensions, extensions_count, "VK_KHR_external_memory"))
+            extra_extensions[extra_count++] = "VK_KHR_external_memory";
+        if (!find_extension(extensions, extensions_count, "VK_EXT_external_memory_host"))
+            extra_extensions[extra_count++] = "VK_EXT_external_memory_host";
     }
 
     /* win32u uses VkSwapchainPresentScalingCreateInfoEXT if available. */
-    if (physical_device->has_surface_maintenance1 && physical_device->has_swapchain_maintenance1 &&
-        has_swapchain && !has_swapchain_maintenance1)
+    if (phys_dev->obj.has_swapchain_maintenance1)
     {
-        if (!has_surface_maintenance1) extensions[count++] = "VK_EXT_surface_maintenance1";
-        extensions[count++] = "VK_EXT_swapchain_maintenance1";
+        if (!find_extension(extensions, extensions_count, "VK_EXT_swapchain_maintenance1"))
+            extra_extensions[extra_count++] = "VK_EXT_swapchain_maintenance1";
     }
 
-    TRACE("Enabling %u device extensions\n", count);
-    for (const char **extension = extensions, **end = extension + count; extension < end; extension++)
-        TRACE("  - %s\n", debugstr_a(*extension));
+    if (extra_count)
+    {
+        const char **new_extensions;
+
+        dst->enabledExtensionCount += extra_count;
+        new_extensions = conversion_context_alloc(ctx, dst->enabledExtensionCount * sizeof(*new_extensions));
+        memcpy(new_extensions, extensions, extensions_count * sizeof(*new_extensions));
+        for (i = 0; i < extensions_count; i++)
+        {
+            for (j = 0; j < remove_count; ++j)
+            {
+                if (!strcmp(new_extensions[i], remove_extensions[j]))
+                {
+                    --dst->enabledExtensionCount;
+                    --extensions_count;
+                    memmove(&new_extensions[i], &new_extensions[i + 1], sizeof(*new_extensions) * (extensions_count - i));
+                    --i;
+                    break;
+                }
+            }
+        }
+        memcpy(new_extensions + extensions_count, extra_extensions, extra_count * sizeof(*new_extensions));
+        dst->ppEnabledExtensionNames = new_extensions;
+    }
 
-    dst->enabledExtensionCount = count;
     return VK_SUCCESS;
 }
 
@@ -688,13 +869,15 @@ static VkResult wine_vk_instance_convert
 {
     VkDebugUtilsMessengerCreateInfoEXT *debug_utils_messenger;
     VkDebugReportCallbackCreateInfoEXT *debug_report_callback;
+    const char **new_extensions;
     VkBaseInStructure *header;
-    const char **extensions;
     unsigned int i;
-    uint32_t count;
 
     *dst = *src;
 
+    if ((header = (VkBaseInStructure *)dst->pNext) && header->sType == VK_STRUCTURE_TYPE_CREATE_INFO_WINE_INSTANCE_CALLBACK)
+        dst->pNext = header->pNext;
+
     instance->utils_messenger_count = wine_vk_count_struct(dst, DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT);
     instance->utils_messengers =  calloc(instance->utils_messenger_count, sizeof(*instance->utils_messengers));
     header = (VkBaseInStructure *) dst;
@@ -737,51 +920,46 @@ static VkResult wine_vk_instance_convert
     {
         const char *extension_name = src->ppEnabledExtensionNames[i];
         TRACE("Extension %u: %s.\n", i, debugstr_a(extension_name));
-        if (!wine_vk_instance_extension_supported(extension_name))
-        {
-            WARN("Extension %s is not supported.\n", debugstr_a(extension_name));
-            return VK_ERROR_EXTENSION_NOT_PRESENT;
-        }
     }
 
-    count = src->enabledExtensionCount;
-    extensions = conversion_context_alloc(ctx, (count + 2) * sizeof(*extensions));
-    memcpy(extensions, src->ppEnabledExtensionNames, count * sizeof(*dst->ppEnabledExtensionNames));
-    dst->ppEnabledExtensionNames = extensions;
+    new_extensions = conversion_context_alloc(ctx, (src->enabledExtensionCount + 2) *
+                                              sizeof(*src->ppEnabledExtensionNames));
+    memcpy(new_extensions, src->ppEnabledExtensionNames,
+           dst->enabledExtensionCount * sizeof(*dst->ppEnabledExtensionNames));
+    dst->ppEnabledExtensionNames = new_extensions;
     dst->enabledExtensionCount = src->enabledExtensionCount;
 
-    for (const char **extension = extensions, **end = extension + count; extension < end; extension++)
+    for (i = 0; i < dst->enabledExtensionCount; i++)
     {
-        if (!strcmp(*extension, "VK_EXT_debug_utils") || !strcmp(*extension, "VK_EXT_debug_report"))
+        const char *extension_name = dst->ppEnabledExtensionNames[i];
+        if (!strcmp(extension_name, "VK_EXT_debug_utils") || !strcmp(extension_name, "VK_EXT_debug_report"))
         {
             rb_init(&instance->objects, vulkan_object_compare);
             pthread_rwlock_init(&instance->objects_lock, NULL);
         }
-        if (!strcmp(*extension, "VK_KHR_win32_surface"))
+        if (!strcmp(extension_name, "VK_KHR_win32_surface"))
         {
-            *extension = vk_funcs->p_get_host_extension("VK_KHR_win32_surface");
+            new_extensions[i] = vk_funcs->p_get_host_surface_extension();
             instance->enable_win32_surface = VK_TRUE;
         }
     }
 
     if (use_external_memory())
     {
-        extensions[count++] = "VK_KHR_get_physical_device_properties2";
-        extensions[count++] = "VK_KHR_external_memory_capabilities";
+        new_extensions[dst->enabledExtensionCount++] = "VK_KHR_get_physical_device_properties2";
+        new_extensions[dst->enabledExtensionCount++] = "VK_KHR_external_memory_capabilities";
     }
 
-    TRACE("Enabling %u instance extensions\n", count);
-    for (const char **extension = extensions, **end = extension + count; extension < end; extension++)
-        TRACE("  - %s\n", debugstr_a(*extension));
+    TRACE("Enabled %u instance extensions.\n", dst->enabledExtensionCount);
 
-    dst->enabledExtensionCount = count;
     return VK_SUCCESS;
 }
 
 /* Helper function which stores wrapped physical devices in the instance object. */
-static VkResult wine_vk_instance_init_physical_devices(struct vulkan_instance *instance,
-        struct vulkan_physical_device *physical_devices)
+static VkResult wine_vk_instance_init_physical_devices(struct wine_instance *object)
 {
+    struct vulkan_instance *instance = &object->obj;
+    struct wine_phys_dev *physical_devices = object->phys_devs;
     VkInstance client_instance = instance->client.instance;
     VkPhysicalDevice *host_physical_devices;
     uint32_t phys_dev_count;
@@ -817,34 +995,34 @@ static VkResult wine_vk_instance_init_ph
     /* Wrap each host physical device handle into a dispatchable object for the ICD loader. */
     for (i = 0; i < phys_dev_count; i++)
     {
-        struct vulkan_physical_device *physical_device = physical_devices + i;
-        res = vulkan_physical_device_init(physical_device, host_physical_devices[i], &client_instance->phys_devs[i], instance);
+        struct wine_phys_dev *phys_dev = physical_devices + i;
+        res = wine_vk_physical_device_init(phys_dev, host_physical_devices[i], &client_instance->phys_devs[i], instance);
         if (res != VK_SUCCESS)
             goto err;
+        TRACE("added host_physical_devices[i] %p.\n", host_physical_devices[i]);
     }
-    instance->physical_device_count = phys_dev_count;
-    instance->physical_devices = physical_devices;
+    object->phys_dev_count = phys_dev_count;
 
     free(host_physical_devices);
     return VK_SUCCESS;
 
 err:
-    while (i) vulkan_physical_device_cleanup(&physical_devices[--i]);
+    while (i) wine_phys_dev_cleanup(&physical_devices[--i]);
     free(host_physical_devices);
     return res;
 }
 
-static struct vulkan_physical_device *vulkan_instance_get_physical_device(struct vulkan_instance *instance,
+static struct wine_phys_dev *wine_vk_instance_wrap_physical_device(struct wine_instance *instance,
         VkPhysicalDevice host_physical_device)
 {
-    struct vulkan_physical_device *physical_devices = instance->physical_devices;
-    uint32_t physical_device_count = instance->physical_device_count;
+    struct wine_phys_dev *physical_devices = instance->phys_devs;
+    uint32_t physical_device_count = instance->phys_dev_count;
     unsigned int i;
 
     for (i = 0; i < physical_device_count; ++i)
     {
-        struct vulkan_physical_device *current = physical_devices + i;
-        if (current->host.physical_device == host_physical_device) return current;
+        struct wine_phys_dev *current = physical_devices + i;
+        if (current->obj.host.physical_device == host_physical_device) return current;
     }
 
     ERR("Unrecognized physical device %p.\n", host_physical_device);
@@ -856,7 +1034,7 @@ VkResult wine_vkAllocateCommandBuffers(V
 {
     struct vulkan_device *device = vulkan_device_from_handle(client_device);
     struct vulkan_instance *instance = device->physical_device->instance;
-    struct vulkan_command_buffer *buffer;
+    struct wine_cmd_buffer *buffer;
     struct wine_cmd_pool *pool;
     VkResult res = VK_SUCCESS;
     unsigned int i;
@@ -912,9 +1090,15 @@ VkResult wine_vkCreateDevice(VkPhysicalD
     VkDevice host_device, client_device = client_ptr;
     VkDeviceCreateInfo create_info_host;
     struct conversion_context ctx;
-    struct wine_device *device;
-    unsigned int queue_count, i;
+    struct vulkan_device *device;
+    unsigned int queue_count, props_count, i;
     VkResult res;
+    size_t size;
+    void *ptr;
+
+    PFN_native_vkCreateDevice native_create_device = NULL;
+    void *native_create_device_context = NULL;
+    VkCreateInfoWineDeviceCallback *callback;
 
     if (allocator)
         FIXME("Support for allocation callbacks not implemented yet\n");
@@ -930,51 +1114,82 @@ VkResult wine_vkCreateDevice(VkPhysicalD
         TRACE("Driver version: %#x.\n", properties.driverVersion);
     }
 
+    size = sizeof(*device);
+
+    instance->p_vkGetPhysicalDeviceQueueFamilyProperties(physical_device->host.physical_device, &props_count, NULL);
+    size += props_count * sizeof(*device->queue_props);
+
     /* We need to cache all queues within the device as each requires wrapping since queues are dispatchable objects. */
     for (queue_count = 0, i = 0; i < create_info->queueCreateInfoCount; i++)
         queue_count += create_info->pQueueCreateInfos[i].queueCount;
+    size += queue_count * sizeof(*device->queues);
 
-    if (!(device = calloc(1, offsetof(struct wine_device, queues[queue_count]))))
-        return VK_ERROR_OUT_OF_HOST_MEMORY;
+    if (!(device = ptr = calloc(1, size))) return VK_ERROR_OUT_OF_HOST_MEMORY;
+    ptr = (char *)ptr + sizeof(*device);
+    device->queue_props = ptr;
+    ptr = (char *)ptr + props_count * sizeof(*device->queue_props);
+    device->queues = ptr;
+    ptr = (char *)ptr + queue_count * sizeof(*device->queues);
+
+    if ((callback = (VkCreateInfoWineDeviceCallback *)create_info->pNext)
+            && callback->sType == VK_STRUCTURE_TYPE_CREATE_INFO_WINE_DEVICE_CALLBACK)
+    {
+        native_create_device = callback->native_create_callback;
+        native_create_device_context = callback->context;
+    }
+
+    pthread_mutex_init(&device->signaller_mutex, NULL);
+    list_init(&device->sem_poll_list);
+    list_init(&device->free_fence_ops_list);
 
     init_conversion_context(&ctx);
-    res = wine_vk_device_convert_create_info(physical_device, &ctx, create_info, &create_info_host, device);
+    res = wine_vk_device_convert_create_info(client_physical_device, &ctx, create_info, &create_info_host, device);
     if (res == VK_SUCCESS)
-        res = instance->p_vkCreateDevice(physical_device->host.physical_device, &create_info_host,
-                                               NULL /* allocator */, &host_device);
+    {
+        if (native_create_device)
+            res = native_create_device(physical_device->host.physical_device, &create_info_host,
+                                       NULL /* allocator */, &host_device,
+                                       (void *)vk_funcs->p_vkGetInstanceProcAddr, native_create_device_context);
+        else
+            res = instance->p_vkCreateDevice(physical_device->host.physical_device, &create_info_host,
+                                             NULL /* allocator */, &host_device);
+    }
     free_conversion_context(&ctx);
     if (res != VK_SUCCESS)
     {
         WARN("Failed to create device, res=%d.\n", res);
+        pthread_mutex_destroy(&device->signaller_mutex);
         free(device);
         return res;
     }
 
-    vulkan_object_init_ptr(&device->obj.obj, (UINT_PTR)host_device, &client_device->obj);
-    device->obj.physical_device = physical_device;
+    vulkan_object_init_ptr(&device->obj, (UINT_PTR)host_device, &client_device->obj);
+    device->physical_device = physical_device;
 
     /* Just load all function pointers we are aware off. The loader takes care of filtering.
      * We use vkGetDeviceProcAddr as opposed to vkGetInstanceProcAddr for efficiency reasons
      * as functions pass through fewer dispatch tables within the loader.
      */
 #define USE_VK_FUNC(name)                                                                          \
-    device->obj.p_##name = (void *)vk_funcs->p_vkGetDeviceProcAddr(device->obj.host.device, #name);  \
-    if (device->obj.p_##name == NULL) TRACE("Not found '%s'.\n", #name);
+    device->p_##name = (void *)vk_funcs->p_vkGetDeviceProcAddr(device->host.device, #name);  \
+    if (device->p_##name == NULL) TRACE("Not found '%s'.\n", #name);
     ALL_VK_DEVICE_FUNCS
 #undef USE_VK_FUNC
 
+    instance->p_vkGetPhysicalDeviceQueueFamilyProperties(physical_device->host.physical_device, &props_count, device->queue_props);
+
     for (i = 0; i < create_info_host.queueCreateInfoCount; i++)
         wine_vk_device_init_queues(device, create_info_host.pQueueCreateInfos + i);
 
     client_device->quirks = CONTAINING_RECORD(instance, struct wine_instance, obj)->quirks;
 
-    TRACE("Created device %p, host_device %p.\n", device, device->obj.host.device);
+    TRACE("Created device %p, host_device %p.\n", device, device->host.device);
     for (i = 0; i < device->queue_count; i++)
     {
-        struct wine_queue *queue = device->queues + i;
-        vulkan_instance_insert_object(instance, &queue->obj.obj);
+        struct vulkan_queue *queue = device->queues + i;
+        vulkan_instance_insert_object(instance, &queue->obj);
     }
-    vulkan_instance_insert_object(instance, &device->obj.obj);
+    vulkan_instance_insert_object(instance, &device->obj);
 
     *ret = client_device;
     return VK_SUCCESS;
@@ -984,29 +1199,43 @@ VkResult wine_vkCreateInstance(const VkI
                                const VkAllocationCallbacks *allocator, VkInstance *ret,
                                void *client_ptr)
 {
+    PFN_native_vkCreateInstance native_create_instance = NULL;
+    void *native_create_instance_context = NULL;
+    VkCreateInfoWineInstanceCallback *callback;
     VkInstanceCreateInfo create_info_host;
     const VkApplicationInfo *app_info;
     struct conversion_context ctx;
     struct wine_instance *instance;
     VkInstance host_instance, client_instance = client_ptr;
-    struct vulkan_physical_device *physical_devices;
     unsigned int i;
     VkResult res;
 
     if (allocator)
         FIXME("Support for allocation callbacks not implemented yet\n");
 
-    if (!(instance = calloc(1, sizeof(*instance) + sizeof(*physical_devices) * client_instance->phys_dev_count)))
+    if (!(instance = calloc(1, offsetof(struct wine_instance, phys_devs[client_instance->phys_dev_count]))))
     {
         ERR("Failed to allocate memory for instance\n");
         return VK_ERROR_OUT_OF_HOST_MEMORY;
     }
-    physical_devices = (struct vulkan_physical_device *)(instance + 1);
+
+    if ((callback = (VkCreateInfoWineInstanceCallback *)create_info->pNext)
+            && callback->sType == VK_STRUCTURE_TYPE_CREATE_INFO_WINE_INSTANCE_CALLBACK)
+    {
+        native_create_instance = callback->native_create_callback;
+        native_create_instance_context = callback->context;
+    }
 
     init_conversion_context(&ctx);
     res = wine_vk_instance_convert_create_info(&ctx, create_info, &create_info_host, instance);
     if (res == VK_SUCCESS)
-        res = p_vkCreateInstance(&create_info_host, NULL /* allocator */, &host_instance);
+    {
+        if (native_create_instance)
+            res = native_create_instance(&create_info_host, NULL /* allocator */, &host_instance,
+                    (void *)vk_funcs->p_vkGetInstanceProcAddr, native_create_instance_context);
+        else
+            res = p_vkCreateInstance(&create_info_host, NULL /* allocator */, &host_instance);
+    }
     free_conversion_context(&ctx);
     if (res != VK_SUCCESS)
     {
@@ -1034,7 +1263,7 @@ VkResult wine_vkCreateInstance(const VkI
      * the host physical devices and present those to the application.
      * Cleanup happens as part of wine_vkDestroyInstance.
      */
-    res = wine_vk_instance_init_physical_devices(&instance->obj, physical_devices);
+    res = wine_vk_instance_init_physical_devices(instance);
     if (res != VK_SUCCESS)
     {
         ERR("Failed to load physical devices, res=%d\n", res);
@@ -1052,16 +1281,20 @@ VkResult wine_vkCreateInstance(const VkI
                 app_info->engineVersion);
         TRACE("API version %#x.\n", app_info->apiVersion);
 
+        instance->obj.api_version = app_info->apiVersion;
+
         if (app_info->pEngineName && !strcmp(app_info->pEngineName, "idTech"))
             instance->quirks |= WINEVULKAN_QUIRK_GET_DEVICE_PROC_ADDR;
     }
 
+    pthread_key_create(&instance->transient_object_handle, free);
+
     TRACE("Created instance %p, host_instance %p.\n", instance, instance->obj.host.instance);
 
-    for (i = 0; i < instance->obj.physical_device_count; i++)
+    for (i = 0; i < instance->phys_dev_count; i++)
     {
-        struct vulkan_physical_device *physical_device = &instance->obj.physical_devices[i];
-        vulkan_instance_insert_object(&instance->obj, &physical_device->obj);
+        struct wine_phys_dev *phys_dev = &instance->phys_devs[i];
+        vulkan_instance_insert_object(&instance->obj, &phys_dev->obj.obj);
     }
     vulkan_instance_insert_object(&instance->obj, &instance->obj.obj);
 
@@ -1071,8 +1304,9 @@ VkResult wine_vkCreateInstance(const VkI
 
 void wine_vkDestroyDevice(VkDevice client_device, const VkAllocationCallbacks *allocator)
 {
-    struct wine_device *device = wine_device_from_handle(client_device);
-    struct vulkan_instance *instance = device->obj.physical_device->instance;
+    struct pending_d3d12_fence_op *op, *next;
+    struct vulkan_device *device = vulkan_device_from_handle(client_device);
+    struct vulkan_instance *instance = device->physical_device->instance;
     unsigned int i;
 
     if (allocator)
@@ -1080,10 +1314,30 @@ void wine_vkDestroyDevice(VkDevice clien
     if (!device)
         return;
 
-    device->obj.p_vkDestroyDevice(device->obj.host.device, NULL /* pAllocator */);
+    if (device->signaller_thread)
+    {
+        TRACE("Shutting down signaller thread.\n");
+        pthread_mutex_lock(&device->signaller_mutex);
+        device->stop = 1;
+        signal_timeline_sem(device, device->sem_poll_update.sem, &device->sem_poll_update.value);
+        pthread_mutex_unlock(&device->signaller_mutex);
+        pthread_join(device->signaller_thread, NULL);
+        device->p_vkDestroySemaphore(device->host.device, device->sem_poll_update.sem, NULL);
+        pthread_cond_destroy(&device->sem_poll_updated_cond);
+        TRACE("Signaller thread shut down.\n");
+    }
+    pthread_mutex_destroy(&device->signaller_mutex);
+
+    LIST_FOR_EACH_ENTRY_SAFE(op, next, &device->free_fence_ops_list, struct pending_d3d12_fence_op, entry)
+    {
+        device->p_vkDestroySemaphore(device->host.device, op->local_sem.sem, NULL);
+        free(op);
+    }
+
+    device->p_vkDestroyDevice(device->host.device, NULL /* pAllocator */);
     for (i = 0; i < device->queue_count; i++)
-        vulkan_instance_remove_object(instance, &device->queues[i].obj.obj);
-    vulkan_instance_remove_object(instance, &device->obj.obj);
+        vulkan_instance_remove_object(instance, &device->queues[i].obj);
+    vulkan_instance_remove_object(instance, &device->obj);
 
     free(device);
 }
@@ -1099,13 +1353,15 @@ void wine_vkDestroyInstance(VkInstance c
         return;
 
     instance->obj.p_vkDestroyInstance(instance->obj.host.instance, NULL /* allocator */);
-    for (i = 0; i < instance->obj.physical_device_count; i++)
+    for (i = 0; i < instance->phys_dev_count; i++)
     {
-        vulkan_instance_remove_object(&instance->obj, &instance->obj.physical_devices[i].obj);
-        vulkan_physical_device_cleanup(&instance->obj.physical_devices[i]);
+        vulkan_instance_remove_object(&instance->obj, &instance->phys_devs[i].obj.obj);
+        wine_phys_dev_cleanup(&instance->phys_devs[i]);
     }
     vulkan_instance_remove_object(&instance->obj, &instance->obj.obj);
 
+    pthread_key_delete(instance->transient_object_handle);
+
     if (instance->objects.compare) pthread_rwlock_destroy(&instance->objects_lock);
     free(instance->utils_messengers);
     free(instance);
@@ -1114,7 +1370,7 @@ void wine_vkDestroyInstance(VkInstance c
 VkResult wine_vkEnumerateDeviceExtensionProperties(VkPhysicalDevice client_physical_device, const char *layer_name,
                                                    uint32_t *count, VkExtensionProperties *properties)
 {
-    struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle(client_physical_device);
+    struct wine_phys_dev *phys_dev = wine_phys_dev_from_handle(client_physical_device);
 
     /* This shouldn't get called with layer_name set, the ICD loader prevents it. */
     if (layer_name)
@@ -1125,15 +1381,15 @@ VkResult wine_vkEnumerateDeviceExtension
 
     if (!properties)
     {
-        *count = physical_device->extension_count;
+        *count = phys_dev->extension_count;
         return VK_SUCCESS;
     }
 
-    *count = min(*count, physical_device->extension_count);
-    memcpy(properties, physical_device->extensions, *count * sizeof(*properties));
+    *count = min(*count, phys_dev->extension_count);
+    memcpy(properties, phys_dev->extensions, *count * sizeof(*properties));
 
     TRACE("Returning %u extensions.\n", *count);
-    return *count < physical_device->extension_count ? VK_INCOMPLETE : VK_SUCCESS;
+    return *count < phys_dev->extension_count ? VK_INCOMPLETE : VK_SUCCESS;
 }
 
 VkResult wine_vkEnumerateInstanceExtensionProperties(const char *name, uint32_t *count,
@@ -1229,23 +1485,23 @@ VkResult wine_vkEnumerateInstanceVersion
 
 VkResult wine_vkEnumeratePhysicalDevices(VkInstance client_instance, uint32_t *count, VkPhysicalDevice *client_physical_devices)
 {
-    struct vulkan_instance *instance = vulkan_instance_from_handle(client_instance);
+    struct wine_instance *instance = wine_instance_from_handle(client_instance);
     unsigned int i;
 
     if (!client_physical_devices)
     {
-        *count = instance->physical_device_count;
+        *count = instance->phys_dev_count;
         return VK_SUCCESS;
     }
 
-    *count = min(*count, instance->physical_device_count);
+    *count = min(*count, instance->phys_dev_count);
     for (i = 0; i < *count; i++)
     {
-        client_physical_devices[i] = instance->physical_devices[i].client.physical_device;
+        client_physical_devices[i] = instance->phys_devs[i].obj.client.physical_device;
     }
 
     TRACE("Returning %u devices.\n", *count);
-    return *count < instance->physical_device_count ? VK_INCOMPLETE : VK_SUCCESS;
+    return *count < instance->phys_dev_count ? VK_INCOMPLETE : VK_SUCCESS;
 }
 
 void wine_vkFreeCommandBuffers(VkDevice client_device, VkCommandPool command_pool, uint32_t count,
@@ -1259,8 +1515,8 @@ void wine_vkFreeCommandBuffers(VkDevice
 
 static VkQueue wine_vk_device_find_queue(VkDevice client_device, const VkDeviceQueueInfo2 *info)
 {
-    struct wine_device *device = wine_device_from_handle(client_device);
-    struct wine_queue *queue;
+    struct vulkan_device *device = vulkan_device_from_handle(client_device);
+    struct vulkan_queue *queue;
     uint32_t i;
 
     for (i = 0; i < device->queue_count; i++)
@@ -1270,7 +1526,7 @@ static VkQueue wine_vk_device_find_queue
                 && queue->queue_index == info->queueIndex
                 && queue->flags == info->flags)
         {
-            return queue->obj.client.queue;
+            return queue->client.queue;
         }
     }
 
@@ -1346,14 +1602,14 @@ void wine_vkDestroyCommandPool(VkDevice
     free(pool);
 }
 
-static VkResult wine_vk_enumerate_physical_device_groups(struct vulkan_instance *instance,
+static VkResult wine_vk_enumerate_physical_device_groups(struct wine_instance *instance,
         VkResult (*p_vkEnumeratePhysicalDeviceGroups)(VkInstance, uint32_t *, VkPhysicalDeviceGroupProperties *),
         uint32_t *count, VkPhysicalDeviceGroupProperties *properties)
 {
     unsigned int i, j;
     VkResult res;
 
-    res = p_vkEnumeratePhysicalDeviceGroups(instance->host.instance, count, properties);
+    res = p_vkEnumeratePhysicalDeviceGroups(instance->obj.host.instance, count, properties);
     if (res < 0 || !properties)
         return res;
 
@@ -1363,9 +1619,10 @@ static VkResult wine_vk_enumerate_physic
         for (j = 0; j < current->physicalDeviceCount; ++j)
         {
             VkPhysicalDevice host_physical_device = current->physicalDevices[j];
-            struct vulkan_physical_device *physical_device = vulkan_instance_get_physical_device(instance, host_physical_device);
-            if (!physical_device) return VK_ERROR_INITIALIZATION_FAILED;
-            current->physicalDevices[j] = physical_device->client.physical_device;
+            struct wine_phys_dev *phys_dev = wine_vk_instance_wrap_physical_device(instance, host_physical_device);
+            if (!phys_dev)
+                return VK_ERROR_INITIALIZATION_FAILED;
+            current->physicalDevices[j] = phys_dev->obj.client.physical_device;
         }
     }
 
@@ -1375,19 +1632,19 @@ static VkResult wine_vk_enumerate_physic
 VkResult wine_vkEnumeratePhysicalDeviceGroups(VkInstance client_instance, uint32_t *count,
                                               VkPhysicalDeviceGroupProperties *properties)
 {
-    struct vulkan_instance *instance = vulkan_instance_from_handle(client_instance);
+    struct wine_instance *instance = wine_instance_from_handle(client_instance);
 
     return wine_vk_enumerate_physical_device_groups(instance,
-            instance->p_vkEnumeratePhysicalDeviceGroups, count, properties);
+            instance->obj.p_vkEnumeratePhysicalDeviceGroups, count, properties);
 }
 
 VkResult wine_vkEnumeratePhysicalDeviceGroupsKHR(VkInstance client_instance, uint32_t *count,
                                                  VkPhysicalDeviceGroupProperties *properties)
 {
-    struct vulkan_instance *instance = vulkan_instance_from_handle(client_instance);
+    struct wine_instance *instance = wine_instance_from_handle(client_instance);
 
     return wine_vk_enumerate_physical_device_groups(instance,
-            instance->p_vkEnumeratePhysicalDeviceGroupsKHR, count, properties);
+            instance->obj.p_vkEnumeratePhysicalDeviceGroupsKHR, count, properties);
 }
 
 void wine_vkGetPhysicalDeviceExternalFenceProperties(VkPhysicalDevice client_physical_device,
@@ -1408,6 +1665,146 @@ void wine_vkGetPhysicalDeviceExternalFen
     properties->externalFenceFeatures = 0;
 }
 
+static inline void wine_vk_normalize_handle_types_win(VkExternalMemoryHandleTypeFlags *types)
+{
+    *types &=
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT;
+}
+
+static inline void wine_vk_normalize_handle_types_host(VkExternalMemoryHandleTypeFlags *types)
+{
+    *types &=
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT |
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT |
+/*      predicated on VK_KHR_external_memory_dma_buf
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT | */
+        VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT;
+}
+
+static const VkExternalMemoryHandleTypeFlagBits wine_vk_handle_over_fd_types =
+                VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT |
+                VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
+                VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT |
+                VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT;
+
+static void wine_vk_get_physical_device_external_buffer_properties(struct wine_phys_dev *phys_dev,
+        void (*p_vkGetPhysicalDeviceExternalBufferProperties)(VkPhysicalDevice, const VkPhysicalDeviceExternalBufferInfo *, VkExternalBufferProperties *),
+        const VkPhysicalDeviceExternalBufferInfo *buffer_info, VkExternalBufferProperties *properties)
+{
+    VkPhysicalDeviceExternalBufferInfo buffer_info_dup = *buffer_info;
+
+    wine_vk_normalize_handle_types_win(&buffer_info_dup.handleType);
+    if (buffer_info_dup.handleType & wine_vk_handle_over_fd_types)
+        buffer_info_dup.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+    wine_vk_normalize_handle_types_host(&buffer_info_dup.handleType);
+
+    if (buffer_info->handleType && !buffer_info_dup.handleType)
+    {
+        memset(&properties->externalMemoryProperties, 0, sizeof(properties->externalMemoryProperties));
+        return;
+    }
+
+    p_vkGetPhysicalDeviceExternalBufferProperties(phys_dev->obj.host.physical_device, &buffer_info_dup, properties);
+
+    if (properties->externalMemoryProperties.exportFromImportedHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
+        properties->externalMemoryProperties.exportFromImportedHandleTypes |= wine_vk_handle_over_fd_types;
+    wine_vk_normalize_handle_types_win(&properties->externalMemoryProperties.exportFromImportedHandleTypes);
+
+    if (properties->externalMemoryProperties.compatibleHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
+        properties->externalMemoryProperties.compatibleHandleTypes |= wine_vk_handle_over_fd_types;
+    wine_vk_normalize_handle_types_win(&properties->externalMemoryProperties.compatibleHandleTypes);
+}
+
+void wine_vkGetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice client_physical_device,
+                                                      const VkPhysicalDeviceExternalBufferInfo *buffer_info,
+                                                      VkExternalBufferProperties *properties)
+{
+    struct wine_phys_dev *phys_dev = wine_phys_dev_from_handle(client_physical_device);
+    wine_vk_get_physical_device_external_buffer_properties(phys_dev, phys_dev->obj.instance->p_vkGetPhysicalDeviceExternalBufferProperties, buffer_info, properties);
+}
+
+void wine_vkGetPhysicalDeviceExternalBufferPropertiesKHR(VkPhysicalDevice client_physical_device,
+                                                         const VkPhysicalDeviceExternalBufferInfo *buffer_info,
+                                                         VkExternalBufferProperties *properties)
+{
+    struct wine_phys_dev *phys_dev = wine_phys_dev_from_handle(client_physical_device);
+    wine_vk_get_physical_device_external_buffer_properties(phys_dev, phys_dev->obj.instance->p_vkGetPhysicalDeviceExternalBufferPropertiesKHR, buffer_info, properties);
+}
+
+static VkResult wine_vk_get_physical_device_image_format_properties_2(struct vulkan_physical_device *physical_device,
+        VkResult (*p_vkGetPhysicalDeviceImageFormatProperties2)(VkPhysicalDevice, const VkPhysicalDeviceImageFormatInfo2 *, VkImageFormatProperties2 *),
+        const VkPhysicalDeviceImageFormatInfo2 *format_info, VkImageFormatProperties2 *properties)
+{
+    VkPhysicalDeviceExternalImageFormatInfo *external_image_info;
+    VkExternalImageFormatProperties *external_image_properties;
+    VkResult res;
+
+    if ((external_image_info = find_next_struct(format_info, VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO))
+            && external_image_info->handleType)
+    {
+        wine_vk_normalize_handle_types_win(&external_image_info->handleType);
+
+        if (external_image_info->handleType & wine_vk_handle_over_fd_types)
+            external_image_info->handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+        wine_vk_normalize_handle_types_host(&external_image_info->handleType);
+        if (!external_image_info->handleType)
+        {
+            FIXME("Unsupported handle type %#x.\n", external_image_info->handleType);
+            return VK_ERROR_FORMAT_NOT_SUPPORTED;
+        }
+    }
+
+    res = p_vkGetPhysicalDeviceImageFormatProperties2(physical_device->host.physical_device, format_info, properties);
+
+    if ((external_image_properties = find_next_struct(properties,
+                                                      VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES)))
+    {
+        VkExternalMemoryProperties *p = &external_image_properties->externalMemoryProperties;
+
+        if (p->exportFromImportedHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
+            p->exportFromImportedHandleTypes |= wine_vk_handle_over_fd_types;
+        wine_vk_normalize_handle_types_win(&p->exportFromImportedHandleTypes);
+
+        if (p->compatibleHandleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
+            p->compatibleHandleTypes |= wine_vk_handle_over_fd_types;
+        wine_vk_normalize_handle_types_win(&p->compatibleHandleTypes);
+    }
+
+    return res;
+}
+
+VkResult wine_vkGetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice client_physical_device,
+                                                        const VkPhysicalDeviceImageFormatInfo2 *format_info,
+                                                        VkImageFormatProperties2 *properties)
+{
+    struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle(client_physical_device);
+    struct vulkan_instance *instance = physical_device->instance;
+
+    return wine_vk_get_physical_device_image_format_properties_2(physical_device,
+            instance->p_vkGetPhysicalDeviceImageFormatProperties2,
+            format_info, properties);
+}
+
+VkResult wine_vkGetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice client_physical_device,
+                                                           const VkPhysicalDeviceImageFormatInfo2 *format_info,
+                                                           VkImageFormatProperties2 *properties)
+{
+    struct vulkan_physical_device *physical_device = vulkan_physical_device_from_handle(client_physical_device);
+    struct vulkan_instance *instance = physical_device->instance;
+
+    return wine_vk_get_physical_device_image_format_properties_2(physical_device,
+            instance->p_vkGetPhysicalDeviceImageFormatProperties2KHR,
+            format_info, properties);
+}
+
 /* From ntdll/unix/sync.c */
 #define NANOSECONDS_IN_A_SECOND 1000000000
 #define TICKSPERSEC             10000000
@@ -1612,22 +2009,1034 @@ VkResult wine_vkGetPhysicalDeviceCalibra
 
 
 
+static inline void wine_vk_normalize_semaphore_handle_types_win(VkExternalSemaphoreHandleTypeFlags *types)
+{
+    *types &=
+        VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT |
+        VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT |
+        VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT;
+}
+
+static inline void wine_vk_normalize_semaphore_handle_types_host(VkExternalSemaphoreHandleTypeFlags *types)
+{
+    *types &=
+        VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT |
+        VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
+}
+
+static void wine_vk_get_physical_device_external_semaphore_properties(struct wine_phys_dev *phys_dev,
+    void (*p_vkGetPhysicalDeviceExternalSemaphoreProperties)(VkPhysicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *, VkExternalSemaphoreProperties *),
+    const VkPhysicalDeviceExternalSemaphoreInfo *semaphore_info, VkExternalSemaphoreProperties *properties)
+{
+    VkPhysicalDeviceExternalSemaphoreInfo semaphore_info_dup = *semaphore_info;
+    VkSemaphoreTypeCreateInfo semaphore_type_info, *p_semaphore_type_info;
+
+    switch(semaphore_info->handleType)
+    {
+        case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT:
+            semaphore_info_dup.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+            break;
+        case VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT:
+        {
+            unsigned int i;
+
+            if (phys_dev->obj.api_version < VK_API_VERSION_1_2 ||
+                phys_dev->obj.instance->api_version < VK_API_VERSION_1_2)
+            {
+                for (i = 0; i < phys_dev->extension_count; i++)
+                {
+                    if (!strcmp(phys_dev->extensions[i].extensionName, "VK_KHR_timeline_semaphore"))
+                        break;
+                }
+                if (i == phys_dev->extension_count)
+                {
+                    properties->exportFromImportedHandleTypes = 0;
+                    properties->compatibleHandleTypes = 0;
+                    properties->externalSemaphoreFeatures = 0;
+                    return;
+                }
+            }
+
+            if ((p_semaphore_type_info = find_next_struct(&semaphore_info_dup, VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO)))
+            {
+                p_semaphore_type_info->semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE;
+                p_semaphore_type_info->initialValue = 0;
+            }
+            else
+            {
+                semaphore_type_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
+                semaphore_type_info.pNext = semaphore_info_dup.pNext;
+                semaphore_type_info.semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE;
+                semaphore_type_info.initialValue = 0;
+
+                semaphore_info_dup.pNext = &semaphore_type_info;
+            }
+
+            semaphore_info_dup.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+            break;
+        }
+        default:
+            semaphore_info_dup.handleType = 0;
+            break;
+    }
+
+    if (semaphore_info->handleType && !semaphore_info_dup.handleType)
+    {
+        properties->exportFromImportedHandleTypes = 0;
+        properties->compatibleHandleTypes = 0;
+        properties->externalSemaphoreFeatures = 0;
+        return;
+    }
+
+    p_vkGetPhysicalDeviceExternalSemaphoreProperties(phys_dev->obj.host.physical_device, &semaphore_info_dup, properties);
+
+    if (properties->exportFromImportedHandleTypes & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT)
+        properties->exportFromImportedHandleTypes = semaphore_info->handleType;
+    wine_vk_normalize_semaphore_handle_types_win(&properties->exportFromImportedHandleTypes);
+
+    if (properties->compatibleHandleTypes & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT)
+        properties->compatibleHandleTypes = semaphore_info->handleType;
+    wine_vk_normalize_semaphore_handle_types_win(&properties->compatibleHandleTypes);
+}
+
 void wine_vkGetPhysicalDeviceExternalSemaphoreProperties(VkPhysicalDevice client_physical_device,
                                                          const VkPhysicalDeviceExternalSemaphoreInfo *info,
                                                          VkExternalSemaphoreProperties *properties)
 {
-    properties->exportFromImportedHandleTypes = 0;
-    properties->compatibleHandleTypes = 0;
-    properties->externalSemaphoreFeatures = 0;
+    struct wine_phys_dev *phys_dev = wine_phys_dev_from_handle(client_physical_device);
+
+    TRACE("%p, %p, %p\n", phys_dev, info, properties);
+    wine_vk_get_physical_device_external_semaphore_properties(phys_dev, phys_dev->obj.instance->p_vkGetPhysicalDeviceExternalSemaphoreProperties, info, properties);
 }
 
 void wine_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice client_physical_device,
                                                             const VkPhysicalDeviceExternalSemaphoreInfo *info,
                                                             VkExternalSemaphoreProperties *properties)
 {
-    properties->exportFromImportedHandleTypes = 0;
-    properties->compatibleHandleTypes = 0;
-    properties->externalSemaphoreFeatures = 0;
+    struct wine_phys_dev *phys_dev = wine_phys_dev_from_handle(client_physical_device);
+
+    TRACE("%p, %p, %p\n", phys_dev, info, properties);
+    wine_vk_get_physical_device_external_semaphore_properties(phys_dev, phys_dev->obj.instance->p_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR, info, properties);
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_CREATE           CTL_CODE(FILE_DEVICE_VIDEO, 0, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+struct shared_resource_create
+{
+    UINT64 resource_size;
+    obj_handle_t unix_handle;
+    WCHAR name[1];
+};
+
+static HANDLE create_gpu_resource(int fd, LPCWSTR name, UINT64 resource_size)
+{
+    static const WCHAR shared_gpu_resourceW[] = {'\\','?','?','\\','S','h','a','r','e','d','G','p','u','R','e','s','o','u','r','c','e',0};
+    HANDLE unix_resource = INVALID_HANDLE_VALUE;
+    struct shared_resource_create *inbuff;
+    UNICODE_STRING shared_gpu_resource_us;
+    HANDLE shared_resource;
+    OBJECT_ATTRIBUTES attr;
+    IO_STATUS_BLOCK iosb;
+    NTSTATUS status;
+    DWORD in_size;
+
+    TRACE("Creating shared vulkan resource fd %d name %s.\n", fd, debugstr_w(name));
+
+    if (wine_server_fd_to_handle(fd, GENERIC_ALL, 0, &unix_resource) != STATUS_SUCCESS)
+        return INVALID_HANDLE_VALUE;
+
+    init_unicode_string(&shared_gpu_resource_us, shared_gpu_resourceW);
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = 0;
+    attr.Attributes = 0;
+    attr.ObjectName = &shared_gpu_resource_us;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    if ((status = NtCreateFile(&shared_resource, GENERIC_READ | GENERIC_WRITE, &attr, &iosb, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, 0, NULL, 0)))
+    {
+        ERR("Failed to load open a shared resource handle, status %#lx.\n", (long int)status);
+        NtClose(unix_resource);
+        return INVALID_HANDLE_VALUE;
+    }
+
+    in_size = sizeof(*inbuff) + (name ? lstrlenW(name) * sizeof(WCHAR) : 0);
+    inbuff = calloc(1, in_size);
+    inbuff->unix_handle = wine_server_obj_handle(unix_resource);
+    inbuff->resource_size = resource_size;
+    if (name)
+        lstrcpyW(&inbuff->name[0], name);
+
+    if ((status = NtDeviceIoControlFile(shared_resource, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_CREATE,
+            inbuff, in_size, NULL, 0)))
+
+    free(inbuff);
+    NtClose(unix_resource);
+
+    if (status)
+    {
+        ERR("Failed to create video resource, status %#lx.\n", (long int)status);
+        NtClose(shared_resource);
+        return INVALID_HANDLE_VALUE;
+    }
+
+    return shared_resource;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_OPEN             CTL_CODE(FILE_DEVICE_VIDEO, 1, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+struct shared_resource_open
+{
+    obj_handle_t kmt_handle;
+    WCHAR name[1];
+};
+
+struct shared_resource_info
+{
+    UINT64 resource_size;
+};
+
+static HANDLE open_shared_resource(HANDLE kmt_handle, LPCWSTR name)
+{
+    static const WCHAR shared_gpu_resourceW[] = {'\\','?','?','\\','S','h','a','r','e','d','G','p','u','R','e','s','o','u','r','c','e',0};
+    UNICODE_STRING shared_gpu_resource_us;
+    struct shared_resource_open *inbuff;
+    HANDLE shared_resource;
+    OBJECT_ATTRIBUTES attr;
+    IO_STATUS_BLOCK iosb;
+    NTSTATUS status;
+    DWORD in_size;
+
+    init_unicode_string(&shared_gpu_resource_us, shared_gpu_resourceW);
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = 0;
+    attr.Attributes = 0;
+    attr.ObjectName = &shared_gpu_resource_us;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    if ((status = NtCreateFile(&shared_resource, GENERIC_READ | GENERIC_WRITE, &attr, &iosb, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, 0, NULL, 0)))
+    {
+        ERR("Failed to load open a shared resource handle, status %#lx.\n", (long int)status);
+        return INVALID_HANDLE_VALUE;
+    }
+
+    in_size = sizeof(*inbuff) + (name ? lstrlenW(name) * sizeof(WCHAR) : 0);
+    inbuff = calloc(1, in_size);
+    inbuff->kmt_handle = wine_server_obj_handle(kmt_handle);
+    if (name)
+        lstrcpyW(&inbuff->name[0], name);
+
+    status = NtDeviceIoControlFile(shared_resource, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_OPEN,
+            inbuff, in_size, NULL, 0);
+
+    free(inbuff);
+
+    if (status)
+    {
+        ERR("Failed to open video resource, status %#lx.\n", (long int)status);
+        NtClose(shared_resource);
+        return INVALID_HANDLE_VALUE;
+    }
+
+    return shared_resource;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_GET_INFO CTL_CODE(FILE_DEVICE_VIDEO, 7, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+static BOOL shared_resource_get_info(HANDLE handle, struct shared_resource_info *info)
+{
+    IO_STATUS_BLOCK iosb;
+    unsigned int status;
+
+    status = NtDeviceIoControlFile(handle, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_GET_INFO,
+            NULL, 0, info, sizeof(*info));
+    if (status)
+        ERR("Failed to get shared resource info, status %#x.\n", status);
+
+    return !status;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_GET_UNIX_RESOURCE           CTL_CODE(FILE_DEVICE_VIDEO, 3, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+static int get_shared_resource_fd(HANDLE shared_resource)
+{
+    IO_STATUS_BLOCK iosb;
+    obj_handle_t unix_resource;
+    NTSTATUS status;
+    int ret;
+
+    if (NtDeviceIoControlFile(shared_resource, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_GET_UNIX_RESOURCE,
+            NULL, 0, &unix_resource, sizeof(unix_resource)))
+        return -1;
+
+    status = wine_server_handle_to_fd(wine_server_ptr_handle(unix_resource), FILE_READ_DATA, &ret, NULL);
+    NtClose(wine_server_ptr_handle(unix_resource));
+    return status == STATUS_SUCCESS ? ret : -1;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_GETKMT           CTL_CODE(FILE_DEVICE_VIDEO, 2, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+static HANDLE get_shared_resource_kmt_handle(HANDLE shared_resource)
+{
+    IO_STATUS_BLOCK iosb;
+    obj_handle_t kmt_handle;
+
+    if (NtDeviceIoControlFile(shared_resource, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_GETKMT,
+            NULL, 0, &kmt_handle, sizeof(kmt_handle)))
+        return INVALID_HANDLE_VALUE;
+
+    return wine_server_ptr_handle(kmt_handle);
+}
+
+static bool set_shared_resource_object(HANDLE shared_resource, unsigned int index, HANDLE handle);
+static HANDLE get_shared_resource_object(HANDLE shared_resource, unsigned int index);
+
+static void destroy_keyed_mutex(struct vulkan_device *device, struct wine_device_memory *memory)
+{
+    if (memory->keyed_mutex_shm)
+    {
+        NtUnmapViewOfSection(GetCurrentProcess(), memory->keyed_mutex_shm);
+        memory->keyed_mutex_shm = NULL;
+    }
+    if (memory->keyed_mutex_sem)
+    {
+        device->p_vkDestroySemaphore(device->host.device, memory->keyed_mutex_sem, NULL);
+        memory->keyed_mutex_sem = VK_NULL_HANDLE;
+    }
+}
+
+static void create_keyed_mutex(struct vulkan_device *device, struct wine_device_memory *memory)
+{
+    VkExportSemaphoreCreateInfo timeline_export_info;
+    VkSemaphoreTypeCreateInfo type_info;
+    VkSemaphoreCreateInfo create_info;
+    VkSemaphoreGetFdInfoKHR fd_info;
+    pthread_mutexattr_t mutex_attr;
+    OBJECT_ATTRIBUTES attr;
+    HANDLE section_handle;
+    LARGE_INTEGER li;
+    HANDLE handle;
+    SIZE_T size;
+    VkResult vr;
+    int fd;
+
+    InitializeObjectAttributes(&attr, NULL, 0, NULL, NULL);
+    size = li.QuadPart = sizeof(*memory->keyed_mutex_shm);
+    if (NtCreateSection(&section_handle, STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE, &attr, &li, PAGE_READWRITE, SEC_COMMIT, NULL))
+    {
+        ERR("NtCreateSection failed.\n");
+        return;
+    }
+
+    if (!set_shared_resource_object(memory->handle, 0, section_handle))
+    {
+        NtClose(section_handle);
+        ERR("set_shared_resource_object failed.\n");
+        return;
+    }
+
+    if (NtMapViewOfSection(section_handle, GetCurrentProcess(), (void**) &memory->keyed_mutex_shm, 0, 0, NULL, &size, ViewShare, 0, PAGE_READWRITE))
+    {
+        NtClose(section_handle);
+        ERR("NtMapViewOfSection failed.\n");
+        return;
+    }
+
+    NtClose(section_handle);
+
+    timeline_export_info.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
+    timeline_export_info.pNext = NULL;
+    timeline_export_info.handleTypes = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+    type_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
+    type_info.pNext = &timeline_export_info;
+    type_info.semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE;
+    type_info.initialValue = 0;
+
+    create_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
+    create_info.pNext = &type_info;
+    create_info.flags = 0;
+
+    if ((vr = device->p_vkCreateSemaphore(device->host.device, &create_info, NULL, &memory->keyed_mutex_sem)) != VK_SUCCESS)
+    {
+        ERR("Failed to create semaphore, vr %d.\n", vr);
+        goto error;
+    }
+    fd_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
+    fd_info.pNext = NULL;
+    fd_info.semaphore = memory->keyed_mutex_sem;
+    fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+    if ((vr = device->p_vkGetSemaphoreFdKHR(device->host.device, &fd_info, &fd)) != VK_SUCCESS)
+    {
+        ERR("Failed to export semaphore fd, vr %d.\n", vr);
+        goto error;
+    }
+    if (wine_server_fd_to_handle(fd, GENERIC_ALL, 0, &handle) != STATUS_SUCCESS)
+    {
+        ERR("wine_server_fd_to_handle failed.\n");
+        close(fd);
+        goto error;
+    }
+    close(fd);
+    if (!set_shared_resource_object(memory->handle, 1, handle))
+    {
+        ERR("set_shared_resource_object failed.\n");
+        NtClose(handle);
+        goto error;
+    }
+    NtClose(handle);
+
+    pthread_mutexattr_init(&mutex_attr);
+    pthread_mutexattr_setpshared(&mutex_attr, PTHREAD_PROCESS_SHARED);
+    if (pthread_mutex_init(&memory->keyed_mutex_shm->mutex, &mutex_attr))
+    memory->keyed_mutex_shm->instance_id_counter = 1;
+    memory->keyed_mutex_instance_id = ++memory->keyed_mutex_shm->instance_id_counter;
+    TRACE("memory %p, created keyed mutex.\n", memory);
+    return;
+
+error:
+    destroy_keyed_mutex(device, memory);
+}
+
+static void import_keyed_mutex(struct vulkan_device *device, struct wine_device_memory *memory)
+{
+    VkSemaphoreTypeCreateInfo type_info;
+    VkImportSemaphoreFdInfoKHR fd_info;
+    VkSemaphoreCreateInfo create_info;
+    HANDLE section_handle, sem_handle;
+    SIZE_T size;
+
+    VkResult vr;
+
+    if (!(section_handle = get_shared_resource_object(memory->handle, 0)))
+    {
+        TRACE("No section handle.\n");
+        return;
+    }
+    if (!(sem_handle = get_shared_resource_object(memory->handle, 1)))
+    {
+        ERR("No smeaphore handle.\n");
+        NtClose(section_handle);
+        return;
+    }
+
+    size = sizeof(*memory->keyed_mutex_shm);
+    if (NtMapViewOfSection(section_handle, GetCurrentProcess(), (void**) &memory->keyed_mutex_shm, 0, 0, NULL, &size, ViewShare, 0, PAGE_READWRITE))
+    {
+        ERR("NtMapViewOfSection failed.\n");
+        goto error;
+    }
+
+    type_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
+    type_info.pNext = NULL;
+    type_info.semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE;
+    type_info.initialValue = 0;
+
+    create_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
+    create_info.pNext = &type_info;
+    create_info.flags = 0;
+
+    if ((vr = device->p_vkCreateSemaphore(device->host.device, &create_info, NULL, &memory->keyed_mutex_sem)) != VK_SUCCESS)
+    {
+        ERR("Failed to create semaphore, vr %d.\n", vr);
+        goto error;
+    }
+
+    fd_info.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;
+    fd_info.pNext = NULL;
+    fd_info.semaphore = memory->keyed_mutex_sem;
+    fd_info.flags = 0;
+    fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+    if (wine_server_handle_to_fd(sem_handle, FILE_READ_DATA, &fd_info.fd, NULL))
+    {
+        ERR("wine_server_handle_to_fd failed.\n");
+        goto error;
+    }
+
+    vr = device->p_vkImportSemaphoreFdKHR(device->host.device, &fd_info);
+    if (vr != VK_SUCCESS)
+    {
+        ERR("vkImportSemaphoreFdKHR failed, vr %d.\n", vr);
+        close(fd_info.fd);
+        goto error;
+    }
+    /* Not closing fd on successful import, the driver now owns it. */
+
+    memory->keyed_mutex_instance_id = InterlockedIncrement64((LONGLONG *)&memory->keyed_mutex_shm->instance_id_counter);
+    TRACE("memory %p, imported keyed mutex.\n", memory);
+    return;
+error:
+    NtClose(section_handle);
+    NtClose(sem_handle);
+    destroy_keyed_mutex(device, memory);
+}
+
+static VkResult acquire_keyed_mutex(struct vulkan_device *device, struct wine_device_memory *memory, uint64_t key,
+        uint32_t timeout_ms)
+{
+    ULONG end_wait, curr_tick, remaining_wait;
+    VkSemaphoreWaitInfo wait_info = { 0 };
+    uint64_t timeline;
+    VkResult vr;
+
+    if (!memory->keyed_mutex_shm)
+        return VK_ERROR_UNKNOWN;
+
+    wait_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO;
+    wait_info.semaphoreCount = 1;
+    wait_info.pSemaphores = &memory->keyed_mutex_sem;
+    wait_info.pValues = &timeline;
+
+    end_wait = NtGetTickCount() + timeout_ms;
+
+    while (1)
+    {
+        pthread_mutex_lock(&memory->keyed_mutex_shm->mutex);
+
+        if (memory->keyed_mutex_shm->acquired_to_instance)
+        {
+            if ((vr = get_semaphore_value(device, memory->keyed_mutex_sem, &timeline)) != VK_SUCCESS)
+            {
+                pthread_mutex_unlock(&memory->keyed_mutex_shm->mutex);
+                return VK_ERROR_UNKNOWN;
+            }
+            assert(timeline == memory->keyed_mutex_shm->timeline_value
+                    || timeline == memory->keyed_mutex_shm->timeline_value + 1);
+            if (timeline == memory->keyed_mutex_shm->timeline_value + 1)
+            {
+                /* released from queue. */
+                assert(memory->keyed_mutex_shm->timeline_queued_release == timeline);
+                memory->keyed_mutex_shm->timeline_queued_release = 0;
+                ++memory->keyed_mutex_shm->timeline_value;
+                memory->keyed_mutex_shm->acquired_to_instance = 0;
+            }
+        }
+
+        if (memory->keyed_mutex_shm->acquired_to_instance == memory->keyed_mutex_instance_id
+                && !memory->keyed_mutex_shm->timeline_queued_release)
+        {
+            /* Already acquired to this device. */
+            pthread_mutex_unlock(&memory->keyed_mutex_shm->mutex);
+            return VK_ERROR_UNKNOWN;
+        }
+        if (!memory->keyed_mutex_shm->acquired_to_instance && memory->keyed_mutex_shm->key == key)
+        {
+            /* Can acquire. */
+            memory->keyed_mutex_shm->acquired_to_instance = memory->keyed_mutex_instance_id;
+            pthread_mutex_unlock(&memory->keyed_mutex_shm->mutex);
+            return VK_SUCCESS;
+        }
+        curr_tick = NtGetTickCount();
+        if (!timeout_ms || curr_tick >= end_wait)
+        {
+            pthread_mutex_unlock(&memory->keyed_mutex_shm->mutex);
+            return VK_TIMEOUT;
+        }
+        remaining_wait = timeout_ms == INFINITE ? INFINITE : end_wait - curr_tick;
+        timeline = memory->keyed_mutex_shm->timeline_value + 1;
+        pthread_mutex_unlock(&memory->keyed_mutex_shm->mutex);
+
+        vr = wait_semaphores(device, &wait_info, remaining_wait * 1000000ull);
+        if (vr != VK_SUCCESS && vr != VK_TIMEOUT)
+        {
+            ERR("vkWaitSemaphores failed, vr %d.\n", vr);
+            return VK_ERROR_UNKNOWN;
+        }
+    }
+}
+
+static VkResult release_keyed_mutex(struct vulkan_device *device, struct wine_device_memory *memory, uint64_t key,
+        uint64_t *timeline_value)
+{
+    if (!memory->keyed_mutex_shm)
+        return VK_ERROR_UNKNOWN;
+
+    pthread_mutex_lock(&memory->keyed_mutex_shm->mutex);
+    if (memory->keyed_mutex_shm->acquired_to_instance != memory->keyed_mutex_instance_id
+            || memory->keyed_mutex_shm->timeline_queued_release)
+    {
+        pthread_mutex_unlock(&memory->keyed_mutex_shm->mutex);
+        return VK_ERROR_UNKNOWN;
+    }
+    memory->keyed_mutex_shm->key = key;
+    if (timeline_value)
+    {
+        /* Return timeline value to signal from queue. */
+        *timeline_value = memory->keyed_mutex_shm->timeline_value + 1;
+        memory->keyed_mutex_shm->timeline_queued_release = *timeline_value;
+    }
+    else
+    {
+        /* Release immediately. */
+        memory->keyed_mutex_shm->acquired_to_instance = 0;
+        signal_timeline_sem(device, memory->keyed_mutex_sem, &memory->keyed_mutex_shm->timeline_value);
+    }
+    pthread_mutex_unlock(&memory->keyed_mutex_shm->mutex);
+
+    return VK_SUCCESS;
+}
+
+VkResult wine_vkAllocateMemory(VkDevice client_device, const VkMemoryAllocateInfo *alloc_info,
+                               const VkAllocationCallbacks *allocator, VkDeviceMemory *ret)
+{
+    struct vulkan_device *device = vulkan_device_from_handle(client_device);
+    struct wine_phys_dev *physical_device = CONTAINING_RECORD(device->physical_device, struct wine_phys_dev, obj);
+    struct vulkan_instance *instance = device->physical_device->instance;
+    struct wine_instance *wine_instance = CONTAINING_RECORD(instance, struct wine_instance, obj);
+    struct wine_device_memory *memory;
+    VkMemoryAllocateInfo info = *alloc_info;
+    VkImportMemoryHostPointerInfoEXT host_pointer_info;
+    VkDeviceMemory host_device_memory;
+    uint32_t mem_flags;
+    void *mapping = NULL;
+    VkResult result;
+
+    const VkImportMemoryWin32HandleInfoKHR *handle_import_info;
+    const VkExportMemoryWin32HandleInfoKHR *handle_export_info;
+    VkExportMemoryAllocateInfo *export_info;
+    VkImportMemoryFdInfoKHR fd_import_info;
+    VkMemoryGetFdInfoKHR get_fd_info;
+    int fd;
+
+    if (!(memory = calloc(sizeof(*memory), 1)))
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+
+    memory->handle = INVALID_HANDLE_VALUE;
+    fd_import_info.fd = -1;
+    fd_import_info.pNext = NULL;
+
+    /* find and process handle import/export info and grab it */
+    handle_import_info = wine_vk_find_unlink_struct(&info, IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR);
+    handle_export_info = wine_vk_find_unlink_struct(&info, EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR);
+    if (handle_export_info && handle_export_info->pAttributes && handle_export_info->pAttributes->lpSecurityDescriptor)
+        FIXME("Support for custom security descriptor not implemented.\n");
+
+    if ((export_info = find_next_struct(alloc_info, VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO)))
+    {
+        memory->handle_types = export_info->handleTypes;
+        if (export_info->handleTypes & wine_vk_handle_over_fd_types)
+            export_info->handleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+        wine_vk_normalize_handle_types_host(&export_info->handleTypes);
+    }
+
+    mem_flags = physical_device->memory_properties.memoryTypes[alloc_info->memoryTypeIndex].propertyFlags;
+
+    /* Vulkan consumes imported FDs, but not imported HANDLEs */
+    if (handle_import_info)
+    {
+        struct shared_resource_info res_info;
+
+        fd_import_info.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR;
+        fd_import_info.pNext = info.pNext;
+        fd_import_info.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+        info.pNext = &fd_import_info;
+
+        TRACE("import handle type %#x.\n", handle_import_info->handleType);
+
+        switch (handle_import_info->handleType)
+        {
+            case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
+            case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT:
+                if (handle_import_info->handle)
+                    NtDuplicateObject( NtCurrentProcess(), handle_import_info->handle, NtCurrentProcess(), &memory->handle, 0, 0, DUPLICATE_SAME_ACCESS );
+                else if (handle_import_info->name)
+                    memory->handle = open_shared_resource( 0, handle_import_info->name );
+                break;
+            case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
+            case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT:
+                /* FIXME: the spec says that device memory imported from a KMT handle doesn't keep a reference to the underyling payload.
+                   This means that in cases where on windows an application leaks VkDeviceMemory objects, we leak the full payload.  To
+                   fix this, we would need wine_dev_mem objects to store no reference to the payload, that means no host VkDeviceMemory
+                   object (as objects imported from FDs hold a reference to the payload), and no win32 handle to the object. We would then
+                   extend make_vulkan to have the thunks converting wine_dev_mem to native handles open the VkDeviceMemory from the KMT
+                   handle, use it in the host function, then close it again. */
+                memory->handle = open_shared_resource( handle_import_info->handle, NULL );
+                break;
+            default:
+                WARN("Invalid handle type %08x passed in.\n", handle_import_info->handleType);
+                result = VK_ERROR_INVALID_EXTERNAL_HANDLE;
+                goto done;
+        }
+
+        if (memory->handle != INVALID_HANDLE_VALUE)
+            fd_import_info.fd = get_shared_resource_fd(memory->handle);
+
+        if (fd_import_info.fd == -1)
+        {
+            TRACE("Couldn't access resource handle or name. type=%08x handle=%p name=%s\n", handle_import_info->handleType, handle_import_info->handle,
+                    handle_import_info->name ? debugstr_w(handle_import_info->name) : "");
+            result = VK_ERROR_INVALID_EXTERNAL_HANDLE;
+            goto done;
+        }
+
+        /* From VkMemoryAllocateInfo spec: "if the parameters define an import operation and the external handle type is
+         * VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,
+         * or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, allocationSize is ignored.". Although test suggests
+         * that it is also true for opaque Win32 handles. */
+        if (shared_resource_get_info(memory->handle, &res_info))
+        {
+            if (res_info.resource_size)
+            {
+                TRACE("Shared resource size %llu.\n", (long long)res_info.resource_size);
+                if (info.allocationSize && info.allocationSize != res_info.resource_size)
+                    FIXME("Shared resource allocationSize %llu, resource_size %llu.\n",
+                            (long long)info.allocationSize, (long long)res_info.resource_size);
+                info.allocationSize = res_info.resource_size;
+            }
+            else
+            {
+                ERR("Zero shared resource size.\n");
+            }
+        }
+        if (device->keyed_mutexes_enabled)
+            import_keyed_mutex(device, memory);
+    }
+    else if (physical_device->external_memory_align && (mem_flags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) &&
+        !find_next_struct(alloc_info->pNext, VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT))
+    {
+        /* For host visible memory, we try to use VK_EXT_external_memory_host on wow64
+         * to ensure that mapped pointer is 32-bit. */
+        VkMemoryHostPointerPropertiesEXT props =
+        {
+            .sType = VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT,
+        };
+        uint32_t i, align = physical_device->external_memory_align - 1;
+        SIZE_T alloc_size = info.allocationSize;
+        static int once;
+
+        if (!once++)
+            FIXME("Using VK_EXT_external_memory_host\n");
+
+        if (NtAllocateVirtualMemory(GetCurrentProcess(), &mapping, zero_bits, &alloc_size,
+                                    MEM_COMMIT, PAGE_READWRITE))
+        {
+            ERR("NtAllocateVirtualMemory failed\n");
+            free(memory);
+            return VK_ERROR_OUT_OF_HOST_MEMORY;
+        }
+
+        result = device->p_vkGetMemoryHostPointerPropertiesEXT(device->host.device,
+                VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT, mapping, &props);
+        if (result != VK_SUCCESS)
+        {
+            ERR("vkGetMemoryHostPointerPropertiesEXT failed: %d\n", result);
+            free(memory);
+            return result;
+        }
+
+        if (!(props.memoryTypeBits & (1u << info.memoryTypeIndex)))
+        {
+            /* If requested memory type is not allowed to use external memory,
+             * try to find a supported compatible type. */
+            uint32_t mask = mem_flags & ~VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT;
+            for (i = 0; i < physical_device->memory_properties.memoryTypeCount; i++)
+            {
+                if (!(props.memoryTypeBits & (1u << i)))
+                    continue;
+                if ((physical_device->memory_properties.memoryTypes[i].propertyFlags & mask) != mask)
+                    continue;
+
+                TRACE("Memory type not compatible with host memory, using %u instead\n", i);
+                info.memoryTypeIndex = i;
+                break;
+            }
+            if (i == physical_device->memory_properties.memoryTypeCount)
+            {
+                FIXME("Not found compatible memory type\n");
+                alloc_size = 0;
+                NtFreeVirtualMemory(GetCurrentProcess(), &mapping, &alloc_size, MEM_RELEASE);
+            }
+        }
+
+        if (props.memoryTypeBits & (1u << info.memoryTypeIndex))
+        {
+            host_pointer_info.sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT;
+            host_pointer_info.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT;
+            host_pointer_info.pHostPointer = mapping;
+            host_pointer_info.pNext = info.pNext;
+            info.pNext = &host_pointer_info;
+
+            info.allocationSize = (info.allocationSize + align) & ~align;
+        }
+    }
+
+    set_transient_client_handle(wine_instance, (uintptr_t)memory);
+    result = device->p_vkAllocateMemory(device->host.device, &info, NULL, &host_device_memory);
+    if (result == VK_SUCCESS && memory->handle == INVALID_HANDLE_VALUE && export_info && export_info->handleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT)
+    {
+        get_fd_info.sType = VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR;
+        get_fd_info.pNext = NULL;
+        get_fd_info.memory = host_device_memory;
+        get_fd_info.handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+        if (device->p_vkGetMemoryFdKHR(device->host.device, &get_fd_info, &fd) == VK_SUCCESS)
+        {
+            memory->handle = create_gpu_resource(fd, handle_export_info ? handle_export_info->name : NULL, alloc_info->allocationSize);
+            memory->access = handle_export_info ? handle_export_info->dwAccess : GENERIC_ALL;
+            if (handle_export_info && handle_export_info->pAttributes)
+                memory->inherit = handle_export_info->pAttributes->bInheritHandle;
+            else
+                memory->inherit = FALSE;
+            close(fd);
+            if (device->keyed_mutexes_enabled)
+                create_keyed_mutex(device, memory);
+        }
+
+        if (memory->handle == INVALID_HANDLE_VALUE)
+        {
+            device->p_vkFreeMemory(device->host.device, host_device_memory, NULL);
+            result = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto done;
+        }
+    }
+done:
+    if (result != VK_SUCCESS)
+    {
+        if (fd_import_info.fd != -1)
+            close(fd_import_info.fd);
+        if (memory->handle != INVALID_HANDLE_VALUE)
+            NtClose(memory->handle);
+        free(memory);
+        return result;
+    }
+
+    vulkan_object_init(&memory->obj, host_device_memory);
+    memory->size = info.allocationSize;
+    memory->vm_map = mapping;
+    vulkan_instance_insert_object(instance, &memory->obj);
+
+    *ret = memory->client.device_memory;
+    return VK_SUCCESS;
+}
+
+void wine_vkFreeMemory(VkDevice client_device, VkDeviceMemory memory_handle, const VkAllocationCallbacks *allocator)
+{
+    struct vulkan_device *device = vulkan_device_from_handle(client_device);
+    struct wine_phys_dev *physical_device = CONTAINING_RECORD(device->physical_device, struct wine_phys_dev, obj);
+    struct vulkan_instance *instance = device->physical_device->instance;
+    struct wine_device_memory *memory;
+
+    if (!memory_handle)
+        return;
+    memory = wine_device_memory_from_handle(memory_handle);
+
+    destroy_keyed_mutex(device, memory);
+    if (memory->vm_map && !physical_device->external_memory_align)
+    {
+        const VkMemoryUnmapInfoKHR info =
+        {
+            .sType = VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR,
+            .memory = memory->host.device_memory,
+            .flags = VK_MEMORY_UNMAP_RESERVE_BIT_EXT,
+        };
+        device->p_vkUnmapMemory2KHR(device->host.device, &info);
+    }
+
+    device->p_vkFreeMemory(device->host.device, memory->host.device_memory, NULL);
+    vulkan_instance_remove_object(instance, &memory->obj);
+
+    if (memory->vm_map)
+    {
+        SIZE_T alloc_size = 0;
+        NtFreeVirtualMemory(GetCurrentProcess(), &memory->vm_map, &alloc_size, MEM_RELEASE);
+    }
+
+    if (memory->handle != INVALID_HANDLE_VALUE)
+        NtClose(memory->handle);
+
+    free(memory);
+}
+
+VkResult wine_vkMapMemory(VkDevice client_device, VkDeviceMemory memory, VkDeviceSize offset,
+                          VkDeviceSize size, VkMemoryMapFlags flags, void **data)
+{
+    const VkMemoryMapInfoKHR info =
+    {
+      .sType = VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR,
+      .flags = flags,
+      .memory = memory,
+      .offset = offset,
+      .size = size,
+   };
+
+   return wine_vkMapMemory2KHR(client_device, &info, data);
+}
+
+VkResult wine_vkMapMemory2KHR(VkDevice client_device, const VkMemoryMapInfoKHR *map_info, void **data)
+{
+    struct vulkan_device *device = vulkan_device_from_handle(client_device);
+    struct wine_phys_dev *physical_device = CONTAINING_RECORD(device->physical_device, struct wine_phys_dev, obj);
+    struct wine_device_memory *memory = wine_device_memory_from_handle(map_info->memory);
+    VkMemoryMapInfoKHR info = *map_info;
+    VkMemoryMapPlacedInfoEXT placed_info =
+    {
+        .sType = VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT,
+    };
+    VkResult result;
+
+    info.memory = memory->host.device_memory;
+    if (memory->vm_map)
+    {
+        *data = (char *)memory->vm_map + info.offset;
+        TRACE("returning %p\n", *data);
+        return VK_SUCCESS;
+    }
+
+    if (physical_device->map_placed_align)
+    {
+        SIZE_T alloc_size = memory->size;
+
+        placed_info.pNext = info.pNext;
+        info.pNext = &placed_info;
+        info.offset = 0;
+        info.size = VK_WHOLE_SIZE;
+        info.flags |=  VK_MEMORY_MAP_PLACED_BIT_EXT;
+
+        if (NtAllocateVirtualMemory(GetCurrentProcess(), &placed_info.pPlacedAddress, zero_bits, &alloc_size,
+                                    MEM_COMMIT, PAGE_READWRITE))
+        {
+            ERR("NtAllocateVirtualMemory failed\n");
+            return VK_ERROR_OUT_OF_HOST_MEMORY;
+        }
+    }
+
+    if (device->p_vkMapMemory2KHR)
+    {
+        result = device->p_vkMapMemory2KHR(device->host.device, &info, data);
+    }
+    else
+    {
+        assert(!info.pNext);
+        result = device->p_vkMapMemory(device->host.device, info.memory, info.offset,
+                                             info.size, info.flags, data);
+    }
+
+    if (placed_info.pPlacedAddress)
+    {
+        if (result != VK_SUCCESS)
+        {
+            SIZE_T alloc_size = 0;
+            ERR("vkMapMemory2EXT failed: %d\n", result);
+            NtFreeVirtualMemory(GetCurrentProcess(), &placed_info.pPlacedAddress, &alloc_size, MEM_RELEASE);
+            return result;
+        }
+        memory->vm_map = placed_info.pPlacedAddress;
+        *data = (char *)memory->vm_map + map_info->offset;
+        TRACE("Using placed mapping %p\n", memory->vm_map);
+    }
+
+#ifdef _WIN64
+    if (NtCurrentTeb()->WowTebOffset && result == VK_SUCCESS && (UINT_PTR)*data >> 32)
+    {
+        FIXME("returned mapping %p does not fit 32-bit pointer\n", *data);
+        device->p_vkUnmapMemory(device->host.device, memory->host.device_memory);
+        *data = NULL;
+        result = VK_ERROR_OUT_OF_HOST_MEMORY;
+    }
+#endif
+
+    return result;
+}
+
+void wine_vkUnmapMemory(VkDevice client_device, VkDeviceMemory memory)
+{
+    const VkMemoryUnmapInfoKHR info =
+    {
+        .sType = VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR,
+        .memory = memory,
+    };
+
+    wine_vkUnmapMemory2KHR(client_device, &info);
+}
+
+VkResult wine_vkUnmapMemory2KHR(VkDevice client_device, const VkMemoryUnmapInfoKHR *unmap_info)
+{
+    struct vulkan_device *device = vulkan_device_from_handle(client_device);
+    struct wine_phys_dev *physical_device = CONTAINING_RECORD(device->physical_device, struct wine_phys_dev, obj);
+    struct wine_device_memory *memory = wine_device_memory_from_handle(unmap_info->memory);
+    VkMemoryUnmapInfoKHR info;
+    VkResult result;
+
+    if (memory->vm_map && physical_device->external_memory_align)
+        return VK_SUCCESS;
+
+    if (!device->p_vkUnmapMemory2KHR)
+    {
+        assert(!unmap_info->pNext && !memory->vm_map);
+        device->p_vkUnmapMemory(device->host.device, memory->host.device_memory);
+        return VK_SUCCESS;
+    }
+
+    info = *unmap_info;
+    info.memory = memory->host.device_memory;
+    if (memory->vm_map)
+        info.flags |= VK_MEMORY_UNMAP_RESERVE_BIT_EXT;
+
+    result = device->p_vkUnmapMemory2KHR(device->host.device, &info);
+
+    if (result == VK_SUCCESS && memory->vm_map)
+    {
+        SIZE_T size = 0;
+        NtFreeVirtualMemory(GetCurrentProcess(), &memory->vm_map, &size, MEM_RELEASE);
+        memory->vm_map = NULL;
+    }
+    return result;
+}
+
+VkResult wine_vkCreateBuffer(VkDevice client_device, const VkBufferCreateInfo *create_info,
+                             const VkAllocationCallbacks *allocator, VkBuffer *buffer)
+{
+    struct vulkan_device *device = vulkan_device_from_handle(client_device);
+    struct wine_phys_dev *physical_device = CONTAINING_RECORD(device->physical_device, struct wine_phys_dev, obj);
+    VkExternalMemoryBufferCreateInfo external_memory_info, *ext_info;
+    VkBufferCreateInfo info = *create_info;
+
+    if ((ext_info = find_next_struct(create_info, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO)))
+    {
+        if (ext_info->handleTypes & wine_vk_handle_over_fd_types)
+            ext_info->handleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
+        wine_vk_normalize_handle_types_host(&ext_info->handleTypes);
+    }
+    else if (physical_device->external_memory_align &&
+        !find_next_struct(info.pNext, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO))
+    {
+        external_memory_info.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO;
+        external_memory_info.pNext = info.pNext;
+        external_memory_info.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT;
+        info.pNext = &external_memory_info;
+    }
+
+    return device->p_vkCreateBuffer(device->host.device, &info, NULL, buffer);
+}
+
+VkResult wine_vkCreateImage(VkDevice client_device, const VkImageCreateInfo *create_info,
+                            const VkAllocationCallbacks *allocator, VkImage *image)
+{
+    struct vulkan_device *device = vulkan_device_from_handle(client_device);
+    struct wine_phys_dev *physical_device = CONTAINING_RECORD(device->physical_device, struct wine_phys_dev, obj);
+    VkExternalMemoryImageCreateInfo external_memory_info, *update_info;
+    VkImageCreateInfo info = *create_info;
+
+    if ((update_info = find_next_struct(info.pNext, VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO)))
+    {
+        if (update_info->handleTypes & wine_vk_handle_over_fd_types)
+            update_info->handleTypes |= VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
+        wine_vk_normalize_handle_types_host(&update_info->handleTypes);
+    }
+    else if (physical_device->external_memory_align)
+    {
+        external_memory_info.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO;
+        external_memory_info.pNext = info.pNext;
+        external_memory_info.handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT;
+        info.pNext = &external_memory_info;
+    }
+
+    return device->p_vkCreateImage(device->host.device, &info, NULL, image);
 }
 
 VkResult wine_vkCreateDebugUtilsMessengerEXT(VkInstance client_instance,
@@ -1793,38 +3202,16 @@ void wine_vkDestroyDeferredOperationKHR(
     free(object);
 }
 
-static NTSTATUS is_available_instance_function(VkInstance handle, const char *name)
+static void substitute_function_name(const char **name)
 {
-    struct wine_instance *instance = wine_instance_from_handle(handle);
-
-    if (!strcmp(name, "vkCreateWin32SurfaceKHR"))
-        return instance->enable_win32_surface;
-    if (!strcmp(name, "vkGetPhysicalDeviceWin32PresentationSupportKHR"))
-        return instance->enable_win32_surface;
-
-    return !!vk_funcs->p_vkGetInstanceProcAddr(instance->obj.host.instance, name);
-}
-
-static NTSTATUS is_available_device_function(VkDevice handle, const char *name)
-{
-    struct wine_device *device = wine_device_from_handle(handle);
-
-    if (!strcmp(name, "vkGetMemoryWin32HandleKHR"))
-        return device->has_external_memory_win32;
-    if (!strcmp(name, "vkGetMemoryWin32HandlePropertiesKHR"))
-        return device->has_external_memory_win32;
-
-    if (!strcmp(name, "vkGetSemaphoreWin32HandleKHR"))
-        return device->has_external_semaphore_win32;
-    if (!strcmp(name, "vkImportSemaphoreWin32HandleKHR"))
-        return device->has_external_semaphore_win32;
-
-    if (!strcmp(name, "vkGetFenceWin32HandleKHR"))
-        return device->has_external_fence_win32;
-    if (!strcmp(name, "vkImportFenceWin32HandleKHR"))
-        return device->has_external_fence_win32;
-
-    return !!vk_funcs->p_vkGetDeviceProcAddr(device->obj.host.device, name);
+    if (!strcmp(*name, "vkGetMemoryWin32HandleKHR") || !strcmp(*name, "vkGetMemoryWin32HandlePropertiesKHR"))
+        *name = "vkGetMemoryFdKHR";
+    else if (!strcmp(*name, "vkGetSemaphoreWin32HandleKHR"))
+        *name = "vkGetSemaphoreFdKHR";
+    else if (!strcmp(*name, "vkImportSemaphoreWin32HandleKHR"))
+        *name = "vkImportSemaphoreFdKHR";
+    else if (!strcmp(*name, "wine_vkAcquireKeyedMutex") || !strcmp(*name, "wine_vkReleaseKeyedMutex"))
+        *name = "vkImportSemaphoreFdKHR";
 }
 
 #ifdef _WIN64
@@ -1832,13 +3219,23 @@ static NTSTATUS is_available_device_func
 NTSTATUS vk_is_available_instance_function(void *arg)
 {
     struct is_available_instance_function_params *params = arg;
-    return is_available_instance_function(params->instance, params->name);
+    struct wine_instance *instance = wine_instance_from_handle(params->instance);
+    substitute_function_name(&params->name);
+
+    if (!strcmp(params->name, "vkCreateWin32SurfaceKHR"))
+        return instance->enable_win32_surface;
+    if (!strcmp(params->name, "vkGetPhysicalDeviceWin32PresentationSupportKHR"))
+        return instance->enable_win32_surface;
+
+    return !!vk_funcs->p_vkGetInstanceProcAddr(instance->obj.host.instance, params->name);
 }
 
 NTSTATUS vk_is_available_device_function(void *arg)
 {
     struct is_available_device_function_params *params = arg;
-    return is_available_device_function(params->device, params->name);
+    struct vulkan_device *device = vulkan_device_from_handle(params->device);
+    substitute_function_name(&params->name);
+    return !!vk_funcs->p_vkGetDeviceProcAddr(device->host.device, params->name);
 }
 
 #endif /* _WIN64 */
@@ -1850,7 +3247,16 @@ NTSTATUS vk_is_available_instance_functi
         UINT32 instance;
         UINT32 name;
     } *params = arg;
-    return is_available_instance_function(UlongToPtr(params->instance), UlongToPtr(params->name));
+    struct wine_instance *instance = wine_instance_from_handle(UlongToPtr(params->instance));
+    const char *name = UlongToPtr(params->name);
+
+    if (!strcmp(UlongToPtr(params->name), "vkCreateWin32SurfaceKHR"))
+        return instance->enable_win32_surface;
+    if (!strcmp(UlongToPtr(params->name), "vkGetPhysicalDeviceWin32PresentationSupportKHR"))
+        return instance->enable_win32_surface;
+
+    substitute_function_name(&name);
+    return !!vk_funcs->p_vkGetInstanceProcAddr(instance->obj.host.instance, name);
 }
 
 NTSTATUS vk_is_available_device_function32(void *arg)
@@ -1860,5 +3266,1441 @@ NTSTATUS vk_is_available_device_function
         UINT32 device;
         UINT32 name;
     } *params = arg;
-    return is_available_device_function(UlongToPtr(params->device), UlongToPtr(params->name));
+    struct vulkan_device *device = vulkan_device_from_handle(UlongToPtr(params->device));
+    const char *name = UlongToPtr(params->name);
+    substitute_function_name(&name);
+    return !!vk_funcs->p_vkGetDeviceProcAddr(device->host.device, name);
+}
+
+VkResult wine_vkGetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32HandleInfoKHR *handle_info, HANDLE *handle)
+{
+    struct wine_device_memory *dev_mem = wine_device_memory_from_handle(handle_info->memory);
+    const VkBaseInStructure *chain;
+    HANDLE ret;
+
+    TRACE("%p, %p %p\n", device, handle_info, handle);
+
+    if (!(dev_mem->handle_types & handle_info->handleType))
+        return VK_ERROR_UNKNOWN;
+
+    if ((chain = handle_info->pNext))
+        FIXME("Ignoring a linked structure of type %u.\n", chain->sType);
+
+    switch(handle_info->handleType)
+    {
+        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
+        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT:
+            return !NtDuplicateObject( NtCurrentProcess(), dev_mem->handle, NtCurrentProcess(), handle, dev_mem->access, dev_mem->inherit ? OBJ_INHERIT : 0, 0) ?
+                VK_SUCCESS : VK_ERROR_OUT_OF_HOST_MEMORY;
+        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
+        case VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT:
+        {
+            if ((ret = get_shared_resource_kmt_handle(dev_mem->handle)) == INVALID_HANDLE_VALUE)
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            *handle = ret;
+            return VK_SUCCESS;
+        }
+        default:
+            FIXME("Unable to get handle of type %x, did the application ignore the capabilities?\n", handle_info->handleType);
+            return VK_ERROR_UNKNOWN;
+    }
+}
+
+VkResult wine_vkGetMemoryWin32HandlePropertiesKHR(VkDevice device_handle, VkExternalMemoryHandleTypeFlagBits type, HANDLE handle, VkMemoryWin32HandlePropertiesKHR *properties)
+{
+    struct vulkan_device *device = vulkan_device_from_handle(device_handle);
+    struct wine_phys_dev *physical_device = CONTAINING_RECORD(device->physical_device, struct wine_phys_dev, obj);
+    unsigned int i;
+
+    TRACE("%p %u %p %p\n", device, type, handle, properties);
+
+    if (!(type & wine_vk_handle_over_fd_types))
+    {
+        FIXME("type %#x.\n", type);
+        return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+    }
+
+    properties->memoryTypeBits = 0;
+    for (i = 0; i < physical_device->memory_properties.memoryTypeCount; ++i)
+        if (physical_device->memory_properties.memoryTypes[i].propertyFlags == VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)
+            properties->memoryTypeBits |= 1u << i;
+
+    return VK_SUCCESS;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_SET_OBJECT           CTL_CODE(FILE_DEVICE_VIDEO, 6, METHOD_BUFFERED, FILE_WRITE_ACCESS)
+
+static bool set_shared_resource_object(HANDLE shared_resource, unsigned int index, HANDLE handle)
+{
+    IO_STATUS_BLOCK iosb;
+    struct shared_resource_set_object
+    {
+        unsigned int index;
+        obj_handle_t handle;
+    } params;
+
+    params.index = index;
+    params.handle = wine_server_obj_handle(handle);
+
+    return NtDeviceIoControlFile(shared_resource, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_SET_OBJECT,
+            &params, sizeof(params), NULL, 0) == STATUS_SUCCESS;
+}
+
+#define IOCTL_SHARED_GPU_RESOURCE_GET_OBJECT           CTL_CODE(FILE_DEVICE_VIDEO, 6, METHOD_BUFFERED, FILE_READ_ACCESS)
+
+static HANDLE get_shared_resource_object(HANDLE shared_resource, unsigned int index)
+{
+    IO_STATUS_BLOCK iosb;
+    obj_handle_t handle;
+
+    if (NtDeviceIoControlFile(shared_resource, NULL, NULL, NULL, &iosb, IOCTL_SHARED_GPU_RESOURCE_GET_OBJECT,
+            &index, sizeof(index), &handle, sizeof(handle)))
+        return NULL;
+
+    return wine_server_ptr_handle(handle);
+}
+
+static void d3d12_semaphore_lock(struct wine_semaphore *semaphore)
+{
+    assert( semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT );
+    pthread_mutex_lock(&semaphore->d3d12_fence_shm->mutex);
+}
+
+static void d3d12_semaphore_unlock(struct wine_semaphore *semaphore)
+{
+    assert( semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT );
+    pthread_mutex_unlock(&semaphore->d3d12_fence_shm->mutex);
+}
+
+static VkSemaphore create_timeline_semaphore(struct vulkan_device *device)
+{
+    VkSemaphoreTypeCreateInfo timeline_info = { 0 };
+    VkSemaphoreCreateInfo create_info = { 0 };
+    VkSemaphore sem = 0;
+    VkResult res;
+
+    timeline_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
+    timeline_info.semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE;
+    create_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
+    create_info.pNext = &timeline_info;
+
+    res = device->p_vkCreateSemaphore(device->host.device, &create_info, NULL, &sem);
+    if (res != VK_SUCCESS)
+        ERR("vkCreateSemaphore failed, res=%d\n", res);
+    return sem;
+}
+
+static void release_fence_op(struct vulkan_device *device, struct pending_d3d12_fence_op *op)
+{
+    list_remove(&op->entry);
+    vulkan_instance_remove_object(device->physical_device->instance, &op->semaphore->obj.obj);
+    vulkan_object_init(&op->semaphore->obj.obj, op->semaphore->semaphore);
+    vulkan_instance_insert_object(device->physical_device->instance, &op->semaphore->obj.obj);
+    op->semaphore = NULL;
+    list_add_head(&device->free_fence_ops_list, &op->entry);
+}
+
+static int wait_info_realloc(VkSemaphoreWaitInfo *wait_info, uint32_t *wait_alloc_count)
+{
+    VkSemaphore *new_sem;
+    uint64_t *new_values;
+
+    if (wait_info->semaphoreCount + 1 <= *wait_alloc_count)
+        return 1;
+    new_sem = realloc((void *)wait_info->pSemaphores, *wait_alloc_count * 2 * sizeof(*new_sem));
+    if (!new_sem)
+    {
+        fprintf(stderr, "err:winevulkan:wait_info_realloc no memory.\n");
+        return 0;
+    }
+    new_values = realloc((void *)wait_info->pValues, *wait_alloc_count * 2 * sizeof(*new_values));
+    if (!new_values)
+    {
+        fprintf(stderr, "err:winevulkan:wait_info_realloc no memory.\n");
+        return 0;
+    }
+    *wait_alloc_count *= 2;
+    wait_info->pSemaphores = new_sem;
+    wait_info->pValues = new_values;
+    return 1;
+}
+
+static int add_sem_wait(VkSemaphoreWaitInfo *wait_info, uint32_t *wait_alloc_count, VkSemaphore sem, uint64_t value)
+{
+    if (!wait_info_realloc(wait_info, wait_alloc_count))
+        return 0;
+    ((VkSemaphore *)wait_info->pSemaphores)[wait_info->semaphoreCount] = sem;
+    ((uint64_t *)wait_info->pValues)[wait_info->semaphoreCount] = value;
+    ++wait_info->semaphoreCount;
+    return 1;
+}
+
+static int semaphore_process(struct vulkan_device *device, struct wine_semaphore *sem,
+        VkSemaphoreWaitInfo *wait_info, uint32_t *wait_alloc_count)
+{
+    /* Called from native thread. */
+    struct pending_d3d12_fence_op *op, *op2;
+    uint64_t global_sem_wait_value;
+    int virtual_value_updated = 0;
+    uint64_t value, virtual_value;
+    VkResult res;
+    uint32_t i;
+
+    /* Check local pending signal ops completion, update shared semaphore. */
+    d3d12_semaphore_lock( sem );
+    virtual_value = sem->d3d12_fence_shm->virtual_value;
+    LIST_FOR_EACH_ENTRY_SAFE(op, op2, &sem->pending_signals, struct pending_d3d12_fence_op, entry)
+    {
+        res = get_semaphore_value(device, op->local_sem.sem, &value);
+        if (res != VK_SUCCESS)
+        {
+            fprintf(stderr, "err:winevulkan:semaphore_process vkGetSemaphoreCounterValue failed, res=%d.\n", res);
+            goto signal_op_complete;
+        }
+        if (value <= op->local_sem.value)
+        {
+            if (!add_sem_wait(wait_info, wait_alloc_count, op->local_sem.sem, op->local_sem.value + 1))
+            {
+                d3d12_semaphore_unlock(sem);
+                return 0;
+            }
+            continue;
+        }
+
+        virtual_value = max( sem->d3d12_fence_shm->virtual_value, op->virtual_value );
+        sem->d3d12_fence_shm->virtual_value = op->virtual_value;
+        virtual_value_updated = 1;
+signal_op_complete:
+        op->local_sem.value = value;
+        release_fence_op(device, op);
+    }
+
+    if (sem->d3d12_fence_shm->virtual_value < virtual_value)
+    {
+        uint32_t idx = sem->d3d12_fence_shm->reset_backlog_count;
+
+        if (debug_level >= 3)
+            fprintf(stderr, "warn:winevulkan:semaphore_process resetting semaphore %p virtual value.\n", sem);
+        if (idx == ARRAY_SIZE(sem->d3d12_fence_shm->reset_backlog))
+        {
+            sem->d3d12_fence_shm->last_dropped_reset_physical = sem->d3d12_fence_shm->reset_backlog[0].physical_at_reset;
+            --idx;
+            memmove(&sem->d3d12_fence_shm->reset_backlog[0], &sem->d3d12_fence_shm->reset_backlog[1],
+                    sizeof(*sem->d3d12_fence_shm->reset_backlog) * sem->d3d12_fence_shm->reset_backlog_count);
+        }
+        else
+        {
+            ++sem->d3d12_fence_shm->reset_backlog_count;
+        }
+        sem->d3d12_fence_shm->last_reset_physical = sem->d3d12_fence_shm->physical_value + 1;
+        sem->d3d12_fence_shm->reset_backlog[idx].physical_at_reset = sem->d3d12_fence_shm->last_reset_physical;
+        sem->d3d12_fence_shm->reset_backlog[idx].virtual_before_reset = virtual_value;
+    }
+    if (virtual_value_updated)
+        signal_timeline_sem(device, sem->fence_timeline_semaphore, &sem->d3d12_fence_shm->physical_value);
+    global_sem_wait_value = sem->d3d12_fence_shm->physical_value + 1;
+
+    /* Complete satisfied local waits. */
+    LIST_FOR_EACH_ENTRY_SAFE(op, op2, &sem->pending_waits, struct pending_d3d12_fence_op, entry)
+    {
+        if (op->virtual_value > virtual_value)
+        {
+            if (op->shared_physical_value > sem->d3d12_fence_shm->last_reset_physical)
+                continue;
+            for (i = 0; i < sem->d3d12_fence_shm->reset_backlog_count; ++i)
+            {
+                if (sem->d3d12_fence_shm->reset_backlog[i].physical_at_reset >= op->shared_physical_value
+                        && sem->d3d12_fence_shm->reset_backlog[i].virtual_before_reset >= op->virtual_value)
+                    break;
+            }
+            if (i == sem->d3d12_fence_shm->reset_backlog_count)
+            {
+                if (sem->d3d12_fence_shm->last_dropped_reset_physical < op->shared_physical_value)
+                    continue;
+                fprintf(stderr, "err:winevulkan:semaphore_process wait needs reset backlog beyond cut off.\n");
+            }
+        }
+
+        signal_timeline_sem(device, op->local_sem.sem, &op->local_sem.value);
+        release_fence_op(device, op);
+    }
+    d3d12_semaphore_unlock(sem);
+
+    /* Only poll shared semaphore if there are waits pending. */
+    if (list_empty(&sem->pending_waits))
+        return 1;
+    return add_sem_wait(wait_info, wait_alloc_count, sem->fence_timeline_semaphore, global_sem_wait_value);
+}
+
+#define SIGNALLER_INITIAL_WAIT_COUNT 256
+
+void *signaller_worker(void *arg)
+{
+#ifdef HAVE_SYS_SYSCALL_H
+    int unix_tid = syscall( __NR_gettid );
+#else
+    int unix_tid = -1;
+#endif
+    struct vulkan_device *device = arg;
+    struct wine_semaphore *sem;
+    VkSemaphoreWaitInfo wait_info = { 0 };
+    uint32_t wait_alloc_count = 0;
+    VkResult res;
+
+    if (debug_level)
+        fprintf(stderr, "[%d] msg:winevulkan:signaller_worker started.\n", unix_tid);
+
+    wait_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO;
+    wait_info.flags = VK_SEMAPHORE_WAIT_ANY_BIT;
+    wait_alloc_count = SIGNALLER_INITIAL_WAIT_COUNT;
+    if (!(wait_info.pSemaphores = malloc(sizeof(*wait_info.pSemaphores) * wait_alloc_count)))
+    {
+        fprintf(stderr, "err:winevulkan:signaller_worker no memory.\n");
+        return NULL;
+    }
+    if (!(wait_info.pValues = malloc(sizeof(*wait_info.pValues) * wait_alloc_count)))
+    {
+        fprintf(stderr, "err:winevulkan:signaller_worker no memory.\n");
+        free((void *)wait_info.pSemaphores);
+        return NULL;
+    }
+
+    for (;;)
+    {
+        pthread_mutex_lock(&device->signaller_mutex);
+        if (device->stop)
+        {
+            pthread_mutex_unlock(&device->signaller_mutex);
+            break;
+        }
+        wait_info.semaphoreCount = 1;
+        *(VkSemaphore *)wait_info.pSemaphores = device->sem_poll_update.sem;
+        *(uint64_t *)wait_info.pValues = device->sem_poll_update.value + 1;
+        LIST_FOR_EACH_ENTRY(sem, &device->sem_poll_list, struct wine_semaphore, poll_entry)
+        {
+            if (!semaphore_process(device, sem, &wait_info, &wait_alloc_count))
+            {
+                pthread_mutex_unlock(&device->signaller_mutex);
+                break;
+            }
+        }
+        device->sem_poll_update_value = device->sem_poll_update.value;
+        pthread_cond_signal(&device->sem_poll_updated_cond);
+        pthread_mutex_unlock(&device->signaller_mutex);
+        while ((res = wait_semaphores(device, &wait_info, 3000000000ull)) == VK_TIMEOUT)
+        {
+            if (wait_info.semaphoreCount > 1)
+                fprintf(stderr, "err:winevulkan:signaller_worker wait timed out with non-empty poll list.\n");
+        }
+        if (res != VK_SUCCESS)
+        {
+            fprintf(stderr, "err:winevulkan:signaller_worker error waiting for semaphores, vr %d.\n", res);
+            break;
+        }
+    }
+
+    free((void *)wait_info.pSemaphores);
+    free((void *)wait_info.pValues);
+    if (debug_level)
+        fprintf(stderr, "[%d] msg:winevulkan:signaller_worker exiting.\n", unix_tid);
+
+    return NULL;
+}
+
+static void register_sem_poll(struct vulkan_device *device, struct wine_semaphore *semaphore)
+{
+    pthread_mutex_lock(&device->signaller_mutex);
+    if (!device->signaller_thread)
+    {
+        device->sem_poll_update.sem = create_timeline_semaphore(device);
+        device->sem_poll_update.value = 0;
+        pthread_cond_init(&device->sem_poll_updated_cond, NULL);
+        if (TRACE_ON(vulkan))
+            debug_level = 4;
+        else if (WARN_ON(vulkan))
+            debug_level = 3;
+        else if (FIXME_ON(vulkan))
+            debug_level = 2;
+        else if (ERR_ON(vulkan))
+            debug_level = 1;
+        else
+            debug_level = 0;
+        if (pthread_create(&device->signaller_thread, NULL, signaller_worker, device))
+            ERR("Failed to create signaller_worker.\n");
+        WARN("d3d12 fence used, created signaller worker.\n");
+    }
+    assert(!semaphore->poll_entry.next);
+    list_add_head(&device->sem_poll_list, &semaphore->poll_entry);
+    signal_timeline_sem(device, device->sem_poll_update.sem, &device->sem_poll_update.value);
+    pthread_mutex_unlock(&device->signaller_mutex);
+}
+
+static void update_sem_poll_wait_processed(struct vulkan_device *device)
+{
+    uint64_t update_value;
+
+    signal_timeline_sem(device, device->sem_poll_update.sem, &device->sem_poll_update.value);
+    update_value = device->sem_poll_update.value;
+    while (device->sem_poll_update_value < update_value)
+        pthread_cond_wait(&device->sem_poll_updated_cond, &device->signaller_mutex);
+}
+
+static void unregister_sem_poll(struct vulkan_device *device, struct wine_semaphore *semaphore)
+{
+    struct list *entry;
+
+    pthread_mutex_lock(&device->signaller_mutex);
+    list_remove(&semaphore->poll_entry);
+    semaphore->poll_entry.next = semaphore->poll_entry.prev = NULL;
+    update_sem_poll_wait_processed(device);
+    pthread_mutex_unlock(&device->signaller_mutex);
+
+    while ((entry = list_head(&semaphore->pending_waits)))
+        release_fence_op(device, CONTAINING_RECORD(entry, struct pending_d3d12_fence_op, entry));
+    while ((entry = list_head(&semaphore->pending_signals)))
+        release_fence_op(device, CONTAINING_RECORD(entry, struct pending_d3d12_fence_op, entry));
+}
+
+static struct pending_d3d12_fence_op *get_free_fence_op(struct vulkan_device *device)
+{
+    struct pending_d3d12_fence_op *op;
+    struct list *entry;
+
+    if ((entry = list_head(&device->free_fence_ops_list)))
+    {
+        list_remove(entry);
+        return CONTAINING_RECORD(entry, struct pending_d3d12_fence_op, entry);
+    }
+
+    if (!(op = malloc(sizeof(*op))))
+    {
+        ERR("No memory.\n");
+        return NULL;
+    }
+    op->local_sem.sem = create_timeline_semaphore(device);
+    op->local_sem.value = 0;
+    ++device->allocated_fence_ops_count;
+    TRACE("Total allocated fence ops %u.\n", device->allocated_fence_ops_count);
+    return op;
+}
+
+static void add_sem_wait_op(struct vulkan_device *device, struct wine_semaphore *semaphore, uint64_t virtual_value,
+        VkSemaphore *phys_semaphore, uint64_t *phys_wait_value)
+{
+    struct pending_d3d12_fence_op *op;
+
+    pthread_mutex_lock(&device->signaller_mutex);
+    LIST_FOR_EACH_ENTRY(op, &semaphore->pending_waits, struct pending_d3d12_fence_op, entry)
+    {
+        if (op->virtual_value == virtual_value)
+        {
+            *phys_semaphore = op->local_sem.sem;
+            *phys_wait_value = op->local_sem.value + 1;
+            pthread_mutex_unlock(&device->signaller_mutex);
+            return;
+        }
+    }
+    if ((op = get_free_fence_op(device)))
+    {
+        op->virtual_value = virtual_value;
+        op->shared_physical_value = __atomic_load_n(&semaphore->d3d12_fence_shm->physical_value, __ATOMIC_ACQUIRE) + 1;
+        *phys_semaphore = op->local_sem.sem;
+        *phys_wait_value = op->local_sem.value + 1;
+        op->semaphore = semaphore;
+        list_add_tail(&semaphore->pending_waits, &op->entry);
+        vulkan_instance_remove_object(device->physical_device->instance, &semaphore->obj.obj);
+        vulkan_object_init(&semaphore->obj.obj, op->local_sem.sem);
+        vulkan_instance_insert_object(device->physical_device->instance, &semaphore->obj.obj);
+
+        signal_timeline_sem(device, device->sem_poll_update.sem, &device->sem_poll_update.value);
+        TRACE("added wait op, semaphore %p, %s, temp sem %s, %s.\n", semaphore, wine_dbgstr_longlong(virtual_value),
+                wine_dbgstr_longlong(op->local_sem.sem), wine_dbgstr_longlong(op->local_sem.value));
+    }
+    else
+    {
+        *phys_semaphore = 0;
+        *phys_wait_value = 0;
+    }
+    pthread_mutex_unlock(&device->signaller_mutex);
+}
+
+static void add_sem_signal_op(struct vulkan_device *device, struct wine_semaphore *semaphore, uint64_t virtual_value,
+        VkSemaphore *phys_semaphore, uint64_t *phys_signal_value, BOOL signal_immediate)
+{
+    struct pending_d3d12_fence_op *op;
+    UINT64 value;
+
+    pthread_mutex_lock(&device->signaller_mutex);
+    if ((op = get_free_fence_op(device)))
+    {
+        op->virtual_value = virtual_value;
+        *phys_semaphore = op->local_sem.sem;
+        *phys_signal_value = op->local_sem.value + 1;
+        op->semaphore = semaphore;
+        list_add_tail(&semaphore->pending_signals, &op->entry);
+        vulkan_instance_remove_object(device->physical_device->instance, &semaphore->obj.obj);
+        vulkan_object_init(&semaphore->obj.obj, op->local_sem.sem);
+        vulkan_instance_insert_object(device->physical_device->instance, &semaphore->obj.obj);
+
+        if (signal_immediate)
+        {
+            value = op->local_sem.value;
+            signal_timeline_sem(device, op->local_sem.sem, &value);
+            update_sem_poll_wait_processed(device);
+            TRACE("signal op %p, semaphore %p, %s, temp sem %s, %s.\n", op, semaphore, wine_dbgstr_longlong(virtual_value),
+                    wine_dbgstr_longlong(op->local_sem.sem), wine_dbgstr_longlong(op->local_sem.value));
+        }
+        else
+        {
+            signal_timeline_sem(device, device->sem_poll_update.sem, &device->sem_poll_update.value);
+            TRACE("added signal op, semaphore %p, %s, temp sem %s, %s.\n", semaphore, wine_dbgstr_longlong(virtual_value),
+                    wine_dbgstr_longlong(op->local_sem.sem), wine_dbgstr_longlong(op->local_sem.value));
+        }
+    }
+    else
+    {
+        *phys_semaphore = 0;
+        *phys_signal_value = 0;
+    }
+    pthread_mutex_unlock(&device->signaller_mutex);
+}
+
+VkResult wine_vkCreateSemaphore(VkDevice client_device, const VkSemaphoreCreateInfo *create_info,
+        const VkAllocationCallbacks *allocator, VkSemaphore *semaphore)
+{
+    struct vulkan_device *device = vulkan_device_from_handle(client_device);
+
+    VkExportSemaphoreWin32HandleInfoKHR *export_handle_info = wine_vk_find_unlink_struct(create_info, EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR);
+    VkExportSemaphoreCreateInfo *export_semaphore_info, timeline_export_info;
+    VkSemaphoreCreateInfo create_info_dup = *create_info;
+    VkSemaphoreTypeCreateInfo *found_type_info, type_info;
+    VkSemaphoreGetFdInfoKHR fd_info;
+    pthread_mutexattr_t mutex_attr;
+    struct wine_semaphore *object;
+    OBJECT_ATTRIBUTES attr;
+    HANDLE section_handle;
+    LARGE_INTEGER li;
+    VkResult res;
+    SIZE_T size;
+    int fd;
+
+    TRACE("(%p, %p, %p, %p)\n", device, create_info, allocator, semaphore);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if (!(object = calloc(1, sizeof(*object))))
+        return VK_ERROR_OUT_OF_HOST_MEMORY;
+
+    list_init(&object->pending_signals);
+    list_init(&object->pending_waits);
+
+    object->handle = INVALID_HANDLE_VALUE;
+
+    if ((export_semaphore_info = find_next_struct(&create_info_dup, VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO)))
+    {
+        object->export_types = export_semaphore_info->handleTypes;
+        if (export_semaphore_info->handleTypes & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT)
+            export_semaphore_info->handleTypes |= VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+        wine_vk_normalize_semaphore_handle_types_host(&export_semaphore_info->handleTypes);
+    }
+
+    if ((res = device->p_vkCreateSemaphore(device->host.device, &create_info_dup, NULL, &object->semaphore)) != VK_SUCCESS)
+        goto done;
+
+    if (export_semaphore_info && export_semaphore_info->handleTypes == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT)
+    {
+        fd_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
+        fd_info.pNext = NULL;
+        fd_info.semaphore = object->semaphore;
+        fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+        if ((res = device->p_vkGetSemaphoreFdKHR(device->host.device, &fd_info, &fd)) == VK_SUCCESS)
+        {
+            object->handle = create_gpu_resource(fd, export_handle_info ? export_handle_info->name : NULL, 0);
+            close(fd);
+        }
+
+        if (object->handle == INVALID_HANDLE_VALUE)
+        {
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto done;
+        }
+    }
+    else if (object->export_types & VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+    {
+        /* compatibleHandleTypes doesn't include any other types */
+        assert(object->export_types == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT);
+        object->handle_type = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT;
+
+        timeline_export_info.sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO;
+        timeline_export_info.pNext = NULL;
+        timeline_export_info.handleTypes = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+        type_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
+        type_info.pNext = &timeline_export_info;
+        type_info.semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE;
+        type_info.initialValue = 0;
+
+        create_info_dup.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
+        create_info_dup.pNext = &type_info;
+        create_info_dup.flags = 0;
+
+        if ((res = device->p_vkCreateSemaphore(device->host.device, &create_info_dup, NULL, &object->fence_timeline_semaphore)) != VK_SUCCESS)
+            goto done;
+
+        fd_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR;
+        fd_info.pNext = NULL;
+        fd_info.semaphore = object->fence_timeline_semaphore;
+        fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+
+        if ((res = device->p_vkGetSemaphoreFdKHR(device->host.device, &fd_info, &fd)) == VK_SUCCESS)
+        {
+            object->handle = create_gpu_resource(fd, export_handle_info ? export_handle_info->name : NULL, 0);
+            close(fd);
+        }
+
+        if (object->handle == INVALID_HANDLE_VALUE)
+        {
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto done;
+        }
+
+        /* Shared Fence Memory */
+        InitializeObjectAttributes(&attr, NULL, 0, NULL, NULL);
+        size = li.QuadPart = sizeof(*object->d3d12_fence_shm);
+        if (NtCreateSection(&section_handle, STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE, &attr, &li, PAGE_READWRITE, SEC_COMMIT, NULL))
+        {
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto done;
+        }
+
+        if (!set_shared_resource_object(object->handle, 0, section_handle))
+        {
+            NtClose(section_handle);
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto done;
+        }
+
+        if (NtMapViewOfSection(section_handle, GetCurrentProcess(), (void**) &object->d3d12_fence_shm, 0, 0, NULL, &size, ViewShare, 0, PAGE_READWRITE))
+        {
+            NtClose(section_handle);
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto done;
+        }
+
+        NtClose(section_handle);
+
+        if ((found_type_info = find_next_struct(create_info, VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO)))
+            object->d3d12_fence_shm->virtual_value = found_type_info->initialValue;
+
+        pthread_mutexattr_init(&mutex_attr);
+        pthread_mutexattr_setpshared(&mutex_attr, PTHREAD_PROCESS_SHARED);
+        if (pthread_mutex_init(&object->d3d12_fence_shm->mutex, &mutex_attr))
+        {
+            pthread_mutexattr_destroy(&mutex_attr);
+            res = VK_ERROR_OUT_OF_HOST_MEMORY;
+            goto done;
+        }
+        pthread_mutexattr_destroy(&mutex_attr);
+
+        vulkan_object_init(&object->obj.obj, object->fence_timeline_semaphore);
+        vulkan_instance_insert_object(device->physical_device->instance, &object->obj.obj);
+        object->obj.d3d12_fence = TRUE;
+    }
+    if (object->fence_timeline_semaphore == VK_NULL_HANDLE)
+    {
+        vulkan_object_init(&object->obj.obj, object->semaphore);
+        vulkan_instance_insert_object(device->physical_device->instance, &object->obj.obj);
+    }
+    *semaphore = object->obj.client.handle;
+
+    done:
+
+    if (res != VK_SUCCESS)
+    {
+        if (object->d3d12_fence_shm)
+        {
+            pthread_mutex_destroy(&object->d3d12_fence_shm->mutex);
+            NtUnmapViewOfSection(GetCurrentProcess(), object->d3d12_fence_shm);
+        }
+        if (object->handle != INVALID_HANDLE_VALUE)
+            NtClose(object->handle);
+        if (object->semaphore != VK_NULL_HANDLE)
+            device->p_vkDestroySemaphore(device->host.device, object->semaphore, NULL);
+        if (object->fence_timeline_semaphore != VK_NULL_HANDLE)
+            device->p_vkDestroySemaphore(device->host.device, object->fence_timeline_semaphore, NULL);
+        free(object);
+    }
+    else if (object->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+        register_sem_poll(device, object);
+    if (res == VK_SUCCESS)
+    {
+        TRACE("-> %p (native %#llx, shared %#llx).\n", object, (long long)object->semaphore, (long long)object->fence_timeline_semaphore);
+    }
+
+    return res;
+}
+
+VkResult wine_vkGetSemaphoreWin32HandleKHR(VkDevice client_device, const VkSemaphoreGetWin32HandleInfoKHR *handle_info,
+        HANDLE *handle)
+{
+    struct wine_semaphore *semaphore = wine_semaphore_from_handle(handle_info->semaphore);
+
+    if (!(semaphore->export_types & handle_info->handleType))
+        return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+
+    if (NtDuplicateObject( NtCurrentProcess(), semaphore->handle, NtCurrentProcess(), handle, 0, 0, DUPLICATE_SAME_ACCESS ))
+        return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+
+    return VK_SUCCESS;
+}
+
+void wine_vkDestroySemaphore(VkDevice client_device, VkSemaphore semaphore_handle, const VkAllocationCallbacks *allocator)
+{
+    struct vulkan_device *device = vulkan_device_from_handle(client_device);
+    struct wine_semaphore *semaphore = wine_semaphore_from_handle(semaphore_handle);
+
+    TRACE("%p, %p, %p\n", device, semaphore, allocator);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if (!semaphore)
+        return;
+
+    if (semaphore->poll_entry.next)
+        unregister_sem_poll(device, semaphore);
+
+    if (semaphore->handle != INVALID_HANDLE_VALUE)
+        NtClose(semaphore->handle);
+
+    if (semaphore->d3d12_fence_shm)
+        NtUnmapViewOfSection(GetCurrentProcess(), semaphore->d3d12_fence_shm);
+
+    vulkan_instance_remove_object(device->physical_device->instance, &semaphore->obj.obj);
+    device->p_vkDestroySemaphore(device->host.device, semaphore->semaphore, NULL);
+
+    if (semaphore->fence_timeline_semaphore)
+        device->p_vkDestroySemaphore(device->host.device, semaphore->fence_timeline_semaphore, NULL);
+
+    free(semaphore);
+}
+
+VkResult wine_vkImportSemaphoreWin32HandleKHR(VkDevice client_device,
+        const VkImportSemaphoreWin32HandleInfoKHR *handle_info)
+{
+    struct vulkan_device *device = vulkan_device_from_handle(client_device);
+    struct wine_semaphore *semaphore = wine_semaphore_from_handle(handle_info->semaphore);
+    struct wine_semaphore output_semaphore;
+    VkSemaphoreTypeCreateInfo type_info;
+    VkImportSemaphoreFdInfoKHR fd_info;
+    VkSemaphoreCreateInfo create_info;
+    HANDLE d3d12_fence_shm;
+    NTSTATUS stat;
+    VkResult res;
+    SIZE_T size;
+
+    TRACE("(%p, %p). semaphore = %p handle = %p\n", device, handle_info, semaphore, handle_info->handle);
+
+    if (semaphore->poll_entry.next)
+        unregister_sem_poll(device, semaphore);
+
+    if (handle_info->handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT && !semaphore->fence_timeline_semaphore)
+    {
+        type_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
+        type_info.pNext = NULL;
+        type_info.semaphoreType = VK_SEMAPHORE_TYPE_TIMELINE;
+        type_info.initialValue = 0;
+
+        create_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;
+        create_info.pNext = &type_info;
+        create_info.flags = 0;
+
+        if ((res = device->p_vkCreateSemaphore(device->host.device, &create_info, NULL, &semaphore->fence_timeline_semaphore)) != VK_SUCCESS)
+        {
+            ERR("Failed to create timeline semaphore backing D3D12 semaphore. vr %d.\n", res);
+            return res;
+        };
+
+        vulkan_instance_remove_object(device->physical_device->instance, &semaphore->obj.obj);
+        vulkan_object_init(&semaphore->obj.obj, semaphore->fence_timeline_semaphore);
+        vulkan_instance_insert_object(device->physical_device->instance, &semaphore->obj.obj);
+        semaphore->obj.d3d12_fence = TRUE;
+    }
+
+    output_semaphore = *semaphore;
+    output_semaphore.handle = NULL;
+    output_semaphore.handle_type = handle_info->handleType;
+    output_semaphore.d3d12_fence_shm = NULL;
+
+    fd_info.sType = VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR;
+    fd_info.pNext = handle_info->pNext;
+    fd_info.semaphore = output_semaphore.obj.host.semaphore;
+    fd_info.flags = handle_info->flags;
+    fd_info.handleType = handle_info->handleType;
+
+    if (handle_info->handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT ||
+        handle_info->handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+    {
+        if (handle_info->name)
+        {
+            FIXME("Importing win32 semaphore by name not supported.\n");
+            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+        }
+
+        if (NtDuplicateObject( NtCurrentProcess(), handle_info->handle, NtCurrentProcess(), &output_semaphore.handle, 0, 0, DUPLICATE_SAME_ACCESS ))
+            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+
+        fd_info.handleType = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
+        if ((fd_info.fd = get_shared_resource_fd(output_semaphore.handle)) == -1)
+        {
+            WARN("Invalid handle %p.\n", handle_info->handle);
+            NtClose(output_semaphore.handle);
+            return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+        }
+
+        if (handle_info->handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+        {
+            if (handle_info->flags & VK_SEMAPHORE_IMPORT_TEMPORARY_BIT)
+            {
+                FIXME("Temporarily importing d3d12 fences unsupported.\n");
+                close(fd_info.fd);
+                NtClose(output_semaphore.handle);
+                return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+            }
+
+            if (!(d3d12_fence_shm = get_shared_resource_object(output_semaphore.handle, 0)))
+            {
+                ERR("Failed to get D3D12 semaphore memory.\n");
+                close(fd_info.fd);
+                NtClose(output_semaphore.handle);
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            }
+
+            size = sizeof(*output_semaphore.d3d12_fence_shm);
+            if ((stat = NtMapViewOfSection(d3d12_fence_shm, GetCurrentProcess(), (void**) &output_semaphore.d3d12_fence_shm, 0, 0, NULL, &size, ViewShare, 0, PAGE_READWRITE)))
+            {
+                ERR("Failed to map D3D12 semaphore memory. stat %#x.\n", (int)stat);
+                close(fd_info.fd);
+                NtClose(d3d12_fence_shm);
+                NtClose(output_semaphore.handle);
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            }
+
+            NtClose(d3d12_fence_shm);
+        }
+    }
+
+    wine_vk_normalize_semaphore_handle_types_host(&fd_info.handleType);
+
+    if (!fd_info.handleType)
+    {
+        FIXME("Importing win32 semaphore with handle type %#x not supported.\n", handle_info->handleType);
+        return VK_ERROR_INVALID_EXTERNAL_HANDLE;
+    }
+
+    if ((res = device->p_vkImportSemaphoreFdKHR(device->host.device, &fd_info)) == VK_SUCCESS)
+    {
+        if (semaphore->handle)
+            NtClose(semaphore->handle);
+        if (semaphore->d3d12_fence_shm)
+            NtUnmapViewOfSection(GetCurrentProcess(), semaphore->d3d12_fence_shm);
+
+        *semaphore = output_semaphore;
+        assert(!semaphore->poll_entry.next);
+        if (semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+            register_sem_poll(device, semaphore);
+    }
+    else
+    {
+        if (output_semaphore.handle)
+            NtClose(output_semaphore.handle);
+        if (output_semaphore.d3d12_fence_shm)
+            NtUnmapViewOfSection(GetCurrentProcess(), output_semaphore.d3d12_fence_shm);
+
+        /* importing FDs transfers ownership, importing NT handles does not  */
+        close(fd_info.fd);
+    }
+
+    return res;
+}
+
+static VkResult wine_vk_get_semaphore_counter_value(VkDevice device_handle, VkSemaphore semaphore_handle, uint64_t *value, bool khr)
+{
+    struct wine_semaphore *semaphore = wine_semaphore_from_handle(semaphore_handle);
+    struct vulkan_device *device = vulkan_device_from_handle(device_handle);
+
+    if (semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+    {
+        d3d12_semaphore_lock(semaphore);
+        *value = semaphore->d3d12_fence_shm->virtual_value;
+        d3d12_semaphore_unlock(semaphore);
+        return VK_SUCCESS;
+    }
+
+    if (khr)
+        return device->p_vkGetSemaphoreCounterValueKHR(device->host.device, semaphore->obj.host.semaphore, value);
+    else
+        return device->p_vkGetSemaphoreCounterValue(device->host.device, semaphore->obj.host.semaphore, value);
+}
+
+VkResult wine_vkGetSemaphoreCounterValue(VkDevice device_handle, VkSemaphore semaphore_handle, uint64_t *value)
+{
+    return wine_vk_get_semaphore_counter_value(device_handle, semaphore_handle, value, false);
+}
+
+VkResult wine_vkGetSemaphoreCounterValueKHR(VkDevice device_handle, VkSemaphore semaphore_handle, uint64_t *value)
+{
+    return wine_vk_get_semaphore_counter_value(device_handle, semaphore_handle, value, true);
+}
+
+static NTSTATUS wine_vk_signal_semaphore(VkDevice device_handle, const VkSemaphoreSignalInfo *signal_info, bool khr)
+{
+    struct wine_semaphore *semaphore = wine_semaphore_from_handle(signal_info->semaphore);
+    struct vulkan_device *device = vulkan_device_from_handle(device_handle);
+    VkSemaphoreSignalInfo dup_signal_info = *signal_info;
+
+    TRACE("(%p, %p)\n", device, signal_info);
+
+    if (semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+    {
+        add_sem_signal_op(device, semaphore, signal_info->value, &dup_signal_info.semaphore, &dup_signal_info.value, TRUE);
+        return VK_SUCCESS;
+    }
+    else
+        dup_signal_info.semaphore = semaphore->obj.host.semaphore;
+
+    if (khr)
+        return device->p_vkSignalSemaphoreKHR(device->host.device, &dup_signal_info);
+    else
+        return device->p_vkSignalSemaphore(device->host.device, &dup_signal_info);
+}
+
+VkResult wine_vkSignalSemaphore(VkDevice device_handle, const VkSemaphoreSignalInfo *signal_info)
+{
+    return wine_vk_signal_semaphore(device_handle, signal_info, false);
+}
+
+VkResult wine_vkSignalSemaphoreKHR(VkDevice device_handle, const VkSemaphoreSignalInfo *signal_info)
+{
+    return wine_vk_signal_semaphore(device_handle, signal_info, true);
+}
+
+static void unwrap_semaphore(struct vulkan_device *device, VkSemaphore *sem_handle, uint64_t *value, BOOL signal)
+{
+    struct wine_semaphore *sem = wine_semaphore_from_handle(*sem_handle);
+
+    if (!sem)
+        return;
+
+    if (sem->handle_type != VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+    {
+        *sem_handle = sem->obj.host.semaphore;
+        return;
+    }
+    if (signal)
+        add_sem_signal_op(device, sem, *value, sem_handle, value, FALSE);
+    else
+        add_sem_wait_op(device, sem, *value, sem_handle, value);
+}
+
+static VkResult unwrap_semaphore_array(const VkSemaphore **sems, const uint64_t **values_out,
+        uint32_t count, struct conversion_context *ctx, BOOL signal, struct vulkan_device *device)
+{
+    const uint64_t *values = NULL;
+    const VkSemaphore *in;
+    VkSemaphore *out;
+    unsigned int i;
+
+    in = *sems;
+    *sems = NULL;
+
+    if (!in || !count)
+        return VK_SUCCESS;
+
+    out = conversion_context_alloc(ctx, count * sizeof(*out));
+    for (i = 0; i < count; ++i)
+    {
+        struct wine_semaphore *sem;
+        if (!in[i])
+        {
+            out[i] = VK_NULL_HANDLE;
+            continue;
+        }
+        sem = wine_semaphore_from_handle(in[i]);
+        if (sem->handle_type != VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+        {
+            out[i] = sem->obj.host.semaphore;
+            continue;
+        }
+        if (!values_out)
+        {
+            ERR("D3D12 fence without values specified.\n");
+            return VK_ERROR_UNKNOWN;
+        }
+        if (!values)
+        {
+            values = *values_out;
+            *values_out = conversion_context_alloc(ctx, count * sizeof(*values_out));
+            memcpy((void *)*values_out, values, count * sizeof(*values));
+        }
+        if (signal)
+            add_sem_signal_op(device, sem, values[i], &out[i], (uint64_t *)&(*values_out)[i], FALSE);
+        else
+            add_sem_wait_op(device, sem, values[i], &out[i], (uint64_t *)&(*values_out)[i]);
+    }
+    *sems = out;
+    return VK_SUCCESS;
+}
+
+static VkResult wine_vk_wait_semaphores(VkDevice device_handle, const VkSemaphoreWaitInfo *wait_info, uint64_t timeout, bool khr)
+{
+    struct vulkan_device *device = vulkan_device_from_handle(device_handle);
+    VkSemaphoreWaitInfo wait_info_dup = *wait_info;
+    struct conversion_context ctx;
+    VkResult ret;
+
+    init_conversion_context(&ctx);
+    if ((ret = unwrap_semaphore_array(&wait_info_dup.pSemaphores, &wait_info_dup.pValues,
+            wait_info->semaphoreCount, &ctx, FALSE, device)))
+        goto done;
+
+    if (khr)
+        ret = device->p_vkWaitSemaphoresKHR(device->host.device, &wait_info_dup, timeout);
+    else
+        ret = device->p_vkWaitSemaphores(device->host.device, &wait_info_dup, timeout);
+done:
+    free_conversion_context(&ctx);
+    return ret;
+}
+
+VkResult wine_vkWaitSemaphores(VkDevice device, const VkSemaphoreWaitInfo *wait_info, uint64_t timeout)
+{
+    TRACE("%p %p %s.\n", device, wait_info, wine_dbgstr_longlong(timeout));
+
+    return wine_vk_wait_semaphores(device, wait_info, timeout, false);
+}
+
+VkResult wine_vkWaitSemaphoresKHR(VkDevice device, const VkSemaphoreWaitInfo *wait_info, uint64_t timeout)
+{
+    TRACE("%p %p %s.\n", device, wait_info, wine_dbgstr_longlong(timeout));
+
+    return wine_vk_wait_semaphores(device, wait_info, timeout, true);
+}
+
+struct struct_chain_def
+{
+    VkStructureType sType;
+    unsigned int size;
+};
+
+static VkResult process_keyed_mutexes(struct conversion_context *ctx, struct vulkan_device *device,
+        uint32_t submit_count, const void *submits_win, size_t submit_size, uint32_t **signal_counts,
+        VkSemaphoreSubmitInfo ***signal_infos)
+{
+    VkWin32KeyedMutexAcquireReleaseInfoKHR *keyed_mutex_info;
+    struct wine_device_memory *memory;
+    VkResult ret = VK_ERROR_UNKNOWN;
+    uint32_t i, j, signal_count = 0;
+    void *ptr;
+
+    for (i = 0; i < submit_count; ++i)
+    {
+        ptr = (char *)submits_win + i * submit_size;
+        if (!(keyed_mutex_info = find_next_struct(ptr, VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR)))
+            continue;
+        for (j = 0; j < keyed_mutex_info->acquireCount; ++j)
+        {
+            memory = wine_device_memory_from_handle(keyed_mutex_info->pAcquireSyncs[j]);
+            if ((ret = acquire_keyed_mutex(device, memory, keyed_mutex_info->pAcquireKeys[j],
+                    keyed_mutex_info->pAcquireTimeouts[j])) == VK_SUCCESS)
+                continue;
+            while (j)
+            {
+                --j;
+                memory = wine_device_memory_from_handle(keyed_mutex_info->pAcquireSyncs[j]);
+                release_keyed_mutex(device, memory, keyed_mutex_info->pAcquireKeys[j], NULL);
+            }
+            goto error;
+        }
+        /* Pre-check release error conditions. */
+        for (j = 0; j < keyed_mutex_info->releaseCount; ++j)
+        {
+            memory = wine_device_memory_from_handle(keyed_mutex_info->pReleaseSyncs[j]);
+            if (!memory->keyed_mutex_shm)
+                goto error;
+            if (memory->keyed_mutex_shm->acquired_to_instance != memory->keyed_mutex_instance_id)
+                goto error;
+        }
+        signal_count += keyed_mutex_info->releaseCount;
+    }
+
+    if (!signal_count)
+    {
+        *signal_counts = NULL;
+        return VK_SUCCESS;
+    }
+    *signal_counts = conversion_context_alloc(ctx, sizeof(**signal_counts) * submit_count);
+    *signal_infos = conversion_context_alloc(ctx, sizeof(**signal_infos) * submit_count);
+    for (i = 0; i < submit_count; ++i)
+    {
+        ptr = (char *)submits_win + i * submit_size;
+        if (!(keyed_mutex_info = wine_vk_find_unlink_struct(ptr, WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR)))
+        {
+            (*signal_counts)[i] = 0;
+            continue;
+        }
+        (*signal_counts)[i] = keyed_mutex_info->releaseCount;
+        (*signal_infos)[i] = conversion_context_alloc(ctx, sizeof(***signal_infos) * keyed_mutex_info->releaseCount);
+        for (j = 0; j < keyed_mutex_info->releaseCount; ++j)
+        {
+            memory = wine_device_memory_from_handle(keyed_mutex_info->pReleaseSyncs[j]);
+            (*signal_infos)[i][j].sType = VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO;
+            (*signal_infos)[i][j].pNext = NULL;
+            (*signal_infos)[i][j].semaphore = memory->keyed_mutex_sem;
+            (*signal_infos)[i][j].stageMask = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT;
+            (*signal_infos)[i][j].deviceIndex = 0;
+            ret = release_keyed_mutex(device, memory, keyed_mutex_info->pReleaseKeys[j], &(*signal_infos)[i][j].value);
+            if (ret != VK_SUCCESS)
+            {
+                /* This should only be possible if a racing submit queued release before us, currently not handled. */
+                ERR("release_keyed_mutex failed, ret %d.\n", ret);
+                (*signal_infos)[i][j].value = 0;
+            }
+        }
+    }
+
+    return VK_SUCCESS;
+
+error:
+    while (i)
+    {
+        --i;
+        ptr = (char *)submits_win + i * submit_size;
+        if (!(keyed_mutex_info = wine_vk_find_unlink_struct(ptr, WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR)))
+            continue;
+        for (j = 0; j < keyed_mutex_info->acquireCount; ++j)
+        {
+            memory = wine_device_memory_from_handle(keyed_mutex_info->pAcquireSyncs[j]);
+            release_keyed_mutex(device, memory, keyed_mutex_info->pAcquireKeys[j], NULL);
+        }
+    }
+    return ret;
+}
+
+static void duplicate_array_for_unwrapping_copy_size(struct conversion_context *ctx, void **ptr, unsigned int size,
+        unsigned int copy_size)
+{
+    void *out;
+
+    if (!size)
+        return;
+
+    out = conversion_context_alloc(ctx, size);
+    if (*ptr)
+        memcpy(out, *ptr, copy_size);
+    *ptr = out;
+}
+
+VkResult wine_vkQueueSubmit(VkQueue queue_handle, uint32_t submit_count, const VkSubmitInfo *submits_orig, VkFence fence)
+{
+    struct vulkan_queue *queue = vulkan_queue_from_handle(queue_handle);
+    struct vulkan_device *device = queue->device;
+    VkTimelineSemaphoreSubmitInfo *timeline_submit_info, ts_info_copy;
+    VkD3D12FenceSubmitInfoKHR *d3d12_submit_info;
+    const uint64_t **values;
+    struct conversion_context ctx;
+    VkSubmitInfo *submits;
+    VkSemaphoreSubmitInfo **km_infos;
+    uint32_t *km_counts;
+    unsigned int i, j;
+    VkResult ret;
+
+    TRACE("(%p %u %p 0x%s)\n", queue_handle, submit_count, submits_orig, wine_dbgstr_longlong(fence));
+
+    init_conversion_context(&ctx);
+    MEMDUP(&ctx, submits, submits_orig, submit_count);
+    if ((ret = process_keyed_mutexes(&ctx, device, submit_count, submits, sizeof(*submits), &km_counts, &km_infos)))
+        return ret;
+
+    for (i = 0; i < submit_count; ++i)
+    {
+        timeline_submit_info = find_next_struct(&submits[i], VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO);
+        d3d12_submit_info = wine_vk_find_unlink_struct(&submits[i], D3D12_FENCE_SUBMIT_INFO_KHR);
+        if (d3d12_submit_info && timeline_submit_info)
+            WARN("Both TIMELINE_SEMAPHORE_SUBMIT_INFO and D3D12_FENCE_SUBMIT_INFO_KHR specified.\n");
+        if (d3d12_submit_info && !timeline_submit_info)
+        {
+            timeline_submit_info = conversion_context_alloc(&ctx, sizeof(*timeline_submit_info));
+            timeline_submit_info->sType = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;
+            timeline_submit_info->pNext = submits[i].pNext;
+            timeline_submit_info->waitSemaphoreValueCount = d3d12_submit_info->waitSemaphoreValuesCount;
+            MEMDUP(&ctx, timeline_submit_info->pWaitSemaphoreValues, d3d12_submit_info->pWaitSemaphoreValues, d3d12_submit_info->waitSemaphoreValuesCount);
+            timeline_submit_info->signalSemaphoreValueCount = d3d12_submit_info->signalSemaphoreValuesCount;
+            MEMDUP(&ctx, timeline_submit_info->pSignalSemaphoreValues, d3d12_submit_info->pSignalSemaphoreValues, d3d12_submit_info->signalSemaphoreValuesCount);
+            submits[i].pNext = timeline_submit_info;
+        }
+
+        if (timeline_submit_info)
+            values = &timeline_submit_info->pWaitSemaphoreValues;
+        else
+            values = NULL;
+        unwrap_semaphore_array(&submits[i].pWaitSemaphores, values, submits[i].waitSemaphoreCount, &ctx, FALSE, device);
+
+        if (timeline_submit_info)
+            values = &timeline_submit_info->pSignalSemaphoreValues;
+        else
+            values = NULL;
+        unwrap_semaphore_array(&submits[i].pSignalSemaphores, values, submits[i].signalSemaphoreCount, &ctx, TRUE, device);
+        if (km_counts && km_counts[i])
+        {
+            if (timeline_submit_info)
+            {
+                ts_info_copy = *timeline_submit_info;
+                timeline_submit_info = &ts_info_copy;
+                duplicate_array_for_unwrapping_copy_size(&ctx, (void **)&timeline_submit_info->pSignalSemaphoreValues,
+                        (timeline_submit_info->signalSemaphoreValueCount + km_counts[i]) * sizeof(*timeline_submit_info->pSignalSemaphoreValues),
+                        timeline_submit_info->signalSemaphoreValueCount * sizeof(*timeline_submit_info->pSignalSemaphoreValues));
+            }
+            else
+            {
+                timeline_submit_info = &ts_info_copy;
+                timeline_submit_info->sType = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;
+                timeline_submit_info->pNext = submits[i].pNext;
+                timeline_submit_info->waitSemaphoreValueCount = 0;
+                timeline_submit_info->signalSemaphoreValueCount = 0;
+                timeline_submit_info->pSignalSemaphoreValues = conversion_context_alloc(&ctx, km_counts[i] * sizeof(*timeline_submit_info->pSignalSemaphoreValues));
+                submits[i].pNext = timeline_submit_info;
+            }
+            duplicate_array_for_unwrapping_copy_size(&ctx, (void **)&submits[i].pSignalSemaphores,
+                    (submits[i].signalSemaphoreCount + km_counts[i]) * sizeof(*submits[i].pSignalSemaphores),
+                    submits[i].signalSemaphoreCount * sizeof(*submits[i].pSignalSemaphores));
+            for (j = 0; j < km_counts[i]; ++j)
+            {
+                ((uint64_t *)timeline_submit_info->pSignalSemaphoreValues)[j + timeline_submit_info->signalSemaphoreValueCount++]
+                        = km_infos[i][j].value;
+                ((VkSemaphore *)submits[i].pSignalSemaphores)[j + submits[i].signalSemaphoreCount++] = km_infos[i][j].semaphore;
+            }
+        }
+
+        if (submits[i].pCommandBuffers && submits[i].commandBufferCount)
+        {
+            VkCommandBuffer *out;
+
+            out = conversion_context_alloc(&ctx, submits[i].commandBufferCount * sizeof(*out));
+            for (j = 0; j < submits[i].commandBufferCount; ++j)
+                out[j] = wine_cmd_buffer_from_handle(submits[i].pCommandBuffers[j])->host.command_buffer;
+            submits[i].pCommandBuffers = out;
+        }
+    }
+    ret = queue->device->p_vkQueueSubmit(queue->host.queue, submit_count, submits, fence);
+    free_conversion_context(&ctx);
+    return ret;
+}
+
+static void duplicate_array_for_unwrapping(struct conversion_context *ctx, void **ptr, unsigned int size)
+{
+    duplicate_array_for_unwrapping_copy_size(ctx, ptr, size, size);
+}
+
+static VkResult vk_queue_submit_2(VkQueue queue_handle, uint32_t submit_count, const VkSubmitInfo2 *submits_orig,
+        VkFence fence, bool khr)
+{
+    struct vulkan_queue *queue = vulkan_queue_from_handle(queue_handle);
+    struct vulkan_device *device = queue->device;
+    struct conversion_context ctx;
+    VkSemaphoreSubmitInfo **km_infos;
+    uint32_t *km_counts, count;
+    VkSubmitInfo2 *submits;
+    unsigned int i, j;
+    VkResult ret;
+
+    TRACE("(%p, %u, %p, %s)\n", queue_handle, submit_count, submits_orig, wine_dbgstr_longlong(fence));
+
+    init_conversion_context(&ctx);
+    MEMDUP(&ctx, submits, submits_orig, submit_count);
+    if ((ret = process_keyed_mutexes(&ctx, device, submit_count, submits, sizeof(*submits), &km_counts, &km_infos)))
+        return ret;
+    for (i = 0; i < submit_count; ++i)
+    {
+        duplicate_array_for_unwrapping(&ctx, (void **)&submits[i].pWaitSemaphoreInfos,
+                submits[i].waitSemaphoreInfoCount * sizeof(*submits[i].pWaitSemaphoreInfos));
+        for (j = 0; j < submits[i].waitSemaphoreInfoCount; ++j)
+            unwrap_semaphore(queue->device, &((VkSemaphoreSubmitInfo *)submits[i].pWaitSemaphoreInfos)[j].semaphore,
+                    &((VkSemaphoreSubmitInfo *)submits[i].pWaitSemaphoreInfos)[j].value, FALSE);
+
+        count = submits[i].signalSemaphoreInfoCount + (km_counts ? km_counts[i] : 0);
+        duplicate_array_for_unwrapping_copy_size(&ctx, (void **)&submits[i].pSignalSemaphoreInfos,
+                count * sizeof(*submits[i].pSignalSemaphoreInfos),
+                submits[i].signalSemaphoreInfoCount * sizeof(*submits[i].pSignalSemaphoreInfos));
+        for (j = 0; j < submits[i].signalSemaphoreInfoCount; ++j)
+            unwrap_semaphore(queue->device, &((VkSemaphoreSubmitInfo *)submits[i].pSignalSemaphoreInfos)[j].semaphore,
+                    &((VkSemaphoreSubmitInfo *)submits[i].pSignalSemaphoreInfos)[j].value, TRUE);
+        for (; j < count; ++j)
+            ((VkSemaphoreSubmitInfo *)submits[i].pSignalSemaphoreInfos)[j] = km_infos[i][j - submits[i].signalSemaphoreInfoCount];
+        submits[i].signalSemaphoreInfoCount = count;
+
+        if (submits[i].pCommandBufferInfos && submits[i].commandBufferInfoCount)
+        {
+            duplicate_array_for_unwrapping(&ctx, (void **)&submits[i].pCommandBufferInfos,
+                    submits[i].commandBufferInfoCount * sizeof(*submits[i].pCommandBufferInfos));
+            for (j = 0; j < submits[i].commandBufferInfoCount; ++j)
+                ((VkCommandBufferSubmitInfo *)submits[i].pCommandBufferInfos)[j].commandBuffer
+                        = wine_cmd_buffer_from_handle(submits[i].pCommandBufferInfos[j].commandBuffer)->host.command_buffer;
+        }
+    }
+
+    if (khr)
+        ret = queue->device->p_vkQueueSubmit2KHR(queue->host.queue, submit_count, submits, fence);
+    else
+        ret = queue->device->p_vkQueueSubmit2(queue->host.queue, submit_count, submits, fence);
+    free_conversion_context(&ctx);
+    return ret;
+}
+
+VkResult wine_vkQueueSubmit2(VkQueue queue, uint32_t submit_count, const VkSubmitInfo2 *submits, VkFence fence)
+{
+    return vk_queue_submit_2(queue, submit_count, submits, fence, false);
+}
+
+VkResult wine_vkQueueSubmit2KHR(VkQueue queue, uint32_t submit_count, const VkSubmitInfo2 *submits, VkFence fence)
+{
+    return vk_queue_submit_2(queue, submit_count, submits, fence, true);
+}
+
+VkResult wine_vkQueueBindSparse(VkQueue queue_handle, uint32_t bind_info_count, const VkBindSparseInfo *bind_info, VkFence fence)
+{
+    struct vulkan_queue *queue = vulkan_queue_from_handle(queue_handle);
+    struct wine_semaphore *semaphore;
+    struct conversion_context ctx;
+    VkBindSparseInfo *batch;
+    unsigned int i, j, k;
+    VkResult ret;
+
+    TRACE("(%p, %u, %p, 0x%s)\n", queue, bind_info_count, bind_info, wine_dbgstr_longlong(fence));
+
+    for (i = 0; i < bind_info_count; i++)
+    {
+        batch = (VkBindSparseInfo *)&bind_info[i];
+
+        for (k = 0; k < batch->waitSemaphoreCount; k++)
+        {
+            semaphore = wine_semaphore_from_handle(batch->pWaitSemaphores[k]);
+
+            if (semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+            {
+                FIXME("Waiting on D3D12-Fence compatible timeline semaphore not supported.\n");
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            }
+        }
+
+        for(k = 0; k < batch->signalSemaphoreCount; k++)
+        {
+            semaphore = wine_semaphore_from_handle(batch->pSignalSemaphores[k]);
+
+            if (semaphore->handle_type == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT)
+            {
+                FIXME("Signalling D3D12-Fence compatible timeline semaphore not supported.\n");
+                return VK_ERROR_OUT_OF_HOST_MEMORY;
+            }
+        }
+    }
+
+    init_conversion_context(&ctx);
+    for (i = 0; i < bind_info_count; ++i)
+    {
+        batch = (VkBindSparseInfo *)&bind_info[i];
+        unwrap_semaphore_array(&batch->pWaitSemaphores, NULL, batch->waitSemaphoreCount, &ctx, FALSE, queue->device);
+        unwrap_semaphore_array(&batch->pSignalSemaphores, NULL, batch->signalSemaphoreCount, &ctx, TRUE, queue->device);
+
+        duplicate_array_for_unwrapping(&ctx, (void **)&batch->pBufferBinds, batch->bufferBindCount * sizeof(*batch->pBufferBinds));
+        for (j = 0; j < batch->bufferBindCount; ++j)
+        {
+            VkSparseBufferMemoryBindInfo *bind = (VkSparseBufferMemoryBindInfo *)&batch->pBufferBinds[j];
+            duplicate_array_for_unwrapping(&ctx, (void **)&bind->pBinds, bind->bindCount * sizeof(*bind->pBinds));
+            for (k = 0; k < bind->bindCount; ++k)
+                if (bind->pBinds[k].memory)
+                    ((VkSparseMemoryBind *)bind->pBinds)[k].memory = wine_device_memory_from_handle(bind->pBinds[k].memory)->host.device_memory;
+        }
+
+        duplicate_array_for_unwrapping(&ctx, (void **)&batch->pImageOpaqueBinds, batch->imageOpaqueBindCount * sizeof(*batch->pImageOpaqueBinds));
+        for (j = 0; j < batch->imageOpaqueBindCount; ++j)
+        {
+            VkSparseImageOpaqueMemoryBindInfo *bind = (VkSparseImageOpaqueMemoryBindInfo *)&batch->pImageOpaqueBinds[j];
+            duplicate_array_for_unwrapping(&ctx, (void **)&bind->pBinds, bind->bindCount * sizeof(*bind->pBinds));
+            for (k = 0; k < bind->bindCount; ++k)
+                if (bind->pBinds[k].memory)
+                    ((VkSparseMemoryBind *)bind->pBinds)[k].memory = wine_device_memory_from_handle(bind->pBinds[k].memory)->host.device_memory;
+        }
+
+        duplicate_array_for_unwrapping(&ctx, (void **)&batch->pImageBinds, batch->imageBindCount * sizeof(*batch->pImageBinds));
+        for (j = 0; j < batch->imageBindCount; ++j)
+        {
+            VkSparseImageMemoryBindInfo *bind = (VkSparseImageMemoryBindInfo *)&batch->pImageBinds[j];
+            duplicate_array_for_unwrapping(&ctx, (void **)&bind->pBinds, bind->bindCount * sizeof(*bind->pBinds));
+            for (k = 0; k < bind->bindCount; ++k)
+                if (bind->pBinds[k].memory)
+                    ((VkSparseImageMemoryBind *)bind->pBinds)[k].memory = wine_device_memory_from_handle(bind->pBinds[k].memory)->host.device_memory;
+        }
+    }
+    ret = queue->device->p_vkQueueBindSparse(queue->host.queue, bind_info_count, bind_info, fence);
+    free_conversion_context(&ctx);
+    return ret;
+}
+
+VkResult wine_wine_vkAcquireKeyedMutex(VkDevice device, VkDeviceMemory memory, uint64_t key, uint32_t timeout_ms)
+{
+    return acquire_keyed_mutex(vulkan_device_from_handle(device), wine_device_memory_from_handle(memory), key, timeout_ms);
+}
+
+VkResult wine_wine_vkReleaseKeyedMutex(VkDevice device, VkDeviceMemory memory, uint64_t key)
+{
+    return release_keyed_mutex(vulkan_device_from_handle(device), wine_device_memory_from_handle(memory), key, NULL);
+}
+
+DECLSPEC_EXPORT VkDevice __wine_get_native_VkDevice(VkDevice handle)
+{
+    struct vulkan_device *device = vulkan_device_from_handle(handle);
+
+    return device->host.device;
+}
+
+DECLSPEC_EXPORT VkInstance __wine_get_native_VkInstance(VkInstance handle)
+{
+    struct vulkan_instance *instance = vulkan_instance_from_handle(handle);
+
+    return instance->host.instance;
+}
+
+DECLSPEC_EXPORT VkPhysicalDevice __wine_get_native_VkPhysicalDevice(VkPhysicalDevice handle)
+{
+    struct vulkan_physical_device *phys_dev;
+
+    if (!handle) return NULL;
+
+    phys_dev = vulkan_physical_device_from_handle(handle);
+    return phys_dev->host.physical_device;
+}
+
+DECLSPEC_EXPORT VkQueue __wine_get_native_VkQueue(VkQueue handle)
+{
+    struct vulkan_queue *queue = vulkan_queue_from_handle(handle);
+
+    return queue->host.queue;
+}
+
+DECLSPEC_EXPORT VkPhysicalDevice __wine_get_wrapped_VkPhysicalDevice(VkInstance handle, VkPhysicalDevice native_phys_dev)
+{
+    struct wine_instance *instance = wine_instance_from_handle(handle);
+    unsigned int i;
+
+    for (i = 0; i < instance->phys_dev_count; ++i)
+    {
+        if (instance->phys_devs[i].obj.host.physical_device == native_phys_dev)
+            return instance->phys_devs[i].obj.client.physical_device;
+    }
+
+    ERR("Unknown native physical device: %p, instance %p, handle %p\n", native_phys_dev, instance, handle);
+    return NULL;
 }
diff -ruN --show-c-function vanilla-1017/dlls/winevulkan/vulkan_private.h protonvulkan-1017/dlls/winevulkan/vulkan_private.h
--- vanilla-1017/dlls/winevulkan/vulkan_private.h	2025-10-21 17:44:36.083775116 -0700
+++ protonvulkan-1017/dlls/winevulkan/vulkan_private.h	2025-10-21 17:23:40.651251132 -0700
@@ -21,6 +21,7 @@
 #define __WINE_VULKAN_PRIVATE_H
 
 #include <pthread.h>
+#include <stdbool.h>
 
 #include "vulkan_loader.h"
 #include "vulkan_thunks.h"
@@ -29,26 +30,31 @@
 
 extern const struct vulkan_funcs *vk_funcs;
 
-struct wine_queue
+struct wine_cmd_buffer
 {
-    struct vulkan_queue obj;
-
-    uint32_t family_index;
-    uint32_t queue_index;
-    VkDeviceQueueCreateFlags flags;
+    VULKAN_OBJECT_HEADER( VkCommandBuffer, command_buffer );
+    struct vulkan_device *device;
 };
 
-struct wine_device
+static inline struct wine_cmd_buffer *wine_cmd_buffer_from_handle(VkCommandBuffer handle)
 {
-    struct vulkan_device obj;
-    bool has_external_memory_win32;
-    bool has_external_semaphore_win32;
-    bool has_external_fence_win32;
-    uint64_t queue_count;
-    struct wine_queue queues[];
-};
+    struct vulkan_client_object *client = (struct vulkan_client_object *)handle;
+    return (struct wine_cmd_buffer *)(UINT_PTR)client->unix_handle;
+}
 
-C_ASSERT(sizeof(struct wine_device) == offsetof(struct wine_device, queues[0]));
+struct wine_semaphore;
+
+struct pending_d3d12_fence_op
+{
+    /* Vulkan native local semaphore. */
+    struct local_timeline_semaphore local_sem;
+
+    /* Operation values. */
+    struct list entry;
+    uint64_t virtual_value;
+    uint64_t shared_physical_value;
+    struct wine_semaphore *semaphore;
+};
 
 struct wine_debug_utils_messenger;
 
@@ -61,6 +67,18 @@ struct wine_debug_report_callback
     UINT64 user_data; /* client pointer */
 };
 
+struct wine_phys_dev
+{
+    struct vulkan_physical_device obj;
+
+    VkPhysicalDeviceMemoryProperties memory_properties;
+    VkExtensionProperties *extensions;
+    uint32_t extension_count;
+
+    uint32_t external_memory_align;
+    uint32_t map_placed_align;
+};
+
 struct wine_debug_report_callback;
 
 struct wine_instance
@@ -78,8 +96,16 @@ struct wine_instance
 
     struct rb_tree objects;
     pthread_rwlock_t objects_lock;
+
+    pthread_key_t transient_object_handle;
+
+    /* We cache devices as we need to wrap them as they are dispatchable objects. */
+    uint32_t phys_dev_count;
+    struct wine_phys_dev phys_devs[];
 };
 
+C_ASSERT(sizeof(struct wine_instance) == offsetof(struct wine_instance, phys_devs[0]));
+
 struct wine_cmd_pool
 {
     VULKAN_OBJECT_HEADER( VkCommandPool, command_pool );
@@ -91,6 +117,35 @@ static inline struct wine_cmd_pool *wine
     return (struct wine_cmd_pool *)(UINT_PTR)client->unix_handle;
 }
 
+struct keyed_mutex_shm
+{
+    pthread_mutex_t mutex;
+    uint64_t instance_id_counter;
+    uint64_t acquired_to_instance;
+    uint64_t key;
+    UINT64 timeline_value;
+    uint64_t timeline_queued_release;
+};
+
+struct wine_device_memory
+{
+    VULKAN_OBJECT_HEADER( VkDeviceMemory, device_memory );
+    VkDeviceSize size;
+    void *vm_map;
+    VkExternalMemoryHandleTypeFlagBits handle_types;
+    BOOL inherit;
+    DWORD access;
+    HANDLE handle;
+    struct keyed_mutex_shm *keyed_mutex_shm;
+    VkSemaphore keyed_mutex_sem;
+    uint64_t keyed_mutex_instance_id;
+};
+
+static inline struct wine_device_memory *wine_device_memory_from_handle(VkDeviceMemory handle)
+{
+    return (struct wine_device_memory *)(uintptr_t)handle;
+}
+
 struct wine_debug_utils_messenger
 {
     VULKAN_OBJECT_HEADER( VkDebugUtilsMessengerEXT, debug_messenger );
@@ -145,6 +200,38 @@ static inline void free_conversion_conte
         free(entry);
 }
 
+struct wine_semaphore
+{
+    struct vulkan_semaphore obj;
+    VkSemaphore semaphore;
+
+    VkExternalSemaphoreHandleTypeFlagBits export_types;
+
+    /* mutable members */
+    VkExternalSemaphoreHandleTypeFlagBits handle_type;
+    struct list poll_entry;
+    struct list pending_waits;
+    struct list pending_signals;
+    HANDLE handle;
+    struct
+    {
+        /* Shared mem access mutex. The non-shared parts access is guarded with device global signaller_mutex. */
+        pthread_mutex_t mutex;
+        UINT64 virtual_value, physical_value;
+        uint64_t last_reset_physical;
+        uint64_t last_dropped_reset_physical;
+        struct
+        {
+            uint64_t physical_at_reset;
+            uint64_t virtual_before_reset;
+        }
+        reset_backlog[16];
+        uint32_t reset_backlog_count;
+    } *d3d12_fence_shm;
+    /* The Vulkan shared semaphore is only waited or signaled in signaller_worker(). */
+    VkSemaphore fence_timeline_semaphore;
+};
+
 static inline void *conversion_context_alloc(struct conversion_context *pool, size_t size)
 {
     if (pool->used + size <= sizeof(pool->buffer))
@@ -215,4 +302,16 @@ static inline void *find_next_struct(con
     return NULL;
 }
 
+static inline void init_unicode_string( UNICODE_STRING *str, const WCHAR *data )
+{
+    str->Length = lstrlenW(data) * sizeof(WCHAR);
+    str->MaximumLength = str->Length + sizeof(WCHAR);
+    str->Buffer = (WCHAR *)data;
+}
+
+#define MEMDUP(ctx, dst, src, count) dst = conversion_context_alloc((ctx), sizeof(*(dst)) * (count)); \
+    memcpy((void *)(dst), (src), sizeof(*(dst)) * (count));
+#define MEMDUP_VOID(ctx, dst, src, size) dst = conversion_context_alloc((ctx), size); \
+    memcpy((void *)(dst), (src), size);
+
 #endif /* __WINE_VULKAN_PRIVATE_H */
diff -ruN --show-c-function vanilla-1017/dlls/winevulkan/vulkan_thunks.c protonvulkan-1017/dlls/winevulkan/vulkan_thunks.c
--- vanilla-1017/dlls/winevulkan/vulkan_thunks.c	2025-10-21 17:44:44.770970445 -0700
+++ protonvulkan-1017/dlls/winevulkan/vulkan_thunks.c	2025-10-21 17:23:44.098834792 -0700
@@ -578,13 +578,6 @@ typedef struct VkVideoPictureResourceInf
     VkImageView DECLSPEC_ALIGN(8) imageViewBinding;
 } VkVideoPictureResourceInfoKHR32;
 
-typedef struct SECURITY_ATTRIBUTES32
-{
-    DWORD nLength;
-    PTR32 lpSecurityDescriptor;
-    BOOL bInheritHandle;
-} SECURITY_ATTRIBUTES32;
-
 typedef struct StdVideoAV1SequenceHeader32
 {
     StdVideoAV1SequenceHeaderFlags flags;
@@ -3140,15 +3133,6 @@ typedef struct VkExportFenceCreateInfo32
 } VkExportFenceCreateInfo32;
 typedef VkExportFenceCreateInfo32 VkExportFenceCreateInfoKHR32;
 
-typedef struct VkExportFenceWin32HandleInfoKHR32
-{
-    VkStructureType sType;
-    PTR32 pNext;
-    PTR32 pAttributes;
-    DWORD dwAccess;
-    PTR32 name;
-} VkExportFenceWin32HandleInfoKHR32;
-
 typedef struct VkExportMemoryAllocateInfo32
 {
     VkStructureType sType;
@@ -3163,7 +3147,7 @@ typedef struct VkExportMemoryWin32Handle
     PTR32 pNext;
     PTR32 pAttributes;
     DWORD dwAccess;
-    PTR32 name;
+    LPCWSTR name;
 } VkExportMemoryWin32HandleInfoKHR32;
 
 typedef struct VkExportSemaphoreCreateInfo32
@@ -3180,7 +3164,7 @@ typedef struct VkExportSemaphoreWin32Han
     PTR32 pNext;
     PTR32 pAttributes;
     DWORD dwAccess;
-    PTR32 name;
+    LPCWSTR name;
 } VkExportSemaphoreWin32HandleInfoKHR32;
 
 typedef struct VkExternalBufferProperties32
@@ -3263,14 +3247,6 @@ typedef struct VkFenceCreateInfo32
     VkFenceCreateFlags flags;
 } VkFenceCreateInfo32;
 
-typedef struct VkFenceGetWin32HandleInfoKHR32
-{
-    VkStructureType sType;
-    PTR32 pNext;
-    VkFence DECLSPEC_ALIGN(8) fence;
-    VkExternalFenceHandleTypeFlagBits handleType;
-} VkFenceGetWin32HandleInfoKHR32;
-
 typedef struct VkFilterCubicImageViewImageFormatPropertiesEXT32
 {
     VkStructureType sType;
@@ -3696,16 +3672,13 @@ typedef struct VkImageViewUsageCreateInf
 } VkImageViewUsageCreateInfo32;
 typedef VkImageViewUsageCreateInfo32 VkImageViewUsageCreateInfoKHR32;
 
-typedef struct VkImportFenceWin32HandleInfoKHR32
+typedef struct VkImportMemoryFdInfoKHR32
 {
     VkStructureType sType;
     PTR32 pNext;
-    VkFence DECLSPEC_ALIGN(8) fence;
-    VkFenceImportFlags flags;
-    VkExternalFenceHandleTypeFlagBits handleType;
-    PTR32 handle;
-    PTR32 name;
-} VkImportFenceWin32HandleInfoKHR32;
+    VkExternalMemoryHandleTypeFlagBits handleType;
+    int fd;
+} VkImportMemoryFdInfoKHR32;
 
 typedef struct VkImportMemoryHostPointerInfoEXT32
 {
@@ -3720,10 +3693,20 @@ typedef struct VkImportMemoryWin32Handle
     VkStructureType sType;
     PTR32 pNext;
     VkExternalMemoryHandleTypeFlagBits handleType;
-    PTR32 handle;
-    PTR32 name;
+    HANDLE handle;
+    LPCWSTR name;
 } VkImportMemoryWin32HandleInfoKHR32;
 
+typedef struct VkImportSemaphoreFdInfoKHR32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    VkSemaphore DECLSPEC_ALIGN(8) semaphore;
+    VkSemaphoreImportFlags flags;
+    VkExternalSemaphoreHandleTypeFlagBits handleType;
+    int fd;
+} VkImportSemaphoreFdInfoKHR32;
+
 typedef struct VkImportSemaphoreWin32HandleInfoKHR32
 {
     VkStructureType sType;
@@ -3731,8 +3714,8 @@ typedef struct VkImportSemaphoreWin32Han
     VkSemaphore DECLSPEC_ALIGN(8) semaphore;
     VkSemaphoreImportFlags flags;
     VkExternalSemaphoreHandleTypeFlagBits handleType;
-    PTR32 handle;
-    PTR32 name;
+    HANDLE handle;
+    LPCWSTR name;
 } VkImportSemaphoreWin32HandleInfoKHR32;
 
 typedef struct VkIndirectCommandsLayoutCreateInfoEXT32
@@ -3893,6 +3876,21 @@ typedef struct VkMemoryDedicatedRequirem
 } VkMemoryDedicatedRequirements32;
 typedef VkMemoryDedicatedRequirements32 VkMemoryDedicatedRequirementsKHR32;
 
+typedef struct VkMemoryFdPropertiesKHR32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    uint32_t memoryTypeBits;
+} VkMemoryFdPropertiesKHR32;
+
+typedef struct VkMemoryGetFdInfoKHR32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    VkDeviceMemory DECLSPEC_ALIGN(8) memory;
+    VkExternalMemoryHandleTypeFlagBits handleType;
+} VkMemoryGetFdInfoKHR32;
+
 typedef struct VkMemoryGetWin32HandleInfoKHR32
 {
     VkStructureType sType;
@@ -8422,6 +8420,14 @@ typedef struct VkSemaphoreCreateInfo32
     VkSemaphoreCreateFlags flags;
 } VkSemaphoreCreateInfo32;
 
+typedef struct VkSemaphoreGetFdInfoKHR32
+{
+    VkStructureType sType;
+    PTR32 pNext;
+    VkSemaphore DECLSPEC_ALIGN(8) semaphore;
+    VkExternalSemaphoreHandleTypeFlagBits handleType;
+} VkSemaphoreGetFdInfoKHR32;
+
 typedef struct VkSemaphoreGetWin32HandleInfoKHR32
 {
     VkStructureType sType;
@@ -9687,7 +9693,7 @@ static uint64_t wine_vk_unwrap_handle(ui
     switch(type)
     {
     case VK_OBJECT_TYPE_COMMAND_BUFFER:
-        return (uint64_t) (uintptr_t) vulkan_command_buffer_from_handle(((VkCommandBuffer) (uintptr_t) handle))->host.command_buffer;
+        return (uint64_t) (uintptr_t) wine_cmd_buffer_from_handle(((VkCommandBuffer) (uintptr_t) handle))->host.command_buffer;
     case VK_OBJECT_TYPE_COMMAND_POOL:
         return (uint64_t) wine_cmd_pool_from_handle(handle)->host.command_pool;
     case VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT:
@@ -9699,9 +9705,7 @@ static uint64_t wine_vk_unwrap_handle(ui
     case VK_OBJECT_TYPE_DEVICE:
         return (uint64_t) (uintptr_t) vulkan_device_from_handle(((VkDevice) (uintptr_t) handle))->host.device;
     case VK_OBJECT_TYPE_DEVICE_MEMORY:
-        return (uint64_t) vulkan_device_memory_from_handle(handle)->host.device_memory;
-    case VK_OBJECT_TYPE_FENCE:
-        return (uint64_t) vulkan_fence_from_handle(handle)->host.fence;
+        return (uint64_t) wine_device_memory_from_handle(handle)->host.device_memory;
     case VK_OBJECT_TYPE_INSTANCE:
         return (uint64_t) (uintptr_t) vulkan_instance_from_handle(((VkInstance) (uintptr_t) handle))->host.instance;
     case VK_OBJECT_TYPE_PHYSICAL_DEVICE:
@@ -9816,7 +9820,18 @@ static void convert_VkDescriptorSetAlloc
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -9875,6 +9890,18 @@ static void convert_VkMemoryAllocateInfo
             out_header = (void *)out_ext;
             break;
         }
+        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
+        {
+            VkImportMemoryFdInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkImportMemoryFdInfoKHR *in_ext = (const VkImportMemoryFdInfoKHR *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR;
+            out_ext->pNext = NULL;
+            out_ext->handleType = in_ext->handleType;
+            out_ext->fd = in_ext->fd;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
         case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
         {
             VkImportMemoryHostPointerInfoEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
@@ -9958,38 +9985,24 @@ static void convert_VkMemoryAllocateInfo
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
 }
 #endif /* _WIN64 */
 
-static void convert_SECURITY_ATTRIBUTES_win32_to_host(const SECURITY_ATTRIBUTES32 *in, SECURITY_ATTRIBUTES *out)
-{
-    if (!in) return;
-
-    out->nLength = in->nLength;
-    out->lpSecurityDescriptor = UlongToPtr(in->lpSecurityDescriptor);
-    out->bInheritHandle = in->bInheritHandle;
-}
-
-static const SECURITY_ATTRIBUTES *convert_SECURITY_ATTRIBUTES_array_win32_to_host(struct conversion_context *ctx, const SECURITY_ATTRIBUTES32 *in, uint32_t count)
-{
-    SECURITY_ATTRIBUTES *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        convert_SECURITY_ATTRIBUTES_win32_to_host(&in[i], &out[i]);
-    }
-
-    return out;
-}
-
 static void convert_VkMemoryAllocateInfo_win32_to_host(struct conversion_context *ctx, const VkMemoryAllocateInfo32 *in, VkMemoryAllocateInfo *out)
 {
     const VkBaseInStructure32 *in_header;
@@ -10035,9 +10048,21 @@ static void convert_VkMemoryAllocateInfo
             const VkExportMemoryWin32HandleInfoKHR32 *in_ext = (const VkExportMemoryWin32HandleInfoKHR32 *)in_header;
             out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
             out_ext->pNext = NULL;
-            out_ext->pAttributes = convert_SECURITY_ATTRIBUTES_array_win32_to_host(ctx, (const SECURITY_ATTRIBUTES32 *)UlongToPtr(in_ext->pAttributes), 1);
+            out_ext->pAttributes = UlongToPtr(in_ext->pAttributes);
             out_ext->dwAccess = in_ext->dwAccess;
-            out_ext->name = (LPCWSTR)UlongToPtr(in_ext->name);
+            out_ext->name = in_ext->name;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
+        {
+            VkImportMemoryFdInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkImportMemoryFdInfoKHR32 *in_ext = (const VkImportMemoryFdInfoKHR32 *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR;
+            out_ext->pNext = NULL;
+            out_ext->handleType = in_ext->handleType;
+            out_ext->fd = in_ext->fd;
             out_header->pNext = (void *)out_ext;
             out_header = (void *)out_ext;
             break;
@@ -10061,8 +10086,8 @@ static void convert_VkMemoryAllocateInfo
             out_ext->sType = VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR;
             out_ext->pNext = NULL;
             out_ext->handleType = in_ext->handleType;
-            out_ext->handle = (HANDLE)UlongToPtr(in_ext->handle);
-            out_ext->name = (LPCWSTR)UlongToPtr(in_ext->name);
+            out_ext->handle = in_ext->handle;
+            out_ext->name = in_ext->name;
             out_header->pNext = (void *)out_ext;
             out_header = (void *)out_ext;
             break;
@@ -10125,7 +10150,18 @@ static void convert_VkMemoryAllocateInfo
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -10303,13 +10339,24 @@ static void convert_VkCommandBufferInher
             const VkTileMemoryBindInfoQCOM *in_ext = (const VkTileMemoryBindInfoQCOM *)in_header;
             out_ext->sType = VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM;
             out_ext->pNext = NULL;
-            out_ext->memory = vulkan_device_memory_from_handle(in_ext->memory)->host.device_memory;
+            out_ext->memory = in_ext->memory ? wine_device_memory_from_handle(in_ext->memory)->host.device_memory : VK_NULL_HANDLE;
             out_header->pNext = (void *)out_ext;
             out_header = (void *)out_ext;
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -10476,13 +10523,24 @@ static void convert_VkCommandBufferInher
             const VkTileMemoryBindInfoQCOM32 *in_ext = (const VkTileMemoryBindInfoQCOM32 *)in_header;
             out_ext->sType = VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM;
             out_ext->pNext = NULL;
-            out_ext->memory = vulkan_device_memory_from_handle(in_ext->memory)->host.device_memory;
+            out_ext->memory = in_ext->memory ? wine_device_memory_from_handle(in_ext->memory)->host.device_memory : VK_NULL_HANDLE;
             out_header->pNext = (void *)out_ext;
             out_header = (void *)out_ext;
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -10532,7 +10590,18 @@ static void convert_VkCommandBufferBegin
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -10546,7 +10615,7 @@ static void convert_VkBindAccelerationSt
     out->sType = in->sType;
     out->pNext = in->pNext;
     out->accelerationStructure = in->accelerationStructure;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
     out->memoryOffset = in->memoryOffset;
     out->deviceIndexCount = in->deviceIndexCount;
     out->pDeviceIndices = in->pDeviceIndices;
@@ -10578,7 +10647,7 @@ static void convert_VkBindAccelerationSt
     out->sType = in->sType;
     out->pNext = NULL;
     out->accelerationStructure = in->accelerationStructure;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
     out->memoryOffset = in->memoryOffset;
     out->deviceIndexCount = in->deviceIndexCount;
     out->pDeviceIndices = UlongToPtr(in->pDeviceIndices);
@@ -10610,7 +10679,7 @@ static void convert_VkBindBufferMemoryIn
     out->sType = in->sType;
     out->pNext = in->pNext;
     out->buffer = in->buffer;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
     out->memoryOffset = in->memoryOffset;
 }
 #endif /* _WIN64 */
@@ -10643,7 +10712,7 @@ static void convert_VkBindBufferMemoryIn
     out->sType = in->sType;
     out->pNext = NULL;
     out->buffer = in->buffer;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
     out->memoryOffset = in->memoryOffset;
 
     for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
@@ -10674,7 +10743,18 @@ static void convert_VkBindBufferMemoryIn
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -10706,7 +10786,7 @@ static void convert_VkBindDataGraphPipel
     out->session = in->session;
     out->bindPoint = in->bindPoint;
     out->objectIndex = in->objectIndex;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
     out->memoryOffset = in->memoryOffset;
 }
 #endif /* _WIN64 */
@@ -10738,7 +10818,7 @@ static void convert_VkBindDataGraphPipel
     out->session = in->session;
     out->bindPoint = in->bindPoint;
     out->objectIndex = in->objectIndex;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
     out->memoryOffset = in->memoryOffset;
     if (in->pNext)
         FIXME("Unexpected pNext\n");
@@ -10771,7 +10851,7 @@ static void convert_VkBindImageMemoryInf
     out->sType = in->sType;
     out->pNext = NULL;
     out->image = in->image;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
     out->memoryOffset = in->memoryOffset;
 
     for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
@@ -10798,7 +10878,7 @@ static void convert_VkBindImageMemoryInf
             const VkBindImageMemorySwapchainInfoKHR *in_ext = (const VkBindImageMemorySwapchainInfoKHR *)in_header;
             out_ext->sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR;
             out_ext->pNext = NULL;
-            out_ext->swapchain = vulkan_swapchain_from_handle(in_ext->swapchain)->host.swapchain;
+            out_ext->swapchain = in_ext->swapchain ? vulkan_swapchain_from_handle(in_ext->swapchain)->host.swapchain : VK_NULL_HANDLE;
             out_ext->imageIndex = in_ext->imageIndex;
             out_header->pNext = (void *)out_ext;
             out_header = (void *)out_ext;
@@ -10827,7 +10907,18 @@ static void convert_VkBindImageMemoryInf
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -10862,7 +10953,7 @@ static void convert_VkBindImageMemoryInf
     out->sType = in->sType;
     out->pNext = NULL;
     out->image = in->image;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
     out->memoryOffset = in->memoryOffset;
 
     for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
@@ -10889,7 +10980,7 @@ static void convert_VkBindImageMemoryInf
             const VkBindImageMemorySwapchainInfoKHR32 *in_ext = (const VkBindImageMemorySwapchainInfoKHR32 *)in_header;
             out_ext->sType = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR;
             out_ext->pNext = NULL;
-            out_ext->swapchain = vulkan_swapchain_from_handle(in_ext->swapchain)->host.swapchain;
+            out_ext->swapchain = in_ext->swapchain ? vulkan_swapchain_from_handle(in_ext->swapchain)->host.swapchain : VK_NULL_HANDLE;
             out_ext->imageIndex = in_ext->imageIndex;
             out_header->pNext = (void *)out_ext;
             out_header = (void *)out_ext;
@@ -10918,7 +11009,18 @@ static void convert_VkBindImageMemoryInf
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -10948,7 +11050,7 @@ static void convert_VkBindTensorMemoryIn
     out->sType = in->sType;
     out->pNext = in->pNext;
     out->tensor = in->tensor;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
     out->memoryOffset = in->memoryOffset;
 }
 #endif /* _WIN64 */
@@ -10978,7 +11080,7 @@ static void convert_VkBindTensorMemoryIn
     out->sType = in->sType;
     out->pNext = NULL;
     out->tensor = in->tensor;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
     out->memoryOffset = in->memoryOffset;
     if (in->pNext)
         FIXME("Unexpected pNext\n");
@@ -11008,7 +11110,7 @@ static void convert_VkBindVideoSessionMe
     out->sType = in->sType;
     out->pNext = in->pNext;
     out->memoryBindIndex = in->memoryBindIndex;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
     out->memoryOffset = in->memoryOffset;
     out->memorySize = in->memorySize;
 }
@@ -11039,7 +11141,7 @@ static void convert_VkBindVideoSessionMe
     out->sType = in->sType;
     out->pNext = NULL;
     out->memoryBindIndex = in->memoryBindIndex;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
     out->memoryOffset = in->memoryOffset;
     out->memorySize = in->memorySize;
     if (in->pNext)
@@ -11129,7 +11231,18 @@ static void convert_VkAccelerationStruct
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -11229,7 +11342,18 @@ static void convert_VkAccelerationStruct
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -11579,7 +11703,18 @@ static void convert_VkRenderPassBeginInf
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -11630,7 +11765,18 @@ static void convert_VkRenderingAttachmen
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -11772,7 +11918,18 @@ static void convert_VkRenderingInfo_win3
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -11908,7 +12065,18 @@ static void convert_VkVideoReferenceSlot
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -11981,7 +12149,18 @@ static void convert_VkVideoEncodeRateCon
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -12097,7 +12276,18 @@ static void convert_VkVideoBeginCodingIn
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -12136,7 +12326,18 @@ static void convert_VkBindDescriptorBuff
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -12181,7 +12382,18 @@ static void convert_VkDescriptorBufferBi
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -12240,7 +12452,18 @@ static void convert_VkBindDescriptorSets
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -12253,7 +12476,7 @@ static void convert_VkTileMemoryBindInfo
 
     out->sType = in->sType;
     out->pNext = in->pNext;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
 }
 #endif /* _WIN64 */
 
@@ -12263,7 +12486,7 @@ static void convert_VkTileMemoryBindInfo
 
     out->sType = in->sType;
     out->pNext = NULL;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
     if (in->pNext)
         FIXME("Unexpected pNext\n");
 }
@@ -12298,7 +12521,18 @@ static void convert_VkImageBlit2_win32_t
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -12353,7 +12587,18 @@ static void convert_VkBlitImageInfo2_win
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -12650,7 +12895,18 @@ static void convert_VkPartitionedAcceler
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -12745,7 +13001,18 @@ static void convert_VkVideoCodingControl
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -12943,7 +13210,18 @@ static void convert_VkBufferImageCopy2_w
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -13409,7 +13687,18 @@ static void convert_VkVideoDecodeInfoKHR
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -13730,7 +14019,18 @@ static void convert_VkVideoEncodeInfoKHR
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -13773,7 +14073,18 @@ static void convert_VkSubpassEndInfo_win
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -13806,7 +14117,18 @@ static void convert_VkRenderingEndInfoEX
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -13834,7 +14156,7 @@ static const VkCommandBuffer *convert_Vk
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        out[i] = vulkan_command_buffer_from_handle(in[i])->host.command_buffer;
+        out[i] = wine_cmd_buffer_from_handle(in[i])->host.command_buffer;
     }
 
     return out;
@@ -13851,7 +14173,7 @@ static const VkCommandBuffer *convert_Vk
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        out[i] = vulkan_command_buffer_from_handle(UlongToPtr(in[i]))->host.command_buffer;
+        out[i] = wine_cmd_buffer_from_handle(UlongToPtr(in[i]))->host.command_buffer;
     }
 
     return out;
@@ -13905,7 +14227,18 @@ static void convert_VkGeneratedCommandsI
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -14032,7 +14365,18 @@ static void convert_VkBufferMemoryBarrie
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -14102,7 +14446,18 @@ static void convert_VkImageMemoryBarrier
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -14201,7 +14556,18 @@ static void convert_VkBufferMemoryBarrie
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -14285,7 +14651,18 @@ static void convert_VkImageMemoryBarrier
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -14391,7 +14768,18 @@ static void convert_VkDependencyInfo_win
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -14432,7 +14820,18 @@ static void convert_VkPushConstantsInfo_
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -14571,7 +14970,18 @@ static void convert_VkWriteDescriptorSet
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -14628,7 +15038,18 @@ static void convert_VkPushDescriptorSetI
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -14668,7 +15089,18 @@ static void convert_VkPushDescriptorSetW
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -14777,7 +15209,18 @@ static void convert_VkDepthBiasInfoEXT_w
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -14819,7 +15262,18 @@ static void convert_VkSetDescriptorBuffe
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -15141,7 +15595,18 @@ static void convert_VkAccelerationStruct
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -15175,7 +15640,18 @@ static void convert_VkAccelerationStruct
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -15281,7 +15757,18 @@ static void convert_VkBufferCreateInfo_w
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -15399,7 +15886,18 @@ static void convert_VkVideoProfileInfoKH
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -15520,7 +16018,18 @@ static void convert_VkBufferCreateInfo_w
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -15557,7 +16066,18 @@ static void convert_VkBufferViewCreateIn
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -15592,7 +16112,18 @@ static void convert_VkCommandPoolCreateI
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -15693,7 +16224,18 @@ static void convert_VkPipelineShaderStag
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -15878,7 +16420,18 @@ static void convert_VkPipelineShaderStag
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -16000,7 +16553,18 @@ static void convert_VkComputePipelineCre
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -16122,7 +16686,18 @@ static void convert_VkCuModuleCreateInfo
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -16174,7 +16749,18 @@ static void convert_VkDataGraphPipelineR
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -16242,7 +16828,18 @@ static void convert_VkDataGraphPipelineC
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -16359,7 +16956,18 @@ static void convert_VkDataGraphPipelineC
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -16536,7 +17144,18 @@ static void convert_VkDescriptorPoolCrea
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -16611,7 +17230,18 @@ static void convert_VkDescriptorSetLayou
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -19507,7 +20137,18 @@ static void convert_VkDeviceCreateInfo_w
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -19555,7 +20196,18 @@ static void convert_VkDeviceQueueCreateI
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -22434,7 +23086,18 @@ static void convert_VkDeviceCreateInfo_w
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -22451,54 +23114,6 @@ static void convert_VkEventCreateInfo_wi
         FIXME("Unexpected pNext\n");
 }
 
-#ifdef _WIN64
-static void convert_VkFenceCreateInfo_win64_to_host(struct conversion_context *ctx, const VkFenceCreateInfo *in, VkFenceCreateInfo *out)
-{
-    const VkBaseInStructure *in_header;
-    VkBaseOutStructure *out_header = (void *)out;
-
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = NULL;
-    out->flags = in->flags;
-
-    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
-    {
-        switch (in_header->sType)
-        {
-        case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
-        {
-            VkExportFenceCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkExportFenceCreateInfo *in_ext = (const VkExportFenceCreateInfo *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO;
-            out_ext->pNext = NULL;
-            out_ext->handleTypes = in_ext->handleTypes;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
-        {
-            VkExportFenceWin32HandleInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkExportFenceWin32HandleInfoKHR *in_ext = (const VkExportFenceWin32HandleInfoKHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->pAttributes = in_ext->pAttributes;
-            out_ext->dwAccess = in_ext->dwAccess;
-            out_ext->name = in_ext->name;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
-            break;
-        }
-    }
-}
-#endif /* _WIN64 */
-
 static void convert_VkFenceCreateInfo_win32_to_host(struct conversion_context *ctx, const VkFenceCreateInfo32 *in, VkFenceCreateInfo *out)
 {
     const VkBaseInStructure32 *in_header;
@@ -22525,21 +23140,19 @@ static void convert_VkFenceCreateInfo_wi
             out_header = (void *)out_ext;
             break;
         }
-        case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
-        {
-            VkExportFenceWin32HandleInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkExportFenceWin32HandleInfoKHR32 *in_ext = (const VkExportFenceWin32HandleInfoKHR32 *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->pAttributes = convert_SECURITY_ATTRIBUTES_array_win32_to_host(ctx, (const SECURITY_ATTRIBUTES32 *)UlongToPtr(in_ext->pAttributes), 1);
-            out_ext->dwAccess = in_ext->dwAccess;
-            out_ext->name = (LPCWSTR)UlongToPtr(in_ext->name);
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -22612,7 +23225,18 @@ static void convert_VkFramebufferCreateI
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -22914,7 +23538,18 @@ static void convert_VkGraphicsPipelineCr
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -22987,7 +23622,18 @@ static void convert_VkPipelineVertexInpu
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -23066,7 +23712,18 @@ static void convert_VkPipelineTessellati
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -23195,7 +23852,18 @@ static void convert_VkPipelineViewportSt
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -23328,7 +23996,18 @@ static void convert_VkPipelineRasterizat
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -23424,7 +24103,18 @@ static void convert_VkPipelineMultisampl
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -23528,7 +24218,18 @@ static void convert_VkPipelineColorBlend
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -23854,7 +24555,18 @@ static void convert_VkGraphicsPipelineCr
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -24059,7 +24771,18 @@ static void convert_VkImageCreateInfo_wi
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -24208,7 +24931,18 @@ static void convert_VkImageCreateInfo_wi
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -24315,7 +25049,18 @@ static void convert_VkImageViewCreateInf
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -24400,7 +25145,18 @@ static void convert_VkIndirectCommandsLa
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -24661,7 +25417,18 @@ static void convert_VkInstanceCreateInfo
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -24815,7 +25582,18 @@ static void convert_VkInstanceCreateInfo
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -24874,7 +25652,18 @@ static void convert_VkOpticalFlowSession
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -25204,7 +25993,18 @@ static void convert_VkQueryPoolCreateInf
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -25426,7 +26226,18 @@ static void convert_VkRayTracingPipeline
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -25604,7 +26415,18 @@ static void convert_VkRayTracingPipeline
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -25782,7 +26604,18 @@ static void convert_VkRenderPassCreateIn
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -25824,7 +26657,18 @@ static void convert_VkAttachmentDescript
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -25875,7 +26719,18 @@ static void convert_VkAttachmentReferenc
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -25982,7 +26837,18 @@ static void convert_VkSubpassDescription
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -26053,7 +26919,18 @@ static void convert_VkSubpassDependency2
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -26155,7 +27032,18 @@ static void convert_VkRenderPassCreateIn
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -26272,7 +27160,18 @@ static void convert_VkSamplerCreateInfo_
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -26313,7 +27212,18 @@ static void convert_VkSamplerYcbcrConver
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -26383,7 +27293,18 @@ static void convert_VkSemaphoreCreateInf
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -26422,9 +27343,9 @@ static void convert_VkSemaphoreCreateInf
             const VkExportSemaphoreWin32HandleInfoKHR32 *in_ext = (const VkExportSemaphoreWin32HandleInfoKHR32 *)in_header;
             out_ext->sType = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR;
             out_ext->pNext = NULL;
-            out_ext->pAttributes = convert_SECURITY_ATTRIBUTES_array_win32_to_host(ctx, (const SECURITY_ATTRIBUTES32 *)UlongToPtr(in_ext->pAttributes), 1);
+            out_ext->pAttributes = UlongToPtr(in_ext->pAttributes);
             out_ext->dwAccess = in_ext->dwAccess;
-            out_ext->name = (LPCWSTR)UlongToPtr(in_ext->name);
+            out_ext->name = in_ext->name;
             out_header->pNext = (void *)out_ext;
             out_header = (void *)out_ext;
             break;
@@ -26453,7 +27374,18 @@ static void convert_VkSemaphoreCreateInf
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -26502,7 +27434,18 @@ static void convert_VkShaderModuleCreate
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -26560,7 +27503,18 @@ static void convert_VkShaderCreateInfoEX
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -26696,7 +27650,18 @@ static void convert_VkSwapchainCreateInf
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -26776,7 +27741,18 @@ static void convert_VkTensorCreateInfoAR
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -26811,7 +27787,18 @@ static void convert_VkTensorViewCreateIn
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -26903,7 +27890,18 @@ static void convert_VkVideoSessionCreate
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -27214,7 +28212,18 @@ static void convert_VkVideoSessionParame
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -27451,7 +28460,7 @@ static void convert_VkMappedMemoryRange_
 
     out->sType = in->sType;
     out->pNext = in->pNext;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
     out->offset = in->offset;
     out->size = in->size;
 }
@@ -27481,7 +28490,7 @@ static void convert_VkMappedMemoryRange_
 
     out->sType = in->sType;
     out->pNext = NULL;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
     out->offset = in->offset;
     out->size = in->size;
     if (in->pNext)
@@ -27642,7 +28651,18 @@ static void convert_VkMemoryRequirements
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -27945,7 +28965,18 @@ static void convert_VkDescriptorGetInfoE
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -28007,7 +29038,18 @@ static void convert_VkDescriptorSetLayou
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -28460,7 +29502,18 @@ static void convert_VkSubresourceLayout2
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -28522,7 +29575,7 @@ static void convert_VkDeviceMemoryOpaque
 
     out->sType = in->sType;
     out->pNext = in->pNext;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
 }
 #endif /* _WIN64 */
 
@@ -28532,7 +29585,7 @@ static void convert_VkDeviceMemoryOpaque
 
     out->sType = in->sType;
     out->pNext = NULL;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
     if (in->pNext)
         FIXME("Unexpected pNext\n");
 }
@@ -28640,7 +29693,18 @@ static void convert_VkVideoEncodeSession
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -28670,7 +29734,18 @@ static void convert_VkVideoEncodeSession
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -28705,18 +29780,6 @@ static void convert_VkVideoEncodeSession
     }
 }
 
-static void convert_VkFenceGetWin32HandleInfoKHR_win32_to_unwrapped_host(const VkFenceGetWin32HandleInfoKHR32 *in, VkFenceGetWin32HandleInfoKHR *out)
-{
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = NULL;
-    out->fence = in->fence;
-    out->handleType = in->handleType;
-    if (in->pNext)
-        FIXME("Unexpected pNext\n");
-}
-
 static VkTilePropertiesQCOM *convert_VkTilePropertiesQCOM_array_win32_to_host(struct conversion_context *ctx, const VkTilePropertiesQCOM32 *in, uint32_t count)
 {
     VkTilePropertiesQCOM *out;
@@ -28787,7 +29850,18 @@ static void convert_VkGeneratedCommandsM
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -28834,7 +29908,18 @@ static void convert_VkImageMemoryRequire
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -29005,6 +30090,47 @@ static void convert_VkGetLatencyMarkerIn
     convert_VkLatencyTimingsFrameReportNV_array_host_to_win32(in->pTimings, (VkLatencyTimingsFrameReportNV32 *)UlongToPtr(out->pTimings), in->timingCount);
 }
 
+#ifdef _WIN64
+static void convert_VkMemoryGetFdInfoKHR_win64_to_host(const VkMemoryGetFdInfoKHR *in, VkMemoryGetFdInfoKHR *out)
+{
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = in->pNext;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
+    out->handleType = in->handleType;
+}
+#endif /* _WIN64 */
+
+static void convert_VkMemoryGetFdInfoKHR_win32_to_host(const VkMemoryGetFdInfoKHR32 *in, VkMemoryGetFdInfoKHR *out)
+{
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = NULL;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
+    out->handleType = in->handleType;
+    if (in->pNext)
+        FIXME("Unexpected pNext\n");
+}
+
+static void convert_VkMemoryFdPropertiesKHR_win32_to_host(const VkMemoryFdPropertiesKHR32 *in, VkMemoryFdPropertiesKHR *out)
+{
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = NULL;
+    if (in->pNext)
+        FIXME("Unexpected pNext\n");
+}
+
+static void convert_VkMemoryFdPropertiesKHR_host_to_win32(const VkMemoryFdPropertiesKHR *in, VkMemoryFdPropertiesKHR32 *out)
+{
+    if (!in) return;
+
+    out->memoryTypeBits = in->memoryTypeBits;
+}
+
 static void convert_VkMemoryHostPointerPropertiesEXT_win32_to_host(const VkMemoryHostPointerPropertiesEXT32 *in, VkMemoryHostPointerPropertiesEXT *out)
 {
     if (!in) return;
@@ -29316,43 +30442,6 @@ static void convert_VkCooperativeVectorP
     }
 }
 
-#ifdef _WIN64
-static void convert_VkPhysicalDeviceExternalBufferInfo_win64_to_host(struct conversion_context *ctx, const VkPhysicalDeviceExternalBufferInfo *in, VkPhysicalDeviceExternalBufferInfo *out)
-{
-    const VkBaseInStructure *in_header;
-    VkBaseOutStructure *out_header = (void *)out;
-
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = NULL;
-    out->flags = in->flags;
-    out->usage = in->usage;
-    out->handleType = in->handleType;
-
-    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
-    {
-        switch (in_header->sType)
-        {
-        case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO:
-        {
-            VkBufferUsageFlags2CreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkBufferUsageFlags2CreateInfo *in_ext = (const VkBufferUsageFlags2CreateInfo *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO;
-            out_ext->pNext = NULL;
-            out_ext->usage = in_ext->usage;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
-            break;
-        }
-    }
-}
-#endif /* _WIN64 */
-
 static void convert_VkPhysicalDeviceExternalBufferInfo_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceExternalBufferInfo32 *in, VkPhysicalDeviceExternalBufferInfo *out)
 {
     const VkBaseInStructure32 *in_header;
@@ -29382,7 +30471,18 @@ static void convert_VkPhysicalDeviceExte
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -29435,6 +30535,53 @@ static void convert_VkExternalFencePrope
     out->externalFenceFeatures = in->externalFenceFeatures;
 }
 
+#ifdef _WIN64
+static void convert_VkPhysicalDeviceExternalSemaphoreInfo_win64_to_host(struct conversion_context *ctx, const VkPhysicalDeviceExternalSemaphoreInfo *in, VkPhysicalDeviceExternalSemaphoreInfo *out)
+{
+    const VkBaseInStructure *in_header;
+    VkBaseOutStructure *out_header = (void *)out;
+
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = NULL;
+    out->handleType = in->handleType;
+
+    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
+    {
+        switch (in_header->sType)
+        {
+        case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
+        {
+            VkSemaphoreTypeCreateInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkSemaphoreTypeCreateInfo *in_ext = (const VkSemaphoreTypeCreateInfo *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO;
+            out_ext->pNext = NULL;
+            out_ext->semaphoreType = in_ext->semaphoreType;
+            out_ext->initialValue = in_ext->initialValue;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        default:
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
+            break;
+        }
+    }
+}
+#endif /* _WIN64 */
+
 static void convert_VkPhysicalDeviceExternalSemaphoreInfo_win32_to_host(struct conversion_context *ctx, const VkPhysicalDeviceExternalSemaphoreInfo32 *in, VkPhysicalDeviceExternalSemaphoreInfo *out)
 {
     const VkBaseInStructure32 *in_header;
@@ -29463,7 +30610,18 @@ static void convert_VkPhysicalDeviceExte
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -32246,7 +33404,18 @@ static void convert_VkPhysicalDeviceFeat
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -34586,7 +35755,18 @@ static void convert_VkFormatProperties2_
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -34800,7 +35980,18 @@ static void convert_VkPhysicalDeviceImag
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -34908,7 +36099,18 @@ static void convert_VkPhysicalDeviceImag
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -34983,7 +36185,18 @@ static void convert_VkImageFormatPropert
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -35119,7 +36332,18 @@ static void convert_VkPhysicalDeviceMemo
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -36256,7 +37480,18 @@ static void convert_VkPhysicalDeviceProp
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -37802,7 +39037,18 @@ static void convert_VkQueueFamilyPropert
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -38045,7 +39291,18 @@ static void convert_VkPhysicalDeviceSurf
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -38136,7 +39393,18 @@ static void convert_VkSurfaceCapabilitie
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -38245,7 +39513,18 @@ static void convert_VkSurfaceFormat2KHR_
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -38489,7 +39768,18 @@ static void convert_VkVideoCapabilitiesK
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -38736,7 +40026,18 @@ static void convert_VkVideoEncodeQuality
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -38830,7 +40131,18 @@ static void convert_VkPhysicalDeviceVide
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -38878,7 +40190,18 @@ static void convert_VkVideoFormatPropert
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -39305,6 +40628,30 @@ static void convert_VkSamplerCaptureDesc
         FIXME("Unexpected pNext\n");
 }
 
+#ifdef _WIN64
+static void convert_VkSemaphoreGetFdInfoKHR_win64_to_host(const VkSemaphoreGetFdInfoKHR *in, VkSemaphoreGetFdInfoKHR *out)
+{
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = in->pNext;
+    out->semaphore = in->semaphore ? vulkan_semaphore_from_handle(in->semaphore)->host.semaphore : VK_NULL_HANDLE;
+    out->handleType = in->handleType;
+}
+#endif /* _WIN64 */
+
+static void convert_VkSemaphoreGetFdInfoKHR_win32_to_host(const VkSemaphoreGetFdInfoKHR32 *in, VkSemaphoreGetFdInfoKHR *out)
+{
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = NULL;
+    out->semaphore = in->semaphore ? vulkan_semaphore_from_handle(in->semaphore)->host.semaphore : VK_NULL_HANDLE;
+    out->handleType = in->handleType;
+    if (in->pNext)
+        FIXME("Unexpected pNext\n");
+}
+
 static void convert_VkSemaphoreGetWin32HandleInfoKHR_win32_to_unwrapped_host(const VkSemaphoreGetWin32HandleInfoKHR32 *in, VkSemaphoreGetWin32HandleInfoKHR *out)
 {
     if (!in) return;
@@ -39414,17 +40761,30 @@ static void convert_VkVideoSessionMemory
     }
 }
 
-static void convert_VkImportFenceWin32HandleInfoKHR_win32_to_unwrapped_host(const VkImportFenceWin32HandleInfoKHR32 *in, VkImportFenceWin32HandleInfoKHR *out)
+#ifdef _WIN64
+static void convert_VkImportSemaphoreFdInfoKHR_win64_to_host(const VkImportSemaphoreFdInfoKHR *in, VkImportSemaphoreFdInfoKHR *out)
+{
+    if (!in) return;
+
+    out->sType = in->sType;
+    out->pNext = in->pNext;
+    out->semaphore = in->semaphore ? vulkan_semaphore_from_handle(in->semaphore)->host.semaphore : VK_NULL_HANDLE;
+    out->flags = in->flags;
+    out->handleType = in->handleType;
+    out->fd = in->fd;
+}
+#endif /* _WIN64 */
+
+static void convert_VkImportSemaphoreFdInfoKHR_win32_to_host(const VkImportSemaphoreFdInfoKHR32 *in, VkImportSemaphoreFdInfoKHR *out)
 {
     if (!in) return;
 
     out->sType = in->sType;
     out->pNext = NULL;
-    out->fence = in->fence;
+    out->semaphore = in->semaphore ? vulkan_semaphore_from_handle(in->semaphore)->host.semaphore : VK_NULL_HANDLE;
     out->flags = in->flags;
     out->handleType = in->handleType;
-    out->handle = (HANDLE)UlongToPtr(in->handle);
-    out->name = (LPCWSTR)UlongToPtr(in->name);
+    out->fd = in->fd;
     if (in->pNext)
         FIXME("Unexpected pNext\n");
 }
@@ -39438,8 +40798,8 @@ static void convert_VkImportSemaphoreWin
     out->semaphore = in->semaphore;
     out->flags = in->flags;
     out->handleType = in->handleType;
-    out->handle = (HANDLE)UlongToPtr(in->handle);
-    out->name = (LPCWSTR)UlongToPtr(in->name);
+    out->handle = in->handle;
+    out->name = in->name;
     if (in->pNext)
         FIXME("Unexpected pNext\n");
 }
@@ -39462,7 +40822,7 @@ static void convert_VkLatencySleepInfoNV
 
     out->sType = in->sType;
     out->pNext = in->pNext;
-    out->signalSemaphore = vulkan_semaphore_from_handle(in->signalSemaphore)->host.semaphore;
+    out->signalSemaphore = in->signalSemaphore ? vulkan_semaphore_from_handle(in->signalSemaphore)->host.semaphore : VK_NULL_HANDLE;
     out->value = in->value;
 }
 #endif /* _WIN64 */
@@ -39473,7 +40833,7 @@ static void convert_VkLatencySleepInfoNV
 
     out->sType = in->sType;
     out->pNext = NULL;
-    out->signalSemaphore = vulkan_semaphore_from_handle(in->signalSemaphore)->host.semaphore;
+    out->signalSemaphore = in->signalSemaphore ? vulkan_semaphore_from_handle(in->signalSemaphore)->host.semaphore : VK_NULL_HANDLE;
     out->value = in->value;
     if (in->pNext)
         FIXME("Unexpected pNext\n");
@@ -39487,7 +40847,7 @@ static void convert_VkMemoryMapInfo_win6
     out->sType = in->sType;
     out->pNext = in->pNext;
     out->flags = in->flags;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
     out->offset = in->offset;
     out->size = in->size;
 }
@@ -39500,7 +40860,7 @@ static void convert_VkMemoryMapInfo_win3
     out->sType = in->sType;
     out->pNext = NULL;
     out->flags = in->flags;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
     out->offset = in->offset;
     out->size = in->size;
     if (in->pNext)
@@ -39522,214 +40882,110 @@ static void convert_VkMemoryMapInfo_win3
 }
 
 #ifdef _WIN64
-static const VkSemaphore *convert_VkSemaphore_array_win64_to_host(struct conversion_context *ctx, const VkSemaphore *in, uint32_t count)
-{
-    VkSemaphore *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        out[i] = vulkan_semaphore_from_handle(in[i])->host.semaphore;
-    }
-
-    return out;
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
-static void convert_VkSparseMemoryBind_win64_to_host(const VkSparseMemoryBind *in, VkSparseMemoryBind *out)
-{
-    if (!in) return;
-
-    out->resourceOffset = in->resourceOffset;
-    out->size = in->size;
-    out->memory = in->memory ? vulkan_device_memory_from_handle(in->memory)->host.device_memory : 0;
-    out->memoryOffset = in->memoryOffset;
-    out->flags = in->flags;
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
-static const VkSparseMemoryBind *convert_VkSparseMemoryBind_array_win64_to_host(struct conversion_context *ctx, const VkSparseMemoryBind *in, uint32_t count)
-{
-    VkSparseMemoryBind *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        convert_VkSparseMemoryBind_win64_to_host(&in[i], &out[i]);
-    }
-
-    return out;
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
-static void convert_VkSparseBufferMemoryBindInfo_win64_to_host(struct conversion_context *ctx, const VkSparseBufferMemoryBindInfo *in, VkSparseBufferMemoryBindInfo *out)
-{
-    if (!in) return;
-
-    out->buffer = in->buffer;
-    out->bindCount = in->bindCount;
-    out->pBinds = convert_VkSparseMemoryBind_array_win64_to_host(ctx, in->pBinds, in->bindCount);
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
-static const VkSparseBufferMemoryBindInfo *convert_VkSparseBufferMemoryBindInfo_array_win64_to_host(struct conversion_context *ctx, const VkSparseBufferMemoryBindInfo *in, uint32_t count)
-{
-    VkSparseBufferMemoryBindInfo *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        convert_VkSparseBufferMemoryBindInfo_win64_to_host(ctx, &in[i], &out[i]);
-    }
-
-    return out;
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
-static void convert_VkSparseImageOpaqueMemoryBindInfo_win64_to_host(struct conversion_context *ctx, const VkSparseImageOpaqueMemoryBindInfo *in, VkSparseImageOpaqueMemoryBindInfo *out)
-{
-    if (!in) return;
-
-    out->image = in->image;
-    out->bindCount = in->bindCount;
-    out->pBinds = convert_VkSparseMemoryBind_array_win64_to_host(ctx, in->pBinds, in->bindCount);
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
-static const VkSparseImageOpaqueMemoryBindInfo *convert_VkSparseImageOpaqueMemoryBindInfo_array_win64_to_host(struct conversion_context *ctx, const VkSparseImageOpaqueMemoryBindInfo *in, uint32_t count)
+static void convert_VkBindSparseInfo_win64_to_unwrapped_host(struct conversion_context *ctx, const VkBindSparseInfo *in, VkBindSparseInfo *out)
 {
-    VkSparseImageOpaqueMemoryBindInfo *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        convert_VkSparseImageOpaqueMemoryBindInfo_win64_to_host(ctx, &in[i], &out[i]);
-    }
-
-    return out;
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
-static void convert_VkSparseImageMemoryBind_win64_to_host(const VkSparseImageMemoryBind *in, VkSparseImageMemoryBind *out)
-{
-    if (!in) return;
-
-    out->subresource = in->subresource;
-    out->offset = in->offset;
-    out->extent = in->extent;
-    out->memory = in->memory ? vulkan_device_memory_from_handle(in->memory)->host.device_memory : 0;
-    out->memoryOffset = in->memoryOffset;
-    out->flags = in->flags;
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
-static const VkSparseImageMemoryBind *convert_VkSparseImageMemoryBind_array_win64_to_host(struct conversion_context *ctx, const VkSparseImageMemoryBind *in, uint32_t count)
-{
-    VkSparseImageMemoryBind *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        convert_VkSparseImageMemoryBind_win64_to_host(&in[i], &out[i]);
-    }
-
-    return out;
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
-static void convert_VkSparseImageMemoryBindInfo_win64_to_host(struct conversion_context *ctx, const VkSparseImageMemoryBindInfo *in, VkSparseImageMemoryBindInfo *out)
-{
-    if (!in) return;
-
-    out->image = in->image;
-    out->bindCount = in->bindCount;
-    out->pBinds = convert_VkSparseImageMemoryBind_array_win64_to_host(ctx, in->pBinds, in->bindCount);
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
-static const VkSparseImageMemoryBindInfo *convert_VkSparseImageMemoryBindInfo_array_win64_to_host(struct conversion_context *ctx, const VkSparseImageMemoryBindInfo *in, uint32_t count)
-{
-    VkSparseImageMemoryBindInfo *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        convert_VkSparseImageMemoryBindInfo_win64_to_host(ctx, &in[i], &out[i]);
-    }
-
-    return out;
-}
-#endif /* _WIN64 */
+    const VkBaseInStructure *in_header;
+    VkBaseOutStructure *out_header = (void *)out;
 
-#ifdef _WIN64
-static void convert_VkBindSparseInfo_win64_to_host(struct conversion_context *ctx, const VkBindSparseInfo *in, VkBindSparseInfo *out)
-{
     if (!in) return;
 
     out->sType = in->sType;
-    out->pNext = in->pNext;
+    out->pNext = NULL;
     out->waitSemaphoreCount = in->waitSemaphoreCount;
-    out->pWaitSemaphores = convert_VkSemaphore_array_win64_to_host(ctx, in->pWaitSemaphores, in->waitSemaphoreCount);
+    out->pWaitSemaphores = in->pWaitSemaphores;
     out->bufferBindCount = in->bufferBindCount;
-    out->pBufferBinds = convert_VkSparseBufferMemoryBindInfo_array_win64_to_host(ctx, in->pBufferBinds, in->bufferBindCount);
+    out->pBufferBinds = in->pBufferBinds;
     out->imageOpaqueBindCount = in->imageOpaqueBindCount;
-    out->pImageOpaqueBinds = convert_VkSparseImageOpaqueMemoryBindInfo_array_win64_to_host(ctx, in->pImageOpaqueBinds, in->imageOpaqueBindCount);
+    out->pImageOpaqueBinds = in->pImageOpaqueBinds;
     out->imageBindCount = in->imageBindCount;
-    out->pImageBinds = convert_VkSparseImageMemoryBindInfo_array_win64_to_host(ctx, in->pImageBinds, in->imageBindCount);
+    out->pImageBinds = in->pImageBinds;
     out->signalSemaphoreCount = in->signalSemaphoreCount;
-    out->pSignalSemaphores = convert_VkSemaphore_array_win64_to_host(ctx, in->pSignalSemaphores, in->signalSemaphoreCount);
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
-static const VkBindSparseInfo *convert_VkBindSparseInfo_array_win64_to_host(struct conversion_context *ctx, const VkBindSparseInfo *in, uint32_t count)
-{
-    VkBindSparseInfo *out;
-    unsigned int i;
+    out->pSignalSemaphores = in->pSignalSemaphores;
 
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
+    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
     {
-        convert_VkBindSparseInfo_win64_to_host(ctx, &in[i], &out[i]);
+        switch (in_header->sType)
+        {
+        case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
+        {
+            VkDeviceGroupBindSparseInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkDeviceGroupBindSparseInfo *in_ext = (const VkDeviceGroupBindSparseInfo *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO;
+            out_ext->pNext = NULL;
+            out_ext->resourceDeviceIndex = in_ext->resourceDeviceIndex;
+            out_ext->memoryDeviceIndex = in_ext->memoryDeviceIndex;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
+        {
+            VkFrameBoundaryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkFrameBoundaryEXT *in_ext = (const VkFrameBoundaryEXT *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT;
+            out_ext->pNext = NULL;
+            out_ext->flags = in_ext->flags;
+            out_ext->frameID = in_ext->frameID;
+            out_ext->imageCount = in_ext->imageCount;
+            out_ext->pImages = in_ext->pImages;
+            out_ext->bufferCount = in_ext->bufferCount;
+            out_ext->pBuffers = in_ext->pBuffers;
+            out_ext->tagName = in_ext->tagName;
+            out_ext->tagSize = in_ext->tagSize;
+            out_ext->pTag = in_ext->pTag;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM:
+        {
+            VkFrameBoundaryTensorsARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkFrameBoundaryTensorsARM *in_ext = (const VkFrameBoundaryTensorsARM *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM;
+            out_ext->pNext = NULL;
+            out_ext->tensorCount = in_ext->tensorCount;
+            out_ext->pTensors = in_ext->pTensors;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
+        {
+            VkTimelineSemaphoreSubmitInfo *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
+            const VkTimelineSemaphoreSubmitInfo *in_ext = (const VkTimelineSemaphoreSubmitInfo *)in_header;
+            out_ext->sType = VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO;
+            out_ext->pNext = NULL;
+            out_ext->waitSemaphoreValueCount = in_ext->waitSemaphoreValueCount;
+            out_ext->pWaitSemaphoreValues = in_ext->pWaitSemaphoreValues;
+            out_ext->signalSemaphoreValueCount = in_ext->signalSemaphoreValueCount;
+            out_ext->pSignalSemaphoreValues = in_ext->pSignalSemaphoreValues;
+            out_header->pNext = (void *)out_ext;
+            out_header = (void *)out_ext;
+            break;
+        }
+        default:
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
+            break;
+        }
     }
-
-    return out;
 }
 #endif /* _WIN64 */
 
-static const VkSemaphore *convert_VkSemaphore_array_win32_to_host(struct conversion_context *ctx, const VkSemaphore *in, uint32_t count)
+#ifdef _WIN64
+static const VkBindSparseInfo *convert_VkBindSparseInfo_array_win64_to_unwrapped_host(struct conversion_context *ctx, const VkBindSparseInfo *in, uint32_t count)
 {
-    VkSemaphore *out;
+    VkBindSparseInfo *out;
     unsigned int i;
 
     if (!in || !count) return NULL;
@@ -39737,24 +40993,25 @@ static const VkSemaphore *convert_VkSema
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        out[i] = vulkan_semaphore_from_handle(in[i])->host.semaphore;
+        convert_VkBindSparseInfo_win64_to_unwrapped_host(ctx, &in[i], &out[i]);
     }
 
     return out;
 }
+#endif /* _WIN64 */
 
-static void convert_VkSparseMemoryBind_win32_to_host(const VkSparseMemoryBind32 *in, VkSparseMemoryBind *out)
+static void convert_VkSparseMemoryBind_win32_to_unwrapped_host(const VkSparseMemoryBind32 *in, VkSparseMemoryBind *out)
 {
     if (!in) return;
 
     out->resourceOffset = in->resourceOffset;
     out->size = in->size;
-    out->memory = in->memory ? vulkan_device_memory_from_handle(in->memory)->host.device_memory : 0;
+    out->memory = in->memory;
     out->memoryOffset = in->memoryOffset;
     out->flags = in->flags;
 }
 
-static const VkSparseMemoryBind *convert_VkSparseMemoryBind_array_win32_to_host(struct conversion_context *ctx, const VkSparseMemoryBind32 *in, uint32_t count)
+static const VkSparseMemoryBind *convert_VkSparseMemoryBind_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSparseMemoryBind32 *in, uint32_t count)
 {
     VkSparseMemoryBind *out;
     unsigned int i;
@@ -39764,22 +41021,22 @@ static const VkSparseMemoryBind *convert
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        convert_VkSparseMemoryBind_win32_to_host(&in[i], &out[i]);
+        convert_VkSparseMemoryBind_win32_to_unwrapped_host(&in[i], &out[i]);
     }
 
     return out;
 }
 
-static void convert_VkSparseBufferMemoryBindInfo_win32_to_host(struct conversion_context *ctx, const VkSparseBufferMemoryBindInfo32 *in, VkSparseBufferMemoryBindInfo *out)
+static void convert_VkSparseBufferMemoryBindInfo_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSparseBufferMemoryBindInfo32 *in, VkSparseBufferMemoryBindInfo *out)
 {
     if (!in) return;
 
     out->buffer = in->buffer;
     out->bindCount = in->bindCount;
-    out->pBinds = convert_VkSparseMemoryBind_array_win32_to_host(ctx, (const VkSparseMemoryBind32 *)UlongToPtr(in->pBinds), in->bindCount);
+    out->pBinds = convert_VkSparseMemoryBind_array_win32_to_unwrapped_host(ctx, (const VkSparseMemoryBind32 *)UlongToPtr(in->pBinds), in->bindCount);
 }
 
-static const VkSparseBufferMemoryBindInfo *convert_VkSparseBufferMemoryBindInfo_array_win32_to_host(struct conversion_context *ctx, const VkSparseBufferMemoryBindInfo32 *in, uint32_t count)
+static const VkSparseBufferMemoryBindInfo *convert_VkSparseBufferMemoryBindInfo_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSparseBufferMemoryBindInfo32 *in, uint32_t count)
 {
     VkSparseBufferMemoryBindInfo *out;
     unsigned int i;
@@ -39789,22 +41046,22 @@ static const VkSparseBufferMemoryBindInf
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        convert_VkSparseBufferMemoryBindInfo_win32_to_host(ctx, &in[i], &out[i]);
+        convert_VkSparseBufferMemoryBindInfo_win32_to_unwrapped_host(ctx, &in[i], &out[i]);
     }
 
     return out;
 }
 
-static void convert_VkSparseImageOpaqueMemoryBindInfo_win32_to_host(struct conversion_context *ctx, const VkSparseImageOpaqueMemoryBindInfo32 *in, VkSparseImageOpaqueMemoryBindInfo *out)
+static void convert_VkSparseImageOpaqueMemoryBindInfo_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSparseImageOpaqueMemoryBindInfo32 *in, VkSparseImageOpaqueMemoryBindInfo *out)
 {
     if (!in) return;
 
     out->image = in->image;
     out->bindCount = in->bindCount;
-    out->pBinds = convert_VkSparseMemoryBind_array_win32_to_host(ctx, (const VkSparseMemoryBind32 *)UlongToPtr(in->pBinds), in->bindCount);
+    out->pBinds = convert_VkSparseMemoryBind_array_win32_to_unwrapped_host(ctx, (const VkSparseMemoryBind32 *)UlongToPtr(in->pBinds), in->bindCount);
 }
 
-static const VkSparseImageOpaqueMemoryBindInfo *convert_VkSparseImageOpaqueMemoryBindInfo_array_win32_to_host(struct conversion_context *ctx, const VkSparseImageOpaqueMemoryBindInfo32 *in, uint32_t count)
+static const VkSparseImageOpaqueMemoryBindInfo *convert_VkSparseImageOpaqueMemoryBindInfo_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSparseImageOpaqueMemoryBindInfo32 *in, uint32_t count)
 {
     VkSparseImageOpaqueMemoryBindInfo *out;
     unsigned int i;
@@ -39814,25 +41071,25 @@ static const VkSparseImageOpaqueMemoryBi
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        convert_VkSparseImageOpaqueMemoryBindInfo_win32_to_host(ctx, &in[i], &out[i]);
+        convert_VkSparseImageOpaqueMemoryBindInfo_win32_to_unwrapped_host(ctx, &in[i], &out[i]);
     }
 
     return out;
 }
 
-static void convert_VkSparseImageMemoryBind_win32_to_host(const VkSparseImageMemoryBind32 *in, VkSparseImageMemoryBind *out)
+static void convert_VkSparseImageMemoryBind_win32_to_unwrapped_host(const VkSparseImageMemoryBind32 *in, VkSparseImageMemoryBind *out)
 {
     if (!in) return;
 
     out->subresource = in->subresource;
     out->offset = in->offset;
     out->extent = in->extent;
-    out->memory = in->memory ? vulkan_device_memory_from_handle(in->memory)->host.device_memory : 0;
+    out->memory = in->memory;
     out->memoryOffset = in->memoryOffset;
     out->flags = in->flags;
 }
 
-static const VkSparseImageMemoryBind *convert_VkSparseImageMemoryBind_array_win32_to_host(struct conversion_context *ctx, const VkSparseImageMemoryBind32 *in, uint32_t count)
+static const VkSparseImageMemoryBind *convert_VkSparseImageMemoryBind_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSparseImageMemoryBind32 *in, uint32_t count)
 {
     VkSparseImageMemoryBind *out;
     unsigned int i;
@@ -39842,22 +41099,22 @@ static const VkSparseImageMemoryBind *co
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        convert_VkSparseImageMemoryBind_win32_to_host(&in[i], &out[i]);
+        convert_VkSparseImageMemoryBind_win32_to_unwrapped_host(&in[i], &out[i]);
     }
 
     return out;
 }
 
-static void convert_VkSparseImageMemoryBindInfo_win32_to_host(struct conversion_context *ctx, const VkSparseImageMemoryBindInfo32 *in, VkSparseImageMemoryBindInfo *out)
+static void convert_VkSparseImageMemoryBindInfo_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSparseImageMemoryBindInfo32 *in, VkSparseImageMemoryBindInfo *out)
 {
     if (!in) return;
 
     out->image = in->image;
     out->bindCount = in->bindCount;
-    out->pBinds = convert_VkSparseImageMemoryBind_array_win32_to_host(ctx, (const VkSparseImageMemoryBind32 *)UlongToPtr(in->pBinds), in->bindCount);
+    out->pBinds = convert_VkSparseImageMemoryBind_array_win32_to_unwrapped_host(ctx, (const VkSparseImageMemoryBind32 *)UlongToPtr(in->pBinds), in->bindCount);
 }
 
-static const VkSparseImageMemoryBindInfo *convert_VkSparseImageMemoryBindInfo_array_win32_to_host(struct conversion_context *ctx, const VkSparseImageMemoryBindInfo32 *in, uint32_t count)
+static const VkSparseImageMemoryBindInfo *convert_VkSparseImageMemoryBindInfo_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSparseImageMemoryBindInfo32 *in, uint32_t count)
 {
     VkSparseImageMemoryBindInfo *out;
     unsigned int i;
@@ -39867,13 +41124,13 @@ static const VkSparseImageMemoryBindInfo
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        convert_VkSparseImageMemoryBindInfo_win32_to_host(ctx, &in[i], &out[i]);
+        convert_VkSparseImageMemoryBindInfo_win32_to_unwrapped_host(ctx, &in[i], &out[i]);
     }
 
     return out;
 }
 
-static void convert_VkBindSparseInfo_win32_to_host(struct conversion_context *ctx, const VkBindSparseInfo32 *in, VkBindSparseInfo *out)
+static void convert_VkBindSparseInfo_win32_to_unwrapped_host(struct conversion_context *ctx, const VkBindSparseInfo32 *in, VkBindSparseInfo *out)
 {
     const VkBaseInStructure32 *in_header;
     VkBaseOutStructure *out_header = (void *)out;
@@ -39883,15 +41140,15 @@ static void convert_VkBindSparseInfo_win
     out->sType = in->sType;
     out->pNext = NULL;
     out->waitSemaphoreCount = in->waitSemaphoreCount;
-    out->pWaitSemaphores = convert_VkSemaphore_array_win32_to_host(ctx, (const VkSemaphore *)UlongToPtr(in->pWaitSemaphores), in->waitSemaphoreCount);
+    out->pWaitSemaphores = UlongToPtr(in->pWaitSemaphores);
     out->bufferBindCount = in->bufferBindCount;
-    out->pBufferBinds = convert_VkSparseBufferMemoryBindInfo_array_win32_to_host(ctx, (const VkSparseBufferMemoryBindInfo32 *)UlongToPtr(in->pBufferBinds), in->bufferBindCount);
+    out->pBufferBinds = convert_VkSparseBufferMemoryBindInfo_array_win32_to_unwrapped_host(ctx, (const VkSparseBufferMemoryBindInfo32 *)UlongToPtr(in->pBufferBinds), in->bufferBindCount);
     out->imageOpaqueBindCount = in->imageOpaqueBindCount;
-    out->pImageOpaqueBinds = convert_VkSparseImageOpaqueMemoryBindInfo_array_win32_to_host(ctx, (const VkSparseImageOpaqueMemoryBindInfo32 *)UlongToPtr(in->pImageOpaqueBinds), in->imageOpaqueBindCount);
+    out->pImageOpaqueBinds = convert_VkSparseImageOpaqueMemoryBindInfo_array_win32_to_unwrapped_host(ctx, (const VkSparseImageOpaqueMemoryBindInfo32 *)UlongToPtr(in->pImageOpaqueBinds), in->imageOpaqueBindCount);
     out->imageBindCount = in->imageBindCount;
-    out->pImageBinds = convert_VkSparseImageMemoryBindInfo_array_win32_to_host(ctx, (const VkSparseImageMemoryBindInfo32 *)UlongToPtr(in->pImageBinds), in->imageBindCount);
+    out->pImageBinds = convert_VkSparseImageMemoryBindInfo_array_win32_to_unwrapped_host(ctx, (const VkSparseImageMemoryBindInfo32 *)UlongToPtr(in->pImageBinds), in->imageBindCount);
     out->signalSemaphoreCount = in->signalSemaphoreCount;
-    out->pSignalSemaphores = convert_VkSemaphore_array_win32_to_host(ctx, (const VkSemaphore *)UlongToPtr(in->pSignalSemaphores), in->signalSemaphoreCount);
+    out->pSignalSemaphores = UlongToPtr(in->pSignalSemaphores);
 
     for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
     {
@@ -39955,13 +41212,24 @@ static void convert_VkBindSparseInfo_win
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
 }
 
-static const VkBindSparseInfo *convert_VkBindSparseInfo_array_win32_to_host(struct conversion_context *ctx, const VkBindSparseInfo32 *in, uint32_t count)
+static const VkBindSparseInfo *convert_VkBindSparseInfo_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkBindSparseInfo32 *in, uint32_t count)
 {
     VkBindSparseInfo *out;
     unsigned int i;
@@ -39971,7 +41239,7 @@ static const VkBindSparseInfo *convert_V
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        convert_VkBindSparseInfo_win32_to_host(ctx, &in[i], &out[i]);
+        convert_VkBindSparseInfo_win32_to_unwrapped_host(ctx, &in[i], &out[i]);
     }
 
     return out;
@@ -39988,225 +41256,6 @@ static void convert_VkOutOfBandQueueType
         FIXME("Unexpected pNext\n");
 }
 
-#ifdef _WIN64
-static const VkSemaphore *convert_VkSemaphore_array_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSemaphore *in, uint32_t count)
-{
-    VkSemaphore *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        out[i] = in[i];
-    }
-
-    return out;
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
-static const VkSwapchainKHR *convert_VkSwapchainKHR_array_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSwapchainKHR *in, uint32_t count)
-{
-    VkSwapchainKHR *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        out[i] = in[i];
-    }
-
-    return out;
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
-static const VkFence *convert_VkFence_array_win64_to_host(struct conversion_context *ctx, const VkFence *in, uint32_t count)
-{
-    VkFence *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        out[i] = vulkan_fence_from_handle(in[i])->host.fence;
-    }
-
-    return out;
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
-static void convert_VkPresentInfoKHR_win64_to_unwrapped_host(struct conversion_context *ctx, const VkPresentInfoKHR *in, VkPresentInfoKHR *out)
-{
-    const VkBaseInStructure *in_header;
-    VkBaseOutStructure *out_header = (void *)out;
-
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = NULL;
-    out->waitSemaphoreCount = in->waitSemaphoreCount;
-    out->pWaitSemaphores = convert_VkSemaphore_array_win64_to_unwrapped_host(ctx, in->pWaitSemaphores, in->waitSemaphoreCount);
-    out->swapchainCount = in->swapchainCount;
-    out->pSwapchains = convert_VkSwapchainKHR_array_win64_to_unwrapped_host(ctx, in->pSwapchains, in->swapchainCount);
-    out->pImageIndices = in->pImageIndices;
-    out->pResults = in->pResults;
-
-    for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
-    {
-        switch (in_header->sType)
-        {
-        case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
-        {
-            VkDeviceGroupPresentInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkDeviceGroupPresentInfoKHR *in_ext = (const VkDeviceGroupPresentInfoKHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->swapchainCount = in_ext->swapchainCount;
-            out_ext->pDeviceMasks = in_ext->pDeviceMasks;
-            out_ext->mode = in_ext->mode;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
-        {
-            VkFrameBoundaryEXT *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkFrameBoundaryEXT *in_ext = (const VkFrameBoundaryEXT *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT;
-            out_ext->pNext = NULL;
-            out_ext->flags = in_ext->flags;
-            out_ext->frameID = in_ext->frameID;
-            out_ext->imageCount = in_ext->imageCount;
-            out_ext->pImages = in_ext->pImages;
-            out_ext->bufferCount = in_ext->bufferCount;
-            out_ext->pBuffers = in_ext->pBuffers;
-            out_ext->tagName = in_ext->tagName;
-            out_ext->tagSize = in_ext->tagSize;
-            out_ext->pTag = in_ext->pTag;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM:
-        {
-            VkFrameBoundaryTensorsARM *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkFrameBoundaryTensorsARM *in_ext = (const VkFrameBoundaryTensorsARM *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM;
-            out_ext->pNext = NULL;
-            out_ext->tensorCount = in_ext->tensorCount;
-            out_ext->pTensors = in_ext->pTensors;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR:
-        {
-            VkPresentId2KHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkPresentId2KHR *in_ext = (const VkPresentId2KHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR;
-            out_ext->pNext = NULL;
-            out_ext->swapchainCount = in_ext->swapchainCount;
-            out_ext->pPresentIds = in_ext->pPresentIds;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PRESENT_ID_KHR:
-        {
-            VkPresentIdKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkPresentIdKHR *in_ext = (const VkPresentIdKHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_PRESENT_ID_KHR;
-            out_ext->pNext = NULL;
-            out_ext->swapchainCount = in_ext->swapchainCount;
-            out_ext->pPresentIds = in_ext->pPresentIds;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
-        {
-            VkPresentRegionsKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkPresentRegionsKHR *in_ext = (const VkPresentRegionsKHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR;
-            out_ext->pNext = NULL;
-            out_ext->swapchainCount = in_ext->swapchainCount;
-            out_ext->pRegions = in_ext->pRegions;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR:
-        {
-            VkSwapchainPresentFenceInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkSwapchainPresentFenceInfoKHR *in_ext = (const VkSwapchainPresentFenceInfoKHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->swapchainCount = in_ext->swapchainCount;
-            out_ext->pFences = convert_VkFence_array_win64_to_host(ctx, in_ext->pFences, in_ext->swapchainCount);
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR:
-        {
-            VkSwapchainPresentModeInfoKHR *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));
-            const VkSwapchainPresentModeInfoKHR *in_ext = (const VkSwapchainPresentModeInfoKHR *)in_header;
-            out_ext->sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR;
-            out_ext->pNext = NULL;
-            out_ext->swapchainCount = in_ext->swapchainCount;
-            out_ext->pPresentModes = in_ext->pPresentModes;
-            out_header->pNext = (void *)out_ext;
-            out_header = (void *)out_ext;
-            break;
-        }
-        default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
-            break;
-        }
-    }
-}
-#endif /* _WIN64 */
-
-static const VkSemaphore *convert_VkSemaphore_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSemaphore *in, uint32_t count)
-{
-    VkSemaphore *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        out[i] = in[i];
-    }
-
-    return out;
-}
-
-static const VkSwapchainKHR *convert_VkSwapchainKHR_array_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSwapchainKHR *in, uint32_t count)
-{
-    VkSwapchainKHR *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        out[i] = in[i];
-    }
-
-    return out;
-}
-
 static void convert_VkPresentRegionKHR_win32_to_host(const VkPresentRegionKHR32 *in, VkPresentRegionKHR *out)
 {
     if (!in) return;
@@ -40231,22 +41280,6 @@ static const VkPresentRegionKHR *convert
     return out;
 }
 
-static const VkFence *convert_VkFence_array_win32_to_host(struct conversion_context *ctx, const VkFence *in, uint32_t count)
-{
-    VkFence *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        out[i] = vulkan_fence_from_handle(in[i])->host.fence;
-    }
-
-    return out;
-}
-
 static void convert_VkPresentInfoKHR_win32_to_unwrapped_host(struct conversion_context *ctx, const VkPresentInfoKHR32 *in, VkPresentInfoKHR *out)
 {
     const VkBaseInStructure32 *in_header;
@@ -40257,9 +41290,9 @@ static void convert_VkPresentInfoKHR_win
     out->sType = in->sType;
     out->pNext = NULL;
     out->waitSemaphoreCount = in->waitSemaphoreCount;
-    out->pWaitSemaphores = convert_VkSemaphore_array_win32_to_unwrapped_host(ctx, (const VkSemaphore *)UlongToPtr(in->pWaitSemaphores), in->waitSemaphoreCount);
+    out->pWaitSemaphores = UlongToPtr(in->pWaitSemaphores);
     out->swapchainCount = in->swapchainCount;
-    out->pSwapchains = convert_VkSwapchainKHR_array_win32_to_unwrapped_host(ctx, (const VkSwapchainKHR *)UlongToPtr(in->pSwapchains), in->swapchainCount);
+    out->pSwapchains = UlongToPtr(in->pSwapchains);
     out->pImageIndices = UlongToPtr(in->pImageIndices);
     out->pResults = UlongToPtr(in->pResults);
 
@@ -40354,7 +41387,7 @@ static void convert_VkPresentInfoKHR_win
             out_ext->sType = VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR;
             out_ext->pNext = NULL;
             out_ext->swapchainCount = in_ext->swapchainCount;
-            out_ext->pFences = convert_VkFence_array_win32_to_host(ctx, (const VkFence *)UlongToPtr(in_ext->pFences), in_ext->swapchainCount);
+            out_ext->pFences = UlongToPtr(in_ext->pFences);
             out_header->pNext = (void *)out_ext;
             out_header = (void *)out_ext;
             break;
@@ -40372,31 +41405,24 @@ static void convert_VkPresentInfoKHR_win
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
 }
 
 #ifdef _WIN64
-static const VkCommandBuffer *convert_VkCommandBuffer_array_win64_to_unwrapped_host(struct conversion_context *ctx, const VkCommandBuffer *in, uint32_t count)
-{
-    VkCommandBuffer *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        out[i] = in[i];
-    }
-
-    return out;
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
 static const VkDeviceMemory *convert_VkDeviceMemory_array_win64_to_host(struct conversion_context *ctx, const VkDeviceMemory *in, uint32_t count)
 {
     VkDeviceMemory *out;
@@ -40407,7 +41433,7 @@ static const VkDeviceMemory *convert_VkD
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        out[i] = vulkan_device_memory_from_handle(in[i])->host.device_memory;
+        out[i] = wine_device_memory_from_handle(in[i])->host.device_memory;
     }
 
     return out;
@@ -40425,12 +41451,12 @@ static void convert_VkSubmitInfo_win64_t
     out->sType = in->sType;
     out->pNext = NULL;
     out->waitSemaphoreCount = in->waitSemaphoreCount;
-    out->pWaitSemaphores = convert_VkSemaphore_array_win64_to_unwrapped_host(ctx, in->pWaitSemaphores, in->waitSemaphoreCount);
+    out->pWaitSemaphores = in->pWaitSemaphores;
     out->pWaitDstStageMask = in->pWaitDstStageMask;
     out->commandBufferCount = in->commandBufferCount;
-    out->pCommandBuffers = convert_VkCommandBuffer_array_win64_to_unwrapped_host(ctx, in->pCommandBuffers, in->commandBufferCount);
+    out->pCommandBuffers = in->pCommandBuffers;
     out->signalSemaphoreCount = in->signalSemaphoreCount;
-    out->pSignalSemaphores = convert_VkSemaphore_array_win64_to_unwrapped_host(ctx, in->pSignalSemaphores, in->signalSemaphoreCount);
+    out->pSignalSemaphores = in->pSignalSemaphores;
 
     for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
     {
@@ -40562,7 +41588,18 @@ static void convert_VkSubmitInfo_win64_t
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -40597,7 +41634,7 @@ static const VkDeviceMemory *convert_VkD
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        out[i] = vulkan_device_memory_from_handle(in[i])->host.device_memory;
+        out[i] = wine_device_memory_from_handle(in[i])->host.device_memory;
     }
 
     return out;
@@ -40613,12 +41650,12 @@ static void convert_VkSubmitInfo_win32_t
     out->sType = in->sType;
     out->pNext = NULL;
     out->waitSemaphoreCount = in->waitSemaphoreCount;
-    out->pWaitSemaphores = convert_VkSemaphore_array_win32_to_unwrapped_host(ctx, (const VkSemaphore *)UlongToPtr(in->pWaitSemaphores), in->waitSemaphoreCount);
+    out->pWaitSemaphores = UlongToPtr(in->pWaitSemaphores);
     out->pWaitDstStageMask = UlongToPtr(in->pWaitDstStageMask);
     out->commandBufferCount = in->commandBufferCount;
     out->pCommandBuffers = convert_VkCommandBuffer_array_win32_to_unwrapped_host(ctx, (const PTR32 *)UlongToPtr(in->pCommandBuffers), in->commandBufferCount);
     out->signalSemaphoreCount = in->signalSemaphoreCount;
-    out->pSignalSemaphores = convert_VkSemaphore_array_win32_to_unwrapped_host(ctx, (const VkSemaphore *)UlongToPtr(in->pSignalSemaphores), in->signalSemaphoreCount);
+    out->pSignalSemaphores = UlongToPtr(in->pSignalSemaphores);
 
     for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
     {
@@ -40750,7 +41787,18 @@ static void convert_VkSubmitInfo_win32_t
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -40773,45 +41821,13 @@ static const VkSubmitInfo *convert_VkSub
 }
 
 #ifdef _WIN64
-static void convert_VkSemaphoreSubmitInfo_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSemaphoreSubmitInfo *in, VkSemaphoreSubmitInfo *out)
-{
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = in->pNext;
-    out->semaphore = in->semaphore;
-    out->value = in->value;
-    out->stageMask = in->stageMask;
-    out->deviceIndex = in->deviceIndex;
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
-static const VkSemaphoreSubmitInfo *convert_VkSemaphoreSubmitInfo_array_win64_to_unwrapped_host(struct conversion_context *ctx, const VkSemaphoreSubmitInfo *in, uint32_t count)
-{
-    VkSemaphoreSubmitInfo *out;
-    unsigned int i;
-
-    if (!in || !count) return NULL;
-
-    out = conversion_context_alloc(ctx, count * sizeof(*out));
-    for (i = 0; i < count; i++)
-    {
-        convert_VkSemaphoreSubmitInfo_win64_to_unwrapped_host(ctx, &in[i], &out[i]);
-    }
-
-    return out;
-}
-#endif /* _WIN64 */
-
-#ifdef _WIN64
-static void convert_VkSemaphoreSubmitInfo_win64_to_host(struct conversion_context *ctx, const VkSemaphoreSubmitInfo *in, VkSemaphoreSubmitInfo *out)
+static void convert_VkSemaphoreSubmitInfo_win64_to_host(const VkSemaphoreSubmitInfo *in, VkSemaphoreSubmitInfo *out)
 {
     if (!in) return;
 
     out->sType = in->sType;
     out->pNext = in->pNext;
-    out->semaphore = vulkan_semaphore_from_handle(in->semaphore)->host.semaphore;
+    out->semaphore = in->semaphore ? vulkan_semaphore_from_handle(in->semaphore)->host.semaphore : VK_NULL_HANDLE;
     out->value = in->value;
     out->stageMask = in->stageMask;
     out->deviceIndex = in->deviceIndex;
@@ -40829,7 +41845,7 @@ static const VkSemaphoreSubmitInfo *conv
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        convert_VkSemaphoreSubmitInfo_win64_to_host(ctx, &in[i], &out[i]);
+        convert_VkSemaphoreSubmitInfo_win64_to_host(&in[i], &out[i]);
     }
 
     return out;
@@ -40866,7 +41882,18 @@ static void convert_VkCommandBufferSubmi
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -40903,11 +41930,11 @@ static void convert_VkSubmitInfo2_win64_
     out->pNext = NULL;
     out->flags = in->flags;
     out->waitSemaphoreInfoCount = in->waitSemaphoreInfoCount;
-    out->pWaitSemaphoreInfos = convert_VkSemaphoreSubmitInfo_array_win64_to_unwrapped_host(ctx, in->pWaitSemaphoreInfos, in->waitSemaphoreInfoCount);
+    out->pWaitSemaphoreInfos = in->pWaitSemaphoreInfos;
     out->commandBufferInfoCount = in->commandBufferInfoCount;
     out->pCommandBufferInfos = convert_VkCommandBufferSubmitInfo_array_win64_to_unwrapped_host(ctx, in->pCommandBufferInfos, in->commandBufferInfoCount);
     out->signalSemaphoreInfoCount = in->signalSemaphoreInfoCount;
-    out->pSignalSemaphoreInfos = convert_VkSemaphoreSubmitInfo_array_win64_to_unwrapped_host(ctx, in->pSignalSemaphoreInfos, in->signalSemaphoreInfoCount);
+    out->pSignalSemaphoreInfos = in->pSignalSemaphoreInfos;
 
     for (in_header = (void *)in->pNext; in_header; in_header = (void *)in_header->pNext)
     {
@@ -40984,7 +42011,18 @@ static void convert_VkSubmitInfo2_win64_
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -41009,7 +42047,7 @@ static const VkSubmitInfo2 *convert_VkSu
 }
 #endif /* _WIN64 */
 
-static void convert_VkSemaphoreSubmitInfo_win32_to_unwrapped_host(struct conversion_context *ctx, const VkSemaphoreSubmitInfo32 *in, VkSemaphoreSubmitInfo *out)
+static void convert_VkSemaphoreSubmitInfo_win32_to_unwrapped_host(const VkSemaphoreSubmitInfo32 *in, VkSemaphoreSubmitInfo *out)
 {
     if (!in) return;
 
@@ -41033,19 +42071,19 @@ static const VkSemaphoreSubmitInfo *conv
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        convert_VkSemaphoreSubmitInfo_win32_to_unwrapped_host(ctx, &in[i], &out[i]);
+        convert_VkSemaphoreSubmitInfo_win32_to_unwrapped_host(&in[i], &out[i]);
     }
 
     return out;
 }
 
-static void convert_VkSemaphoreSubmitInfo_win32_to_host(struct conversion_context *ctx, const VkSemaphoreSubmitInfo32 *in, VkSemaphoreSubmitInfo *out)
+static void convert_VkSemaphoreSubmitInfo_win32_to_host(const VkSemaphoreSubmitInfo32 *in, VkSemaphoreSubmitInfo *out)
 {
     if (!in) return;
 
     out->sType = in->sType;
     out->pNext = NULL;
-    out->semaphore = vulkan_semaphore_from_handle(in->semaphore)->host.semaphore;
+    out->semaphore = in->semaphore ? vulkan_semaphore_from_handle(in->semaphore)->host.semaphore : VK_NULL_HANDLE;
     out->value = in->value;
     out->stageMask = in->stageMask;
     out->deviceIndex = in->deviceIndex;
@@ -41063,7 +42101,7 @@ static const VkSemaphoreSubmitInfo *conv
     out = conversion_context_alloc(ctx, count * sizeof(*out));
     for (i = 0; i < count; i++)
     {
-        convert_VkSemaphoreSubmitInfo_win32_to_host(ctx, &in[i], &out[i]);
+        convert_VkSemaphoreSubmitInfo_win32_to_host(&in[i], &out[i]);
     }
 
     return out;
@@ -41078,7 +42116,7 @@ static void convert_VkCommandBufferSubmi
 
     out->sType = in->sType;
     out->pNext = NULL;
-    out->commandBuffer = (VkCommandBuffer)UlongToPtr(in->commandBuffer);
+    out->commandBuffer = in->commandBuffer ? (VkCommandBuffer)UlongToPtr(in->commandBuffer) : VK_NULL_HANDLE;
     out->deviceMask = in->deviceMask;
 
     for (in_header = UlongToPtr(in->pNext); in_header; in_header = UlongToPtr(in_header->pNext))
@@ -41098,7 +42136,18 @@ static void convert_VkCommandBufferSubmi
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -41212,7 +42261,18 @@ static void convert_VkSubmitInfo2_win32_
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -41252,7 +42312,7 @@ static void convert_VkReleaseSwapchainIm
 
     out->sType = in->sType;
     out->pNext = in->pNext;
-    out->swapchain = vulkan_swapchain_from_handle(in->swapchain)->host.swapchain;
+    out->swapchain = in->swapchain ? vulkan_swapchain_from_handle(in->swapchain)->host.swapchain : VK_NULL_HANDLE;
     out->imageIndexCount = in->imageIndexCount;
     out->pImageIndices = in->pImageIndices;
 }
@@ -41264,7 +42324,7 @@ static void convert_VkReleaseSwapchainIm
 
     out->sType = in->sType;
     out->pNext = NULL;
-    out->swapchain = vulkan_swapchain_from_handle(in->swapchain)->host.swapchain;
+    out->swapchain = in->swapchain ? vulkan_swapchain_from_handle(in->swapchain)->host.swapchain : VK_NULL_HANDLE;
     out->imageIndexCount = in->imageIndexCount;
     out->pImageIndices = UlongToPtr(in->pImageIndices);
     if (in->pNext)
@@ -41396,7 +42456,18 @@ static void convert_VkHdrMetadataEXT_win
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -41443,25 +42514,13 @@ static void convert_VkLatencySleepModeIn
         FIXME("Unexpected pNext\n");
 }
 
-#ifdef _WIN64
-static void convert_VkSemaphoreSignalInfo_win64_to_host(const VkSemaphoreSignalInfo *in, VkSemaphoreSignalInfo *out)
-{
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = in->pNext;
-    out->semaphore = vulkan_semaphore_from_handle(in->semaphore)->host.semaphore;
-    out->value = in->value;
-}
-#endif /* _WIN64 */
-
-static void convert_VkSemaphoreSignalInfo_win32_to_host(const VkSemaphoreSignalInfo32 *in, VkSemaphoreSignalInfo *out)
+static void convert_VkSemaphoreSignalInfo_win32_to_unwrapped_host(const VkSemaphoreSignalInfo32 *in, VkSemaphoreSignalInfo *out)
 {
     if (!in) return;
 
     out->sType = in->sType;
     out->pNext = NULL;
-    out->semaphore = vulkan_semaphore_from_handle(in->semaphore)->host.semaphore;
+    out->semaphore = in->semaphore;
     out->value = in->value;
     if (in->pNext)
         FIXME("Unexpected pNext\n");
@@ -41576,7 +42635,18 @@ static void convert_VkDebugUtilsMessenge
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -41620,7 +42690,7 @@ static void convert_VkMemoryUnmapInfo_wi
     out->sType = in->sType;
     out->pNext = in->pNext;
     out->flags = in->flags;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
 }
 #endif /* _WIN64 */
 
@@ -41631,7 +42701,7 @@ static void convert_VkMemoryUnmapInfo_wi
     out->sType = in->sType;
     out->pNext = NULL;
     out->flags = in->flags;
-    out->memory = vulkan_device_memory_from_handle(in->memory)->host.device_memory;
+    out->memory = in->memory ? wine_device_memory_from_handle(in->memory)->host.device_memory : VK_NULL_HANDLE;
     if (in->pNext)
         FIXME("Unexpected pNext\n");
 }
@@ -41781,7 +42851,18 @@ static void convert_VkVideoSessionParame
             break;
         }
         default:
-            FIXME("Unhandled sType %u.\n", in_header->sType);
+            if ((in_header->sType >> 16) == 0x7ead)
+            {
+                VkBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->pNext = NULL;
+                out_header->pNext = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled sType %u.\n", in_header->sType);
+            }
             break;
         }
     }
@@ -41799,21 +42880,7 @@ static void convert_VkPresentWait2InfoKH
         FIXME("Unexpected pNext\n");
 }
 
-#ifdef _WIN64
-static void convert_VkSemaphoreWaitInfo_win64_to_host(struct conversion_context *ctx, const VkSemaphoreWaitInfo *in, VkSemaphoreWaitInfo *out)
-{
-    if (!in) return;
-
-    out->sType = in->sType;
-    out->pNext = in->pNext;
-    out->flags = in->flags;
-    out->semaphoreCount = in->semaphoreCount;
-    out->pSemaphores = convert_VkSemaphore_array_win64_to_host(ctx, in->pSemaphores, in->semaphoreCount);
-    out->pValues = in->pValues;
-}
-#endif /* _WIN64 */
-
-static void convert_VkSemaphoreWaitInfo_win32_to_host(struct conversion_context *ctx, const VkSemaphoreWaitInfo32 *in, VkSemaphoreWaitInfo *out)
+static void convert_VkSemaphoreWaitInfo_win32_to_unwrapped_host(const VkSemaphoreWaitInfo32 *in, VkSemaphoreWaitInfo *out)
 {
     if (!in) return;
 
@@ -41821,7 +42888,7 @@ static void convert_VkSemaphoreWaitInfo_
     out->pNext = NULL;
     out->flags = in->flags;
     out->semaphoreCount = in->semaphoreCount;
-    out->pSemaphores = convert_VkSemaphore_array_win32_to_host(ctx, (const VkSemaphore *)UlongToPtr(in->pSemaphores), in->semaphoreCount);
+    out->pSemaphores = UlongToPtr(in->pSemaphores);
     out->pValues = UlongToPtr(in->pValues);
     if (in->pNext)
         FIXME("Unexpected pNext\n");
@@ -42029,7 +43096,7 @@ static NTSTATUS thunk64_vkAllocateMemory
 
     init_conversion_context(ctx);
     convert_VkMemoryAllocateInfo_win64_to_host(ctx, params->pAllocateInfo, &pAllocateInfo_host);
-    params->result = vk_funcs->p_vkAllocateMemory(params->device, &pAllocateInfo_host, params->pAllocator, params->pMemory);
+    params->result = wine_vkAllocateMemory(params->device, &pAllocateInfo_host, params->pAllocator, params->pMemory);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -42053,7 +43120,7 @@ static NTSTATUS thunk32_vkAllocateMemory
 
     init_conversion_context(ctx);
     convert_VkMemoryAllocateInfo_win32_to_host(ctx, (const VkMemoryAllocateInfo32 *)UlongToPtr(params->pAllocateInfo), &pAllocateInfo_host);
-    params->result = vk_funcs->p_vkAllocateMemory((VkDevice)UlongToPtr(params->device), &pAllocateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkDeviceMemory *)UlongToPtr(params->pMemory));
+    params->result = wine_vkAllocateMemory((VkDevice)UlongToPtr(params->device), &pAllocateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkDeviceMemory *)UlongToPtr(params->pMemory));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -42102,7 +43169,7 @@ static NTSTATUS thunk64_vkBeginCommandBu
 
     init_conversion_context(ctx);
     convert_VkCommandBufferBeginInfo_win64_to_host(ctx, params->pBeginInfo, &pBeginInfo_host);
-    params->result = vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkBeginCommandBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, &pBeginInfo_host);
+    params->result = wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkBeginCommandBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, &pBeginInfo_host);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -42124,7 +43191,7 @@ static NTSTATUS thunk32_vkBeginCommandBu
 
     init_conversion_context(ctx);
     convert_VkCommandBufferBeginInfo_win32_to_host(ctx, (const VkCommandBufferBeginInfo32 *)UlongToPtr(params->pBeginInfo), &pBeginInfo_host);
-    params->result = vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkBeginCommandBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBeginInfo_host);
+    params->result = wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkBeginCommandBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBeginInfo_host);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -42176,7 +43243,7 @@ static NTSTATUS thunk64_vkBindBufferMemo
 
     TRACE("%p, 0x%s, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->buffer), wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->memoryOffset));
 
-    params->result = vulkan_device_from_handle(params->device)->p_vkBindBufferMemory(vulkan_device_from_handle(params->device)->host.device, params->buffer, vulkan_device_memory_from_handle(params->memory)->host.device_memory, params->memoryOffset);
+    params->result = vulkan_device_from_handle(params->device)->p_vkBindBufferMemory(vulkan_device_from_handle(params->device)->host.device, params->buffer, wine_device_memory_from_handle(params->memory)->host.device_memory, params->memoryOffset);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -42194,7 +43261,7 @@ static NTSTATUS thunk32_vkBindBufferMemo
 
     TRACE("%#x, 0x%s, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->buffer), wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->memoryOffset));
 
-    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkBindBufferMemory(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->buffer, vulkan_device_memory_from_handle(params->memory)->host.device_memory, params->memoryOffset);
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkBindBufferMemory(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->buffer, wine_device_memory_from_handle(params->memory)->host.device_memory, params->memoryOffset);
     return STATUS_SUCCESS;
 }
 
@@ -42325,7 +43392,7 @@ static NTSTATUS thunk64_vkBindImageMemor
 
     TRACE("%p, 0x%s, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->image), wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->memoryOffset));
 
-    params->result = vulkan_device_from_handle(params->device)->p_vkBindImageMemory(vulkan_device_from_handle(params->device)->host.device, params->image, vulkan_device_memory_from_handle(params->memory)->host.device_memory, params->memoryOffset);
+    params->result = vulkan_device_from_handle(params->device)->p_vkBindImageMemory(vulkan_device_from_handle(params->device)->host.device, params->image, wine_device_memory_from_handle(params->memory)->host.device_memory, params->memoryOffset);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -42343,7 +43410,7 @@ static NTSTATUS thunk32_vkBindImageMemor
 
     TRACE("%#x, 0x%s, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->image), wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->memoryOffset));
 
-    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkBindImageMemory(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->image, vulkan_device_memory_from_handle(params->memory)->host.device_memory, params->memoryOffset);
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkBindImageMemory(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->image, wine_device_memory_from_handle(params->memory)->host.device_memory, params->memoryOffset);
     return STATUS_SUCCESS;
 }
 
@@ -42624,7 +43691,7 @@ static void thunk64_vkCmdBeginConditiona
 {
     struct vkCmdBeginConditionalRenderingEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginConditionalRenderingEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pConditionalRenderingBegin);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginConditionalRenderingEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pConditionalRenderingBegin);
 }
 #endif /* _WIN64 */
 
@@ -42638,7 +43705,7 @@ static void thunk32_vkCmdBeginConditiona
     VkConditionalRenderingBeginInfoEXT pConditionalRenderingBegin_host;
 
     convert_VkConditionalRenderingBeginInfoEXT_win32_to_host((const VkConditionalRenderingBeginInfoEXT32 *)UlongToPtr(params->pConditionalRenderingBegin), &pConditionalRenderingBegin_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginConditionalRenderingEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pConditionalRenderingBegin_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginConditionalRenderingEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pConditionalRenderingBegin_host);
 }
 
 #ifdef _WIN64
@@ -42646,7 +43713,7 @@ static void thunk64_vkCmdBeginDebugUtils
 {
     struct vkCmdBeginDebugUtilsLabelEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginDebugUtilsLabelEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLabelInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginDebugUtilsLabelEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLabelInfo);
 }
 #endif /* _WIN64 */
 
@@ -42660,7 +43727,7 @@ static void thunk32_vkCmdBeginDebugUtils
     VkDebugUtilsLabelEXT pLabelInfo_host;
 
     convert_VkDebugUtilsLabelEXT_win32_to_host((const VkDebugUtilsLabelEXT32 *)UlongToPtr(params->pLabelInfo), &pLabelInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginDebugUtilsLabelEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLabelInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginDebugUtilsLabelEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLabelInfo_host);
 }
 
 #ifdef _WIN64
@@ -42668,7 +43735,7 @@ static void thunk64_vkCmdBeginPerTileExe
 {
     struct vkCmdBeginPerTileExecutionQCOM_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginPerTileExecutionQCOM(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPerTileBeginInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginPerTileExecutionQCOM(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPerTileBeginInfo);
 }
 #endif /* _WIN64 */
 
@@ -42682,7 +43749,7 @@ static void thunk32_vkCmdBeginPerTileExe
     VkPerTileBeginInfoQCOM pPerTileBeginInfo_host;
 
     convert_VkPerTileBeginInfoQCOM_win32_to_host((const VkPerTileBeginInfoQCOM32 *)UlongToPtr(params->pPerTileBeginInfo), &pPerTileBeginInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginPerTileExecutionQCOM(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPerTileBeginInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginPerTileExecutionQCOM(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPerTileBeginInfo_host);
 }
 
 #ifdef _WIN64
@@ -42690,7 +43757,7 @@ static void thunk64_vkCmdBeginQuery(void
 {
     struct vkCmdBeginQuery_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginQuery(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->query, params->flags);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginQuery(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->query, params->flags);
 }
 #endif /* _WIN64 */
 
@@ -42704,7 +43771,7 @@ static void thunk32_vkCmdBeginQuery(void
         VkQueryControlFlags flags;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginQuery(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->query, params->flags);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginQuery(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->query, params->flags);
 }
 
 #ifdef _WIN64
@@ -42712,7 +43779,7 @@ static void thunk64_vkCmdBeginQueryIndex
 {
     struct vkCmdBeginQueryIndexedEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginQueryIndexedEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->query, params->flags, params->index);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginQueryIndexedEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->query, params->flags, params->index);
 }
 #endif /* _WIN64 */
 
@@ -42727,7 +43794,7 @@ static void thunk32_vkCmdBeginQueryIndex
         uint32_t index;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginQueryIndexedEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->query, params->flags, params->index);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginQueryIndexedEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->query, params->flags, params->index);
 }
 
 #ifdef _WIN64
@@ -42735,7 +43802,7 @@ static void thunk64_vkCmdBeginRenderPass
 {
     struct vkCmdBeginRenderPass_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRenderPass(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderPassBegin, params->contents);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRenderPass(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderPassBegin, params->contents);
 }
 #endif /* _WIN64 */
 
@@ -42753,7 +43820,7 @@ static void thunk32_vkCmdBeginRenderPass
 
     init_conversion_context(ctx);
     convert_VkRenderPassBeginInfo_win32_to_host(ctx, (const VkRenderPassBeginInfo32 *)UlongToPtr(params->pRenderPassBegin), &pRenderPassBegin_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRenderPass(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderPassBegin_host, params->contents);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRenderPass(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderPassBegin_host, params->contents);
     free_conversion_context(ctx);
 }
 
@@ -42762,7 +43829,7 @@ static void thunk64_vkCmdBeginRenderPass
 {
     struct vkCmdBeginRenderPass2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRenderPass2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderPassBegin, params->pSubpassBeginInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRenderPass2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderPassBegin, params->pSubpassBeginInfo);
 }
 #endif /* _WIN64 */
 
@@ -42782,7 +43849,7 @@ static void thunk32_vkCmdBeginRenderPass
     init_conversion_context(ctx);
     convert_VkRenderPassBeginInfo_win32_to_host(ctx, (const VkRenderPassBeginInfo32 *)UlongToPtr(params->pRenderPassBegin), &pRenderPassBegin_host);
     convert_VkSubpassBeginInfo_win32_to_host((const VkSubpassBeginInfo32 *)UlongToPtr(params->pSubpassBeginInfo), &pSubpassBeginInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRenderPass2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderPassBegin_host, &pSubpassBeginInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRenderPass2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderPassBegin_host, &pSubpassBeginInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -42791,7 +43858,7 @@ static void thunk64_vkCmdBeginRenderPass
 {
     struct vkCmdBeginRenderPass2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRenderPass2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderPassBegin, params->pSubpassBeginInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRenderPass2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderPassBegin, params->pSubpassBeginInfo);
 }
 #endif /* _WIN64 */
 
@@ -42811,7 +43878,7 @@ static void thunk32_vkCmdBeginRenderPass
     init_conversion_context(ctx);
     convert_VkRenderPassBeginInfo_win32_to_host(ctx, (const VkRenderPassBeginInfo32 *)UlongToPtr(params->pRenderPassBegin), &pRenderPassBegin_host);
     convert_VkSubpassBeginInfo_win32_to_host((const VkSubpassBeginInfo32 *)UlongToPtr(params->pSubpassBeginInfo), &pSubpassBeginInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRenderPass2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderPassBegin_host, &pSubpassBeginInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRenderPass2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderPassBegin_host, &pSubpassBeginInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -42820,7 +43887,7 @@ static void thunk64_vkCmdBeginRendering(
 {
     struct vkCmdBeginRendering_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRendering(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderingInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRendering(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderingInfo);
 }
 #endif /* _WIN64 */
 
@@ -42837,7 +43904,7 @@ static void thunk32_vkCmdBeginRendering(
 
     init_conversion_context(ctx);
     convert_VkRenderingInfo_win32_to_host(ctx, (const VkRenderingInfo32 *)UlongToPtr(params->pRenderingInfo), &pRenderingInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRendering(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderingInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRendering(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderingInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -42846,7 +43913,7 @@ static void thunk64_vkCmdBeginRenderingK
 {
     struct vkCmdBeginRenderingKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRenderingKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderingInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginRenderingKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderingInfo);
 }
 #endif /* _WIN64 */
 
@@ -42863,7 +43930,7 @@ static void thunk32_vkCmdBeginRenderingK
 
     init_conversion_context(ctx);
     convert_VkRenderingInfo_win32_to_host(ctx, (const VkRenderingInfo32 *)UlongToPtr(params->pRenderingInfo), &pRenderingInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRenderingKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderingInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginRenderingKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRenderingInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -42872,7 +43939,7 @@ static void thunk64_vkCmdBeginTransformF
 {
     struct vkCmdBeginTransformFeedbackEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginTransformFeedbackEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstCounterBuffer, params->counterBufferCount, params->pCounterBuffers, params->pCounterBufferOffsets);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginTransformFeedbackEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstCounterBuffer, params->counterBufferCount, params->pCounterBuffers, params->pCounterBufferOffsets);
 }
 #endif /* _WIN64 */
 
@@ -42887,7 +43954,7 @@ static void thunk32_vkCmdBeginTransformF
         PTR32 pCounterBufferOffsets;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginTransformFeedbackEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstCounterBuffer, params->counterBufferCount, (const VkBuffer *)UlongToPtr(params->pCounterBuffers), (const VkDeviceSize *)UlongToPtr(params->pCounterBufferOffsets));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginTransformFeedbackEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstCounterBuffer, params->counterBufferCount, (const VkBuffer *)UlongToPtr(params->pCounterBuffers), (const VkDeviceSize *)UlongToPtr(params->pCounterBufferOffsets));
 }
 
 #ifdef _WIN64
@@ -42895,7 +43962,7 @@ static void thunk64_vkCmdBeginVideoCodin
 {
     struct vkCmdBeginVideoCodingKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginVideoCodingKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBeginInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBeginVideoCodingKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBeginInfo);
 }
 #endif /* _WIN64 */
 
@@ -42912,7 +43979,7 @@ static void thunk32_vkCmdBeginVideoCodin
 
     init_conversion_context(ctx);
     convert_VkVideoBeginCodingInfoKHR_win32_to_host(ctx, (const VkVideoBeginCodingInfoKHR32 *)UlongToPtr(params->pBeginInfo), &pBeginInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginVideoCodingKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBeginInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBeginVideoCodingKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBeginInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -42921,7 +43988,7 @@ static void thunk64_vkCmdBindDescriptorB
 {
     struct vkCmdBindDescriptorBufferEmbeddedSamplers2EXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBindDescriptorBufferEmbeddedSamplersInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBindDescriptorBufferEmbeddedSamplersInfo);
 }
 #endif /* _WIN64 */
 
@@ -42938,7 +44005,7 @@ static void thunk32_vkCmdBindDescriptorB
 
     init_conversion_context(ctx);
     convert_VkBindDescriptorBufferEmbeddedSamplersInfoEXT_win32_to_host(ctx, (const VkBindDescriptorBufferEmbeddedSamplersInfoEXT32 *)UlongToPtr(params->pBindDescriptorBufferEmbeddedSamplersInfo), &pBindDescriptorBufferEmbeddedSamplersInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBindDescriptorBufferEmbeddedSamplersInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBindDescriptorBufferEmbeddedSamplersInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -42947,7 +44014,7 @@ static void thunk64_vkCmdBindDescriptorB
 {
     struct vkCmdBindDescriptorBufferEmbeddedSamplersEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->set);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->set);
 }
 #endif /* _WIN64 */
 
@@ -42961,7 +44028,7 @@ static void thunk32_vkCmdBindDescriptorB
         uint32_t set;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->set);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorBufferEmbeddedSamplersEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->set);
 }
 
 #ifdef _WIN64
@@ -42969,7 +44036,7 @@ static void thunk64_vkCmdBindDescriptorB
 {
     struct vkCmdBindDescriptorBuffersEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorBuffersEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->bufferCount, params->pBindingInfos);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorBuffersEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->bufferCount, params->pBindingInfos);
 }
 #endif /* _WIN64 */
 
@@ -42987,7 +44054,7 @@ static void thunk32_vkCmdBindDescriptorB
 
     init_conversion_context(ctx);
     pBindingInfos_host = convert_VkDescriptorBufferBindingInfoEXT_array_win32_to_host(ctx, (const VkDescriptorBufferBindingInfoEXT32 *)UlongToPtr(params->pBindingInfos), params->bufferCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorBuffersEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->bufferCount, pBindingInfos_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorBuffersEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->bufferCount, pBindingInfos_host);
     free_conversion_context(ctx);
 }
 
@@ -42996,7 +44063,7 @@ static void thunk64_vkCmdBindDescriptorS
 {
     struct vkCmdBindDescriptorSets_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorSets(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->descriptorSetCount, params->pDescriptorSets, params->dynamicOffsetCount, params->pDynamicOffsets);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorSets(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->descriptorSetCount, params->pDescriptorSets, params->dynamicOffsetCount, params->pDynamicOffsets);
 }
 #endif /* _WIN64 */
 
@@ -43014,7 +44081,7 @@ static void thunk32_vkCmdBindDescriptorS
         PTR32 pDynamicOffsets;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorSets(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->descriptorSetCount, (const VkDescriptorSet *)UlongToPtr(params->pDescriptorSets), params->dynamicOffsetCount, (const uint32_t *)UlongToPtr(params->pDynamicOffsets));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorSets(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->descriptorSetCount, (const VkDescriptorSet *)UlongToPtr(params->pDescriptorSets), params->dynamicOffsetCount, (const uint32_t *)UlongToPtr(params->pDynamicOffsets));
 }
 
 #ifdef _WIN64
@@ -43022,7 +44089,7 @@ static void thunk64_vkCmdBindDescriptorS
 {
     struct vkCmdBindDescriptorSets2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorSets2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBindDescriptorSetsInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorSets2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBindDescriptorSetsInfo);
 }
 #endif /* _WIN64 */
 
@@ -43039,7 +44106,7 @@ static void thunk32_vkCmdBindDescriptorS
 
     init_conversion_context(ctx);
     convert_VkBindDescriptorSetsInfo_win32_to_host(ctx, (const VkBindDescriptorSetsInfo32 *)UlongToPtr(params->pBindDescriptorSetsInfo), &pBindDescriptorSetsInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorSets2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBindDescriptorSetsInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorSets2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBindDescriptorSetsInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -43048,7 +44115,7 @@ static void thunk64_vkCmdBindDescriptorS
 {
     struct vkCmdBindDescriptorSets2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorSets2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBindDescriptorSetsInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindDescriptorSets2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBindDescriptorSetsInfo);
 }
 #endif /* _WIN64 */
 
@@ -43065,7 +44132,7 @@ static void thunk32_vkCmdBindDescriptorS
 
     init_conversion_context(ctx);
     convert_VkBindDescriptorSetsInfo_win32_to_host(ctx, (const VkBindDescriptorSetsInfo32 *)UlongToPtr(params->pBindDescriptorSetsInfo), &pBindDescriptorSetsInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorSets2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBindDescriptorSetsInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindDescriptorSets2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBindDescriptorSetsInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -43074,7 +44141,7 @@ static void thunk64_vkCmdBindIndexBuffer
 {
     struct vkCmdBindIndexBuffer_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindIndexBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->indexType);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindIndexBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->indexType);
 }
 #endif /* _WIN64 */
 
@@ -43088,7 +44155,7 @@ static void thunk32_vkCmdBindIndexBuffer
         VkIndexType indexType;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindIndexBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->indexType);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindIndexBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->indexType);
 }
 
 #ifdef _WIN64
@@ -43096,7 +44163,7 @@ static void thunk64_vkCmdBindIndexBuffer
 {
     struct vkCmdBindIndexBuffer2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindIndexBuffer2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->size, params->indexType);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindIndexBuffer2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->size, params->indexType);
 }
 #endif /* _WIN64 */
 
@@ -43111,7 +44178,7 @@ static void thunk32_vkCmdBindIndexBuffer
         VkIndexType indexType;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindIndexBuffer2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->size, params->indexType);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindIndexBuffer2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->size, params->indexType);
 }
 
 #ifdef _WIN64
@@ -43119,7 +44186,7 @@ static void thunk64_vkCmdBindIndexBuffer
 {
     struct vkCmdBindIndexBuffer2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindIndexBuffer2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->size, params->indexType);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindIndexBuffer2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->size, params->indexType);
 }
 #endif /* _WIN64 */
 
@@ -43134,7 +44201,7 @@ static void thunk32_vkCmdBindIndexBuffer
         VkIndexType indexType;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindIndexBuffer2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->size, params->indexType);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindIndexBuffer2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->size, params->indexType);
 }
 
 #ifdef _WIN64
@@ -43142,7 +44209,7 @@ static void thunk64_vkCmdBindInvocationM
 {
     struct vkCmdBindInvocationMaskHUAWEI_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindInvocationMaskHUAWEI(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->imageView, params->imageLayout);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindInvocationMaskHUAWEI(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->imageView, params->imageLayout);
 }
 #endif /* _WIN64 */
 
@@ -43155,7 +44222,7 @@ static void thunk32_vkCmdBindInvocationM
         VkImageLayout imageLayout;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindInvocationMaskHUAWEI(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->imageView, params->imageLayout);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindInvocationMaskHUAWEI(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->imageView, params->imageLayout);
 }
 
 #ifdef _WIN64
@@ -43163,7 +44230,7 @@ static void thunk64_vkCmdBindPipeline(vo
 {
     struct vkCmdBindPipeline_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindPipeline(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->pipeline);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindPipeline(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->pipeline);
 }
 #endif /* _WIN64 */
 
@@ -43176,7 +44243,7 @@ static void thunk32_vkCmdBindPipeline(vo
         VkPipeline DECLSPEC_ALIGN(8) pipeline;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindPipeline(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->pipeline);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindPipeline(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->pipeline);
 }
 
 #ifdef _WIN64
@@ -43184,7 +44251,7 @@ static void thunk64_vkCmdBindPipelineSha
 {
     struct vkCmdBindPipelineShaderGroupNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindPipelineShaderGroupNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->pipeline, params->groupIndex);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindPipelineShaderGroupNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->pipeline, params->groupIndex);
 }
 #endif /* _WIN64 */
 
@@ -43198,7 +44265,7 @@ static void thunk32_vkCmdBindPipelineSha
         uint32_t groupIndex;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindPipelineShaderGroupNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->pipeline, params->groupIndex);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindPipelineShaderGroupNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->pipeline, params->groupIndex);
 }
 
 #ifdef _WIN64
@@ -43206,7 +44273,7 @@ static void thunk64_vkCmdBindShadersEXT(
 {
     struct vkCmdBindShadersEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindShadersEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stageCount, params->pStages, params->pShaders);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindShadersEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stageCount, params->pStages, params->pShaders);
 }
 #endif /* _WIN64 */
 
@@ -43220,7 +44287,7 @@ static void thunk32_vkCmdBindShadersEXT(
         PTR32 pShaders;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindShadersEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stageCount, (const VkShaderStageFlagBits *)UlongToPtr(params->pStages), (const VkShaderEXT *)UlongToPtr(params->pShaders));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindShadersEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stageCount, (const VkShaderStageFlagBits *)UlongToPtr(params->pStages), (const VkShaderEXT *)UlongToPtr(params->pShaders));
 }
 
 #ifdef _WIN64
@@ -43228,7 +44295,7 @@ static void thunk64_vkCmdBindShadingRate
 {
     struct vkCmdBindShadingRateImageNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindShadingRateImageNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->imageView, params->imageLayout);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindShadingRateImageNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->imageView, params->imageLayout);
 }
 #endif /* _WIN64 */
 
@@ -43241,7 +44308,7 @@ static void thunk32_vkCmdBindShadingRate
         VkImageLayout imageLayout;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindShadingRateImageNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->imageView, params->imageLayout);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindShadingRateImageNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->imageView, params->imageLayout);
 }
 
 #ifdef _WIN64
@@ -43258,7 +44325,7 @@ static void thunk64_vkCmdBindTileMemoryQ
         pTileMemoryBindInfo_host = conversion_context_alloc(ctx, sizeof(*pTileMemoryBindInfo_host));
         convert_VkTileMemoryBindInfoQCOM_win64_to_host(params->pTileMemoryBindInfo, pTileMemoryBindInfo_host);
     }
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindTileMemoryQCOM(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, pTileMemoryBindInfo_host);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindTileMemoryQCOM(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, pTileMemoryBindInfo_host);
     free_conversion_context(ctx);
 }
 #endif /* _WIN64 */
@@ -43280,7 +44347,7 @@ static void thunk32_vkCmdBindTileMemoryQ
         pTileMemoryBindInfo_host = conversion_context_alloc(ctx, sizeof(*pTileMemoryBindInfo_host));
         convert_VkTileMemoryBindInfoQCOM_win32_to_host((const VkTileMemoryBindInfoQCOM32 *)UlongToPtr(params->pTileMemoryBindInfo), pTileMemoryBindInfo_host);
     }
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindTileMemoryQCOM(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, pTileMemoryBindInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindTileMemoryQCOM(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, pTileMemoryBindInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -43289,7 +44356,7 @@ static void thunk64_vkCmdBindTransformFe
 {
     struct vkCmdBindTransformFeedbackBuffersEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindTransformFeedbackBuffersEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets, params->pSizes);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindTransformFeedbackBuffersEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets, params->pSizes);
 }
 #endif /* _WIN64 */
 
@@ -43305,7 +44372,7 @@ static void thunk32_vkCmdBindTransformFe
         PTR32 pSizes;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindTransformFeedbackBuffersEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets), (const VkDeviceSize *)UlongToPtr(params->pSizes));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindTransformFeedbackBuffersEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets), (const VkDeviceSize *)UlongToPtr(params->pSizes));
 }
 
 #ifdef _WIN64
@@ -43313,7 +44380,7 @@ static void thunk64_vkCmdBindVertexBuffe
 {
     struct vkCmdBindVertexBuffers_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindVertexBuffers(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindVertexBuffers(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets);
 }
 #endif /* _WIN64 */
 
@@ -43328,7 +44395,7 @@ static void thunk32_vkCmdBindVertexBuffe
         PTR32 pOffsets;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindVertexBuffers(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindVertexBuffers(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets));
 }
 
 #ifdef _WIN64
@@ -43336,7 +44403,7 @@ static void thunk64_vkCmdBindVertexBuffe
 {
     struct vkCmdBindVertexBuffers2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindVertexBuffers2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets, params->pSizes, params->pStrides);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindVertexBuffers2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets, params->pSizes, params->pStrides);
 }
 #endif /* _WIN64 */
 
@@ -43353,7 +44420,7 @@ static void thunk32_vkCmdBindVertexBuffe
         PTR32 pStrides;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindVertexBuffers2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets), (const VkDeviceSize *)UlongToPtr(params->pSizes), (const VkDeviceSize *)UlongToPtr(params->pStrides));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindVertexBuffers2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets), (const VkDeviceSize *)UlongToPtr(params->pSizes), (const VkDeviceSize *)UlongToPtr(params->pStrides));
 }
 
 #ifdef _WIN64
@@ -43361,7 +44428,7 @@ static void thunk64_vkCmdBindVertexBuffe
 {
     struct vkCmdBindVertexBuffers2EXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindVertexBuffers2EXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets, params->pSizes, params->pStrides);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBindVertexBuffers2EXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstBinding, params->bindingCount, params->pBuffers, params->pOffsets, params->pSizes, params->pStrides);
 }
 #endif /* _WIN64 */
 
@@ -43378,7 +44445,7 @@ static void thunk32_vkCmdBindVertexBuffe
         PTR32 pStrides;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindVertexBuffers2EXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets), (const VkDeviceSize *)UlongToPtr(params->pSizes), (const VkDeviceSize *)UlongToPtr(params->pStrides));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBindVertexBuffers2EXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstBinding, params->bindingCount, (const VkBuffer *)UlongToPtr(params->pBuffers), (const VkDeviceSize *)UlongToPtr(params->pOffsets), (const VkDeviceSize *)UlongToPtr(params->pSizes), (const VkDeviceSize *)UlongToPtr(params->pStrides));
 }
 
 #ifdef _WIN64
@@ -43386,7 +44453,7 @@ static void thunk64_vkCmdBlitImage(void
 {
     struct vkCmdBlitImage_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBlitImage(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions, params->filter);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBlitImage(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions, params->filter);
 }
 #endif /* _WIN64 */
 
@@ -43404,7 +44471,7 @@ static void thunk32_vkCmdBlitImage(void
         VkFilter filter;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBlitImage(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, (const VkImageBlit *)UlongToPtr(params->pRegions), params->filter);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBlitImage(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, (const VkImageBlit *)UlongToPtr(params->pRegions), params->filter);
 }
 
 #ifdef _WIN64
@@ -43412,7 +44479,7 @@ static void thunk64_vkCmdBlitImage2(void
 {
     struct vkCmdBlitImage2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBlitImage2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBlitImageInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBlitImage2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBlitImageInfo);
 }
 #endif /* _WIN64 */
 
@@ -43429,7 +44496,7 @@ static void thunk32_vkCmdBlitImage2(void
 
     init_conversion_context(ctx);
     convert_VkBlitImageInfo2_win32_to_host(ctx, (const VkBlitImageInfo232 *)UlongToPtr(params->pBlitImageInfo), &pBlitImageInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBlitImage2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBlitImageInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBlitImage2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBlitImageInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -43438,7 +44505,7 @@ static void thunk64_vkCmdBlitImage2KHR(v
 {
     struct vkCmdBlitImage2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBlitImage2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBlitImageInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBlitImage2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBlitImageInfo);
 }
 #endif /* _WIN64 */
 
@@ -43455,7 +44522,7 @@ static void thunk32_vkCmdBlitImage2KHR(v
 
     init_conversion_context(ctx);
     convert_VkBlitImageInfo2_win32_to_host(ctx, (const VkBlitImageInfo232 *)UlongToPtr(params->pBlitImageInfo), &pBlitImageInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBlitImage2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBlitImageInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBlitImage2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBlitImageInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -43464,7 +44531,7 @@ static void thunk64_vkCmdBuildAccelerati
 {
     struct vkCmdBuildAccelerationStructureNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildAccelerationStructureNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo, params->instanceData, params->instanceOffset, params->update, params->dst, params->src, params->scratch, params->scratchOffset);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildAccelerationStructureNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo, params->instanceData, params->instanceOffset, params->update, params->dst, params->src, params->scratch, params->scratchOffset);
 }
 #endif /* _WIN64 */
 
@@ -43488,7 +44555,7 @@ static void thunk32_vkCmdBuildAccelerati
 
     init_conversion_context(ctx);
     convert_VkAccelerationStructureInfoNV_win32_to_host(ctx, (const VkAccelerationStructureInfoNV32 *)UlongToPtr(params->pInfo), &pInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildAccelerationStructureNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host, params->instanceData, params->instanceOffset, params->update, params->dst, params->src, params->scratch, params->scratchOffset);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildAccelerationStructureNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host, params->instanceData, params->instanceOffset, params->update, params->dst, params->src, params->scratch, params->scratchOffset);
     free_conversion_context(ctx);
 }
 
@@ -43497,7 +44564,7 @@ static void thunk64_vkCmdBuildAccelerati
 {
     struct vkCmdBuildAccelerationStructuresIndirectKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildAccelerationStructuresIndirectKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->infoCount, params->pInfos, params->pIndirectDeviceAddresses, params->pIndirectStrides, params->ppMaxPrimitiveCounts);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildAccelerationStructuresIndirectKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->infoCount, params->pInfos, params->pIndirectDeviceAddresses, params->pIndirectStrides, params->ppMaxPrimitiveCounts);
 }
 #endif /* _WIN64 */
 
@@ -43520,7 +44587,7 @@ static void thunk32_vkCmdBuildAccelerati
     init_conversion_context(ctx);
     pInfos_host = convert_VkAccelerationStructureBuildGeometryInfoKHR_array_win32_to_host(ctx, (const VkAccelerationStructureBuildGeometryInfoKHR32 *)UlongToPtr(params->pInfos), params->infoCount);
     ppMaxPrimitiveCounts_host = convert_uint32_t_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(params->ppMaxPrimitiveCounts), params->infoCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildAccelerationStructuresIndirectKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->infoCount, pInfos_host, (const VkDeviceAddress *)UlongToPtr(params->pIndirectDeviceAddresses), (const uint32_t *)UlongToPtr(params->pIndirectStrides), ppMaxPrimitiveCounts_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildAccelerationStructuresIndirectKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->infoCount, pInfos_host, (const VkDeviceAddress *)UlongToPtr(params->pIndirectDeviceAddresses), (const uint32_t *)UlongToPtr(params->pIndirectStrides), ppMaxPrimitiveCounts_host);
     convert_uint32_t_array_host_to_win32(ppMaxPrimitiveCounts_host, (PTR32 *)UlongToPtr(params->ppMaxPrimitiveCounts), params->infoCount);
     free_conversion_context(ctx);
 }
@@ -43530,7 +44597,7 @@ static void thunk64_vkCmdBuildAccelerati
 {
     struct vkCmdBuildAccelerationStructuresKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildAccelerationStructuresKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->infoCount, params->pInfos, params->ppBuildRangeInfos);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildAccelerationStructuresKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->infoCount, params->pInfos, params->ppBuildRangeInfos);
 }
 #endif /* _WIN64 */
 
@@ -43551,7 +44618,7 @@ static void thunk32_vkCmdBuildAccelerati
     init_conversion_context(ctx);
     pInfos_host = convert_VkAccelerationStructureBuildGeometryInfoKHR_array_win32_to_host(ctx, (const VkAccelerationStructureBuildGeometryInfoKHR32 *)UlongToPtr(params->pInfos), params->infoCount);
     ppBuildRangeInfos_host = convert_VkAccelerationStructureBuildRangeInfoKHR_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(params->ppBuildRangeInfos), params->infoCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildAccelerationStructuresKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->infoCount, pInfos_host, ppBuildRangeInfos_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildAccelerationStructuresKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->infoCount, pInfos_host, ppBuildRangeInfos_host);
     free_conversion_context(ctx);
 }
 
@@ -43560,7 +44627,7 @@ static void thunk64_vkCmdBuildClusterAcc
 {
     struct vkCmdBuildClusterAccelerationStructureIndirectNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildClusterAccelerationStructureIndirectNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCommandInfos);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildClusterAccelerationStructureIndirectNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCommandInfos);
 }
 #endif /* _WIN64 */
 
@@ -43577,7 +44644,7 @@ static void thunk32_vkCmdBuildClusterAcc
 
     init_conversion_context(ctx);
     convert_VkClusterAccelerationStructureCommandsInfoNV_win32_to_host(ctx, (const VkClusterAccelerationStructureCommandsInfoNV32 *)UlongToPtr(params->pCommandInfos), &pCommandInfos_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildClusterAccelerationStructureIndirectNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCommandInfos_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildClusterAccelerationStructureIndirectNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCommandInfos_host);
     free_conversion_context(ctx);
 }
 
@@ -43586,7 +44653,7 @@ static void thunk64_vkCmdBuildMicromapsE
 {
     struct vkCmdBuildMicromapsEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildMicromapsEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->infoCount, params->pInfos);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildMicromapsEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->infoCount, params->pInfos);
 }
 #endif /* _WIN64 */
 
@@ -43604,7 +44671,7 @@ static void thunk32_vkCmdBuildMicromapsE
 
     init_conversion_context(ctx);
     pInfos_host = convert_VkMicromapBuildInfoEXT_array_win32_to_host(ctx, (const VkMicromapBuildInfoEXT32 *)UlongToPtr(params->pInfos), params->infoCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildMicromapsEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->infoCount, pInfos_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildMicromapsEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->infoCount, pInfos_host);
     free_conversion_context(ctx);
 }
 
@@ -43613,7 +44680,7 @@ static void thunk64_vkCmdBuildPartitione
 {
     struct vkCmdBuildPartitionedAccelerationStructuresNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildPartitionedAccelerationStructuresNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBuildInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdBuildPartitionedAccelerationStructuresNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pBuildInfo);
 }
 #endif /* _WIN64 */
 
@@ -43630,7 +44697,7 @@ static void thunk32_vkCmdBuildPartitione
 
     init_conversion_context(ctx);
     convert_VkBuildPartitionedAccelerationStructureInfoNV_win32_to_host(ctx, (const VkBuildPartitionedAccelerationStructureInfoNV32 *)UlongToPtr(params->pBuildInfo), &pBuildInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildPartitionedAccelerationStructuresNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBuildInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdBuildPartitionedAccelerationStructuresNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pBuildInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -43639,7 +44706,7 @@ static void thunk64_vkCmdClearAttachment
 {
     struct vkCmdClearAttachments_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdClearAttachments(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->attachmentCount, params->pAttachments, params->rectCount, params->pRects);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdClearAttachments(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->attachmentCount, params->pAttachments, params->rectCount, params->pRects);
 }
 #endif /* _WIN64 */
 
@@ -43654,7 +44721,7 @@ static void thunk32_vkCmdClearAttachment
         PTR32 pRects;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdClearAttachments(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->attachmentCount, (const VkClearAttachment *)UlongToPtr(params->pAttachments), params->rectCount, (const VkClearRect *)UlongToPtr(params->pRects));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdClearAttachments(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->attachmentCount, (const VkClearAttachment *)UlongToPtr(params->pAttachments), params->rectCount, (const VkClearRect *)UlongToPtr(params->pRects));
 }
 
 #ifdef _WIN64
@@ -43662,7 +44729,7 @@ static void thunk64_vkCmdClearColorImage
 {
     struct vkCmdClearColorImage_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdClearColorImage(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->image, params->imageLayout, params->pColor, params->rangeCount, params->pRanges);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdClearColorImage(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->image, params->imageLayout, params->pColor, params->rangeCount, params->pRanges);
 }
 #endif /* _WIN64 */
 
@@ -43678,7 +44745,7 @@ static void thunk32_vkCmdClearColorImage
         PTR32 pRanges;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdClearColorImage(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->image, params->imageLayout, (const VkClearColorValue *)UlongToPtr(params->pColor), params->rangeCount, (const VkImageSubresourceRange *)UlongToPtr(params->pRanges));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdClearColorImage(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->image, params->imageLayout, (const VkClearColorValue *)UlongToPtr(params->pColor), params->rangeCount, (const VkImageSubresourceRange *)UlongToPtr(params->pRanges));
 }
 
 #ifdef _WIN64
@@ -43686,7 +44753,7 @@ static void thunk64_vkCmdClearDepthStenc
 {
     struct vkCmdClearDepthStencilImage_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdClearDepthStencilImage(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->image, params->imageLayout, params->pDepthStencil, params->rangeCount, params->pRanges);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdClearDepthStencilImage(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->image, params->imageLayout, params->pDepthStencil, params->rangeCount, params->pRanges);
 }
 #endif /* _WIN64 */
 
@@ -43702,7 +44769,7 @@ static void thunk32_vkCmdClearDepthStenc
         PTR32 pRanges;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdClearDepthStencilImage(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->image, params->imageLayout, (const VkClearDepthStencilValue *)UlongToPtr(params->pDepthStencil), params->rangeCount, (const VkImageSubresourceRange *)UlongToPtr(params->pRanges));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdClearDepthStencilImage(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->image, params->imageLayout, (const VkClearDepthStencilValue *)UlongToPtr(params->pDepthStencil), params->rangeCount, (const VkImageSubresourceRange *)UlongToPtr(params->pRanges));
 }
 
 #ifdef _WIN64
@@ -43710,7 +44777,7 @@ static void thunk64_vkCmdControlVideoCod
 {
     struct vkCmdControlVideoCodingKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdControlVideoCodingKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCodingControlInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdControlVideoCodingKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCodingControlInfo);
 }
 #endif /* _WIN64 */
 
@@ -43727,7 +44794,7 @@ static void thunk32_vkCmdControlVideoCod
 
     init_conversion_context(ctx);
     convert_VkVideoCodingControlInfoKHR_win32_to_host(ctx, (const VkVideoCodingControlInfoKHR32 *)UlongToPtr(params->pCodingControlInfo), &pCodingControlInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdControlVideoCodingKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCodingControlInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdControlVideoCodingKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCodingControlInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -43736,7 +44803,7 @@ static void thunk64_vkCmdConvertCooperat
 {
     struct vkCmdConvertCooperativeVectorMatrixNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdConvertCooperativeVectorMatrixNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->infoCount, params->pInfos);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdConvertCooperativeVectorMatrixNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->infoCount, params->pInfos);
 }
 #endif /* _WIN64 */
 
@@ -43754,7 +44821,7 @@ static void thunk32_vkCmdConvertCooperat
 
     init_conversion_context(ctx);
     pInfos_host = convert_VkConvertCooperativeVectorMatrixInfoNV_array_win32_to_host(ctx, (const VkConvertCooperativeVectorMatrixInfoNV32 *)UlongToPtr(params->pInfos), params->infoCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdConvertCooperativeVectorMatrixNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->infoCount, pInfos_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdConvertCooperativeVectorMatrixNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->infoCount, pInfos_host);
     free_conversion_context(ctx);
 }
 
@@ -43763,7 +44830,7 @@ static void thunk64_vkCmdCopyAcceleratio
 {
     struct vkCmdCopyAccelerationStructureKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyAccelerationStructureKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyAccelerationStructureKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
 }
 #endif /* _WIN64 */
 
@@ -43777,7 +44844,7 @@ static void thunk32_vkCmdCopyAcceleratio
     VkCopyAccelerationStructureInfoKHR pInfo_host;
 
     convert_VkCopyAccelerationStructureInfoKHR_win32_to_host((const VkCopyAccelerationStructureInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyAccelerationStructureKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyAccelerationStructureKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
 }
 
 #ifdef _WIN64
@@ -43785,7 +44852,7 @@ static void thunk64_vkCmdCopyAcceleratio
 {
     struct vkCmdCopyAccelerationStructureNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyAccelerationStructureNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->dst, params->src, params->mode);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyAccelerationStructureNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->dst, params->src, params->mode);
 }
 #endif /* _WIN64 */
 
@@ -43799,7 +44866,7 @@ static void thunk32_vkCmdCopyAcceleratio
         VkCopyAccelerationStructureModeKHR mode;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyAccelerationStructureNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->dst, params->src, params->mode);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyAccelerationStructureNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->dst, params->src, params->mode);
 }
 
 #ifdef _WIN64
@@ -43807,7 +44874,7 @@ static void thunk64_vkCmdCopyAcceleratio
 {
     struct vkCmdCopyAccelerationStructureToMemoryKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyAccelerationStructureToMemoryKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyAccelerationStructureToMemoryKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
 }
 #endif /* _WIN64 */
 
@@ -43821,7 +44888,7 @@ static void thunk32_vkCmdCopyAcceleratio
     VkCopyAccelerationStructureToMemoryInfoKHR pInfo_host;
 
     convert_VkCopyAccelerationStructureToMemoryInfoKHR_win32_to_host((const VkCopyAccelerationStructureToMemoryInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyAccelerationStructureToMemoryKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyAccelerationStructureToMemoryKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
 }
 
 #ifdef _WIN64
@@ -43829,7 +44896,7 @@ static void thunk64_vkCmdCopyBuffer(void
 {
     struct vkCmdCopyBuffer_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcBuffer, params->dstBuffer, params->regionCount, params->pRegions);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcBuffer, params->dstBuffer, params->regionCount, params->pRegions);
 }
 #endif /* _WIN64 */
 
@@ -43849,7 +44916,7 @@ static void thunk32_vkCmdCopyBuffer(void
 
     init_conversion_context(ctx);
     pRegions_host = convert_VkBufferCopy_array_win32_to_host(ctx, (const VkBufferCopy32 *)UlongToPtr(params->pRegions), params->regionCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcBuffer, params->dstBuffer, params->regionCount, pRegions_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcBuffer, params->dstBuffer, params->regionCount, pRegions_host);
     free_conversion_context(ctx);
 }
 
@@ -43858,7 +44925,7 @@ static void thunk64_vkCmdCopyBuffer2(voi
 {
     struct vkCmdCopyBuffer2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBuffer2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyBufferInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBuffer2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyBufferInfo);
 }
 #endif /* _WIN64 */
 
@@ -43875,7 +44942,7 @@ static void thunk32_vkCmdCopyBuffer2(voi
 
     init_conversion_context(ctx);
     convert_VkCopyBufferInfo2_win32_to_host(ctx, (const VkCopyBufferInfo232 *)UlongToPtr(params->pCopyBufferInfo), &pCopyBufferInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBuffer2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyBufferInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBuffer2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyBufferInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -43884,7 +44951,7 @@ static void thunk64_vkCmdCopyBuffer2KHR(
 {
     struct vkCmdCopyBuffer2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBuffer2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyBufferInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBuffer2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyBufferInfo);
 }
 #endif /* _WIN64 */
 
@@ -43901,7 +44968,7 @@ static void thunk32_vkCmdCopyBuffer2KHR(
 
     init_conversion_context(ctx);
     convert_VkCopyBufferInfo2_win32_to_host(ctx, (const VkCopyBufferInfo232 *)UlongToPtr(params->pCopyBufferInfo), &pCopyBufferInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBuffer2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyBufferInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBuffer2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyBufferInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -43910,7 +44977,7 @@ static void thunk64_vkCmdCopyBufferToIma
 {
     struct vkCmdCopyBufferToImage_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBufferToImage(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcBuffer, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBufferToImage(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcBuffer, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions);
 }
 #endif /* _WIN64 */
 
@@ -43931,7 +44998,7 @@ static void thunk32_vkCmdCopyBufferToIma
 
     init_conversion_context(ctx);
     pRegions_host = convert_VkBufferImageCopy_array_win32_to_host(ctx, (const VkBufferImageCopy32 *)UlongToPtr(params->pRegions), params->regionCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBufferToImage(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcBuffer, params->dstImage, params->dstImageLayout, params->regionCount, pRegions_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBufferToImage(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcBuffer, params->dstImage, params->dstImageLayout, params->regionCount, pRegions_host);
     free_conversion_context(ctx);
 }
 
@@ -43940,7 +45007,7 @@ static void thunk64_vkCmdCopyBufferToIma
 {
     struct vkCmdCopyBufferToImage2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBufferToImage2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyBufferToImageInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBufferToImage2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyBufferToImageInfo);
 }
 #endif /* _WIN64 */
 
@@ -43957,7 +45024,7 @@ static void thunk32_vkCmdCopyBufferToIma
 
     init_conversion_context(ctx);
     convert_VkCopyBufferToImageInfo2_win32_to_host(ctx, (const VkCopyBufferToImageInfo232 *)UlongToPtr(params->pCopyBufferToImageInfo), &pCopyBufferToImageInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBufferToImage2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyBufferToImageInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBufferToImage2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyBufferToImageInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -43966,7 +45033,7 @@ static void thunk64_vkCmdCopyBufferToIma
 {
     struct vkCmdCopyBufferToImage2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBufferToImage2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyBufferToImageInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyBufferToImage2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyBufferToImageInfo);
 }
 #endif /* _WIN64 */
 
@@ -43983,7 +45050,7 @@ static void thunk32_vkCmdCopyBufferToIma
 
     init_conversion_context(ctx);
     convert_VkCopyBufferToImageInfo2_win32_to_host(ctx, (const VkCopyBufferToImageInfo232 *)UlongToPtr(params->pCopyBufferToImageInfo), &pCopyBufferToImageInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBufferToImage2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyBufferToImageInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyBufferToImage2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyBufferToImageInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -43992,7 +45059,7 @@ static void thunk64_vkCmdCopyImage(void
 {
     struct vkCmdCopyImage_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImage(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImage(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions);
 }
 #endif /* _WIN64 */
 
@@ -44009,7 +45076,7 @@ static void thunk32_vkCmdCopyImage(void
         PTR32 pRegions;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImage(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, (const VkImageCopy *)UlongToPtr(params->pRegions));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImage(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, (const VkImageCopy *)UlongToPtr(params->pRegions));
 }
 
 #ifdef _WIN64
@@ -44017,7 +45084,7 @@ static void thunk64_vkCmdCopyImage2(void
 {
     struct vkCmdCopyImage2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImage2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyImageInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImage2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyImageInfo);
 }
 #endif /* _WIN64 */
 
@@ -44034,7 +45101,7 @@ static void thunk32_vkCmdCopyImage2(void
 
     init_conversion_context(ctx);
     convert_VkCopyImageInfo2_win32_to_host(ctx, (const VkCopyImageInfo232 *)UlongToPtr(params->pCopyImageInfo), &pCopyImageInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImage2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyImageInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImage2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyImageInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -44043,7 +45110,7 @@ static void thunk64_vkCmdCopyImage2KHR(v
 {
     struct vkCmdCopyImage2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImage2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyImageInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImage2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyImageInfo);
 }
 #endif /* _WIN64 */
 
@@ -44060,7 +45127,7 @@ static void thunk32_vkCmdCopyImage2KHR(v
 
     init_conversion_context(ctx);
     convert_VkCopyImageInfo2_win32_to_host(ctx, (const VkCopyImageInfo232 *)UlongToPtr(params->pCopyImageInfo), &pCopyImageInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImage2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyImageInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImage2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyImageInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -44069,7 +45136,7 @@ static void thunk64_vkCmdCopyImageToBuff
 {
     struct vkCmdCopyImageToBuffer_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImageToBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstBuffer, params->regionCount, params->pRegions);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImageToBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstBuffer, params->regionCount, params->pRegions);
 }
 #endif /* _WIN64 */
 
@@ -44090,7 +45157,7 @@ static void thunk32_vkCmdCopyImageToBuff
 
     init_conversion_context(ctx);
     pRegions_host = convert_VkBufferImageCopy_array_win32_to_host(ctx, (const VkBufferImageCopy32 *)UlongToPtr(params->pRegions), params->regionCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImageToBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstBuffer, params->regionCount, pRegions_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImageToBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstBuffer, params->regionCount, pRegions_host);
     free_conversion_context(ctx);
 }
 
@@ -44099,7 +45166,7 @@ static void thunk64_vkCmdCopyImageToBuff
 {
     struct vkCmdCopyImageToBuffer2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImageToBuffer2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyImageToBufferInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImageToBuffer2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyImageToBufferInfo);
 }
 #endif /* _WIN64 */
 
@@ -44116,7 +45183,7 @@ static void thunk32_vkCmdCopyImageToBuff
 
     init_conversion_context(ctx);
     convert_VkCopyImageToBufferInfo2_win32_to_host(ctx, (const VkCopyImageToBufferInfo232 *)UlongToPtr(params->pCopyImageToBufferInfo), &pCopyImageToBufferInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImageToBuffer2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyImageToBufferInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImageToBuffer2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyImageToBufferInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -44125,7 +45192,7 @@ static void thunk64_vkCmdCopyImageToBuff
 {
     struct vkCmdCopyImageToBuffer2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImageToBuffer2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyImageToBufferInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyImageToBuffer2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyImageToBufferInfo);
 }
 #endif /* _WIN64 */
 
@@ -44142,7 +45209,7 @@ static void thunk32_vkCmdCopyImageToBuff
 
     init_conversion_context(ctx);
     convert_VkCopyImageToBufferInfo2_win32_to_host(ctx, (const VkCopyImageToBufferInfo232 *)UlongToPtr(params->pCopyImageToBufferInfo), &pCopyImageToBufferInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImageToBuffer2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyImageToBufferInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyImageToBuffer2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyImageToBufferInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -44151,7 +45218,7 @@ static void thunk64_vkCmdCopyMemoryIndir
 {
     struct vkCmdCopyMemoryIndirectKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryIndirectKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyMemoryIndirectInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryIndirectKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyMemoryIndirectInfo);
 }
 #endif /* _WIN64 */
 
@@ -44165,7 +45232,7 @@ static void thunk32_vkCmdCopyMemoryIndir
     VkCopyMemoryIndirectInfoKHR pCopyMemoryIndirectInfo_host;
 
     convert_VkCopyMemoryIndirectInfoKHR_win32_to_host((const VkCopyMemoryIndirectInfoKHR32 *)UlongToPtr(params->pCopyMemoryIndirectInfo), &pCopyMemoryIndirectInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryIndirectKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyMemoryIndirectInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryIndirectKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyMemoryIndirectInfo_host);
 }
 
 #ifdef _WIN64
@@ -44173,7 +45240,7 @@ static void thunk64_vkCmdCopyMemoryIndir
 {
     struct vkCmdCopyMemoryIndirectNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryIndirectNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->copyBufferAddress, params->copyCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryIndirectNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->copyBufferAddress, params->copyCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -44187,7 +45254,7 @@ static void thunk32_vkCmdCopyMemoryIndir
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryIndirectNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->copyBufferAddress, params->copyCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryIndirectNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->copyBufferAddress, params->copyCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -44195,7 +45262,7 @@ static void thunk64_vkCmdCopyMemoryToAcc
 {
     struct vkCmdCopyMemoryToAccelerationStructureKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryToAccelerationStructureKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryToAccelerationStructureKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
 }
 #endif /* _WIN64 */
 
@@ -44209,7 +45276,7 @@ static void thunk32_vkCmdCopyMemoryToAcc
     VkCopyMemoryToAccelerationStructureInfoKHR pInfo_host;
 
     convert_VkCopyMemoryToAccelerationStructureInfoKHR_win32_to_host((const VkCopyMemoryToAccelerationStructureInfoKHR32 *)UlongToPtr(params->pInfo), &pInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryToAccelerationStructureKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryToAccelerationStructureKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
 }
 
 #ifdef _WIN64
@@ -44217,7 +45284,7 @@ static void thunk64_vkCmdCopyMemoryToIma
 {
     struct vkCmdCopyMemoryToImageIndirectKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryToImageIndirectKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyMemoryToImageIndirectInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryToImageIndirectKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyMemoryToImageIndirectInfo);
 }
 #endif /* _WIN64 */
 
@@ -44231,7 +45298,7 @@ static void thunk32_vkCmdCopyMemoryToIma
     VkCopyMemoryToImageIndirectInfoKHR pCopyMemoryToImageIndirectInfo_host;
 
     convert_VkCopyMemoryToImageIndirectInfoKHR_win32_to_host((const VkCopyMemoryToImageIndirectInfoKHR32 *)UlongToPtr(params->pCopyMemoryToImageIndirectInfo), &pCopyMemoryToImageIndirectInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryToImageIndirectKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyMemoryToImageIndirectInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryToImageIndirectKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyMemoryToImageIndirectInfo_host);
 }
 
 #ifdef _WIN64
@@ -44239,7 +45306,7 @@ static void thunk64_vkCmdCopyMemoryToIma
 {
     struct vkCmdCopyMemoryToImageIndirectNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryToImageIndirectNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->copyBufferAddress, params->copyCount, params->stride, params->dstImage, params->dstImageLayout, params->pImageSubresources);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryToImageIndirectNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->copyBufferAddress, params->copyCount, params->stride, params->dstImage, params->dstImageLayout, params->pImageSubresources);
 }
 #endif /* _WIN64 */
 
@@ -44256,7 +45323,7 @@ static void thunk32_vkCmdCopyMemoryToIma
         PTR32 pImageSubresources;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryToImageIndirectNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->copyBufferAddress, params->copyCount, params->stride, params->dstImage, params->dstImageLayout, (const VkImageSubresourceLayers *)UlongToPtr(params->pImageSubresources));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryToImageIndirectNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->copyBufferAddress, params->copyCount, params->stride, params->dstImage, params->dstImageLayout, (const VkImageSubresourceLayers *)UlongToPtr(params->pImageSubresources));
 }
 
 #ifdef _WIN64
@@ -44264,7 +45331,7 @@ static void thunk64_vkCmdCopyMemoryToMic
 {
     struct vkCmdCopyMemoryToMicromapEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryToMicromapEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMemoryToMicromapEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
 }
 #endif /* _WIN64 */
 
@@ -44278,7 +45345,7 @@ static void thunk32_vkCmdCopyMemoryToMic
     VkCopyMemoryToMicromapInfoEXT pInfo_host;
 
     convert_VkCopyMemoryToMicromapInfoEXT_win32_to_host((const VkCopyMemoryToMicromapInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryToMicromapEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMemoryToMicromapEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
 }
 
 #ifdef _WIN64
@@ -44286,7 +45353,7 @@ static void thunk64_vkCmdCopyMicromapEXT
 {
     struct vkCmdCopyMicromapEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMicromapEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMicromapEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
 }
 #endif /* _WIN64 */
 
@@ -44300,7 +45367,7 @@ static void thunk32_vkCmdCopyMicromapEXT
     VkCopyMicromapInfoEXT pInfo_host;
 
     convert_VkCopyMicromapInfoEXT_win32_to_host((const VkCopyMicromapInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMicromapEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMicromapEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
 }
 
 #ifdef _WIN64
@@ -44308,7 +45375,7 @@ static void thunk64_vkCmdCopyMicromapToM
 {
     struct vkCmdCopyMicromapToMemoryEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMicromapToMemoryEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyMicromapToMemoryEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInfo);
 }
 #endif /* _WIN64 */
 
@@ -44322,7 +45389,7 @@ static void thunk32_vkCmdCopyMicromapToM
     VkCopyMicromapToMemoryInfoEXT pInfo_host;
 
     convert_VkCopyMicromapToMemoryInfoEXT_win32_to_host((const VkCopyMicromapToMemoryInfoEXT32 *)UlongToPtr(params->pInfo), &pInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMicromapToMemoryEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyMicromapToMemoryEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInfo_host);
 }
 
 #ifdef _WIN64
@@ -44330,7 +45397,7 @@ static void thunk64_vkCmdCopyQueryPoolRe
 {
     struct vkCmdCopyQueryPoolResults_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyQueryPoolResults(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->firstQuery, params->queryCount, params->dstBuffer, params->dstOffset, params->stride, params->flags);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyQueryPoolResults(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->firstQuery, params->queryCount, params->dstBuffer, params->dstOffset, params->stride, params->flags);
 }
 #endif /* _WIN64 */
 
@@ -44348,7 +45415,7 @@ static void thunk32_vkCmdCopyQueryPoolRe
         VkQueryResultFlags flags;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyQueryPoolResults(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->firstQuery, params->queryCount, params->dstBuffer, params->dstOffset, params->stride, params->flags);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyQueryPoolResults(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->firstQuery, params->queryCount, params->dstBuffer, params->dstOffset, params->stride, params->flags);
 }
 
 #ifdef _WIN64
@@ -44356,7 +45423,7 @@ static void thunk64_vkCmdCopyTensorARM(v
 {
     struct vkCmdCopyTensorARM_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyTensorARM(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyTensorInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCopyTensorARM(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCopyTensorInfo);
 }
 #endif /* _WIN64 */
 
@@ -44373,7 +45440,7 @@ static void thunk32_vkCmdCopyTensorARM(v
 
     init_conversion_context(ctx);
     convert_VkCopyTensorInfoARM_win32_to_host(ctx, (const VkCopyTensorInfoARM32 *)UlongToPtr(params->pCopyTensorInfo), &pCopyTensorInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyTensorARM(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyTensorInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCopyTensorARM(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pCopyTensorInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -44382,7 +45449,7 @@ static void thunk64_vkCmdCuLaunchKernelN
 {
     struct vkCmdCuLaunchKernelNVX_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCuLaunchKernelNVX(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLaunchInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdCuLaunchKernelNVX(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLaunchInfo);
 }
 #endif /* _WIN64 */
 
@@ -44396,7 +45463,7 @@ static void thunk32_vkCmdCuLaunchKernelN
     VkCuLaunchInfoNVX pLaunchInfo_host;
 
     convert_VkCuLaunchInfoNVX_win32_to_host((const VkCuLaunchInfoNVX32 *)UlongToPtr(params->pLaunchInfo), &pLaunchInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCuLaunchKernelNVX(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLaunchInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdCuLaunchKernelNVX(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLaunchInfo_host);
 }
 
 #ifdef _WIN64
@@ -44404,7 +45471,7 @@ static void thunk64_vkCmdDebugMarkerBegi
 {
     struct vkCmdDebugMarkerBeginEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDebugMarkerBeginEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pMarkerInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDebugMarkerBeginEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pMarkerInfo);
 }
 #endif /* _WIN64 */
 
@@ -44418,7 +45485,7 @@ static void thunk32_vkCmdDebugMarkerBegi
     VkDebugMarkerMarkerInfoEXT pMarkerInfo_host;
 
     convert_VkDebugMarkerMarkerInfoEXT_win32_to_host((const VkDebugMarkerMarkerInfoEXT32 *)UlongToPtr(params->pMarkerInfo), &pMarkerInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDebugMarkerBeginEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pMarkerInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDebugMarkerBeginEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pMarkerInfo_host);
 }
 
 #ifdef _WIN64
@@ -44426,7 +45493,7 @@ static void thunk64_vkCmdDebugMarkerEndE
 {
     struct vkCmdDebugMarkerEndEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDebugMarkerEndEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDebugMarkerEndEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer);
 }
 #endif /* _WIN64 */
 
@@ -44437,7 +45504,7 @@ static void thunk32_vkCmdDebugMarkerEndE
         PTR32 commandBuffer;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDebugMarkerEndEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDebugMarkerEndEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
 }
 
 #ifdef _WIN64
@@ -44445,7 +45512,7 @@ static void thunk64_vkCmdDebugMarkerInse
 {
     struct vkCmdDebugMarkerInsertEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDebugMarkerInsertEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pMarkerInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDebugMarkerInsertEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pMarkerInfo);
 }
 #endif /* _WIN64 */
 
@@ -44459,7 +45526,7 @@ static void thunk32_vkCmdDebugMarkerInse
     VkDebugMarkerMarkerInfoEXT pMarkerInfo_host;
 
     convert_VkDebugMarkerMarkerInfoEXT_win32_to_host((const VkDebugMarkerMarkerInfoEXT32 *)UlongToPtr(params->pMarkerInfo), &pMarkerInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDebugMarkerInsertEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pMarkerInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDebugMarkerInsertEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pMarkerInfo_host);
 }
 
 #ifdef _WIN64
@@ -44467,7 +45534,7 @@ static void thunk64_vkCmdDecodeVideoKHR(
 {
     struct vkCmdDecodeVideoKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDecodeVideoKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDecodeInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDecodeVideoKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDecodeInfo);
 }
 #endif /* _WIN64 */
 
@@ -44484,7 +45551,7 @@ static void thunk32_vkCmdDecodeVideoKHR(
 
     init_conversion_context(ctx);
     convert_VkVideoDecodeInfoKHR_win32_to_host(ctx, (const VkVideoDecodeInfoKHR32 *)UlongToPtr(params->pDecodeInfo), &pDecodeInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDecodeVideoKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDecodeInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDecodeVideoKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDecodeInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -44493,7 +45560,7 @@ static void thunk64_vkCmdDecompressMemor
 {
     struct vkCmdDecompressMemoryIndirectCountNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDecompressMemoryIndirectCountNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->indirectCommandsAddress, params->indirectCommandsCountAddress, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDecompressMemoryIndirectCountNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->indirectCommandsAddress, params->indirectCommandsCountAddress, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -44507,7 +45574,7 @@ static void thunk32_vkCmdDecompressMemor
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDecompressMemoryIndirectCountNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->indirectCommandsAddress, params->indirectCommandsCountAddress, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDecompressMemoryIndirectCountNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->indirectCommandsAddress, params->indirectCommandsCountAddress, params->stride);
 }
 
 #ifdef _WIN64
@@ -44515,7 +45582,7 @@ static void thunk64_vkCmdDecompressMemor
 {
     struct vkCmdDecompressMemoryNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDecompressMemoryNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->decompressRegionCount, params->pDecompressMemoryRegions);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDecompressMemoryNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->decompressRegionCount, params->pDecompressMemoryRegions);
 }
 #endif /* _WIN64 */
 
@@ -44533,7 +45600,7 @@ static void thunk32_vkCmdDecompressMemor
 
     init_conversion_context(ctx);
     pDecompressMemoryRegions_host = convert_VkDecompressMemoryRegionNV_array_win32_to_host(ctx, (const VkDecompressMemoryRegionNV32 *)UlongToPtr(params->pDecompressMemoryRegions), params->decompressRegionCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDecompressMemoryNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->decompressRegionCount, pDecompressMemoryRegions_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDecompressMemoryNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->decompressRegionCount, pDecompressMemoryRegions_host);
     free_conversion_context(ctx);
 }
 
@@ -44542,7 +45609,7 @@ static void thunk64_vkCmdDispatch(void *
 {
     struct vkCmdDispatch_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatch(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatch(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
 }
 #endif /* _WIN64 */
 
@@ -44556,7 +45623,7 @@ static void thunk32_vkCmdDispatch(void *
         uint32_t groupCountZ;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatch(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatch(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
 }
 
 #ifdef _WIN64
@@ -44564,7 +45631,7 @@ static void thunk64_vkCmdDispatchBase(vo
 {
     struct vkCmdDispatchBase_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchBase(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchBase(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
 }
 #endif /* _WIN64 */
 
@@ -44581,7 +45648,7 @@ static void thunk32_vkCmdDispatchBase(vo
         uint32_t groupCountZ;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchBase(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchBase(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
 }
 
 #ifdef _WIN64
@@ -44589,7 +45656,7 @@ static void thunk64_vkCmdDispatchBaseKHR
 {
     struct vkCmdDispatchBaseKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchBaseKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchBaseKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
 }
 #endif /* _WIN64 */
 
@@ -44606,7 +45673,7 @@ static void thunk32_vkCmdDispatchBaseKHR
         uint32_t groupCountZ;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchBaseKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchBaseKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->baseGroupX, params->baseGroupY, params->baseGroupZ, params->groupCountX, params->groupCountY, params->groupCountZ);
 }
 
 #ifdef _WIN64
@@ -44614,7 +45681,7 @@ static void thunk64_vkCmdDispatchDataGra
 {
     struct vkCmdDispatchDataGraphARM_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchDataGraphARM(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->session, params->pInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchDataGraphARM(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->session, params->pInfo);
 }
 #endif /* _WIN64 */
 
@@ -44636,7 +45703,7 @@ static void thunk32_vkCmdDispatchDataGra
         pInfo_host = conversion_context_alloc(ctx, sizeof(*pInfo_host));
         convert_VkDataGraphPipelineDispatchInfoARM_win32_to_host((const VkDataGraphPipelineDispatchInfoARM32 *)UlongToPtr(params->pInfo), pInfo_host);
     }
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchDataGraphARM(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->session, pInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchDataGraphARM(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->session, pInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -44645,7 +45712,7 @@ static void thunk64_vkCmdDispatchIndirec
 {
     struct vkCmdDispatchIndirect_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchIndirect(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchIndirect(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset);
 }
 #endif /* _WIN64 */
 
@@ -44658,7 +45725,7 @@ static void thunk32_vkCmdDispatchIndirec
         VkDeviceSize DECLSPEC_ALIGN(8) offset;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchIndirect(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchIndirect(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset);
 }
 
 #ifdef _WIN64
@@ -44666,7 +45733,7 @@ static void thunk64_vkCmdDispatchTileQCO
 {
     struct vkCmdDispatchTileQCOM_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchTileQCOM(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDispatchTileInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDispatchTileQCOM(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDispatchTileInfo);
 }
 #endif /* _WIN64 */
 
@@ -44680,7 +45747,7 @@ static void thunk32_vkCmdDispatchTileQCO
     VkDispatchTileInfoQCOM pDispatchTileInfo_host;
 
     convert_VkDispatchTileInfoQCOM_win32_to_host((const VkDispatchTileInfoQCOM32 *)UlongToPtr(params->pDispatchTileInfo), &pDispatchTileInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchTileQCOM(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDispatchTileInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDispatchTileQCOM(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDispatchTileInfo_host);
 }
 
 #ifdef _WIN64
@@ -44688,7 +45755,7 @@ static void thunk64_vkCmdDraw(void *args
 {
     struct vkCmdDraw_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDraw(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->vertexCount, params->instanceCount, params->firstVertex, params->firstInstance);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDraw(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->vertexCount, params->instanceCount, params->firstVertex, params->firstInstance);
 }
 #endif /* _WIN64 */
 
@@ -44703,7 +45770,7 @@ static void thunk32_vkCmdDraw(void *args
         uint32_t firstInstance;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDraw(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->vertexCount, params->instanceCount, params->firstVertex, params->firstInstance);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDraw(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->vertexCount, params->instanceCount, params->firstVertex, params->firstInstance);
 }
 
 #ifdef _WIN64
@@ -44711,7 +45778,7 @@ static void thunk64_vkCmdDrawClusterHUAW
 {
     struct vkCmdDrawClusterHUAWEI_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawClusterHUAWEI(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawClusterHUAWEI(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
 }
 #endif /* _WIN64 */
 
@@ -44725,7 +45792,7 @@ static void thunk32_vkCmdDrawClusterHUAW
         uint32_t groupCountZ;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawClusterHUAWEI(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawClusterHUAWEI(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
 }
 
 #ifdef _WIN64
@@ -44733,7 +45800,7 @@ static void thunk64_vkCmdDrawClusterIndi
 {
     struct vkCmdDrawClusterIndirectHUAWEI_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawClusterIndirectHUAWEI(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawClusterIndirectHUAWEI(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset);
 }
 #endif /* _WIN64 */
 
@@ -44746,7 +45813,7 @@ static void thunk32_vkCmdDrawClusterIndi
         VkDeviceSize DECLSPEC_ALIGN(8) offset;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawClusterIndirectHUAWEI(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawClusterIndirectHUAWEI(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset);
 }
 
 #ifdef _WIN64
@@ -44754,7 +45821,7 @@ static void thunk64_vkCmdDrawIndexed(voi
 {
     struct vkCmdDrawIndexed_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexed(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->indexCount, params->instanceCount, params->firstIndex, params->vertexOffset, params->firstInstance);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexed(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->indexCount, params->instanceCount, params->firstIndex, params->vertexOffset, params->firstInstance);
 }
 #endif /* _WIN64 */
 
@@ -44770,7 +45837,7 @@ static void thunk32_vkCmdDrawIndexed(voi
         uint32_t firstInstance;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexed(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->indexCount, params->instanceCount, params->firstIndex, params->vertexOffset, params->firstInstance);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexed(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->indexCount, params->instanceCount, params->firstIndex, params->vertexOffset, params->firstInstance);
 }
 
 #ifdef _WIN64
@@ -44778,7 +45845,7 @@ static void thunk64_vkCmdDrawIndexedIndi
 {
     struct vkCmdDrawIndexedIndirect_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexedIndirect(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexedIndirect(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -44793,7 +45860,7 @@ static void thunk32_vkCmdDrawIndexedIndi
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexedIndirect(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexedIndirect(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -44801,7 +45868,7 @@ static void thunk64_vkCmdDrawIndexedIndi
 {
     struct vkCmdDrawIndexedIndirectCount_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexedIndirectCount(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexedIndirectCount(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -44818,7 +45885,7 @@ static void thunk32_vkCmdDrawIndexedIndi
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexedIndirectCount(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexedIndirectCount(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -44826,7 +45893,7 @@ static void thunk64_vkCmdDrawIndexedIndi
 {
     struct vkCmdDrawIndexedIndirectCountAMD_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexedIndirectCountAMD(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexedIndirectCountAMD(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -44843,7 +45910,7 @@ static void thunk32_vkCmdDrawIndexedIndi
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexedIndirectCountAMD(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexedIndirectCountAMD(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -44851,7 +45918,7 @@ static void thunk64_vkCmdDrawIndexedIndi
 {
     struct vkCmdDrawIndexedIndirectCountKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexedIndirectCountKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndexedIndirectCountKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -44868,7 +45935,7 @@ static void thunk32_vkCmdDrawIndexedIndi
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexedIndirectCountKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndexedIndirectCountKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -44876,7 +45943,7 @@ static void thunk64_vkCmdDrawIndirect(vo
 {
     struct vkCmdDrawIndirect_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirect(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirect(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -44891,7 +45958,7 @@ static void thunk32_vkCmdDrawIndirect(vo
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirect(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirect(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -44899,7 +45966,7 @@ static void thunk64_vkCmdDrawIndirectByt
 {
     struct vkCmdDrawIndirectByteCountEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirectByteCountEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->instanceCount, params->firstInstance, params->counterBuffer, params->counterBufferOffset, params->counterOffset, params->vertexStride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirectByteCountEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->instanceCount, params->firstInstance, params->counterBuffer, params->counterBufferOffset, params->counterOffset, params->vertexStride);
 }
 #endif /* _WIN64 */
 
@@ -44916,7 +45983,7 @@ static void thunk32_vkCmdDrawIndirectByt
         uint32_t vertexStride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirectByteCountEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->instanceCount, params->firstInstance, params->counterBuffer, params->counterBufferOffset, params->counterOffset, params->vertexStride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirectByteCountEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->instanceCount, params->firstInstance, params->counterBuffer, params->counterBufferOffset, params->counterOffset, params->vertexStride);
 }
 
 #ifdef _WIN64
@@ -44924,7 +45991,7 @@ static void thunk64_vkCmdDrawIndirectCou
 {
     struct vkCmdDrawIndirectCount_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirectCount(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirectCount(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -44941,7 +46008,7 @@ static void thunk32_vkCmdDrawIndirectCou
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirectCount(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirectCount(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -44949,7 +46016,7 @@ static void thunk64_vkCmdDrawIndirectCou
 {
     struct vkCmdDrawIndirectCountAMD_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirectCountAMD(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirectCountAMD(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -44966,7 +46033,7 @@ static void thunk32_vkCmdDrawIndirectCou
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirectCountAMD(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirectCountAMD(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -44974,7 +46041,7 @@ static void thunk64_vkCmdDrawIndirectCou
 {
     struct vkCmdDrawIndirectCountKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirectCountKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawIndirectCountKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -44991,7 +46058,7 @@ static void thunk32_vkCmdDrawIndirectCou
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirectCountKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawIndirectCountKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -44999,7 +46066,7 @@ static void thunk64_vkCmdDrawMeshTasksEX
 {
     struct vkCmdDrawMeshTasksEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
 }
 #endif /* _WIN64 */
 
@@ -45013,7 +46080,7 @@ static void thunk32_vkCmdDrawMeshTasksEX
         uint32_t groupCountZ;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->groupCountX, params->groupCountY, params->groupCountZ);
 }
 
 #ifdef _WIN64
@@ -45021,7 +46088,7 @@ static void thunk64_vkCmdDrawMeshTasksIn
 {
     struct vkCmdDrawMeshTasksIndirectCountEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksIndirectCountEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksIndirectCountEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -45038,7 +46105,7 @@ static void thunk32_vkCmdDrawMeshTasksIn
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksIndirectCountEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksIndirectCountEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -45046,7 +46113,7 @@ static void thunk64_vkCmdDrawMeshTasksIn
 {
     struct vkCmdDrawMeshTasksIndirectCountNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksIndirectCountNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksIndirectCountNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -45063,7 +46130,7 @@ static void thunk32_vkCmdDrawMeshTasksIn
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksIndirectCountNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksIndirectCountNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->countBuffer, params->countBufferOffset, params->maxDrawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -45071,7 +46138,7 @@ static void thunk64_vkCmdDrawMeshTasksIn
 {
     struct vkCmdDrawMeshTasksIndirectEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksIndirectEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksIndirectEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -45086,7 +46153,7 @@ static void thunk32_vkCmdDrawMeshTasksIn
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksIndirectEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksIndirectEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -45094,7 +46161,7 @@ static void thunk64_vkCmdDrawMeshTasksIn
 {
     struct vkCmdDrawMeshTasksIndirectNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksIndirectNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksIndirectNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -45109,7 +46176,7 @@ static void thunk32_vkCmdDrawMeshTasksIn
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksIndirectNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksIndirectNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->buffer, params->offset, params->drawCount, params->stride);
 }
 
 #ifdef _WIN64
@@ -45117,7 +46184,7 @@ static void thunk64_vkCmdDrawMeshTasksNV
 {
     struct vkCmdDrawMeshTasksNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->taskCount, params->firstTask);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMeshTasksNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->taskCount, params->firstTask);
 }
 #endif /* _WIN64 */
 
@@ -45130,7 +46197,7 @@ static void thunk32_vkCmdDrawMeshTasksNV
         uint32_t firstTask;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->taskCount, params->firstTask);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMeshTasksNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->taskCount, params->firstTask);
 }
 
 #ifdef _WIN64
@@ -45138,7 +46205,7 @@ static void thunk64_vkCmdDrawMultiEXT(vo
 {
     struct vkCmdDrawMultiEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMultiEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->drawCount, params->pVertexInfo, params->instanceCount, params->firstInstance, params->stride);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMultiEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->drawCount, params->pVertexInfo, params->instanceCount, params->firstInstance, params->stride);
 }
 #endif /* _WIN64 */
 
@@ -45154,7 +46221,7 @@ static void thunk32_vkCmdDrawMultiEXT(vo
         uint32_t stride;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMultiEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->drawCount, (const VkMultiDrawInfoEXT *)UlongToPtr(params->pVertexInfo), params->instanceCount, params->firstInstance, params->stride);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMultiEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->drawCount, (const VkMultiDrawInfoEXT *)UlongToPtr(params->pVertexInfo), params->instanceCount, params->firstInstance, params->stride);
 }
 
 #ifdef _WIN64
@@ -45162,7 +46229,7 @@ static void thunk64_vkCmdDrawMultiIndexe
 {
     struct vkCmdDrawMultiIndexedEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMultiIndexedEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->drawCount, params->pIndexInfo, params->instanceCount, params->firstInstance, params->stride, params->pVertexOffset);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdDrawMultiIndexedEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->drawCount, params->pIndexInfo, params->instanceCount, params->firstInstance, params->stride, params->pVertexOffset);
 }
 #endif /* _WIN64 */
 
@@ -45179,7 +46246,7 @@ static void thunk32_vkCmdDrawMultiIndexe
         PTR32 pVertexOffset;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMultiIndexedEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->drawCount, (const VkMultiDrawIndexedInfoEXT *)UlongToPtr(params->pIndexInfo), params->instanceCount, params->firstInstance, params->stride, (const int32_t *)UlongToPtr(params->pVertexOffset));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdDrawMultiIndexedEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->drawCount, (const VkMultiDrawIndexedInfoEXT *)UlongToPtr(params->pIndexInfo), params->instanceCount, params->firstInstance, params->stride, (const int32_t *)UlongToPtr(params->pVertexOffset));
 }
 
 #ifdef _WIN64
@@ -45187,7 +46254,7 @@ static void thunk64_vkCmdEncodeVideoKHR(
 {
     struct vkCmdEncodeVideoKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEncodeVideoKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pEncodeInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEncodeVideoKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pEncodeInfo);
 }
 #endif /* _WIN64 */
 
@@ -45204,7 +46271,7 @@ static void thunk32_vkCmdEncodeVideoKHR(
 
     init_conversion_context(ctx);
     convert_VkVideoEncodeInfoKHR_win32_to_host(ctx, (const VkVideoEncodeInfoKHR32 *)UlongToPtr(params->pEncodeInfo), &pEncodeInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEncodeVideoKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pEncodeInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEncodeVideoKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pEncodeInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45213,7 +46280,7 @@ static void thunk64_vkCmdEndConditionalR
 {
     struct vkCmdEndConditionalRenderingEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndConditionalRenderingEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndConditionalRenderingEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer);
 }
 #endif /* _WIN64 */
 
@@ -45224,7 +46291,7 @@ static void thunk32_vkCmdEndConditionalR
         PTR32 commandBuffer;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndConditionalRenderingEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndConditionalRenderingEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
 }
 
 #ifdef _WIN64
@@ -45232,7 +46299,7 @@ static void thunk64_vkCmdEndDebugUtilsLa
 {
     struct vkCmdEndDebugUtilsLabelEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndDebugUtilsLabelEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndDebugUtilsLabelEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer);
 }
 #endif /* _WIN64 */
 
@@ -45243,7 +46310,7 @@ static void thunk32_vkCmdEndDebugUtilsLa
         PTR32 commandBuffer;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndDebugUtilsLabelEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndDebugUtilsLabelEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
 }
 
 #ifdef _WIN64
@@ -45251,7 +46318,7 @@ static void thunk64_vkCmdEndPerTileExecu
 {
     struct vkCmdEndPerTileExecutionQCOM_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndPerTileExecutionQCOM(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPerTileEndInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndPerTileExecutionQCOM(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPerTileEndInfo);
 }
 #endif /* _WIN64 */
 
@@ -45265,7 +46332,7 @@ static void thunk32_vkCmdEndPerTileExecu
     VkPerTileEndInfoQCOM pPerTileEndInfo_host;
 
     convert_VkPerTileEndInfoQCOM_win32_to_host((const VkPerTileEndInfoQCOM32 *)UlongToPtr(params->pPerTileEndInfo), &pPerTileEndInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndPerTileExecutionQCOM(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPerTileEndInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndPerTileExecutionQCOM(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPerTileEndInfo_host);
 }
 
 #ifdef _WIN64
@@ -45273,7 +46340,7 @@ static void thunk64_vkCmdEndQuery(void *
 {
     struct vkCmdEndQuery_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndQuery(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->query);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndQuery(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->query);
 }
 #endif /* _WIN64 */
 
@@ -45286,7 +46353,7 @@ static void thunk32_vkCmdEndQuery(void *
         uint32_t query;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndQuery(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->query);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndQuery(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->query);
 }
 
 #ifdef _WIN64
@@ -45294,7 +46361,7 @@ static void thunk64_vkCmdEndQueryIndexed
 {
     struct vkCmdEndQueryIndexedEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndQueryIndexedEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->query, params->index);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndQueryIndexedEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->query, params->index);
 }
 #endif /* _WIN64 */
 
@@ -45308,7 +46375,7 @@ static void thunk32_vkCmdEndQueryIndexed
         uint32_t index;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndQueryIndexedEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->query, params->index);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndQueryIndexedEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->query, params->index);
 }
 
 #ifdef _WIN64
@@ -45316,7 +46383,7 @@ static void thunk64_vkCmdEndRenderPass(v
 {
     struct vkCmdEndRenderPass_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRenderPass(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRenderPass(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer);
 }
 #endif /* _WIN64 */
 
@@ -45327,7 +46394,7 @@ static void thunk32_vkCmdEndRenderPass(v
         PTR32 commandBuffer;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRenderPass(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRenderPass(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
 }
 
 #ifdef _WIN64
@@ -45335,7 +46402,7 @@ static void thunk64_vkCmdEndRenderPass2(
 {
     struct vkCmdEndRenderPass2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRenderPass2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSubpassEndInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRenderPass2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSubpassEndInfo);
 }
 #endif /* _WIN64 */
 
@@ -45352,7 +46419,7 @@ static void thunk32_vkCmdEndRenderPass2(
 
     init_conversion_context(ctx);
     convert_VkSubpassEndInfo_win32_to_host(ctx, (const VkSubpassEndInfo32 *)UlongToPtr(params->pSubpassEndInfo), &pSubpassEndInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRenderPass2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSubpassEndInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRenderPass2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSubpassEndInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45361,7 +46428,7 @@ static void thunk64_vkCmdEndRenderPass2K
 {
     struct vkCmdEndRenderPass2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRenderPass2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSubpassEndInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRenderPass2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSubpassEndInfo);
 }
 #endif /* _WIN64 */
 
@@ -45378,7 +46445,7 @@ static void thunk32_vkCmdEndRenderPass2K
 
     init_conversion_context(ctx);
     convert_VkSubpassEndInfo_win32_to_host(ctx, (const VkSubpassEndInfo32 *)UlongToPtr(params->pSubpassEndInfo), &pSubpassEndInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRenderPass2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSubpassEndInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRenderPass2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSubpassEndInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45387,7 +46454,7 @@ static void thunk64_vkCmdEndRendering(vo
 {
     struct vkCmdEndRendering_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRendering(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRendering(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer);
 }
 #endif /* _WIN64 */
 
@@ -45398,7 +46465,7 @@ static void thunk32_vkCmdEndRendering(vo
         PTR32 commandBuffer;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRendering(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRendering(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
 }
 
 #ifdef _WIN64
@@ -45406,7 +46473,7 @@ static void thunk64_vkCmdEndRendering2EX
 {
     struct vkCmdEndRendering2EXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRendering2EXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderingEndInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRendering2EXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRenderingEndInfo);
 }
 #endif /* _WIN64 */
 
@@ -45427,7 +46494,7 @@ static void thunk32_vkCmdEndRendering2EX
         pRenderingEndInfo_host = conversion_context_alloc(ctx, sizeof(*pRenderingEndInfo_host));
         convert_VkRenderingEndInfoEXT_win32_to_host(ctx, (const VkRenderingEndInfoEXT32 *)UlongToPtr(params->pRenderingEndInfo), pRenderingEndInfo_host);
     }
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRendering2EXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, pRenderingEndInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRendering2EXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, pRenderingEndInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45436,7 +46503,7 @@ static void thunk64_vkCmdEndRenderingKHR
 {
     struct vkCmdEndRenderingKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRenderingKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndRenderingKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer);
 }
 #endif /* _WIN64 */
 
@@ -45447,7 +46514,7 @@ static void thunk32_vkCmdEndRenderingKHR
         PTR32 commandBuffer;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRenderingKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndRenderingKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
 }
 
 #ifdef _WIN64
@@ -45455,7 +46522,7 @@ static void thunk64_vkCmdEndTransformFee
 {
     struct vkCmdEndTransformFeedbackEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndTransformFeedbackEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstCounterBuffer, params->counterBufferCount, params->pCounterBuffers, params->pCounterBufferOffsets);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndTransformFeedbackEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstCounterBuffer, params->counterBufferCount, params->pCounterBuffers, params->pCounterBufferOffsets);
 }
 #endif /* _WIN64 */
 
@@ -45470,7 +46537,7 @@ static void thunk32_vkCmdEndTransformFee
         PTR32 pCounterBufferOffsets;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndTransformFeedbackEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstCounterBuffer, params->counterBufferCount, (const VkBuffer *)UlongToPtr(params->pCounterBuffers), (const VkDeviceSize *)UlongToPtr(params->pCounterBufferOffsets));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndTransformFeedbackEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstCounterBuffer, params->counterBufferCount, (const VkBuffer *)UlongToPtr(params->pCounterBuffers), (const VkDeviceSize *)UlongToPtr(params->pCounterBufferOffsets));
 }
 
 #ifdef _WIN64
@@ -45478,7 +46545,7 @@ static void thunk64_vkCmdEndVideoCodingK
 {
     struct vkCmdEndVideoCodingKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndVideoCodingKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pEndCodingInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdEndVideoCodingKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pEndCodingInfo);
 }
 #endif /* _WIN64 */
 
@@ -45492,7 +46559,7 @@ static void thunk32_vkCmdEndVideoCodingK
     VkVideoEndCodingInfoKHR pEndCodingInfo_host;
 
     convert_VkVideoEndCodingInfoKHR_win32_to_host((const VkVideoEndCodingInfoKHR32 *)UlongToPtr(params->pEndCodingInfo), &pEndCodingInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndVideoCodingKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pEndCodingInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdEndVideoCodingKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pEndCodingInfo_host);
 }
 
 #ifdef _WIN64
@@ -45505,7 +46572,7 @@ static void thunk64_vkCmdExecuteCommands
 
     init_conversion_context(ctx);
     pCommandBuffers_host = convert_VkCommandBuffer_array_win64_to_host(ctx, params->pCommandBuffers, params->commandBufferCount);
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdExecuteCommands(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->commandBufferCount, pCommandBuffers_host);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdExecuteCommands(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->commandBufferCount, pCommandBuffers_host);
     free_conversion_context(ctx);
 }
 #endif /* _WIN64 */
@@ -45524,7 +46591,7 @@ static void thunk32_vkCmdExecuteCommands
 
     init_conversion_context(ctx);
     pCommandBuffers_host = convert_VkCommandBuffer_array_win32_to_host(ctx, (const PTR32 *)UlongToPtr(params->pCommandBuffers), params->commandBufferCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdExecuteCommands(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->commandBufferCount, pCommandBuffers_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdExecuteCommands(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->commandBufferCount, pCommandBuffers_host);
     free_conversion_context(ctx);
 }
 
@@ -45533,7 +46600,7 @@ static void thunk64_vkCmdExecuteGenerate
 {
     struct vkCmdExecuteGeneratedCommandsEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdExecuteGeneratedCommandsEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->isPreprocessed, params->pGeneratedCommandsInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdExecuteGeneratedCommandsEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->isPreprocessed, params->pGeneratedCommandsInfo);
 }
 #endif /* _WIN64 */
 
@@ -45551,7 +46618,7 @@ static void thunk32_vkCmdExecuteGenerate
 
     init_conversion_context(ctx);
     convert_VkGeneratedCommandsInfoEXT_win32_to_host(ctx, (const VkGeneratedCommandsInfoEXT32 *)UlongToPtr(params->pGeneratedCommandsInfo), &pGeneratedCommandsInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdExecuteGeneratedCommandsEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->isPreprocessed, &pGeneratedCommandsInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdExecuteGeneratedCommandsEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->isPreprocessed, &pGeneratedCommandsInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45560,7 +46627,7 @@ static void thunk64_vkCmdExecuteGenerate
 {
     struct vkCmdExecuteGeneratedCommandsNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdExecuteGeneratedCommandsNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->isPreprocessed, params->pGeneratedCommandsInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdExecuteGeneratedCommandsNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->isPreprocessed, params->pGeneratedCommandsInfo);
 }
 #endif /* _WIN64 */
 
@@ -45578,7 +46645,7 @@ static void thunk32_vkCmdExecuteGenerate
 
     init_conversion_context(ctx);
     convert_VkGeneratedCommandsInfoNV_win32_to_host(ctx, (const VkGeneratedCommandsInfoNV32 *)UlongToPtr(params->pGeneratedCommandsInfo), &pGeneratedCommandsInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdExecuteGeneratedCommandsNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->isPreprocessed, &pGeneratedCommandsInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdExecuteGeneratedCommandsNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->isPreprocessed, &pGeneratedCommandsInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45587,7 +46654,7 @@ static void thunk64_vkCmdFillBuffer(void
 {
     struct vkCmdFillBuffer_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdFillBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->dstBuffer, params->dstOffset, params->size, params->data);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdFillBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->dstBuffer, params->dstOffset, params->size, params->data);
 }
 #endif /* _WIN64 */
 
@@ -45602,7 +46669,7 @@ static void thunk32_vkCmdFillBuffer(void
         uint32_t data;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdFillBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->dstBuffer, params->dstOffset, params->size, params->data);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdFillBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->dstBuffer, params->dstOffset, params->size, params->data);
 }
 
 #ifdef _WIN64
@@ -45610,7 +46677,7 @@ static void thunk64_vkCmdInsertDebugUtil
 {
     struct vkCmdInsertDebugUtilsLabelEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdInsertDebugUtilsLabelEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLabelInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdInsertDebugUtilsLabelEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLabelInfo);
 }
 #endif /* _WIN64 */
 
@@ -45624,7 +46691,7 @@ static void thunk32_vkCmdInsertDebugUtil
     VkDebugUtilsLabelEXT pLabelInfo_host;
 
     convert_VkDebugUtilsLabelEXT_win32_to_host((const VkDebugUtilsLabelEXT32 *)UlongToPtr(params->pLabelInfo), &pLabelInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdInsertDebugUtilsLabelEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLabelInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdInsertDebugUtilsLabelEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLabelInfo_host);
 }
 
 #ifdef _WIN64
@@ -45632,7 +46699,7 @@ static void thunk64_vkCmdNextSubpass(voi
 {
     struct vkCmdNextSubpass_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdNextSubpass(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->contents);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdNextSubpass(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->contents);
 }
 #endif /* _WIN64 */
 
@@ -45644,7 +46711,7 @@ static void thunk32_vkCmdNextSubpass(voi
         VkSubpassContents contents;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdNextSubpass(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->contents);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdNextSubpass(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->contents);
 }
 
 #ifdef _WIN64
@@ -45652,7 +46719,7 @@ static void thunk64_vkCmdNextSubpass2(vo
 {
     struct vkCmdNextSubpass2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdNextSubpass2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSubpassBeginInfo, params->pSubpassEndInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdNextSubpass2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSubpassBeginInfo, params->pSubpassEndInfo);
 }
 #endif /* _WIN64 */
 
@@ -45672,7 +46739,7 @@ static void thunk32_vkCmdNextSubpass2(vo
     init_conversion_context(ctx);
     convert_VkSubpassBeginInfo_win32_to_host((const VkSubpassBeginInfo32 *)UlongToPtr(params->pSubpassBeginInfo), &pSubpassBeginInfo_host);
     convert_VkSubpassEndInfo_win32_to_host(ctx, (const VkSubpassEndInfo32 *)UlongToPtr(params->pSubpassEndInfo), &pSubpassEndInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdNextSubpass2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSubpassBeginInfo_host, &pSubpassEndInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdNextSubpass2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSubpassBeginInfo_host, &pSubpassEndInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45681,7 +46748,7 @@ static void thunk64_vkCmdNextSubpass2KHR
 {
     struct vkCmdNextSubpass2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdNextSubpass2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSubpassBeginInfo, params->pSubpassEndInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdNextSubpass2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSubpassBeginInfo, params->pSubpassEndInfo);
 }
 #endif /* _WIN64 */
 
@@ -45701,7 +46768,7 @@ static void thunk32_vkCmdNextSubpass2KHR
     init_conversion_context(ctx);
     convert_VkSubpassBeginInfo_win32_to_host((const VkSubpassBeginInfo32 *)UlongToPtr(params->pSubpassBeginInfo), &pSubpassBeginInfo_host);
     convert_VkSubpassEndInfo_win32_to_host(ctx, (const VkSubpassEndInfo32 *)UlongToPtr(params->pSubpassEndInfo), &pSubpassEndInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdNextSubpass2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSubpassBeginInfo_host, &pSubpassEndInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdNextSubpass2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSubpassBeginInfo_host, &pSubpassEndInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45710,7 +46777,7 @@ static void thunk64_vkCmdOpticalFlowExec
 {
     struct vkCmdOpticalFlowExecuteNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdOpticalFlowExecuteNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->session, params->pExecuteInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdOpticalFlowExecuteNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->session, params->pExecuteInfo);
 }
 #endif /* _WIN64 */
 
@@ -45725,7 +46792,7 @@ static void thunk32_vkCmdOpticalFlowExec
     VkOpticalFlowExecuteInfoNV pExecuteInfo_host;
 
     convert_VkOpticalFlowExecuteInfoNV_win32_to_host((const VkOpticalFlowExecuteInfoNV32 *)UlongToPtr(params->pExecuteInfo), &pExecuteInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdOpticalFlowExecuteNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->session, &pExecuteInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdOpticalFlowExecuteNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->session, &pExecuteInfo_host);
 }
 
 #ifdef _WIN64
@@ -45733,7 +46800,7 @@ static void thunk64_vkCmdPipelineBarrier
 {
     struct vkCmdPipelineBarrier_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPipelineBarrier(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcStageMask, params->dstStageMask, params->dependencyFlags, params->memoryBarrierCount, params->pMemoryBarriers, params->bufferMemoryBarrierCount, params->pBufferMemoryBarriers, params->imageMemoryBarrierCount, params->pImageMemoryBarriers);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPipelineBarrier(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcStageMask, params->dstStageMask, params->dependencyFlags, params->memoryBarrierCount, params->pMemoryBarriers, params->bufferMemoryBarrierCount, params->pBufferMemoryBarriers, params->imageMemoryBarrierCount, params->pImageMemoryBarriers);
 }
 #endif /* _WIN64 */
 
@@ -45762,7 +46829,7 @@ static void thunk32_vkCmdPipelineBarrier
     pMemoryBarriers_host = convert_VkMemoryBarrier_array_win32_to_host(ctx, (const VkMemoryBarrier32 *)UlongToPtr(params->pMemoryBarriers), params->memoryBarrierCount);
     pBufferMemoryBarriers_host = convert_VkBufferMemoryBarrier_array_win32_to_host(ctx, (const VkBufferMemoryBarrier32 *)UlongToPtr(params->pBufferMemoryBarriers), params->bufferMemoryBarrierCount);
     pImageMemoryBarriers_host = convert_VkImageMemoryBarrier_array_win32_to_host(ctx, (const VkImageMemoryBarrier32 *)UlongToPtr(params->pImageMemoryBarriers), params->imageMemoryBarrierCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPipelineBarrier(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcStageMask, params->dstStageMask, params->dependencyFlags, params->memoryBarrierCount, pMemoryBarriers_host, params->bufferMemoryBarrierCount, pBufferMemoryBarriers_host, params->imageMemoryBarrierCount, pImageMemoryBarriers_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPipelineBarrier(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcStageMask, params->dstStageMask, params->dependencyFlags, params->memoryBarrierCount, pMemoryBarriers_host, params->bufferMemoryBarrierCount, pBufferMemoryBarriers_host, params->imageMemoryBarrierCount, pImageMemoryBarriers_host);
     free_conversion_context(ctx);
 }
 
@@ -45771,7 +46838,7 @@ static void thunk64_vkCmdPipelineBarrier
 {
     struct vkCmdPipelineBarrier2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPipelineBarrier2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDependencyInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPipelineBarrier2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDependencyInfo);
 }
 #endif /* _WIN64 */
 
@@ -45788,7 +46855,7 @@ static void thunk32_vkCmdPipelineBarrier
 
     init_conversion_context(ctx);
     convert_VkDependencyInfo_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfo), &pDependencyInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPipelineBarrier2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDependencyInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPipelineBarrier2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDependencyInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45797,7 +46864,7 @@ static void thunk64_vkCmdPipelineBarrier
 {
     struct vkCmdPipelineBarrier2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPipelineBarrier2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDependencyInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPipelineBarrier2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDependencyInfo);
 }
 #endif /* _WIN64 */
 
@@ -45814,7 +46881,7 @@ static void thunk32_vkCmdPipelineBarrier
 
     init_conversion_context(ctx);
     convert_VkDependencyInfo_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfo), &pDependencyInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPipelineBarrier2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDependencyInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPipelineBarrier2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDependencyInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45823,7 +46890,7 @@ static void thunk64_vkCmdPreprocessGener
 {
     struct vkCmdPreprocessGeneratedCommandsEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPreprocessGeneratedCommandsEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pGeneratedCommandsInfo, vulkan_command_buffer_from_handle(params->stateCommandBuffer)->host.command_buffer);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPreprocessGeneratedCommandsEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pGeneratedCommandsInfo, wine_cmd_buffer_from_handle(params->stateCommandBuffer)->host.command_buffer);
 }
 #endif /* _WIN64 */
 
@@ -45841,7 +46908,7 @@ static void thunk32_vkCmdPreprocessGener
 
     init_conversion_context(ctx);
     convert_VkGeneratedCommandsInfoEXT_win32_to_host(ctx, (const VkGeneratedCommandsInfoEXT32 *)UlongToPtr(params->pGeneratedCommandsInfo), &pGeneratedCommandsInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPreprocessGeneratedCommandsEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pGeneratedCommandsInfo_host, vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->stateCommandBuffer))->host.command_buffer);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPreprocessGeneratedCommandsEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pGeneratedCommandsInfo_host, wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->stateCommandBuffer))->host.command_buffer);
     free_conversion_context(ctx);
 }
 
@@ -45850,7 +46917,7 @@ static void thunk64_vkCmdPreprocessGener
 {
     struct vkCmdPreprocessGeneratedCommandsNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPreprocessGeneratedCommandsNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pGeneratedCommandsInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPreprocessGeneratedCommandsNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pGeneratedCommandsInfo);
 }
 #endif /* _WIN64 */
 
@@ -45867,7 +46934,7 @@ static void thunk32_vkCmdPreprocessGener
 
     init_conversion_context(ctx);
     convert_VkGeneratedCommandsInfoNV_win32_to_host(ctx, (const VkGeneratedCommandsInfoNV32 *)UlongToPtr(params->pGeneratedCommandsInfo), &pGeneratedCommandsInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPreprocessGeneratedCommandsNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pGeneratedCommandsInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPreprocessGeneratedCommandsNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pGeneratedCommandsInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45876,7 +46943,7 @@ static void thunk64_vkCmdPushConstants(v
 {
     struct vkCmdPushConstants_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushConstants(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->layout, params->stageFlags, params->offset, params->size, params->pValues);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushConstants(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->layout, params->stageFlags, params->offset, params->size, params->pValues);
 }
 #endif /* _WIN64 */
 
@@ -45892,7 +46959,7 @@ static void thunk32_vkCmdPushConstants(v
         PTR32 pValues;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushConstants(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->layout, params->stageFlags, params->offset, params->size, (const void *)UlongToPtr(params->pValues));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushConstants(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->layout, params->stageFlags, params->offset, params->size, (const void *)UlongToPtr(params->pValues));
 }
 
 #ifdef _WIN64
@@ -45900,7 +46967,7 @@ static void thunk64_vkCmdPushConstants2(
 {
     struct vkCmdPushConstants2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushConstants2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushConstantsInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushConstants2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushConstantsInfo);
 }
 #endif /* _WIN64 */
 
@@ -45917,7 +46984,7 @@ static void thunk32_vkCmdPushConstants2(
 
     init_conversion_context(ctx);
     convert_VkPushConstantsInfo_win32_to_host(ctx, (const VkPushConstantsInfo32 *)UlongToPtr(params->pPushConstantsInfo), &pPushConstantsInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushConstants2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushConstantsInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushConstants2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushConstantsInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45926,7 +46993,7 @@ static void thunk64_vkCmdPushConstants2K
 {
     struct vkCmdPushConstants2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushConstants2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushConstantsInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushConstants2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushConstantsInfo);
 }
 #endif /* _WIN64 */
 
@@ -45943,7 +47010,7 @@ static void thunk32_vkCmdPushConstants2K
 
     init_conversion_context(ctx);
     convert_VkPushConstantsInfo_win32_to_host(ctx, (const VkPushConstantsInfo32 *)UlongToPtr(params->pPushConstantsInfo), &pPushConstantsInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushConstants2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushConstantsInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushConstants2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushConstantsInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -45952,7 +47019,7 @@ static void thunk64_vkCmdPushDescriptorS
 {
     struct vkCmdPushDescriptorSet_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSet(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->set, params->descriptorWriteCount, params->pDescriptorWrites);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSet(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->set, params->descriptorWriteCount, params->pDescriptorWrites);
 }
 #endif /* _WIN64 */
 
@@ -45973,7 +47040,7 @@ static void thunk32_vkCmdPushDescriptorS
 
     init_conversion_context(ctx);
     pDescriptorWrites_host = convert_VkWriteDescriptorSet_array_win32_to_host(ctx, (const VkWriteDescriptorSet32 *)UlongToPtr(params->pDescriptorWrites), params->descriptorWriteCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSet(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->set, params->descriptorWriteCount, pDescriptorWrites_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSet(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->set, params->descriptorWriteCount, pDescriptorWrites_host);
     free_conversion_context(ctx);
 }
 
@@ -45982,7 +47049,7 @@ static void thunk64_vkCmdPushDescriptorS
 {
     struct vkCmdPushDescriptorSet2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSet2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushDescriptorSetInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSet2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushDescriptorSetInfo);
 }
 #endif /* _WIN64 */
 
@@ -45999,7 +47066,7 @@ static void thunk32_vkCmdPushDescriptorS
 
     init_conversion_context(ctx);
     convert_VkPushDescriptorSetInfo_win32_to_host(ctx, (const VkPushDescriptorSetInfo32 *)UlongToPtr(params->pPushDescriptorSetInfo), &pPushDescriptorSetInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSet2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushDescriptorSetInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSet2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushDescriptorSetInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -46008,7 +47075,7 @@ static void thunk64_vkCmdPushDescriptorS
 {
     struct vkCmdPushDescriptorSet2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSet2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushDescriptorSetInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSet2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushDescriptorSetInfo);
 }
 #endif /* _WIN64 */
 
@@ -46025,7 +47092,7 @@ static void thunk32_vkCmdPushDescriptorS
 
     init_conversion_context(ctx);
     convert_VkPushDescriptorSetInfo_win32_to_host(ctx, (const VkPushDescriptorSetInfo32 *)UlongToPtr(params->pPushDescriptorSetInfo), &pPushDescriptorSetInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSet2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushDescriptorSetInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSet2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushDescriptorSetInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -46034,7 +47101,7 @@ static void thunk64_vkCmdPushDescriptorS
 {
     struct vkCmdPushDescriptorSetKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->set, params->descriptorWriteCount, params->pDescriptorWrites);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->set, params->descriptorWriteCount, params->pDescriptorWrites);
 }
 #endif /* _WIN64 */
 
@@ -46055,7 +47122,7 @@ static void thunk32_vkCmdPushDescriptorS
 
     init_conversion_context(ctx);
     pDescriptorWrites_host = convert_VkWriteDescriptorSet_array_win32_to_host(ctx, (const VkWriteDescriptorSet32 *)UlongToPtr(params->pDescriptorWrites), params->descriptorWriteCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->set, params->descriptorWriteCount, pDescriptorWrites_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->set, params->descriptorWriteCount, pDescriptorWrites_host);
     free_conversion_context(ctx);
 }
 
@@ -46064,7 +47131,7 @@ static void thunk64_vkCmdPushDescriptorS
 {
     struct vkCmdPushDescriptorSetWithTemplate_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetWithTemplate(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->descriptorUpdateTemplate, params->layout, params->set, params->pData);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetWithTemplate(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->descriptorUpdateTemplate, params->layout, params->set, params->pData);
 }
 #endif /* _WIN64 */
 
@@ -46079,7 +47146,7 @@ static void thunk32_vkCmdPushDescriptorS
         PTR32 pData;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetWithTemplate(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->descriptorUpdateTemplate, params->layout, params->set, (const void *)UlongToPtr(params->pData));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetWithTemplate(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->descriptorUpdateTemplate, params->layout, params->set, (const void *)UlongToPtr(params->pData));
 }
 
 #ifdef _WIN64
@@ -46087,7 +47154,7 @@ static void thunk64_vkCmdPushDescriptorS
 {
     struct vkCmdPushDescriptorSetWithTemplate2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetWithTemplate2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushDescriptorSetWithTemplateInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetWithTemplate2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushDescriptorSetWithTemplateInfo);
 }
 #endif /* _WIN64 */
 
@@ -46104,7 +47171,7 @@ static void thunk32_vkCmdPushDescriptorS
 
     init_conversion_context(ctx);
     convert_VkPushDescriptorSetWithTemplateInfo_win32_to_host(ctx, (const VkPushDescriptorSetWithTemplateInfo32 *)UlongToPtr(params->pPushDescriptorSetWithTemplateInfo), &pPushDescriptorSetWithTemplateInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetWithTemplate2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushDescriptorSetWithTemplateInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetWithTemplate2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushDescriptorSetWithTemplateInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -46113,7 +47180,7 @@ static void thunk64_vkCmdPushDescriptorS
 {
     struct vkCmdPushDescriptorSetWithTemplate2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetWithTemplate2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushDescriptorSetWithTemplateInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetWithTemplate2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pPushDescriptorSetWithTemplateInfo);
 }
 #endif /* _WIN64 */
 
@@ -46130,7 +47197,7 @@ static void thunk32_vkCmdPushDescriptorS
 
     init_conversion_context(ctx);
     convert_VkPushDescriptorSetWithTemplateInfo_win32_to_host(ctx, (const VkPushDescriptorSetWithTemplateInfo32 *)UlongToPtr(params->pPushDescriptorSetWithTemplateInfo), &pPushDescriptorSetWithTemplateInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetWithTemplate2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushDescriptorSetWithTemplateInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetWithTemplate2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pPushDescriptorSetWithTemplateInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -46139,7 +47206,7 @@ static void thunk64_vkCmdPushDescriptorS
 {
     struct vkCmdPushDescriptorSetWithTemplateKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetWithTemplateKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->descriptorUpdateTemplate, params->layout, params->set, params->pData);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdPushDescriptorSetWithTemplateKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->descriptorUpdateTemplate, params->layout, params->set, params->pData);
 }
 #endif /* _WIN64 */
 
@@ -46154,7 +47221,7 @@ static void thunk32_vkCmdPushDescriptorS
         PTR32 pData;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetWithTemplateKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->descriptorUpdateTemplate, params->layout, params->set, (const void *)UlongToPtr(params->pData));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdPushDescriptorSetWithTemplateKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->descriptorUpdateTemplate, params->layout, params->set, (const void *)UlongToPtr(params->pData));
 }
 
 #ifdef _WIN64
@@ -46162,7 +47229,7 @@ static void thunk64_vkCmdResetEvent(void
 {
     struct vkCmdResetEvent_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResetEvent(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->stageMask);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResetEvent(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->stageMask);
 }
 #endif /* _WIN64 */
 
@@ -46175,7 +47242,7 @@ static void thunk32_vkCmdResetEvent(void
         VkPipelineStageFlags stageMask;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResetEvent(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, params->stageMask);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResetEvent(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, params->stageMask);
 }
 
 #ifdef _WIN64
@@ -46183,7 +47250,7 @@ static void thunk64_vkCmdResetEvent2(voi
 {
     struct vkCmdResetEvent2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResetEvent2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->stageMask);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResetEvent2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->stageMask);
 }
 #endif /* _WIN64 */
 
@@ -46196,7 +47263,7 @@ static void thunk32_vkCmdResetEvent2(voi
         VkPipelineStageFlags2 DECLSPEC_ALIGN(8) stageMask;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResetEvent2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, params->stageMask);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResetEvent2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, params->stageMask);
 }
 
 #ifdef _WIN64
@@ -46204,7 +47271,7 @@ static void thunk64_vkCmdResetEvent2KHR(
 {
     struct vkCmdResetEvent2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResetEvent2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->stageMask);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResetEvent2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->stageMask);
 }
 #endif /* _WIN64 */
 
@@ -46217,7 +47284,7 @@ static void thunk32_vkCmdResetEvent2KHR(
         VkPipelineStageFlags2 DECLSPEC_ALIGN(8) stageMask;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResetEvent2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, params->stageMask);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResetEvent2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, params->stageMask);
 }
 
 #ifdef _WIN64
@@ -46225,7 +47292,7 @@ static void thunk64_vkCmdResetQueryPool(
 {
     struct vkCmdResetQueryPool_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResetQueryPool(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->firstQuery, params->queryCount);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResetQueryPool(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->queryPool, params->firstQuery, params->queryCount);
 }
 #endif /* _WIN64 */
 
@@ -46239,7 +47306,7 @@ static void thunk32_vkCmdResetQueryPool(
         uint32_t queryCount;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResetQueryPool(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->firstQuery, params->queryCount);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResetQueryPool(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->queryPool, params->firstQuery, params->queryCount);
 }
 
 #ifdef _WIN64
@@ -46247,7 +47314,7 @@ static void thunk64_vkCmdResolveImage(vo
 {
     struct vkCmdResolveImage_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResolveImage(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResolveImage(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, params->pRegions);
 }
 #endif /* _WIN64 */
 
@@ -46264,7 +47331,7 @@ static void thunk32_vkCmdResolveImage(vo
         PTR32 pRegions;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResolveImage(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, (const VkImageResolve *)UlongToPtr(params->pRegions));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResolveImage(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->srcImage, params->srcImageLayout, params->dstImage, params->dstImageLayout, params->regionCount, (const VkImageResolve *)UlongToPtr(params->pRegions));
 }
 
 #ifdef _WIN64
@@ -46272,7 +47339,7 @@ static void thunk64_vkCmdResolveImage2(v
 {
     struct vkCmdResolveImage2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResolveImage2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pResolveImageInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResolveImage2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pResolveImageInfo);
 }
 #endif /* _WIN64 */
 
@@ -46289,7 +47356,7 @@ static void thunk32_vkCmdResolveImage2(v
 
     init_conversion_context(ctx);
     convert_VkResolveImageInfo2_win32_to_host(ctx, (const VkResolveImageInfo232 *)UlongToPtr(params->pResolveImageInfo), &pResolveImageInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResolveImage2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pResolveImageInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResolveImage2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pResolveImageInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -46298,7 +47365,7 @@ static void thunk64_vkCmdResolveImage2KH
 {
     struct vkCmdResolveImage2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResolveImage2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pResolveImageInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdResolveImage2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pResolveImageInfo);
 }
 #endif /* _WIN64 */
 
@@ -46315,7 +47382,7 @@ static void thunk32_vkCmdResolveImage2KH
 
     init_conversion_context(ctx);
     convert_VkResolveImageInfo2_win32_to_host(ctx, (const VkResolveImageInfo232 *)UlongToPtr(params->pResolveImageInfo), &pResolveImageInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResolveImage2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pResolveImageInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdResolveImage2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pResolveImageInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -46324,7 +47391,7 @@ static void thunk64_vkCmdSetAlphaToCover
 {
     struct vkCmdSetAlphaToCoverageEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetAlphaToCoverageEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->alphaToCoverageEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetAlphaToCoverageEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->alphaToCoverageEnable);
 }
 #endif /* _WIN64 */
 
@@ -46336,7 +47403,7 @@ static void thunk32_vkCmdSetAlphaToCover
         VkBool32 alphaToCoverageEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetAlphaToCoverageEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->alphaToCoverageEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetAlphaToCoverageEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->alphaToCoverageEnable);
 }
 
 #ifdef _WIN64
@@ -46344,7 +47411,7 @@ static void thunk64_vkCmdSetAlphaToOneEn
 {
     struct vkCmdSetAlphaToOneEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetAlphaToOneEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->alphaToOneEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetAlphaToOneEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->alphaToOneEnable);
 }
 #endif /* _WIN64 */
 
@@ -46356,7 +47423,7 @@ static void thunk32_vkCmdSetAlphaToOneEn
         VkBool32 alphaToOneEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetAlphaToOneEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->alphaToOneEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetAlphaToOneEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->alphaToOneEnable);
 }
 
 #ifdef _WIN64
@@ -46364,7 +47431,7 @@ static void thunk64_vkCmdSetAttachmentFe
 {
     struct vkCmdSetAttachmentFeedbackLoopEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetAttachmentFeedbackLoopEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->aspectMask);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetAttachmentFeedbackLoopEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->aspectMask);
 }
 #endif /* _WIN64 */
 
@@ -46376,7 +47443,7 @@ static void thunk32_vkCmdSetAttachmentFe
         VkImageAspectFlags aspectMask;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetAttachmentFeedbackLoopEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->aspectMask);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetAttachmentFeedbackLoopEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->aspectMask);
 }
 
 #ifdef _WIN64
@@ -46384,7 +47451,7 @@ static void thunk64_vkCmdSetBlendConstan
 {
     struct vkCmdSetBlendConstants_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetBlendConstants(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->blendConstants);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetBlendConstants(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->blendConstants);
 }
 #endif /* _WIN64 */
 
@@ -46396,7 +47463,7 @@ static void thunk32_vkCmdSetBlendConstan
         PTR32 blendConstants;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetBlendConstants(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, (const float *)UlongToPtr(params->blendConstants));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetBlendConstants(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, (const float *)UlongToPtr(params->blendConstants));
 }
 
 #ifdef _WIN64
@@ -46404,7 +47471,7 @@ static void thunk64_vkCmdSetCheckpointNV
 {
     struct vkCmdSetCheckpointNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCheckpointNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCheckpointMarker);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCheckpointNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pCheckpointMarker);
 }
 #endif /* _WIN64 */
 
@@ -46416,7 +47483,7 @@ static void thunk32_vkCmdSetCheckpointNV
         PTR32 pCheckpointMarker;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCheckpointNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, (const void *)UlongToPtr(params->pCheckpointMarker));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCheckpointNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, (const void *)UlongToPtr(params->pCheckpointMarker));
 }
 
 #ifdef _WIN64
@@ -46424,7 +47491,7 @@ static void thunk64_vkCmdSetCoarseSample
 {
     struct vkCmdSetCoarseSampleOrderNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoarseSampleOrderNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->sampleOrderType, params->customSampleOrderCount, params->pCustomSampleOrders);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoarseSampleOrderNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->sampleOrderType, params->customSampleOrderCount, params->pCustomSampleOrders);
 }
 #endif /* _WIN64 */
 
@@ -46443,7 +47510,7 @@ static void thunk32_vkCmdSetCoarseSample
 
     init_conversion_context(ctx);
     pCustomSampleOrders_host = convert_VkCoarseSampleOrderCustomNV_array_win32_to_host(ctx, (const VkCoarseSampleOrderCustomNV32 *)UlongToPtr(params->pCustomSampleOrders), params->customSampleOrderCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoarseSampleOrderNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->sampleOrderType, params->customSampleOrderCount, pCustomSampleOrders_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoarseSampleOrderNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->sampleOrderType, params->customSampleOrderCount, pCustomSampleOrders_host);
     free_conversion_context(ctx);
 }
 
@@ -46452,7 +47519,7 @@ static void thunk64_vkCmdSetColorBlendAd
 {
     struct vkCmdSetColorBlendAdvancedEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorBlendAdvancedEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstAttachment, params->attachmentCount, params->pColorBlendAdvanced);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorBlendAdvancedEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstAttachment, params->attachmentCount, params->pColorBlendAdvanced);
 }
 #endif /* _WIN64 */
 
@@ -46466,7 +47533,7 @@ static void thunk32_vkCmdSetColorBlendAd
         PTR32 pColorBlendAdvanced;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorBlendAdvancedEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstAttachment, params->attachmentCount, (const VkColorBlendAdvancedEXT *)UlongToPtr(params->pColorBlendAdvanced));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorBlendAdvancedEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstAttachment, params->attachmentCount, (const VkColorBlendAdvancedEXT *)UlongToPtr(params->pColorBlendAdvanced));
 }
 
 #ifdef _WIN64
@@ -46474,7 +47541,7 @@ static void thunk64_vkCmdSetColorBlendEn
 {
     struct vkCmdSetColorBlendEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorBlendEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstAttachment, params->attachmentCount, params->pColorBlendEnables);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorBlendEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstAttachment, params->attachmentCount, params->pColorBlendEnables);
 }
 #endif /* _WIN64 */
 
@@ -46488,7 +47555,7 @@ static void thunk32_vkCmdSetColorBlendEn
         PTR32 pColorBlendEnables;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorBlendEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstAttachment, params->attachmentCount, (const VkBool32 *)UlongToPtr(params->pColorBlendEnables));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorBlendEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstAttachment, params->attachmentCount, (const VkBool32 *)UlongToPtr(params->pColorBlendEnables));
 }
 
 #ifdef _WIN64
@@ -46496,7 +47563,7 @@ static void thunk64_vkCmdSetColorBlendEq
 {
     struct vkCmdSetColorBlendEquationEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorBlendEquationEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstAttachment, params->attachmentCount, params->pColorBlendEquations);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorBlendEquationEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstAttachment, params->attachmentCount, params->pColorBlendEquations);
 }
 #endif /* _WIN64 */
 
@@ -46510,7 +47577,7 @@ static void thunk32_vkCmdSetColorBlendEq
         PTR32 pColorBlendEquations;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorBlendEquationEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstAttachment, params->attachmentCount, (const VkColorBlendEquationEXT *)UlongToPtr(params->pColorBlendEquations));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorBlendEquationEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstAttachment, params->attachmentCount, (const VkColorBlendEquationEXT *)UlongToPtr(params->pColorBlendEquations));
 }
 
 #ifdef _WIN64
@@ -46518,7 +47585,7 @@ static void thunk64_vkCmdSetColorWriteEn
 {
     struct vkCmdSetColorWriteEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorWriteEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->attachmentCount, params->pColorWriteEnables);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorWriteEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->attachmentCount, params->pColorWriteEnables);
 }
 #endif /* _WIN64 */
 
@@ -46531,7 +47598,7 @@ static void thunk32_vkCmdSetColorWriteEn
         PTR32 pColorWriteEnables;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorWriteEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->attachmentCount, (const VkBool32 *)UlongToPtr(params->pColorWriteEnables));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorWriteEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->attachmentCount, (const VkBool32 *)UlongToPtr(params->pColorWriteEnables));
 }
 
 #ifdef _WIN64
@@ -46539,7 +47606,7 @@ static void thunk64_vkCmdSetColorWriteMa
 {
     struct vkCmdSetColorWriteMaskEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorWriteMaskEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstAttachment, params->attachmentCount, params->pColorWriteMasks);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetColorWriteMaskEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstAttachment, params->attachmentCount, params->pColorWriteMasks);
 }
 #endif /* _WIN64 */
 
@@ -46553,7 +47620,7 @@ static void thunk32_vkCmdSetColorWriteMa
         PTR32 pColorWriteMasks;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorWriteMaskEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstAttachment, params->attachmentCount, (const VkColorComponentFlags *)UlongToPtr(params->pColorWriteMasks));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetColorWriteMaskEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstAttachment, params->attachmentCount, (const VkColorComponentFlags *)UlongToPtr(params->pColorWriteMasks));
 }
 
 #ifdef _WIN64
@@ -46561,7 +47628,7 @@ static void thunk64_vkCmdSetConservative
 {
     struct vkCmdSetConservativeRasterizationModeEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetConservativeRasterizationModeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->conservativeRasterizationMode);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetConservativeRasterizationModeEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->conservativeRasterizationMode);
 }
 #endif /* _WIN64 */
 
@@ -46573,7 +47640,7 @@ static void thunk32_vkCmdSetConservative
         VkConservativeRasterizationModeEXT conservativeRasterizationMode;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetConservativeRasterizationModeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->conservativeRasterizationMode);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetConservativeRasterizationModeEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->conservativeRasterizationMode);
 }
 
 #ifdef _WIN64
@@ -46581,7 +47648,7 @@ static void thunk64_vkCmdSetCoverageModu
 {
     struct vkCmdSetCoverageModulationModeNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageModulationModeNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageModulationMode);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageModulationModeNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageModulationMode);
 }
 #endif /* _WIN64 */
 
@@ -46593,7 +47660,7 @@ static void thunk32_vkCmdSetCoverageModu
         VkCoverageModulationModeNV coverageModulationMode;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageModulationModeNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageModulationMode);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageModulationModeNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageModulationMode);
 }
 
 #ifdef _WIN64
@@ -46601,7 +47668,7 @@ static void thunk64_vkCmdSetCoverageModu
 {
     struct vkCmdSetCoverageModulationTableEnableNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageModulationTableEnableNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageModulationTableEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageModulationTableEnableNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageModulationTableEnable);
 }
 #endif /* _WIN64 */
 
@@ -46613,7 +47680,7 @@ static void thunk32_vkCmdSetCoverageModu
         VkBool32 coverageModulationTableEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageModulationTableEnableNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageModulationTableEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageModulationTableEnableNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageModulationTableEnable);
 }
 
 #ifdef _WIN64
@@ -46621,7 +47688,7 @@ static void thunk64_vkCmdSetCoverageModu
 {
     struct vkCmdSetCoverageModulationTableNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageModulationTableNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageModulationTableCount, params->pCoverageModulationTable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageModulationTableNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageModulationTableCount, params->pCoverageModulationTable);
 }
 #endif /* _WIN64 */
 
@@ -46634,7 +47701,7 @@ static void thunk32_vkCmdSetCoverageModu
         PTR32 pCoverageModulationTable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageModulationTableNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageModulationTableCount, (const float *)UlongToPtr(params->pCoverageModulationTable));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageModulationTableNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageModulationTableCount, (const float *)UlongToPtr(params->pCoverageModulationTable));
 }
 
 #ifdef _WIN64
@@ -46642,7 +47709,7 @@ static void thunk64_vkCmdSetCoverageRedu
 {
     struct vkCmdSetCoverageReductionModeNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageReductionModeNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageReductionMode);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageReductionModeNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageReductionMode);
 }
 #endif /* _WIN64 */
 
@@ -46654,7 +47721,7 @@ static void thunk32_vkCmdSetCoverageRedu
         VkCoverageReductionModeNV coverageReductionMode;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageReductionModeNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageReductionMode);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageReductionModeNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageReductionMode);
 }
 
 #ifdef _WIN64
@@ -46662,7 +47729,7 @@ static void thunk64_vkCmdSetCoverageToCo
 {
     struct vkCmdSetCoverageToColorEnableNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageToColorEnableNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageToColorEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageToColorEnableNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageToColorEnable);
 }
 #endif /* _WIN64 */
 
@@ -46674,7 +47741,7 @@ static void thunk32_vkCmdSetCoverageToCo
         VkBool32 coverageToColorEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageToColorEnableNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageToColorEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageToColorEnableNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageToColorEnable);
 }
 
 #ifdef _WIN64
@@ -46682,7 +47749,7 @@ static void thunk64_vkCmdSetCoverageToCo
 {
     struct vkCmdSetCoverageToColorLocationNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageToColorLocationNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageToColorLocation);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCoverageToColorLocationNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->coverageToColorLocation);
 }
 #endif /* _WIN64 */
 
@@ -46694,7 +47761,7 @@ static void thunk32_vkCmdSetCoverageToCo
         uint32_t coverageToColorLocation;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageToColorLocationNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageToColorLocation);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCoverageToColorLocationNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->coverageToColorLocation);
 }
 
 #ifdef _WIN64
@@ -46702,7 +47769,7 @@ static void thunk64_vkCmdSetCullMode(voi
 {
     struct vkCmdSetCullMode_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCullMode(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->cullMode);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCullMode(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->cullMode);
 }
 #endif /* _WIN64 */
 
@@ -46714,7 +47781,7 @@ static void thunk32_vkCmdSetCullMode(voi
         VkCullModeFlags cullMode;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCullMode(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->cullMode);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCullMode(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->cullMode);
 }
 
 #ifdef _WIN64
@@ -46722,7 +47789,7 @@ static void thunk64_vkCmdSetCullModeEXT(
 {
     struct vkCmdSetCullModeEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCullModeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->cullMode);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetCullModeEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->cullMode);
 }
 #endif /* _WIN64 */
 
@@ -46734,7 +47801,7 @@ static void thunk32_vkCmdSetCullModeEXT(
         VkCullModeFlags cullMode;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCullModeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->cullMode);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetCullModeEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->cullMode);
 }
 
 #ifdef _WIN64
@@ -46742,7 +47809,7 @@ static void thunk64_vkCmdSetDepthBias(vo
 {
     struct vkCmdSetDepthBias_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBias(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBiasConstantFactor, params->depthBiasClamp, params->depthBiasSlopeFactor);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBias(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBiasConstantFactor, params->depthBiasClamp, params->depthBiasSlopeFactor);
 }
 #endif /* _WIN64 */
 
@@ -46756,7 +47823,7 @@ static void thunk32_vkCmdSetDepthBias(vo
         float depthBiasSlopeFactor;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBias(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBiasConstantFactor, params->depthBiasClamp, params->depthBiasSlopeFactor);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBias(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBiasConstantFactor, params->depthBiasClamp, params->depthBiasSlopeFactor);
 }
 
 #ifdef _WIN64
@@ -46764,7 +47831,7 @@ static void thunk64_vkCmdSetDepthBias2EX
 {
     struct vkCmdSetDepthBias2EXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBias2EXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDepthBiasInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBias2EXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pDepthBiasInfo);
 }
 #endif /* _WIN64 */
 
@@ -46781,7 +47848,7 @@ static void thunk32_vkCmdSetDepthBias2EX
 
     init_conversion_context(ctx);
     convert_VkDepthBiasInfoEXT_win32_to_host(ctx, (const VkDepthBiasInfoEXT32 *)UlongToPtr(params->pDepthBiasInfo), &pDepthBiasInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBias2EXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDepthBiasInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBias2EXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pDepthBiasInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -46790,7 +47857,7 @@ static void thunk64_vkCmdSetDepthBiasEna
 {
     struct vkCmdSetDepthBiasEnable_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBiasEnable(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBiasEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBiasEnable(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBiasEnable);
 }
 #endif /* _WIN64 */
 
@@ -46802,7 +47869,7 @@ static void thunk32_vkCmdSetDepthBiasEna
         VkBool32 depthBiasEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBiasEnable(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBiasEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBiasEnable(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBiasEnable);
 }
 
 #ifdef _WIN64
@@ -46810,7 +47877,7 @@ static void thunk64_vkCmdSetDepthBiasEna
 {
     struct vkCmdSetDepthBiasEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBiasEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBiasEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBiasEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBiasEnable);
 }
 #endif /* _WIN64 */
 
@@ -46822,7 +47889,7 @@ static void thunk32_vkCmdSetDepthBiasEna
         VkBool32 depthBiasEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBiasEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBiasEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBiasEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBiasEnable);
 }
 
 #ifdef _WIN64
@@ -46830,7 +47897,7 @@ static void thunk64_vkCmdSetDepthBounds(
 {
     struct vkCmdSetDepthBounds_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBounds(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->minDepthBounds, params->maxDepthBounds);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBounds(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->minDepthBounds, params->maxDepthBounds);
 }
 #endif /* _WIN64 */
 
@@ -46843,7 +47910,7 @@ static void thunk32_vkCmdSetDepthBounds(
         float maxDepthBounds;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBounds(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->minDepthBounds, params->maxDepthBounds);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBounds(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->minDepthBounds, params->maxDepthBounds);
 }
 
 #ifdef _WIN64
@@ -46851,7 +47918,7 @@ static void thunk64_vkCmdSetDepthBoundsT
 {
     struct vkCmdSetDepthBoundsTestEnable_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBoundsTestEnable(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBoundsTestEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBoundsTestEnable(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBoundsTestEnable);
 }
 #endif /* _WIN64 */
 
@@ -46863,7 +47930,7 @@ static void thunk32_vkCmdSetDepthBoundsT
         VkBool32 depthBoundsTestEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBoundsTestEnable(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBoundsTestEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBoundsTestEnable(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBoundsTestEnable);
 }
 
 #ifdef _WIN64
@@ -46871,7 +47938,7 @@ static void thunk64_vkCmdSetDepthBoundsT
 {
     struct vkCmdSetDepthBoundsTestEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBoundsTestEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBoundsTestEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthBoundsTestEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthBoundsTestEnable);
 }
 #endif /* _WIN64 */
 
@@ -46883,7 +47950,7 @@ static void thunk32_vkCmdSetDepthBoundsT
         VkBool32 depthBoundsTestEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBoundsTestEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBoundsTestEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthBoundsTestEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthBoundsTestEnable);
 }
 
 #ifdef _WIN64
@@ -46891,7 +47958,7 @@ static void thunk64_vkCmdSetDepthClampEn
 {
     struct vkCmdSetDepthClampEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthClampEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthClampEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthClampEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthClampEnable);
 }
 #endif /* _WIN64 */
 
@@ -46903,7 +47970,7 @@ static void thunk32_vkCmdSetDepthClampEn
         VkBool32 depthClampEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthClampEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthClampEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthClampEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthClampEnable);
 }
 
 #ifdef _WIN64
@@ -46911,7 +47978,7 @@ static void thunk64_vkCmdSetDepthClampRa
 {
     struct vkCmdSetDepthClampRangeEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthClampRangeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthClampMode, params->pDepthClampRange);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthClampRangeEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthClampMode, params->pDepthClampRange);
 }
 #endif /* _WIN64 */
 
@@ -46924,7 +47991,7 @@ static void thunk32_vkCmdSetDepthClampRa
         PTR32 pDepthClampRange;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthClampRangeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthClampMode, (const VkDepthClampRangeEXT *)UlongToPtr(params->pDepthClampRange));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthClampRangeEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthClampMode, (const VkDepthClampRangeEXT *)UlongToPtr(params->pDepthClampRange));
 }
 
 #ifdef _WIN64
@@ -46932,7 +47999,7 @@ static void thunk64_vkCmdSetDepthClipEna
 {
     struct vkCmdSetDepthClipEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthClipEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthClipEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthClipEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthClipEnable);
 }
 #endif /* _WIN64 */
 
@@ -46944,7 +48011,7 @@ static void thunk32_vkCmdSetDepthClipEna
         VkBool32 depthClipEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthClipEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthClipEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthClipEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthClipEnable);
 }
 
 #ifdef _WIN64
@@ -46952,7 +48019,7 @@ static void thunk64_vkCmdSetDepthClipNeg
 {
     struct vkCmdSetDepthClipNegativeOneToOneEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthClipNegativeOneToOneEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->negativeOneToOne);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthClipNegativeOneToOneEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->negativeOneToOne);
 }
 #endif /* _WIN64 */
 
@@ -46964,7 +48031,7 @@ static void thunk32_vkCmdSetDepthClipNeg
         VkBool32 negativeOneToOne;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthClipNegativeOneToOneEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->negativeOneToOne);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthClipNegativeOneToOneEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->negativeOneToOne);
 }
 
 #ifdef _WIN64
@@ -46972,7 +48039,7 @@ static void thunk64_vkCmdSetDepthCompare
 {
     struct vkCmdSetDepthCompareOp_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthCompareOp(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthCompareOp);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthCompareOp(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthCompareOp);
 }
 #endif /* _WIN64 */
 
@@ -46984,7 +48051,7 @@ static void thunk32_vkCmdSetDepthCompare
         VkCompareOp depthCompareOp;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthCompareOp(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthCompareOp);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthCompareOp(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthCompareOp);
 }
 
 #ifdef _WIN64
@@ -46992,7 +48059,7 @@ static void thunk64_vkCmdSetDepthCompare
 {
     struct vkCmdSetDepthCompareOpEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthCompareOpEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthCompareOp);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthCompareOpEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthCompareOp);
 }
 #endif /* _WIN64 */
 
@@ -47004,7 +48071,7 @@ static void thunk32_vkCmdSetDepthCompare
         VkCompareOp depthCompareOp;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthCompareOpEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthCompareOp);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthCompareOpEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthCompareOp);
 }
 
 #ifdef _WIN64
@@ -47012,7 +48079,7 @@ static void thunk64_vkCmdSetDepthTestEna
 {
     struct vkCmdSetDepthTestEnable_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthTestEnable(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthTestEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthTestEnable(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthTestEnable);
 }
 #endif /* _WIN64 */
 
@@ -47024,7 +48091,7 @@ static void thunk32_vkCmdSetDepthTestEna
         VkBool32 depthTestEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthTestEnable(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthTestEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthTestEnable(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthTestEnable);
 }
 
 #ifdef _WIN64
@@ -47032,7 +48099,7 @@ static void thunk64_vkCmdSetDepthTestEna
 {
     struct vkCmdSetDepthTestEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthTestEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthTestEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthTestEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthTestEnable);
 }
 #endif /* _WIN64 */
 
@@ -47044,7 +48111,7 @@ static void thunk32_vkCmdSetDepthTestEna
         VkBool32 depthTestEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthTestEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthTestEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthTestEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthTestEnable);
 }
 
 #ifdef _WIN64
@@ -47052,7 +48119,7 @@ static void thunk64_vkCmdSetDepthWriteEn
 {
     struct vkCmdSetDepthWriteEnable_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthWriteEnable(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthWriteEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthWriteEnable(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthWriteEnable);
 }
 #endif /* _WIN64 */
 
@@ -47064,7 +48131,7 @@ static void thunk32_vkCmdSetDepthWriteEn
         VkBool32 depthWriteEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthWriteEnable(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthWriteEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthWriteEnable(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthWriteEnable);
 }
 
 #ifdef _WIN64
@@ -47072,7 +48139,7 @@ static void thunk64_vkCmdSetDepthWriteEn
 {
     struct vkCmdSetDepthWriteEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthWriteEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthWriteEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDepthWriteEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->depthWriteEnable);
 }
 #endif /* _WIN64 */
 
@@ -47084,7 +48151,7 @@ static void thunk32_vkCmdSetDepthWriteEn
         VkBool32 depthWriteEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthWriteEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthWriteEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDepthWriteEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->depthWriteEnable);
 }
 
 #ifdef _WIN64
@@ -47092,7 +48159,7 @@ static void thunk64_vkCmdSetDescriptorBu
 {
     struct vkCmdSetDescriptorBufferOffsets2EXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDescriptorBufferOffsets2EXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSetDescriptorBufferOffsetsInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDescriptorBufferOffsets2EXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSetDescriptorBufferOffsetsInfo);
 }
 #endif /* _WIN64 */
 
@@ -47109,7 +48176,7 @@ static void thunk32_vkCmdSetDescriptorBu
 
     init_conversion_context(ctx);
     convert_VkSetDescriptorBufferOffsetsInfoEXT_win32_to_host(ctx, (const VkSetDescriptorBufferOffsetsInfoEXT32 *)UlongToPtr(params->pSetDescriptorBufferOffsetsInfo), &pSetDescriptorBufferOffsetsInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDescriptorBufferOffsets2EXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSetDescriptorBufferOffsetsInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDescriptorBufferOffsets2EXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSetDescriptorBufferOffsetsInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -47118,7 +48185,7 @@ static void thunk64_vkCmdSetDescriptorBu
 {
     struct vkCmdSetDescriptorBufferOffsetsEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDescriptorBufferOffsetsEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->setCount, params->pBufferIndices, params->pOffsets);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDescriptorBufferOffsetsEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->setCount, params->pBufferIndices, params->pOffsets);
 }
 #endif /* _WIN64 */
 
@@ -47135,7 +48202,7 @@ static void thunk32_vkCmdSetDescriptorBu
         PTR32 pOffsets;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDescriptorBufferOffsetsEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->setCount, (const uint32_t *)UlongToPtr(params->pBufferIndices), (const VkDeviceSize *)UlongToPtr(params->pOffsets));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDescriptorBufferOffsetsEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->layout, params->firstSet, params->setCount, (const uint32_t *)UlongToPtr(params->pBufferIndices), (const VkDeviceSize *)UlongToPtr(params->pOffsets));
 }
 
 #ifdef _WIN64
@@ -47143,7 +48210,7 @@ static void thunk64_vkCmdSetDeviceMask(v
 {
     struct vkCmdSetDeviceMask_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDeviceMask(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->deviceMask);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDeviceMask(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->deviceMask);
 }
 #endif /* _WIN64 */
 
@@ -47155,7 +48222,7 @@ static void thunk32_vkCmdSetDeviceMask(v
         uint32_t deviceMask;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDeviceMask(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->deviceMask);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDeviceMask(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->deviceMask);
 }
 
 #ifdef _WIN64
@@ -47163,7 +48230,7 @@ static void thunk64_vkCmdSetDeviceMaskKH
 {
     struct vkCmdSetDeviceMaskKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDeviceMaskKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->deviceMask);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDeviceMaskKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->deviceMask);
 }
 #endif /* _WIN64 */
 
@@ -47175,7 +48242,7 @@ static void thunk32_vkCmdSetDeviceMaskKH
         uint32_t deviceMask;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDeviceMaskKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->deviceMask);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDeviceMaskKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->deviceMask);
 }
 
 #ifdef _WIN64
@@ -47183,7 +48250,7 @@ static void thunk64_vkCmdSetDiscardRecta
 {
     struct vkCmdSetDiscardRectangleEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDiscardRectangleEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstDiscardRectangle, params->discardRectangleCount, params->pDiscardRectangles);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDiscardRectangleEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstDiscardRectangle, params->discardRectangleCount, params->pDiscardRectangles);
 }
 #endif /* _WIN64 */
 
@@ -47197,7 +48264,7 @@ static void thunk32_vkCmdSetDiscardRecta
         PTR32 pDiscardRectangles;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDiscardRectangleEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstDiscardRectangle, params->discardRectangleCount, (const VkRect2D *)UlongToPtr(params->pDiscardRectangles));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDiscardRectangleEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstDiscardRectangle, params->discardRectangleCount, (const VkRect2D *)UlongToPtr(params->pDiscardRectangles));
 }
 
 #ifdef _WIN64
@@ -47205,7 +48272,7 @@ static void thunk64_vkCmdSetDiscardRecta
 {
     struct vkCmdSetDiscardRectangleEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDiscardRectangleEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->discardRectangleEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDiscardRectangleEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->discardRectangleEnable);
 }
 #endif /* _WIN64 */
 
@@ -47217,7 +48284,7 @@ static void thunk32_vkCmdSetDiscardRecta
         VkBool32 discardRectangleEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDiscardRectangleEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->discardRectangleEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDiscardRectangleEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->discardRectangleEnable);
 }
 
 #ifdef _WIN64
@@ -47225,7 +48292,7 @@ static void thunk64_vkCmdSetDiscardRecta
 {
     struct vkCmdSetDiscardRectangleModeEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDiscardRectangleModeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->discardRectangleMode);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetDiscardRectangleModeEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->discardRectangleMode);
 }
 #endif /* _WIN64 */
 
@@ -47237,7 +48304,7 @@ static void thunk32_vkCmdSetDiscardRecta
         VkDiscardRectangleModeEXT discardRectangleMode;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDiscardRectangleModeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->discardRectangleMode);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetDiscardRectangleModeEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->discardRectangleMode);
 }
 
 #ifdef _WIN64
@@ -47245,7 +48312,7 @@ static void thunk64_vkCmdSetEvent(void *
 {
     struct vkCmdSetEvent_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetEvent(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->stageMask);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetEvent(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->stageMask);
 }
 #endif /* _WIN64 */
 
@@ -47258,7 +48325,7 @@ static void thunk32_vkCmdSetEvent(void *
         VkPipelineStageFlags stageMask;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetEvent(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, params->stageMask);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetEvent(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, params->stageMask);
 }
 
 #ifdef _WIN64
@@ -47266,7 +48333,7 @@ static void thunk64_vkCmdSetEvent2(void
 {
     struct vkCmdSetEvent2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetEvent2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->pDependencyInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetEvent2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->pDependencyInfo);
 }
 #endif /* _WIN64 */
 
@@ -47284,7 +48351,7 @@ static void thunk32_vkCmdSetEvent2(void
 
     init_conversion_context(ctx);
     convert_VkDependencyInfo_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfo), &pDependencyInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetEvent2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, &pDependencyInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetEvent2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, &pDependencyInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -47293,7 +48360,7 @@ static void thunk64_vkCmdSetEvent2KHR(vo
 {
     struct vkCmdSetEvent2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetEvent2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->pDependencyInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetEvent2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->event, params->pDependencyInfo);
 }
 #endif /* _WIN64 */
 
@@ -47311,7 +48378,7 @@ static void thunk32_vkCmdSetEvent2KHR(vo
 
     init_conversion_context(ctx);
     convert_VkDependencyInfo_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfo), &pDependencyInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetEvent2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, &pDependencyInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetEvent2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->event, &pDependencyInfo_host);
     free_conversion_context(ctx);
 }
 
@@ -47320,7 +48387,7 @@ static void thunk64_vkCmdSetExclusiveSci
 {
     struct vkCmdSetExclusiveScissorEnableNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetExclusiveScissorEnableNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, params->pExclusiveScissorEnables);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetExclusiveScissorEnableNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, params->pExclusiveScissorEnables);
 }
 #endif /* _WIN64 */
 
@@ -47334,7 +48401,7 @@ static void thunk32_vkCmdSetExclusiveSci
         PTR32 pExclusiveScissorEnables;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetExclusiveScissorEnableNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, (const VkBool32 *)UlongToPtr(params->pExclusiveScissorEnables));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetExclusiveScissorEnableNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, (const VkBool32 *)UlongToPtr(params->pExclusiveScissorEnables));
 }
 
 #ifdef _WIN64
@@ -47342,7 +48409,7 @@ static void thunk64_vkCmdSetExclusiveSci
 {
     struct vkCmdSetExclusiveScissorNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetExclusiveScissorNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, params->pExclusiveScissors);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetExclusiveScissorNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, params->pExclusiveScissors);
 }
 #endif /* _WIN64 */
 
@@ -47356,7 +48423,7 @@ static void thunk32_vkCmdSetExclusiveSci
         PTR32 pExclusiveScissors;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetExclusiveScissorNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, (const VkRect2D *)UlongToPtr(params->pExclusiveScissors));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetExclusiveScissorNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstExclusiveScissor, params->exclusiveScissorCount, (const VkRect2D *)UlongToPtr(params->pExclusiveScissors));
 }
 
 #ifdef _WIN64
@@ -47364,7 +48431,7 @@ static void thunk64_vkCmdSetExtraPrimiti
 {
     struct vkCmdSetExtraPrimitiveOverestimationSizeEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetExtraPrimitiveOverestimationSizeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->extraPrimitiveOverestimationSize);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetExtraPrimitiveOverestimationSizeEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->extraPrimitiveOverestimationSize);
 }
 #endif /* _WIN64 */
 
@@ -47376,7 +48443,7 @@ static void thunk32_vkCmdSetExtraPrimiti
         float extraPrimitiveOverestimationSize;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetExtraPrimitiveOverestimationSizeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->extraPrimitiveOverestimationSize);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetExtraPrimitiveOverestimationSizeEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->extraPrimitiveOverestimationSize);
 }
 
 #ifdef _WIN64
@@ -47384,7 +48451,7 @@ static void thunk64_vkCmdSetFragmentShad
 {
     struct vkCmdSetFragmentShadingRateEnumNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetFragmentShadingRateEnumNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->shadingRate, params->combinerOps);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetFragmentShadingRateEnumNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->shadingRate, params->combinerOps);
 }
 #endif /* _WIN64 */
 
@@ -47397,7 +48464,7 @@ static void thunk32_vkCmdSetFragmentShad
         PTR32 combinerOps;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetFragmentShadingRateEnumNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->shadingRate, (const VkFragmentShadingRateCombinerOpKHR *)UlongToPtr(params->combinerOps));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetFragmentShadingRateEnumNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->shadingRate, (const VkFragmentShadingRateCombinerOpKHR *)UlongToPtr(params->combinerOps));
 }
 
 #ifdef _WIN64
@@ -47405,7 +48472,7 @@ static void thunk64_vkCmdSetFragmentShad
 {
     struct vkCmdSetFragmentShadingRateKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetFragmentShadingRateKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pFragmentSize, params->combinerOps);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetFragmentShadingRateKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pFragmentSize, params->combinerOps);
 }
 #endif /* _WIN64 */
 
@@ -47418,7 +48485,7 @@ static void thunk32_vkCmdSetFragmentShad
         PTR32 combinerOps;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetFragmentShadingRateKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, (const VkExtent2D *)UlongToPtr(params->pFragmentSize), (const VkFragmentShadingRateCombinerOpKHR *)UlongToPtr(params->combinerOps));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetFragmentShadingRateKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, (const VkExtent2D *)UlongToPtr(params->pFragmentSize), (const VkFragmentShadingRateCombinerOpKHR *)UlongToPtr(params->combinerOps));
 }
 
 #ifdef _WIN64
@@ -47426,7 +48493,7 @@ static void thunk64_vkCmdSetFrontFace(vo
 {
     struct vkCmdSetFrontFace_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetFrontFace(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->frontFace);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetFrontFace(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->frontFace);
 }
 #endif /* _WIN64 */
 
@@ -47438,7 +48505,7 @@ static void thunk32_vkCmdSetFrontFace(vo
         VkFrontFace frontFace;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetFrontFace(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->frontFace);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetFrontFace(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->frontFace);
 }
 
 #ifdef _WIN64
@@ -47446,7 +48513,7 @@ static void thunk64_vkCmdSetFrontFaceEXT
 {
     struct vkCmdSetFrontFaceEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetFrontFaceEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->frontFace);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetFrontFaceEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->frontFace);
 }
 #endif /* _WIN64 */
 
@@ -47458,7 +48525,7 @@ static void thunk32_vkCmdSetFrontFaceEXT
         VkFrontFace frontFace;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetFrontFaceEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->frontFace);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetFrontFaceEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->frontFace);
 }
 
 #ifdef _WIN64
@@ -47466,7 +48533,7 @@ static void thunk64_vkCmdSetLineRasteriz
 {
     struct vkCmdSetLineRasterizationModeEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineRasterizationModeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineRasterizationMode);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineRasterizationModeEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineRasterizationMode);
 }
 #endif /* _WIN64 */
 
@@ -47478,7 +48545,7 @@ static void thunk32_vkCmdSetLineRasteriz
         VkLineRasterizationModeEXT lineRasterizationMode;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineRasterizationModeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineRasterizationMode);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineRasterizationModeEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineRasterizationMode);
 }
 
 #ifdef _WIN64
@@ -47486,7 +48553,7 @@ static void thunk64_vkCmdSetLineStipple(
 {
     struct vkCmdSetLineStipple_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineStipple(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineStipple(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
 }
 #endif /* _WIN64 */
 
@@ -47499,7 +48566,7 @@ static void thunk32_vkCmdSetLineStipple(
         uint16_t lineStipplePattern;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineStipple(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineStipple(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
 }
 
 #ifdef _WIN64
@@ -47507,7 +48574,7 @@ static void thunk64_vkCmdSetLineStippleE
 {
     struct vkCmdSetLineStippleEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineStippleEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineStippleEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
 }
 #endif /* _WIN64 */
 
@@ -47520,7 +48587,7 @@ static void thunk32_vkCmdSetLineStippleE
         uint16_t lineStipplePattern;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineStippleEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineStippleEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
 }
 
 #ifdef _WIN64
@@ -47528,7 +48595,7 @@ static void thunk64_vkCmdSetLineStippleE
 {
     struct vkCmdSetLineStippleEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineStippleEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stippledLineEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineStippleEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stippledLineEnable);
 }
 #endif /* _WIN64 */
 
@@ -47540,7 +48607,7 @@ static void thunk32_vkCmdSetLineStippleE
         VkBool32 stippledLineEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineStippleEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stippledLineEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineStippleEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stippledLineEnable);
 }
 
 #ifdef _WIN64
@@ -47548,7 +48615,7 @@ static void thunk64_vkCmdSetLineStippleK
 {
     struct vkCmdSetLineStippleKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineStippleKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineStippleKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
 }
 #endif /* _WIN64 */
 
@@ -47561,7 +48628,7 @@ static void thunk32_vkCmdSetLineStippleK
         uint16_t lineStipplePattern;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineStippleKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineStippleKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineStippleFactor, params->lineStipplePattern);
 }
 
 #ifdef _WIN64
@@ -47569,7 +48636,7 @@ static void thunk64_vkCmdSetLineWidth(vo
 {
     struct vkCmdSetLineWidth_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineWidth(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineWidth);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLineWidth(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->lineWidth);
 }
 #endif /* _WIN64 */
 
@@ -47581,7 +48648,7 @@ static void thunk32_vkCmdSetLineWidth(vo
         float lineWidth;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineWidth(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineWidth);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLineWidth(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->lineWidth);
 }
 
 #ifdef _WIN64
@@ -47589,7 +48656,7 @@ static void thunk64_vkCmdSetLogicOpEXT(v
 {
     struct vkCmdSetLogicOpEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLogicOpEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->logicOp);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLogicOpEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->logicOp);
 }
 #endif /* _WIN64 */
 
@@ -47601,7 +48668,7 @@ static void thunk32_vkCmdSetLogicOpEXT(v
         VkLogicOp logicOp;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLogicOpEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->logicOp);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLogicOpEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->logicOp);
 }
 
 #ifdef _WIN64
@@ -47609,7 +48676,7 @@ static void thunk64_vkCmdSetLogicOpEnabl
 {
     struct vkCmdSetLogicOpEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLogicOpEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->logicOpEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetLogicOpEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->logicOpEnable);
 }
 #endif /* _WIN64 */
 
@@ -47621,7 +48688,7 @@ static void thunk32_vkCmdSetLogicOpEnabl
         VkBool32 logicOpEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLogicOpEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->logicOpEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetLogicOpEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->logicOpEnable);
 }
 
 #ifdef _WIN64
@@ -47629,7 +48696,7 @@ static void thunk64_vkCmdSetPatchControl
 {
     struct vkCmdSetPatchControlPointsEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPatchControlPointsEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->patchControlPoints);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPatchControlPointsEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->patchControlPoints);
 }
 #endif /* _WIN64 */
 
@@ -47641,7 +48708,7 @@ static void thunk32_vkCmdSetPatchControl
         uint32_t patchControlPoints;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPatchControlPointsEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->patchControlPoints);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPatchControlPointsEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->patchControlPoints);
 }
 
 #ifdef _WIN64
@@ -47651,7 +48718,7 @@ static NTSTATUS thunk64_vkCmdSetPerforma
 
     TRACE("%p, %p\n", params->commandBuffer, params->pMarkerInfo);
 
-    params->result = vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPerformanceMarkerINTEL(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pMarkerInfo);
+    params->result = wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPerformanceMarkerINTEL(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pMarkerInfo);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -47669,7 +48736,7 @@ static NTSTATUS thunk32_vkCmdSetPerforma
     TRACE("%#x, %#x\n", params->commandBuffer, params->pMarkerInfo);
 
     convert_VkPerformanceMarkerInfoINTEL_win32_to_host((const VkPerformanceMarkerInfoINTEL32 *)UlongToPtr(params->pMarkerInfo), &pMarkerInfo_host);
-    params->result = vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPerformanceMarkerINTEL(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pMarkerInfo_host);
+    params->result = wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPerformanceMarkerINTEL(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pMarkerInfo_host);
     return STATUS_SUCCESS;
 }
 
@@ -47680,7 +48747,7 @@ static NTSTATUS thunk64_vkCmdSetPerforma
 
     TRACE("%p, %p\n", params->commandBuffer, params->pOverrideInfo);
 
-    params->result = vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPerformanceOverrideINTEL(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pOverrideInfo);
+    params->result = wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPerformanceOverrideINTEL(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pOverrideInfo);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -47698,7 +48765,7 @@ static NTSTATUS thunk32_vkCmdSetPerforma
     TRACE("%#x, %#x\n", params->commandBuffer, params->pOverrideInfo);
 
     convert_VkPerformanceOverrideInfoINTEL_win32_to_host((const VkPerformanceOverrideInfoINTEL32 *)UlongToPtr(params->pOverrideInfo), &pOverrideInfo_host);
-    params->result = vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPerformanceOverrideINTEL(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pOverrideInfo_host);
+    params->result = wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPerformanceOverrideINTEL(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pOverrideInfo_host);
     return STATUS_SUCCESS;
 }
 
@@ -47709,7 +48776,7 @@ static NTSTATUS thunk64_vkCmdSetPerforma
 
     TRACE("%p, %p\n", params->commandBuffer, params->pMarkerInfo);
 
-    params->result = vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPerformanceStreamMarkerINTEL(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pMarkerInfo);
+    params->result = wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPerformanceStreamMarkerINTEL(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pMarkerInfo);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -47727,7 +48794,7 @@ static NTSTATUS thunk32_vkCmdSetPerforma
     TRACE("%#x, %#x\n", params->commandBuffer, params->pMarkerInfo);
 
     convert_VkPerformanceStreamMarkerInfoINTEL_win32_to_host((const VkPerformanceStreamMarkerInfoINTEL32 *)UlongToPtr(params->pMarkerInfo), &pMarkerInfo_host);
-    params->result = vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPerformanceStreamMarkerINTEL(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pMarkerInfo_host);
+    params->result = wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPerformanceStreamMarkerINTEL(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pMarkerInfo_host);
     return STATUS_SUCCESS;
 }
 
@@ -47736,7 +48803,7 @@ static void thunk64_vkCmdSetPolygonModeE
 {
     struct vkCmdSetPolygonModeEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPolygonModeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->polygonMode);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPolygonModeEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->polygonMode);
 }
 #endif /* _WIN64 */
 
@@ -47748,7 +48815,7 @@ static void thunk32_vkCmdSetPolygonModeE
         VkPolygonMode polygonMode;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPolygonModeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->polygonMode);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPolygonModeEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->polygonMode);
 }
 
 #ifdef _WIN64
@@ -47756,7 +48823,7 @@ static void thunk64_vkCmdSetPrimitiveRes
 {
     struct vkCmdSetPrimitiveRestartEnable_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPrimitiveRestartEnable(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->primitiveRestartEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPrimitiveRestartEnable(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->primitiveRestartEnable);
 }
 #endif /* _WIN64 */
 
@@ -47768,7 +48835,7 @@ static void thunk32_vkCmdSetPrimitiveRes
         VkBool32 primitiveRestartEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPrimitiveRestartEnable(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->primitiveRestartEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPrimitiveRestartEnable(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->primitiveRestartEnable);
 }
 
 #ifdef _WIN64
@@ -47776,7 +48843,7 @@ static void thunk64_vkCmdSetPrimitiveRes
 {
     struct vkCmdSetPrimitiveRestartEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPrimitiveRestartEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->primitiveRestartEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPrimitiveRestartEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->primitiveRestartEnable);
 }
 #endif /* _WIN64 */
 
@@ -47788,7 +48855,7 @@ static void thunk32_vkCmdSetPrimitiveRes
         VkBool32 primitiveRestartEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPrimitiveRestartEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->primitiveRestartEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPrimitiveRestartEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->primitiveRestartEnable);
 }
 
 #ifdef _WIN64
@@ -47796,7 +48863,7 @@ static void thunk64_vkCmdSetPrimitiveTop
 {
     struct vkCmdSetPrimitiveTopology_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPrimitiveTopology(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->primitiveTopology);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPrimitiveTopology(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->primitiveTopology);
 }
 #endif /* _WIN64 */
 
@@ -47808,7 +48875,7 @@ static void thunk32_vkCmdSetPrimitiveTop
         VkPrimitiveTopology primitiveTopology;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPrimitiveTopology(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->primitiveTopology);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPrimitiveTopology(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->primitiveTopology);
 }
 
 #ifdef _WIN64
@@ -47816,7 +48883,7 @@ static void thunk64_vkCmdSetPrimitiveTop
 {
     struct vkCmdSetPrimitiveTopologyEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPrimitiveTopologyEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->primitiveTopology);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetPrimitiveTopologyEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->primitiveTopology);
 }
 #endif /* _WIN64 */
 
@@ -47828,7 +48895,7 @@ static void thunk32_vkCmdSetPrimitiveTop
         VkPrimitiveTopology primitiveTopology;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPrimitiveTopologyEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->primitiveTopology);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetPrimitiveTopologyEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->primitiveTopology);
 }
 
 #ifdef _WIN64
@@ -47836,7 +48903,7 @@ static void thunk64_vkCmdSetProvokingVer
 {
     struct vkCmdSetProvokingVertexModeEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetProvokingVertexModeEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->provokingVertexMode);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetProvokingVertexModeEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->provokingVertexMode);
 }
 #endif /* _WIN64 */
 
@@ -47848,7 +48915,7 @@ static void thunk32_vkCmdSetProvokingVer
         VkProvokingVertexModeEXT provokingVertexMode;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetProvokingVertexModeEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->provokingVertexMode);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetProvokingVertexModeEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->provokingVertexMode);
 }
 
 #ifdef _WIN64
@@ -47856,7 +48923,7 @@ static void thunk64_vkCmdSetRasterizatio
 {
     struct vkCmdSetRasterizationSamplesEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRasterizationSamplesEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->rasterizationSamples);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRasterizationSamplesEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->rasterizationSamples);
 }
 #endif /* _WIN64 */
 
@@ -47868,7 +48935,7 @@ static void thunk32_vkCmdSetRasterizatio
         VkSampleCountFlagBits rasterizationSamples;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRasterizationSamplesEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->rasterizationSamples);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRasterizationSamplesEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->rasterizationSamples);
 }
 
 #ifdef _WIN64
@@ -47876,7 +48943,7 @@ static void thunk64_vkCmdSetRasterizatio
 {
     struct vkCmdSetRasterizationStreamEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRasterizationStreamEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->rasterizationStream);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRasterizationStreamEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->rasterizationStream);
 }
 #endif /* _WIN64 */
 
@@ -47888,7 +48955,7 @@ static void thunk32_vkCmdSetRasterizatio
         uint32_t rasterizationStream;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRasterizationStreamEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->rasterizationStream);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRasterizationStreamEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->rasterizationStream);
 }
 
 #ifdef _WIN64
@@ -47896,7 +48963,7 @@ static void thunk64_vkCmdSetRasterizerDi
 {
     struct vkCmdSetRasterizerDiscardEnable_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRasterizerDiscardEnable(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->rasterizerDiscardEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRasterizerDiscardEnable(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->rasterizerDiscardEnable);
 }
 #endif /* _WIN64 */
 
@@ -47908,7 +48975,7 @@ static void thunk32_vkCmdSetRasterizerDi
         VkBool32 rasterizerDiscardEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRasterizerDiscardEnable(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->rasterizerDiscardEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRasterizerDiscardEnable(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->rasterizerDiscardEnable);
 }
 
 #ifdef _WIN64
@@ -47916,7 +48983,7 @@ static void thunk64_vkCmdSetRasterizerDi
 {
     struct vkCmdSetRasterizerDiscardEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRasterizerDiscardEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->rasterizerDiscardEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRasterizerDiscardEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->rasterizerDiscardEnable);
 }
 #endif /* _WIN64 */
 
@@ -47928,7 +48995,7 @@ static void thunk32_vkCmdSetRasterizerDi
         VkBool32 rasterizerDiscardEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRasterizerDiscardEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->rasterizerDiscardEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRasterizerDiscardEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->rasterizerDiscardEnable);
 }
 
 #ifdef _WIN64
@@ -47936,7 +49003,7 @@ static void thunk64_vkCmdSetRayTracingPi
 {
     struct vkCmdSetRayTracingPipelineStackSizeKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRayTracingPipelineStackSizeKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineStackSize);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRayTracingPipelineStackSizeKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineStackSize);
 }
 #endif /* _WIN64 */
 
@@ -47948,7 +49015,7 @@ static void thunk32_vkCmdSetRayTracingPi
         uint32_t pipelineStackSize;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRayTracingPipelineStackSizeKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineStackSize);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRayTracingPipelineStackSizeKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineStackSize);
 }
 
 #ifdef _WIN64
@@ -47956,7 +49023,7 @@ static void thunk64_vkCmdSetRenderingAtt
 {
     struct vkCmdSetRenderingAttachmentLocations_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRenderingAttachmentLocations(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLocationInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRenderingAttachmentLocations(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLocationInfo);
 }
 #endif /* _WIN64 */
 
@@ -47970,7 +49037,7 @@ static void thunk32_vkCmdSetRenderingAtt
     VkRenderingAttachmentLocationInfo pLocationInfo_host;
 
     convert_VkRenderingAttachmentLocationInfo_win32_to_host((const VkRenderingAttachmentLocationInfo32 *)UlongToPtr(params->pLocationInfo), &pLocationInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRenderingAttachmentLocations(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLocationInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRenderingAttachmentLocations(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLocationInfo_host);
 }
 
 #ifdef _WIN64
@@ -47978,7 +49045,7 @@ static void thunk64_vkCmdSetRenderingAtt
 {
     struct vkCmdSetRenderingAttachmentLocationsKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRenderingAttachmentLocationsKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLocationInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRenderingAttachmentLocationsKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pLocationInfo);
 }
 #endif /* _WIN64 */
 
@@ -47992,7 +49059,7 @@ static void thunk32_vkCmdSetRenderingAtt
     VkRenderingAttachmentLocationInfo pLocationInfo_host;
 
     convert_VkRenderingAttachmentLocationInfo_win32_to_host((const VkRenderingAttachmentLocationInfo32 *)UlongToPtr(params->pLocationInfo), &pLocationInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRenderingAttachmentLocationsKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLocationInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRenderingAttachmentLocationsKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pLocationInfo_host);
 }
 
 #ifdef _WIN64
@@ -48000,7 +49067,7 @@ static void thunk64_vkCmdSetRenderingInp
 {
     struct vkCmdSetRenderingInputAttachmentIndices_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRenderingInputAttachmentIndices(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInputAttachmentIndexInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRenderingInputAttachmentIndices(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInputAttachmentIndexInfo);
 }
 #endif /* _WIN64 */
 
@@ -48014,7 +49081,7 @@ static void thunk32_vkCmdSetRenderingInp
     VkRenderingInputAttachmentIndexInfo pInputAttachmentIndexInfo_host;
 
     convert_VkRenderingInputAttachmentIndexInfo_win32_to_host((const VkRenderingInputAttachmentIndexInfo32 *)UlongToPtr(params->pInputAttachmentIndexInfo), &pInputAttachmentIndexInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRenderingInputAttachmentIndices(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInputAttachmentIndexInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRenderingInputAttachmentIndices(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInputAttachmentIndexInfo_host);
 }
 
 #ifdef _WIN64
@@ -48022,7 +49089,7 @@ static void thunk64_vkCmdSetRenderingInp
 {
     struct vkCmdSetRenderingInputAttachmentIndicesKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRenderingInputAttachmentIndicesKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInputAttachmentIndexInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRenderingInputAttachmentIndicesKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pInputAttachmentIndexInfo);
 }
 #endif /* _WIN64 */
 
@@ -48036,7 +49103,7 @@ static void thunk32_vkCmdSetRenderingInp
     VkRenderingInputAttachmentIndexInfo pInputAttachmentIndexInfo_host;
 
     convert_VkRenderingInputAttachmentIndexInfo_win32_to_host((const VkRenderingInputAttachmentIndexInfo32 *)UlongToPtr(params->pInputAttachmentIndexInfo), &pInputAttachmentIndexInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRenderingInputAttachmentIndicesKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInputAttachmentIndexInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRenderingInputAttachmentIndicesKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pInputAttachmentIndexInfo_host);
 }
 
 #ifdef _WIN64
@@ -48044,7 +49111,7 @@ static void thunk64_vkCmdSetRepresentati
 {
     struct vkCmdSetRepresentativeFragmentTestEnableNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRepresentativeFragmentTestEnableNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->representativeFragmentTestEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetRepresentativeFragmentTestEnableNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->representativeFragmentTestEnable);
 }
 #endif /* _WIN64 */
 
@@ -48056,7 +49123,7 @@ static void thunk32_vkCmdSetRepresentati
         VkBool32 representativeFragmentTestEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRepresentativeFragmentTestEnableNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->representativeFragmentTestEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetRepresentativeFragmentTestEnableNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->representativeFragmentTestEnable);
 }
 
 #ifdef _WIN64
@@ -48064,7 +49131,7 @@ static void thunk64_vkCmdSetSampleLocati
 {
     struct vkCmdSetSampleLocationsEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetSampleLocationsEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSampleLocationsInfo);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetSampleLocationsEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pSampleLocationsInfo);
 }
 #endif /* _WIN64 */
 
@@ -48078,7 +49145,7 @@ static void thunk32_vkCmdSetSampleLocati
     VkSampleLocationsInfoEXT pSampleLocationsInfo_host;
 
     convert_VkSampleLocationsInfoEXT_win32_to_host((const VkSampleLocationsInfoEXT32 *)UlongToPtr(params->pSampleLocationsInfo), &pSampleLocationsInfo_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetSampleLocationsEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSampleLocationsInfo_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetSampleLocationsEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pSampleLocationsInfo_host);
 }
 
 #ifdef _WIN64
@@ -48086,7 +49153,7 @@ static void thunk64_vkCmdSetSampleLocati
 {
     struct vkCmdSetSampleLocationsEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetSampleLocationsEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->sampleLocationsEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetSampleLocationsEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->sampleLocationsEnable);
 }
 #endif /* _WIN64 */
 
@@ -48098,7 +49165,7 @@ static void thunk32_vkCmdSetSampleLocati
         VkBool32 sampleLocationsEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetSampleLocationsEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->sampleLocationsEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetSampleLocationsEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->sampleLocationsEnable);
 }
 
 #ifdef _WIN64
@@ -48106,7 +49173,7 @@ static void thunk64_vkCmdSetSampleMaskEX
 {
     struct vkCmdSetSampleMaskEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetSampleMaskEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->samples, params->pSampleMask);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetSampleMaskEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->samples, params->pSampleMask);
 }
 #endif /* _WIN64 */
 
@@ -48119,7 +49186,7 @@ static void thunk32_vkCmdSetSampleMaskEX
         PTR32 pSampleMask;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetSampleMaskEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->samples, (const VkSampleMask *)UlongToPtr(params->pSampleMask));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetSampleMaskEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->samples, (const VkSampleMask *)UlongToPtr(params->pSampleMask));
 }
 
 #ifdef _WIN64
@@ -48127,7 +49194,7 @@ static void thunk64_vkCmdSetScissor(void
 {
     struct vkCmdSetScissor_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetScissor(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstScissor, params->scissorCount, params->pScissors);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetScissor(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstScissor, params->scissorCount, params->pScissors);
 }
 #endif /* _WIN64 */
 
@@ -48141,7 +49208,7 @@ static void thunk32_vkCmdSetScissor(void
         PTR32 pScissors;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetScissor(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstScissor, params->scissorCount, (const VkRect2D *)UlongToPtr(params->pScissors));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetScissor(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstScissor, params->scissorCount, (const VkRect2D *)UlongToPtr(params->pScissors));
 }
 
 #ifdef _WIN64
@@ -48149,7 +49216,7 @@ static void thunk64_vkCmdSetScissorWithC
 {
     struct vkCmdSetScissorWithCount_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetScissorWithCount(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->scissorCount, params->pScissors);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetScissorWithCount(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->scissorCount, params->pScissors);
 }
 #endif /* _WIN64 */
 
@@ -48162,7 +49229,7 @@ static void thunk32_vkCmdSetScissorWithC
         PTR32 pScissors;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetScissorWithCount(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->scissorCount, (const VkRect2D *)UlongToPtr(params->pScissors));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetScissorWithCount(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->scissorCount, (const VkRect2D *)UlongToPtr(params->pScissors));
 }
 
 #ifdef _WIN64
@@ -48170,7 +49237,7 @@ static void thunk64_vkCmdSetScissorWithC
 {
     struct vkCmdSetScissorWithCountEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetScissorWithCountEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->scissorCount, params->pScissors);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetScissorWithCountEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->scissorCount, params->pScissors);
 }
 #endif /* _WIN64 */
 
@@ -48183,7 +49250,7 @@ static void thunk32_vkCmdSetScissorWithC
         PTR32 pScissors;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetScissorWithCountEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->scissorCount, (const VkRect2D *)UlongToPtr(params->pScissors));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetScissorWithCountEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->scissorCount, (const VkRect2D *)UlongToPtr(params->pScissors));
 }
 
 #ifdef _WIN64
@@ -48191,7 +49258,7 @@ static void thunk64_vkCmdSetShadingRateI
 {
     struct vkCmdSetShadingRateImageEnableNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetShadingRateImageEnableNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->shadingRateImageEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetShadingRateImageEnableNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->shadingRateImageEnable);
 }
 #endif /* _WIN64 */
 
@@ -48203,7 +49270,7 @@ static void thunk32_vkCmdSetShadingRateI
         VkBool32 shadingRateImageEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetShadingRateImageEnableNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->shadingRateImageEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetShadingRateImageEnableNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->shadingRateImageEnable);
 }
 
 #ifdef _WIN64
@@ -48211,7 +49278,7 @@ static void thunk64_vkCmdSetStencilCompa
 {
     struct vkCmdSetStencilCompareMask_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilCompareMask(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->compareMask);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilCompareMask(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->compareMask);
 }
 #endif /* _WIN64 */
 
@@ -48224,7 +49291,7 @@ static void thunk32_vkCmdSetStencilCompa
         uint32_t compareMask;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilCompareMask(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->compareMask);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilCompareMask(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->compareMask);
 }
 
 #ifdef _WIN64
@@ -48232,7 +49299,7 @@ static void thunk64_vkCmdSetStencilOp(vo
 {
     struct vkCmdSetStencilOp_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilOp(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilOp(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
 }
 #endif /* _WIN64 */
 
@@ -48248,7 +49315,7 @@ static void thunk32_vkCmdSetStencilOp(vo
         VkCompareOp compareOp;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilOp(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilOp(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
 }
 
 #ifdef _WIN64
@@ -48256,7 +49323,7 @@ static void thunk64_vkCmdSetStencilOpEXT
 {
     struct vkCmdSetStencilOpEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilOpEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilOpEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
 }
 #endif /* _WIN64 */
 
@@ -48272,7 +49339,7 @@ static void thunk32_vkCmdSetStencilOpEXT
         VkCompareOp compareOp;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilOpEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilOpEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->failOp, params->passOp, params->depthFailOp, params->compareOp);
 }
 
 #ifdef _WIN64
@@ -48280,7 +49347,7 @@ static void thunk64_vkCmdSetStencilRefer
 {
     struct vkCmdSetStencilReference_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilReference(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->reference);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilReference(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->reference);
 }
 #endif /* _WIN64 */
 
@@ -48293,7 +49360,7 @@ static void thunk32_vkCmdSetStencilRefer
         uint32_t reference;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilReference(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->reference);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilReference(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->reference);
 }
 
 #ifdef _WIN64
@@ -48301,7 +49368,7 @@ static void thunk64_vkCmdSetStencilTestE
 {
     struct vkCmdSetStencilTestEnable_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilTestEnable(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stencilTestEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilTestEnable(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stencilTestEnable);
 }
 #endif /* _WIN64 */
 
@@ -48313,7 +49380,7 @@ static void thunk32_vkCmdSetStencilTestE
         VkBool32 stencilTestEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilTestEnable(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stencilTestEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilTestEnable(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stencilTestEnable);
 }
 
 #ifdef _WIN64
@@ -48321,7 +49388,7 @@ static void thunk64_vkCmdSetStencilTestE
 {
     struct vkCmdSetStencilTestEnableEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilTestEnableEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stencilTestEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilTestEnableEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stencilTestEnable);
 }
 #endif /* _WIN64 */
 
@@ -48333,7 +49400,7 @@ static void thunk32_vkCmdSetStencilTestE
         VkBool32 stencilTestEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilTestEnableEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stencilTestEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilTestEnableEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stencilTestEnable);
 }
 
 #ifdef _WIN64
@@ -48341,7 +49408,7 @@ static void thunk64_vkCmdSetStencilWrite
 {
     struct vkCmdSetStencilWriteMask_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilWriteMask(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->writeMask);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetStencilWriteMask(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->faceMask, params->writeMask);
 }
 #endif /* _WIN64 */
 
@@ -48354,7 +49421,7 @@ static void thunk32_vkCmdSetStencilWrite
         uint32_t writeMask;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilWriteMask(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->writeMask);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetStencilWriteMask(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->faceMask, params->writeMask);
 }
 
 #ifdef _WIN64
@@ -48362,7 +49429,7 @@ static void thunk64_vkCmdSetTessellation
 {
     struct vkCmdSetTessellationDomainOriginEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetTessellationDomainOriginEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->domainOrigin);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetTessellationDomainOriginEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->domainOrigin);
 }
 #endif /* _WIN64 */
 
@@ -48374,7 +49441,7 @@ static void thunk32_vkCmdSetTessellation
         VkTessellationDomainOrigin domainOrigin;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetTessellationDomainOriginEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->domainOrigin);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetTessellationDomainOriginEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->domainOrigin);
 }
 
 #ifdef _WIN64
@@ -48382,7 +49449,7 @@ static void thunk64_vkCmdSetVertexInputE
 {
     struct vkCmdSetVertexInputEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetVertexInputEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->vertexBindingDescriptionCount, params->pVertexBindingDescriptions, params->vertexAttributeDescriptionCount, params->pVertexAttributeDescriptions);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetVertexInputEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->vertexBindingDescriptionCount, params->pVertexBindingDescriptions, params->vertexAttributeDescriptionCount, params->pVertexAttributeDescriptions);
 }
 #endif /* _WIN64 */
 
@@ -48404,7 +49471,7 @@ static void thunk32_vkCmdSetVertexInputE
     init_conversion_context(ctx);
     pVertexBindingDescriptions_host = convert_VkVertexInputBindingDescription2EXT_array_win32_to_host(ctx, (const VkVertexInputBindingDescription2EXT32 *)UlongToPtr(params->pVertexBindingDescriptions), params->vertexBindingDescriptionCount);
     pVertexAttributeDescriptions_host = convert_VkVertexInputAttributeDescription2EXT_array_win32_to_host(ctx, (const VkVertexInputAttributeDescription2EXT32 *)UlongToPtr(params->pVertexAttributeDescriptions), params->vertexAttributeDescriptionCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetVertexInputEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->vertexBindingDescriptionCount, pVertexBindingDescriptions_host, params->vertexAttributeDescriptionCount, pVertexAttributeDescriptions_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetVertexInputEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->vertexBindingDescriptionCount, pVertexBindingDescriptions_host, params->vertexAttributeDescriptionCount, pVertexAttributeDescriptions_host);
     free_conversion_context(ctx);
 }
 
@@ -48413,7 +49480,7 @@ static void thunk64_vkCmdSetViewport(voi
 {
     struct vkCmdSetViewport_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewport(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstViewport, params->viewportCount, params->pViewports);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewport(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstViewport, params->viewportCount, params->pViewports);
 }
 #endif /* _WIN64 */
 
@@ -48427,7 +49494,7 @@ static void thunk32_vkCmdSetViewport(voi
         PTR32 pViewports;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewport(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstViewport, params->viewportCount, (const VkViewport *)UlongToPtr(params->pViewports));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewport(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstViewport, params->viewportCount, (const VkViewport *)UlongToPtr(params->pViewports));
 }
 
 #ifdef _WIN64
@@ -48435,7 +49502,7 @@ static void thunk64_vkCmdSetViewportShad
 {
     struct vkCmdSetViewportShadingRatePaletteNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportShadingRatePaletteNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstViewport, params->viewportCount, params->pShadingRatePalettes);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportShadingRatePaletteNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstViewport, params->viewportCount, params->pShadingRatePalettes);
 }
 #endif /* _WIN64 */
 
@@ -48454,7 +49521,7 @@ static void thunk32_vkCmdSetViewportShad
 
     init_conversion_context(ctx);
     pShadingRatePalettes_host = convert_VkShadingRatePaletteNV_array_win32_to_host(ctx, (const VkShadingRatePaletteNV32 *)UlongToPtr(params->pShadingRatePalettes), params->viewportCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportShadingRatePaletteNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstViewport, params->viewportCount, pShadingRatePalettes_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportShadingRatePaletteNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstViewport, params->viewportCount, pShadingRatePalettes_host);
     free_conversion_context(ctx);
 }
 
@@ -48463,7 +49530,7 @@ static void thunk64_vkCmdSetViewportSwiz
 {
     struct vkCmdSetViewportSwizzleNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportSwizzleNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstViewport, params->viewportCount, params->pViewportSwizzles);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportSwizzleNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstViewport, params->viewportCount, params->pViewportSwizzles);
 }
 #endif /* _WIN64 */
 
@@ -48477,7 +49544,7 @@ static void thunk32_vkCmdSetViewportSwiz
         PTR32 pViewportSwizzles;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportSwizzleNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstViewport, params->viewportCount, (const VkViewportSwizzleNV *)UlongToPtr(params->pViewportSwizzles));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportSwizzleNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstViewport, params->viewportCount, (const VkViewportSwizzleNV *)UlongToPtr(params->pViewportSwizzles));
 }
 
 #ifdef _WIN64
@@ -48485,7 +49552,7 @@ static void thunk64_vkCmdSetViewportWSca
 {
     struct vkCmdSetViewportWScalingEnableNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportWScalingEnableNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->viewportWScalingEnable);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportWScalingEnableNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->viewportWScalingEnable);
 }
 #endif /* _WIN64 */
 
@@ -48497,7 +49564,7 @@ static void thunk32_vkCmdSetViewportWSca
         VkBool32 viewportWScalingEnable;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportWScalingEnableNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->viewportWScalingEnable);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportWScalingEnableNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->viewportWScalingEnable);
 }
 
 #ifdef _WIN64
@@ -48505,7 +49572,7 @@ static void thunk64_vkCmdSetViewportWSca
 {
     struct vkCmdSetViewportWScalingNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportWScalingNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstViewport, params->viewportCount, params->pViewportWScalings);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportWScalingNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->firstViewport, params->viewportCount, params->pViewportWScalings);
 }
 #endif /* _WIN64 */
 
@@ -48519,7 +49586,7 @@ static void thunk32_vkCmdSetViewportWSca
         PTR32 pViewportWScalings;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportWScalingNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstViewport, params->viewportCount, (const VkViewportWScalingNV *)UlongToPtr(params->pViewportWScalings));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportWScalingNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->firstViewport, params->viewportCount, (const VkViewportWScalingNV *)UlongToPtr(params->pViewportWScalings));
 }
 
 #ifdef _WIN64
@@ -48527,7 +49594,7 @@ static void thunk64_vkCmdSetViewportWith
 {
     struct vkCmdSetViewportWithCount_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportWithCount(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->viewportCount, params->pViewports);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportWithCount(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->viewportCount, params->pViewports);
 }
 #endif /* _WIN64 */
 
@@ -48540,7 +49607,7 @@ static void thunk32_vkCmdSetViewportWith
         PTR32 pViewports;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportWithCount(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->viewportCount, (const VkViewport *)UlongToPtr(params->pViewports));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportWithCount(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->viewportCount, (const VkViewport *)UlongToPtr(params->pViewports));
 }
 
 #ifdef _WIN64
@@ -48548,7 +49615,7 @@ static void thunk64_vkCmdSetViewportWith
 {
     struct vkCmdSetViewportWithCountEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportWithCountEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->viewportCount, params->pViewports);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSetViewportWithCountEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->viewportCount, params->pViewports);
 }
 #endif /* _WIN64 */
 
@@ -48561,7 +49628,7 @@ static void thunk32_vkCmdSetViewportWith
         PTR32 pViewports;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportWithCountEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->viewportCount, (const VkViewport *)UlongToPtr(params->pViewports));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSetViewportWithCountEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->viewportCount, (const VkViewport *)UlongToPtr(params->pViewports));
 }
 
 #ifdef _WIN64
@@ -48569,7 +49636,7 @@ static void thunk64_vkCmdSubpassShadingH
 {
     struct vkCmdSubpassShadingHUAWEI_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSubpassShadingHUAWEI(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdSubpassShadingHUAWEI(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer);
 }
 #endif /* _WIN64 */
 
@@ -48580,7 +49647,7 @@ static void thunk32_vkCmdSubpassShadingH
         PTR32 commandBuffer;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSubpassShadingHUAWEI(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdSubpassShadingHUAWEI(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
 }
 
 #ifdef _WIN64
@@ -48588,7 +49655,7 @@ static void thunk64_vkCmdTraceRaysIndire
 {
     struct vkCmdTraceRaysIndirect2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdTraceRaysIndirect2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->indirectDeviceAddress);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdTraceRaysIndirect2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->indirectDeviceAddress);
 }
 #endif /* _WIN64 */
 
@@ -48600,7 +49667,7 @@ static void thunk32_vkCmdTraceRaysIndire
         VkDeviceAddress DECLSPEC_ALIGN(8) indirectDeviceAddress;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdTraceRaysIndirect2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->indirectDeviceAddress);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdTraceRaysIndirect2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->indirectDeviceAddress);
 }
 
 #ifdef _WIN64
@@ -48608,7 +49675,7 @@ static void thunk64_vkCmdTraceRaysIndire
 {
     struct vkCmdTraceRaysIndirectKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdTraceRaysIndirectKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRaygenShaderBindingTable, params->pMissShaderBindingTable, params->pHitShaderBindingTable, params->pCallableShaderBindingTable, params->indirectDeviceAddress);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdTraceRaysIndirectKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRaygenShaderBindingTable, params->pMissShaderBindingTable, params->pHitShaderBindingTable, params->pCallableShaderBindingTable, params->indirectDeviceAddress);
 }
 #endif /* _WIN64 */
 
@@ -48632,7 +49699,7 @@ static void thunk32_vkCmdTraceRaysIndire
     convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pMissShaderBindingTable), &pMissShaderBindingTable_host);
     convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pHitShaderBindingTable), &pHitShaderBindingTable_host);
     convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pCallableShaderBindingTable), &pCallableShaderBindingTable_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdTraceRaysIndirectKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRaygenShaderBindingTable_host, &pMissShaderBindingTable_host, &pHitShaderBindingTable_host, &pCallableShaderBindingTable_host, params->indirectDeviceAddress);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdTraceRaysIndirectKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRaygenShaderBindingTable_host, &pMissShaderBindingTable_host, &pHitShaderBindingTable_host, &pCallableShaderBindingTable_host, params->indirectDeviceAddress);
 }
 
 #ifdef _WIN64
@@ -48640,7 +49707,7 @@ static void thunk64_vkCmdTraceRaysKHR(vo
 {
     struct vkCmdTraceRaysKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdTraceRaysKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRaygenShaderBindingTable, params->pMissShaderBindingTable, params->pHitShaderBindingTable, params->pCallableShaderBindingTable, params->width, params->height, params->depth);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdTraceRaysKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pRaygenShaderBindingTable, params->pMissShaderBindingTable, params->pHitShaderBindingTable, params->pCallableShaderBindingTable, params->width, params->height, params->depth);
 }
 #endif /* _WIN64 */
 
@@ -48666,7 +49733,7 @@ static void thunk32_vkCmdTraceRaysKHR(vo
     convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pMissShaderBindingTable), &pMissShaderBindingTable_host);
     convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pHitShaderBindingTable), &pHitShaderBindingTable_host);
     convert_VkStridedDeviceAddressRegionKHR_win32_to_host((const VkStridedDeviceAddressRegionKHR32 *)UlongToPtr(params->pCallableShaderBindingTable), &pCallableShaderBindingTable_host);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdTraceRaysKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRaygenShaderBindingTable_host, &pMissShaderBindingTable_host, &pHitShaderBindingTable_host, &pCallableShaderBindingTable_host, params->width, params->height, params->depth);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdTraceRaysKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, &pRaygenShaderBindingTable_host, &pMissShaderBindingTable_host, &pHitShaderBindingTable_host, &pCallableShaderBindingTable_host, params->width, params->height, params->depth);
 }
 
 #ifdef _WIN64
@@ -48674,7 +49741,7 @@ static void thunk64_vkCmdTraceRaysNV(voi
 {
     struct vkCmdTraceRaysNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdTraceRaysNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->raygenShaderBindingTableBuffer, params->raygenShaderBindingOffset, params->missShaderBindingTableBuffer, params->missShaderBindingOffset, params->missShaderBindingStride, params->hitShaderBindingTableBuffer, params->hitShaderBindingOffset, params->hitShaderBindingStride, params->callableShaderBindingTableBuffer, params->callableShaderBindingOffset, params->callableShaderBindingStride, params->width, params->height, params->depth);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdTraceRaysNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->raygenShaderBindingTableBuffer, params->raygenShaderBindingOffset, params->missShaderBindingTableBuffer, params->missShaderBindingOffset, params->missShaderBindingStride, params->hitShaderBindingTableBuffer, params->hitShaderBindingOffset, params->hitShaderBindingStride, params->callableShaderBindingTableBuffer, params->callableShaderBindingOffset, params->callableShaderBindingStride, params->width, params->height, params->depth);
 }
 #endif /* _WIN64 */
 
@@ -48699,7 +49766,7 @@ static void thunk32_vkCmdTraceRaysNV(voi
         uint32_t depth;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdTraceRaysNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->raygenShaderBindingTableBuffer, params->raygenShaderBindingOffset, params->missShaderBindingTableBuffer, params->missShaderBindingOffset, params->missShaderBindingStride, params->hitShaderBindingTableBuffer, params->hitShaderBindingOffset, params->hitShaderBindingStride, params->callableShaderBindingTableBuffer, params->callableShaderBindingOffset, params->callableShaderBindingStride, params->width, params->height, params->depth);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdTraceRaysNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->raygenShaderBindingTableBuffer, params->raygenShaderBindingOffset, params->missShaderBindingTableBuffer, params->missShaderBindingOffset, params->missShaderBindingStride, params->hitShaderBindingTableBuffer, params->hitShaderBindingOffset, params->hitShaderBindingStride, params->callableShaderBindingTableBuffer, params->callableShaderBindingOffset, params->callableShaderBindingStride, params->width, params->height, params->depth);
 }
 
 #ifdef _WIN64
@@ -48707,7 +49774,7 @@ static void thunk64_vkCmdUpdateBuffer(vo
 {
     struct vkCmdUpdateBuffer_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdUpdateBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->dstBuffer, params->dstOffset, params->dataSize, params->pData);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdUpdateBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->dstBuffer, params->dstOffset, params->dataSize, params->pData);
 }
 #endif /* _WIN64 */
 
@@ -48722,7 +49789,7 @@ static void thunk32_vkCmdUpdateBuffer(vo
         PTR32 pData;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdUpdateBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->dstBuffer, params->dstOffset, params->dataSize, (const void *)UlongToPtr(params->pData));
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdUpdateBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->dstBuffer, params->dstOffset, params->dataSize, (const void *)UlongToPtr(params->pData));
 }
 
 #ifdef _WIN64
@@ -48730,7 +49797,7 @@ static void thunk64_vkCmdUpdatePipelineI
 {
     struct vkCmdUpdatePipelineIndirectBufferNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdUpdatePipelineIndirectBufferNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->pipeline);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdUpdatePipelineIndirectBufferNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineBindPoint, params->pipeline);
 }
 #endif /* _WIN64 */
 
@@ -48743,7 +49810,7 @@ static void thunk32_vkCmdUpdatePipelineI
         VkPipeline DECLSPEC_ALIGN(8) pipeline;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdUpdatePipelineIndirectBufferNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->pipeline);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdUpdatePipelineIndirectBufferNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineBindPoint, params->pipeline);
 }
 
 #ifdef _WIN64
@@ -48751,7 +49818,7 @@ static void thunk64_vkCmdWaitEvents(void
 {
     struct vkCmdWaitEvents_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWaitEvents(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->eventCount, params->pEvents, params->srcStageMask, params->dstStageMask, params->memoryBarrierCount, params->pMemoryBarriers, params->bufferMemoryBarrierCount, params->pBufferMemoryBarriers, params->imageMemoryBarrierCount, params->pImageMemoryBarriers);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWaitEvents(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->eventCount, params->pEvents, params->srcStageMask, params->dstStageMask, params->memoryBarrierCount, params->pMemoryBarriers, params->bufferMemoryBarrierCount, params->pBufferMemoryBarriers, params->imageMemoryBarrierCount, params->pImageMemoryBarriers);
 }
 #endif /* _WIN64 */
 
@@ -48781,7 +49848,7 @@ static void thunk32_vkCmdWaitEvents(void
     pMemoryBarriers_host = convert_VkMemoryBarrier_array_win32_to_host(ctx, (const VkMemoryBarrier32 *)UlongToPtr(params->pMemoryBarriers), params->memoryBarrierCount);
     pBufferMemoryBarriers_host = convert_VkBufferMemoryBarrier_array_win32_to_host(ctx, (const VkBufferMemoryBarrier32 *)UlongToPtr(params->pBufferMemoryBarriers), params->bufferMemoryBarrierCount);
     pImageMemoryBarriers_host = convert_VkImageMemoryBarrier_array_win32_to_host(ctx, (const VkImageMemoryBarrier32 *)UlongToPtr(params->pImageMemoryBarriers), params->imageMemoryBarrierCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWaitEvents(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->eventCount, (const VkEvent *)UlongToPtr(params->pEvents), params->srcStageMask, params->dstStageMask, params->memoryBarrierCount, pMemoryBarriers_host, params->bufferMemoryBarrierCount, pBufferMemoryBarriers_host, params->imageMemoryBarrierCount, pImageMemoryBarriers_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWaitEvents(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->eventCount, (const VkEvent *)UlongToPtr(params->pEvents), params->srcStageMask, params->dstStageMask, params->memoryBarrierCount, pMemoryBarriers_host, params->bufferMemoryBarrierCount, pBufferMemoryBarriers_host, params->imageMemoryBarrierCount, pImageMemoryBarriers_host);
     free_conversion_context(ctx);
 }
 
@@ -48790,7 +49857,7 @@ static void thunk64_vkCmdWaitEvents2(voi
 {
     struct vkCmdWaitEvents2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWaitEvents2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->eventCount, params->pEvents, params->pDependencyInfos);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWaitEvents2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->eventCount, params->pEvents, params->pDependencyInfos);
 }
 #endif /* _WIN64 */
 
@@ -48809,7 +49876,7 @@ static void thunk32_vkCmdWaitEvents2(voi
 
     init_conversion_context(ctx);
     pDependencyInfos_host = convert_VkDependencyInfo_array_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfos), params->eventCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWaitEvents2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->eventCount, (const VkEvent *)UlongToPtr(params->pEvents), pDependencyInfos_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWaitEvents2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->eventCount, (const VkEvent *)UlongToPtr(params->pEvents), pDependencyInfos_host);
     free_conversion_context(ctx);
 }
 
@@ -48818,7 +49885,7 @@ static void thunk64_vkCmdWaitEvents2KHR(
 {
     struct vkCmdWaitEvents2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWaitEvents2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->eventCount, params->pEvents, params->pDependencyInfos);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWaitEvents2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->eventCount, params->pEvents, params->pDependencyInfos);
 }
 #endif /* _WIN64 */
 
@@ -48837,7 +49904,7 @@ static void thunk32_vkCmdWaitEvents2KHR(
 
     init_conversion_context(ctx);
     pDependencyInfos_host = convert_VkDependencyInfo_array_win32_to_host(ctx, (const VkDependencyInfo32 *)UlongToPtr(params->pDependencyInfos), params->eventCount);
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWaitEvents2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->eventCount, (const VkEvent *)UlongToPtr(params->pEvents), pDependencyInfos_host);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWaitEvents2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->eventCount, (const VkEvent *)UlongToPtr(params->pEvents), pDependencyInfos_host);
     free_conversion_context(ctx);
 }
 
@@ -48846,7 +49913,7 @@ static void thunk64_vkCmdWriteAccelerati
 {
     struct vkCmdWriteAccelerationStructuresPropertiesKHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteAccelerationStructuresPropertiesKHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->accelerationStructureCount, params->pAccelerationStructures, params->queryType, params->queryPool, params->firstQuery);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteAccelerationStructuresPropertiesKHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->accelerationStructureCount, params->pAccelerationStructures, params->queryType, params->queryPool, params->firstQuery);
 }
 #endif /* _WIN64 */
 
@@ -48862,7 +49929,7 @@ static void thunk32_vkCmdWriteAccelerati
         uint32_t firstQuery;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteAccelerationStructuresPropertiesKHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->accelerationStructureCount, (const VkAccelerationStructureKHR *)UlongToPtr(params->pAccelerationStructures), params->queryType, params->queryPool, params->firstQuery);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteAccelerationStructuresPropertiesKHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->accelerationStructureCount, (const VkAccelerationStructureKHR *)UlongToPtr(params->pAccelerationStructures), params->queryType, params->queryPool, params->firstQuery);
 }
 
 #ifdef _WIN64
@@ -48870,7 +49937,7 @@ static void thunk64_vkCmdWriteAccelerati
 {
     struct vkCmdWriteAccelerationStructuresPropertiesNV_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteAccelerationStructuresPropertiesNV(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->accelerationStructureCount, params->pAccelerationStructures, params->queryType, params->queryPool, params->firstQuery);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteAccelerationStructuresPropertiesNV(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->accelerationStructureCount, params->pAccelerationStructures, params->queryType, params->queryPool, params->firstQuery);
 }
 #endif /* _WIN64 */
 
@@ -48886,7 +49953,7 @@ static void thunk32_vkCmdWriteAccelerati
         uint32_t firstQuery;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteAccelerationStructuresPropertiesNV(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->accelerationStructureCount, (const VkAccelerationStructureNV *)UlongToPtr(params->pAccelerationStructures), params->queryType, params->queryPool, params->firstQuery);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteAccelerationStructuresPropertiesNV(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->accelerationStructureCount, (const VkAccelerationStructureNV *)UlongToPtr(params->pAccelerationStructures), params->queryType, params->queryPool, params->firstQuery);
 }
 
 #ifdef _WIN64
@@ -48894,7 +49961,7 @@ static void thunk64_vkCmdWriteBufferMark
 {
     struct vkCmdWriteBufferMarker2AMD_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteBufferMarker2AMD(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stage, params->dstBuffer, params->dstOffset, params->marker);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteBufferMarker2AMD(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stage, params->dstBuffer, params->dstOffset, params->marker);
 }
 #endif /* _WIN64 */
 
@@ -48909,7 +49976,7 @@ static void thunk32_vkCmdWriteBufferMark
         uint32_t marker;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteBufferMarker2AMD(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stage, params->dstBuffer, params->dstOffset, params->marker);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteBufferMarker2AMD(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stage, params->dstBuffer, params->dstOffset, params->marker);
 }
 
 #ifdef _WIN64
@@ -48917,7 +49984,7 @@ static void thunk64_vkCmdWriteBufferMark
 {
     struct vkCmdWriteBufferMarkerAMD_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteBufferMarkerAMD(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineStage, params->dstBuffer, params->dstOffset, params->marker);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteBufferMarkerAMD(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineStage, params->dstBuffer, params->dstOffset, params->marker);
 }
 #endif /* _WIN64 */
 
@@ -48932,7 +49999,7 @@ static void thunk32_vkCmdWriteBufferMark
         uint32_t marker;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteBufferMarkerAMD(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineStage, params->dstBuffer, params->dstOffset, params->marker);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteBufferMarkerAMD(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineStage, params->dstBuffer, params->dstOffset, params->marker);
 }
 
 #ifdef _WIN64
@@ -48940,7 +50007,7 @@ static void thunk64_vkCmdWriteMicromapsP
 {
     struct vkCmdWriteMicromapsPropertiesEXT_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteMicromapsPropertiesEXT(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->micromapCount, params->pMicromaps, params->queryType, params->queryPool, params->firstQuery);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteMicromapsPropertiesEXT(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->micromapCount, params->pMicromaps, params->queryType, params->queryPool, params->firstQuery);
 }
 #endif /* _WIN64 */
 
@@ -48956,7 +50023,7 @@ static void thunk32_vkCmdWriteMicromapsP
         uint32_t firstQuery;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteMicromapsPropertiesEXT(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->micromapCount, (const VkMicromapEXT *)UlongToPtr(params->pMicromaps), params->queryType, params->queryPool, params->firstQuery);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteMicromapsPropertiesEXT(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->micromapCount, (const VkMicromapEXT *)UlongToPtr(params->pMicromaps), params->queryType, params->queryPool, params->firstQuery);
 }
 
 #ifdef _WIN64
@@ -48964,7 +50031,7 @@ static void thunk64_vkCmdWriteTimestamp(
 {
     struct vkCmdWriteTimestamp_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteTimestamp(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineStage, params->queryPool, params->query);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteTimestamp(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->pipelineStage, params->queryPool, params->query);
 }
 #endif /* _WIN64 */
 
@@ -48978,7 +50045,7 @@ static void thunk32_vkCmdWriteTimestamp(
         uint32_t query;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteTimestamp(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineStage, params->queryPool, params->query);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteTimestamp(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->pipelineStage, params->queryPool, params->query);
 }
 
 #ifdef _WIN64
@@ -48986,7 +50053,7 @@ static void thunk64_vkCmdWriteTimestamp2
 {
     struct vkCmdWriteTimestamp2_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteTimestamp2(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stage, params->queryPool, params->query);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteTimestamp2(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stage, params->queryPool, params->query);
 }
 #endif /* _WIN64 */
 
@@ -49000,7 +50067,7 @@ static void thunk32_vkCmdWriteTimestamp2
         uint32_t query;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteTimestamp2(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stage, params->queryPool, params->query);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteTimestamp2(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stage, params->queryPool, params->query);
 }
 
 #ifdef _WIN64
@@ -49008,7 +50075,7 @@ static void thunk64_vkCmdWriteTimestamp2
 {
     struct vkCmdWriteTimestamp2KHR_params *params = args;
 
-    vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteTimestamp2KHR(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stage, params->queryPool, params->query);
+    wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkCmdWriteTimestamp2KHR(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->stage, params->queryPool, params->query);
 }
 #endif /* _WIN64 */
 
@@ -49022,7 +50089,7 @@ static void thunk32_vkCmdWriteTimestamp2
         uint32_t query;
     } *params = args;
 
-    vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteTimestamp2KHR(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stage, params->queryPool, params->query);
+    wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkCmdWriteTimestamp2KHR(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->stage, params->queryPool, params->query);
 }
 
 #ifdef _WIN64
@@ -49542,7 +50609,7 @@ static NTSTATUS thunk64_vkCreateBuffer(v
 
     init_conversion_context(ctx);
     convert_VkBufferCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
-    params->result = vk_funcs->p_vkCreateBuffer(params->device, &pCreateInfo_host, params->pAllocator, params->pBuffer);
+    params->result = wine_vkCreateBuffer(params->device, &pCreateInfo_host, params->pAllocator, params->pBuffer);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -49566,7 +50633,7 @@ static NTSTATUS thunk32_vkCreateBuffer(v
 
     init_conversion_context(ctx);
     convert_VkBufferCreateInfo_win32_to_host(ctx, (const VkBufferCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
-    params->result = vk_funcs->p_vkCreateBuffer((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkBuffer *)UlongToPtr(params->pBuffer));
+    params->result = wine_vkCreateBuffer((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkBuffer *)UlongToPtr(params->pBuffer));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -49613,7 +50680,7 @@ static NTSTATUS thunk64_vkCreateCommandP
 
     TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pCommandPool);
 
-    params->result = wine_vkCreateCommandPool(params->device, params->pCreateInfo, params->pAllocator, params->pCommandPool, params->client_ptr);
+    params->result = wine_vkCreateCommandPool(params->device, params->pCreateInfo, params->pAllocator, params->pCommandPool, (void *)params->client_ptr);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -50068,7 +51135,7 @@ static NTSTATUS thunk64_vkCreateDevice(v
 
     init_conversion_context(ctx);
     convert_VkDeviceCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
-    params->result = wine_vkCreateDevice(params->physicalDevice, &pCreateInfo_host, params->pAllocator, params->pDevice, params->client_ptr);
+    params->result = wine_vkCreateDevice(params->physicalDevice, &pCreateInfo_host, params->pAllocator, params->pDevice, (void *)params->client_ptr);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -50136,16 +51203,10 @@ static NTSTATUS thunk32_vkCreateEvent(vo
 static NTSTATUS thunk64_vkCreateFence(void *args)
 {
     struct vkCreateFence_params *params = args;
-    VkFenceCreateInfo pCreateInfo_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %p, %p, %p\n", params->device, params->pCreateInfo, params->pAllocator, params->pFence);
 
-    init_conversion_context(ctx);
-    convert_VkFenceCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
-    params->result = vk_funcs->p_vkCreateFence(params->device, &pCreateInfo_host, params->pAllocator, params->pFence);
-    free_conversion_context(ctx);
+    params->result = vulkan_device_from_handle(params->device)->p_vkCreateFence(vulkan_device_from_handle(params->device)->host.device, params->pCreateInfo, NULL, params->pFence);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -50168,7 +51229,7 @@ static NTSTATUS thunk32_vkCreateFence(vo
 
     init_conversion_context(ctx);
     convert_VkFenceCreateInfo_win32_to_host(ctx, (const VkFenceCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
-    params->result = vk_funcs->p_vkCreateFence((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkFence *)UlongToPtr(params->pFence));
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkCreateFence(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pCreateInfo_host, NULL, (VkFence *)UlongToPtr(params->pFence));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -50264,7 +51325,7 @@ static NTSTATUS thunk64_vkCreateImage(vo
 
     init_conversion_context(ctx);
     convert_VkImageCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
-    params->result = vk_funcs->p_vkCreateImage(params->device, &pCreateInfo_host, params->pAllocator, params->pImage);
+    params->result = wine_vkCreateImage(params->device, &pCreateInfo_host, params->pAllocator, params->pImage);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -50288,7 +51349,7 @@ static NTSTATUS thunk32_vkCreateImage(vo
 
     init_conversion_context(ctx);
     convert_VkImageCreateInfo_win32_to_host(ctx, (const VkImageCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
-    params->result = vk_funcs->p_vkCreateImage((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkImage *)UlongToPtr(params->pImage));
+    params->result = wine_vkCreateImage((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkImage *)UlongToPtr(params->pImage));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -50445,7 +51506,7 @@ static NTSTATUS thunk64_vkCreateInstance
 
     init_conversion_context(ctx);
     convert_VkInstanceCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
-    params->result = wine_vkCreateInstance(&pCreateInfo_host, params->pAllocator, params->pInstance, params->client_ptr);
+    params->result = wine_vkCreateInstance(&pCreateInfo_host, params->pAllocator, params->pInstance, (void *)params->client_ptr);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -51059,7 +52120,7 @@ static NTSTATUS thunk64_vkCreateSemaphor
 
     init_conversion_context(ctx);
     convert_VkSemaphoreCreateInfo_win64_to_host(ctx, params->pCreateInfo, &pCreateInfo_host);
-    params->result = vk_funcs->p_vkCreateSemaphore(params->device, &pCreateInfo_host, params->pAllocator, params->pSemaphore);
+    params->result = wine_vkCreateSemaphore(params->device, &pCreateInfo_host, params->pAllocator, params->pSemaphore);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -51083,7 +52144,7 @@ static NTSTATUS thunk32_vkCreateSemaphor
 
     init_conversion_context(ctx);
     convert_VkSemaphoreCreateInfo_win32_to_host(ctx, (const VkSemaphoreCreateInfo32 *)UlongToPtr(params->pCreateInfo), &pCreateInfo_host);
-    params->result = vk_funcs->p_vkCreateSemaphore((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkSemaphore *)UlongToPtr(params->pSemaphore));
+    params->result = wine_vkCreateSemaphore((VkDevice)UlongToPtr(params->device), &pCreateInfo_host, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator), (VkSemaphore *)UlongToPtr(params->pSemaphore));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -51988,7 +53049,7 @@ static NTSTATUS thunk64_vkDestroyFence(v
 
     TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->fence), params->pAllocator);
 
-    vk_funcs->p_vkDestroyFence(params->device, params->fence, params->pAllocator);
+    vulkan_device_from_handle(params->device)->p_vkDestroyFence(vulkan_device_from_handle(params->device)->host.device, params->fence, NULL);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -52004,7 +53065,7 @@ static NTSTATUS thunk32_vkDestroyFence(v
 
     TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->fence), params->pAllocator);
 
-    vk_funcs->p_vkDestroyFence((VkDevice)UlongToPtr(params->device), params->fence, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
+    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkDestroyFence(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->fence, NULL);
     return STATUS_SUCCESS;
 }
 
@@ -52560,7 +53621,7 @@ static NTSTATUS thunk64_vkDestroySemapho
 
     TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pAllocator);
 
-    vk_funcs->p_vkDestroySemaphore(params->device, params->semaphore, params->pAllocator);
+    wine_vkDestroySemaphore(params->device, params->semaphore, params->pAllocator);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -52576,7 +53637,7 @@ static NTSTATUS thunk32_vkDestroySemapho
 
     TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pAllocator);
 
-    vk_funcs->p_vkDestroySemaphore((VkDevice)UlongToPtr(params->device), params->semaphore, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
+    wine_vkDestroySemaphore((VkDevice)UlongToPtr(params->device), params->semaphore, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
     return STATUS_SUCCESS;
 }
 
@@ -52856,7 +53917,7 @@ static NTSTATUS thunk64_vkEndCommandBuff
 
     TRACE("%p\n", params->commandBuffer);
 
-    params->result = vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkEndCommandBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer);
+    params->result = wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkEndCommandBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -52871,7 +53932,7 @@ static NTSTATUS thunk32_vkEndCommandBuff
 
     TRACE("%#x\n", params->commandBuffer);
 
-    params->result = vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkEndCommandBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
+    params->result = wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkEndCommandBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer);
     return STATUS_SUCCESS;
 }
 
@@ -53241,7 +54302,7 @@ static NTSTATUS thunk64_vkFreeMemory(voi
 
     TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->memory), params->pAllocator);
 
-    vk_funcs->p_vkFreeMemory(params->device, params->memory, params->pAllocator);
+    wine_vkFreeMemory(params->device, params->memory, params->pAllocator);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -53257,7 +54318,7 @@ static NTSTATUS thunk32_vkFreeMemory(voi
 
     TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->memory), params->pAllocator);
 
-    vk_funcs->p_vkFreeMemory((VkDevice)UlongToPtr(params->device), params->memory, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
+    wine_vkFreeMemory((VkDevice)UlongToPtr(params->device), params->memory, (const VkAllocationCallbacks *)UlongToPtr(params->pAllocator));
     return STATUS_SUCCESS;
 }
 
@@ -54258,7 +55319,7 @@ static NTSTATUS thunk64_vkGetDeviceBuffe
 
     init_conversion_context(ctx);
     convert_VkDeviceBufferMemoryRequirements_win64_to_host(ctx, params->pInfo, &pInfo_host);
-    vk_funcs->p_vkGetDeviceBufferMemoryRequirements(params->device, &pInfo_host, params->pMemoryRequirements);
+    vulkan_device_from_handle(params->device)->p_vkGetDeviceBufferMemoryRequirements(vulkan_device_from_handle(params->device)->host.device, &pInfo_host, params->pMemoryRequirements);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -54282,7 +55343,7 @@ static NTSTATUS thunk32_vkGetDeviceBuffe
     init_conversion_context(ctx);
     convert_VkDeviceBufferMemoryRequirements_win32_to_host(ctx, (const VkDeviceBufferMemoryRequirements32 *)UlongToPtr(params->pInfo), &pInfo_host);
     convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
-    vk_funcs->p_vkGetDeviceBufferMemoryRequirements((VkDevice)UlongToPtr(params->device), &pInfo_host, &pMemoryRequirements_host);
+    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceBufferMemoryRequirements(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, &pMemoryRequirements_host);
     convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
@@ -54300,7 +55361,7 @@ static NTSTATUS thunk64_vkGetDeviceBuffe
 
     init_conversion_context(ctx);
     convert_VkDeviceBufferMemoryRequirements_win64_to_host(ctx, params->pInfo, &pInfo_host);
-    vk_funcs->p_vkGetDeviceBufferMemoryRequirementsKHR(params->device, &pInfo_host, params->pMemoryRequirements);
+    vulkan_device_from_handle(params->device)->p_vkGetDeviceBufferMemoryRequirementsKHR(vulkan_device_from_handle(params->device)->host.device, &pInfo_host, params->pMemoryRequirements);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -54324,7 +55385,7 @@ static NTSTATUS thunk32_vkGetDeviceBuffe
     init_conversion_context(ctx);
     convert_VkDeviceBufferMemoryRequirements_win32_to_host(ctx, (const VkDeviceBufferMemoryRequirements32 *)UlongToPtr(params->pInfo), &pInfo_host);
     convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
-    vk_funcs->p_vkGetDeviceBufferMemoryRequirementsKHR((VkDevice)UlongToPtr(params->device), &pInfo_host, &pMemoryRequirements_host);
+    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceBufferMemoryRequirementsKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, &pMemoryRequirements_host);
     convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
@@ -54500,7 +55561,7 @@ static NTSTATUS thunk64_vkGetDeviceImage
 
     init_conversion_context(ctx);
     convert_VkDeviceImageMemoryRequirements_win64_to_host(ctx, params->pInfo, &pInfo_host);
-    vk_funcs->p_vkGetDeviceImageMemoryRequirements(params->device, &pInfo_host, params->pMemoryRequirements);
+    vulkan_device_from_handle(params->device)->p_vkGetDeviceImageMemoryRequirements(vulkan_device_from_handle(params->device)->host.device, &pInfo_host, params->pMemoryRequirements);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -54524,7 +55585,7 @@ static NTSTATUS thunk32_vkGetDeviceImage
     init_conversion_context(ctx);
     convert_VkDeviceImageMemoryRequirements_win32_to_host(ctx, (const VkDeviceImageMemoryRequirements32 *)UlongToPtr(params->pInfo), &pInfo_host);
     convert_VkMemoryRequirements2_win32_to_host(ctx, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements), &pMemoryRequirements_host);
-    vk_funcs->p_vkGetDeviceImageMemoryRequirements((VkDevice)UlongToPtr(params->device), &pInfo_host, &pMemoryRequirements_host);
+    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceImageMemoryRequirements(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pInfo_host, &pMemoryRequirements_host);
     convert_VkMemoryRequirements2_host_to_win32(&pMemoryRequirements_host, (VkMemoryRequirements232 *)UlongToPtr(params->pMemoryRequirements));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
@@ -54749,7 +55810,7 @@ static NTSTATUS thunk64_vkGetDeviceMemor
 
     TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->memory), params->pCommittedMemoryInBytes);
 
-    vulkan_device_from_handle(params->device)->p_vkGetDeviceMemoryCommitment(vulkan_device_from_handle(params->device)->host.device, vulkan_device_memory_from_handle(params->memory)->host.device_memory, params->pCommittedMemoryInBytes);
+    vulkan_device_from_handle(params->device)->p_vkGetDeviceMemoryCommitment(vulkan_device_from_handle(params->device)->host.device, wine_device_memory_from_handle(params->memory)->host.device_memory, params->pCommittedMemoryInBytes);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -54765,7 +55826,7 @@ static NTSTATUS thunk32_vkGetDeviceMemor
 
     TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->memory), params->pCommittedMemoryInBytes);
 
-    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceMemoryCommitment(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, vulkan_device_memory_from_handle(params->memory)->host.device_memory, (VkDeviceSize *)UlongToPtr(params->pCommittedMemoryInBytes));
+    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetDeviceMemoryCommitment(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, wine_device_memory_from_handle(params->memory)->host.device_memory, (VkDeviceSize *)UlongToPtr(params->pCommittedMemoryInBytes));
     return STATUS_SUCCESS;
 }
 
@@ -55104,7 +56165,7 @@ static NTSTATUS thunk64_vkGetFenceStatus
 
     TRACE("%p, 0x%s\n", params->device, wine_dbgstr_longlong(params->fence));
 
-    params->result = vulkan_device_from_handle(params->device)->p_vkGetFenceStatus(vulkan_device_from_handle(params->device)->host.device, vulkan_fence_from_handle(params->fence)->host.fence);
+    params->result = vulkan_device_from_handle(params->device)->p_vkGetFenceStatus(vulkan_device_from_handle(params->device)->host.device, params->fence);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -55120,40 +56181,7 @@ static NTSTATUS thunk32_vkGetFenceStatus
 
     TRACE("%#x, 0x%s\n", params->device, wine_dbgstr_longlong(params->fence));
 
-    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetFenceStatus(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, vulkan_fence_from_handle(params->fence)->host.fence);
-    return STATUS_SUCCESS;
-}
-
-#ifdef _WIN64
-static NTSTATUS thunk64_vkGetFenceWin32HandleKHR(void *args)
-{
-    struct vkGetFenceWin32HandleKHR_params *params = args;
-
-    TRACE("%p, %p, %p\n", params->device, params->pGetWin32HandleInfo, params->pHandle);
-
-    params->result = vk_funcs->p_vkGetFenceWin32HandleKHR(params->device, params->pGetWin32HandleInfo, params->pHandle);
-    return STATUS_SUCCESS;
-}
-#endif /* _WIN64 */
-
-static NTSTATUS thunk32_vkGetFenceWin32HandleKHR(void *args)
-{
-    struct
-    {
-        PTR32 device;
-        PTR32 pGetWin32HandleInfo;
-        PTR32 pHandle;
-        VkResult result;
-    } *params = args;
-    VkFenceGetWin32HandleInfoKHR pGetWin32HandleInfo_host;
-    HANDLE pHandle_host;
-
-    TRACE("%#x, %#x, %#x\n", params->device, params->pGetWin32HandleInfo, params->pHandle);
-
-    convert_VkFenceGetWin32HandleInfoKHR_win32_to_unwrapped_host((const VkFenceGetWin32HandleInfoKHR32 *)UlongToPtr(params->pGetWin32HandleInfo), &pGetWin32HandleInfo_host);
-    pHandle_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->pHandle));
-    params->result = vk_funcs->p_vkGetFenceWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pGetWin32HandleInfo_host, &pHandle_host);
-    *(PTR32 *)UlongToPtr(params->pHandle) = PtrToUlong(pHandle_host);
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetFenceStatus(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->fence);
     return STATUS_SUCCESS;
 }
 
@@ -55801,6 +56829,70 @@ static NTSTATUS thunk32_vkGetLatencyTimi
 }
 
 #ifdef _WIN64
+static NTSTATUS thunk64_vkGetMemoryFdKHR(void *args)
+{
+    struct vkGetMemoryFdKHR_params *params = args;
+    VkMemoryGetFdInfoKHR pGetFdInfo_host;
+
+    TRACE("%p, %p, %p\n", params->device, params->pGetFdInfo, params->pFd);
+
+    convert_VkMemoryGetFdInfoKHR_win64_to_host(params->pGetFdInfo, &pGetFdInfo_host);
+    params->result = vulkan_device_from_handle(params->device)->p_vkGetMemoryFdKHR(vulkan_device_from_handle(params->device)->host.device, &pGetFdInfo_host, params->pFd);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+static NTSTATUS thunk32_vkGetMemoryFdKHR(void *args)
+{
+    struct
+    {
+        PTR32 device;
+        PTR32 pGetFdInfo;
+        PTR32 pFd;
+        VkResult result;
+    } *params = args;
+    VkMemoryGetFdInfoKHR pGetFdInfo_host;
+
+    TRACE("%#x, %#x, %#x\n", params->device, params->pGetFdInfo, params->pFd);
+
+    convert_VkMemoryGetFdInfoKHR_win32_to_host((const VkMemoryGetFdInfoKHR32 *)UlongToPtr(params->pGetFdInfo), &pGetFdInfo_host);
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetMemoryFdKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pGetFdInfo_host, (int *)UlongToPtr(params->pFd));
+    return STATUS_SUCCESS;
+}
+
+#ifdef _WIN64
+static NTSTATUS thunk64_vkGetMemoryFdPropertiesKHR(void *args)
+{
+    struct vkGetMemoryFdPropertiesKHR_params *params = args;
+
+    TRACE("%p, %#x, %d, %p\n", params->device, params->handleType, params->fd, params->pMemoryFdProperties);
+
+    params->result = vulkan_device_from_handle(params->device)->p_vkGetMemoryFdPropertiesKHR(vulkan_device_from_handle(params->device)->host.device, params->handleType, params->fd, params->pMemoryFdProperties);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+static NTSTATUS thunk32_vkGetMemoryFdPropertiesKHR(void *args)
+{
+    struct
+    {
+        PTR32 device;
+        VkExternalMemoryHandleTypeFlagBits handleType;
+        int fd;
+        PTR32 pMemoryFdProperties;
+        VkResult result;
+    } *params = args;
+    VkMemoryFdPropertiesKHR pMemoryFdProperties_host;
+
+    TRACE("%#x, %#x, %d, %#x\n", params->device, params->handleType, params->fd, params->pMemoryFdProperties);
+
+    convert_VkMemoryFdPropertiesKHR_win32_to_host((VkMemoryFdPropertiesKHR32 *)UlongToPtr(params->pMemoryFdProperties), &pMemoryFdProperties_host);
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetMemoryFdPropertiesKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->handleType, params->fd, &pMemoryFdProperties_host);
+    convert_VkMemoryFdPropertiesKHR_host_to_win32(&pMemoryFdProperties_host, (VkMemoryFdPropertiesKHR32 *)UlongToPtr(params->pMemoryFdProperties));
+    return STATUS_SUCCESS;
+}
+
+#ifdef _WIN64
 static NTSTATUS thunk64_vkGetMemoryHostPointerPropertiesEXT(void *args)
 {
     struct vkGetMemoryHostPointerPropertiesEXT_params *params = args;
@@ -55839,7 +56931,7 @@ static NTSTATUS thunk64_vkGetMemoryWin32
 
     TRACE("%p, %p, %p\n", params->device, params->pGetWin32HandleInfo, params->pHandle);
 
-    params->result = vk_funcs->p_vkGetMemoryWin32HandleKHR(params->device, params->pGetWin32HandleInfo, params->pHandle);
+    params->result = wine_vkGetMemoryWin32HandleKHR(params->device, params->pGetWin32HandleInfo, params->pHandle);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -55854,14 +56946,11 @@ static NTSTATUS thunk32_vkGetMemoryWin32
         VkResult result;
     } *params = args;
     VkMemoryGetWin32HandleInfoKHR pGetWin32HandleInfo_host;
-    HANDLE pHandle_host;
 
     TRACE("%#x, %#x, %#x\n", params->device, params->pGetWin32HandleInfo, params->pHandle);
 
     convert_VkMemoryGetWin32HandleInfoKHR_win32_to_unwrapped_host((const VkMemoryGetWin32HandleInfoKHR32 *)UlongToPtr(params->pGetWin32HandleInfo), &pGetWin32HandleInfo_host);
-    pHandle_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->pHandle));
-    params->result = vk_funcs->p_vkGetMemoryWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pGetWin32HandleInfo_host, &pHandle_host);
-    *(PTR32 *)UlongToPtr(params->pHandle) = PtrToUlong(pHandle_host);
+    params->result = wine_vkGetMemoryWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pGetWin32HandleInfo_host, (HANDLE *)UlongToPtr(params->pHandle));
     return STATUS_SUCCESS;
 }
 
@@ -55872,7 +56961,7 @@ static NTSTATUS thunk64_vkGetMemoryWin32
 
     TRACE("%p, %#x, %p, %p\n", params->device, params->handleType, params->handle, params->pMemoryWin32HandleProperties);
 
-    params->result = vk_funcs->p_vkGetMemoryWin32HandlePropertiesKHR(params->device, params->handleType, params->handle, params->pMemoryWin32HandleProperties);
+    params->result = wine_vkGetMemoryWin32HandlePropertiesKHR(params->device, params->handleType, params->handle, params->pMemoryWin32HandleProperties);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -55883,16 +56972,16 @@ static NTSTATUS thunk32_vkGetMemoryWin32
     {
         PTR32 device;
         VkExternalMemoryHandleTypeFlagBits handleType;
-        PTR32 handle;
+        HANDLE handle;
         PTR32 pMemoryWin32HandleProperties;
         VkResult result;
     } *params = args;
     VkMemoryWin32HandlePropertiesKHR pMemoryWin32HandleProperties_host;
 
-    TRACE("%#x, %#x, %#x, %#x\n", params->device, params->handleType, params->handle, params->pMemoryWin32HandleProperties);
+    TRACE("%#x, %#x, %p, %#x\n", params->device, params->handleType, params->handle, params->pMemoryWin32HandleProperties);
 
     convert_VkMemoryWin32HandlePropertiesKHR_win32_to_host((VkMemoryWin32HandlePropertiesKHR32 *)UlongToPtr(params->pMemoryWin32HandleProperties), &pMemoryWin32HandleProperties_host);
-    params->result = vk_funcs->p_vkGetMemoryWin32HandlePropertiesKHR((VkDevice)UlongToPtr(params->device), params->handleType, (HANDLE)UlongToPtr(params->handle), &pMemoryWin32HandleProperties_host);
+    params->result = wine_vkGetMemoryWin32HandlePropertiesKHR((VkDevice)UlongToPtr(params->device), params->handleType, params->handle, &pMemoryWin32HandleProperties_host);
     convert_VkMemoryWin32HandlePropertiesKHR_host_to_win32(&pMemoryWin32HandleProperties_host, (VkMemoryWin32HandlePropertiesKHR32 *)UlongToPtr(params->pMemoryWin32HandleProperties));
     return STATUS_SUCCESS;
 }
@@ -56201,16 +57290,10 @@ static NTSTATUS thunk32_vkGetPhysicalDev
 static NTSTATUS thunk64_vkGetPhysicalDeviceExternalBufferProperties(void *args)
 {
     struct vkGetPhysicalDeviceExternalBufferProperties_params *params = args;
-    VkPhysicalDeviceExternalBufferInfo pExternalBufferInfo_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %p, %p\n", params->physicalDevice, params->pExternalBufferInfo, params->pExternalBufferProperties);
 
-    init_conversion_context(ctx);
-    convert_VkPhysicalDeviceExternalBufferInfo_win64_to_host(ctx, params->pExternalBufferInfo, &pExternalBufferInfo_host);
-    vk_funcs->p_vkGetPhysicalDeviceExternalBufferProperties(params->physicalDevice, &pExternalBufferInfo_host, params->pExternalBufferProperties);
-    free_conversion_context(ctx);
+    wine_vkGetPhysicalDeviceExternalBufferProperties(params->physicalDevice, params->pExternalBufferInfo, params->pExternalBufferProperties);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -56233,7 +57316,7 @@ static NTSTATUS thunk32_vkGetPhysicalDev
     init_conversion_context(ctx);
     convert_VkPhysicalDeviceExternalBufferInfo_win32_to_host(ctx, (const VkPhysicalDeviceExternalBufferInfo32 *)UlongToPtr(params->pExternalBufferInfo), &pExternalBufferInfo_host);
     convert_VkExternalBufferProperties_win32_to_host((VkExternalBufferProperties32 *)UlongToPtr(params->pExternalBufferProperties), &pExternalBufferProperties_host);
-    vk_funcs->p_vkGetPhysicalDeviceExternalBufferProperties((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalBufferInfo_host, &pExternalBufferProperties_host);
+    wine_vkGetPhysicalDeviceExternalBufferProperties((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalBufferInfo_host, &pExternalBufferProperties_host);
     convert_VkExternalBufferProperties_host_to_win32(&pExternalBufferProperties_host, (VkExternalBufferProperties32 *)UlongToPtr(params->pExternalBufferProperties));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
@@ -56243,16 +57326,10 @@ static NTSTATUS thunk32_vkGetPhysicalDev
 static NTSTATUS thunk64_vkGetPhysicalDeviceExternalBufferPropertiesKHR(void *args)
 {
     struct vkGetPhysicalDeviceExternalBufferPropertiesKHR_params *params = args;
-    VkPhysicalDeviceExternalBufferInfo pExternalBufferInfo_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %p, %p\n", params->physicalDevice, params->pExternalBufferInfo, params->pExternalBufferProperties);
 
-    init_conversion_context(ctx);
-    convert_VkPhysicalDeviceExternalBufferInfo_win64_to_host(ctx, params->pExternalBufferInfo, &pExternalBufferInfo_host);
-    vk_funcs->p_vkGetPhysicalDeviceExternalBufferPropertiesKHR(params->physicalDevice, &pExternalBufferInfo_host, params->pExternalBufferProperties);
-    free_conversion_context(ctx);
+    wine_vkGetPhysicalDeviceExternalBufferPropertiesKHR(params->physicalDevice, params->pExternalBufferInfo, params->pExternalBufferProperties);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -56275,7 +57352,7 @@ static NTSTATUS thunk32_vkGetPhysicalDev
     init_conversion_context(ctx);
     convert_VkPhysicalDeviceExternalBufferInfo_win32_to_host(ctx, (const VkPhysicalDeviceExternalBufferInfo32 *)UlongToPtr(params->pExternalBufferInfo), &pExternalBufferInfo_host);
     convert_VkExternalBufferProperties_win32_to_host((VkExternalBufferProperties32 *)UlongToPtr(params->pExternalBufferProperties), &pExternalBufferProperties_host);
-    vk_funcs->p_vkGetPhysicalDeviceExternalBufferPropertiesKHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalBufferInfo_host, &pExternalBufferProperties_host);
+    wine_vkGetPhysicalDeviceExternalBufferPropertiesKHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalBufferInfo_host, &pExternalBufferProperties_host);
     convert_VkExternalBufferProperties_host_to_win32(&pExternalBufferProperties_host, (VkExternalBufferProperties32 *)UlongToPtr(params->pExternalBufferProperties));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
@@ -56349,10 +57426,16 @@ static NTSTATUS thunk32_vkGetPhysicalDev
 static NTSTATUS thunk64_vkGetPhysicalDeviceExternalSemaphoreProperties(void *args)
 {
     struct vkGetPhysicalDeviceExternalSemaphoreProperties_params *params = args;
+    VkPhysicalDeviceExternalSemaphoreInfo pExternalSemaphoreInfo_host;
+    struct conversion_context local_ctx;
+    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %p, %p\n", params->physicalDevice, params->pExternalSemaphoreInfo, params->pExternalSemaphoreProperties);
 
-    vk_funcs->p_vkGetPhysicalDeviceExternalSemaphoreProperties(params->physicalDevice, params->pExternalSemaphoreInfo, params->pExternalSemaphoreProperties);
+    init_conversion_context(ctx);
+    convert_VkPhysicalDeviceExternalSemaphoreInfo_win64_to_host(ctx, params->pExternalSemaphoreInfo, &pExternalSemaphoreInfo_host);
+    wine_vkGetPhysicalDeviceExternalSemaphoreProperties(params->physicalDevice, &pExternalSemaphoreInfo_host, params->pExternalSemaphoreProperties);
+    free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -56375,7 +57458,7 @@ static NTSTATUS thunk32_vkGetPhysicalDev
     init_conversion_context(ctx);
     convert_VkPhysicalDeviceExternalSemaphoreInfo_win32_to_host(ctx, (const VkPhysicalDeviceExternalSemaphoreInfo32 *)UlongToPtr(params->pExternalSemaphoreInfo), &pExternalSemaphoreInfo_host);
     convert_VkExternalSemaphoreProperties_win32_to_host((VkExternalSemaphoreProperties32 *)UlongToPtr(params->pExternalSemaphoreProperties), &pExternalSemaphoreProperties_host);
-    vk_funcs->p_vkGetPhysicalDeviceExternalSemaphoreProperties((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalSemaphoreInfo_host, &pExternalSemaphoreProperties_host);
+    wine_vkGetPhysicalDeviceExternalSemaphoreProperties((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalSemaphoreInfo_host, &pExternalSemaphoreProperties_host);
     convert_VkExternalSemaphoreProperties_host_to_win32(&pExternalSemaphoreProperties_host, (VkExternalSemaphoreProperties32 *)UlongToPtr(params->pExternalSemaphoreProperties));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
@@ -56385,10 +57468,16 @@ static NTSTATUS thunk32_vkGetPhysicalDev
 static NTSTATUS thunk64_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(void *args)
 {
     struct vkGetPhysicalDeviceExternalSemaphorePropertiesKHR_params *params = args;
+    VkPhysicalDeviceExternalSemaphoreInfo pExternalSemaphoreInfo_host;
+    struct conversion_context local_ctx;
+    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %p, %p\n", params->physicalDevice, params->pExternalSemaphoreInfo, params->pExternalSemaphoreProperties);
 
-    vk_funcs->p_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(params->physicalDevice, params->pExternalSemaphoreInfo, params->pExternalSemaphoreProperties);
+    init_conversion_context(ctx);
+    convert_VkPhysicalDeviceExternalSemaphoreInfo_win64_to_host(ctx, params->pExternalSemaphoreInfo, &pExternalSemaphoreInfo_host);
+    wine_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(params->physicalDevice, &pExternalSemaphoreInfo_host, params->pExternalSemaphoreProperties);
+    free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -56411,7 +57500,7 @@ static NTSTATUS thunk32_vkGetPhysicalDev
     init_conversion_context(ctx);
     convert_VkPhysicalDeviceExternalSemaphoreInfo_win32_to_host(ctx, (const VkPhysicalDeviceExternalSemaphoreInfo32 *)UlongToPtr(params->pExternalSemaphoreInfo), &pExternalSemaphoreInfo_host);
     convert_VkExternalSemaphoreProperties_win32_to_host((VkExternalSemaphoreProperties32 *)UlongToPtr(params->pExternalSemaphoreProperties), &pExternalSemaphoreProperties_host);
-    vk_funcs->p_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalSemaphoreInfo_host, &pExternalSemaphoreProperties_host);
+    wine_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pExternalSemaphoreInfo_host, &pExternalSemaphoreProperties_host);
     convert_VkExternalSemaphoreProperties_host_to_win32(&pExternalSemaphoreProperties_host, (VkExternalSemaphoreProperties32 *)UlongToPtr(params->pExternalSemaphoreProperties));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
@@ -56721,7 +57810,7 @@ static NTSTATUS thunk64_vkGetPhysicalDev
 
     init_conversion_context(ctx);
     convert_VkPhysicalDeviceImageFormatInfo2_win64_to_host(ctx, params->pImageFormatInfo, &pImageFormatInfo_host);
-    params->result = vk_funcs->p_vkGetPhysicalDeviceImageFormatProperties2(params->physicalDevice, &pImageFormatInfo_host, params->pImageFormatProperties);
+    params->result = wine_vkGetPhysicalDeviceImageFormatProperties2(params->physicalDevice, &pImageFormatInfo_host, params->pImageFormatProperties);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -56746,7 +57835,7 @@ static NTSTATUS thunk32_vkGetPhysicalDev
     init_conversion_context(ctx);
     convert_VkPhysicalDeviceImageFormatInfo2_win32_to_host(ctx, (const VkPhysicalDeviceImageFormatInfo232 *)UlongToPtr(params->pImageFormatInfo), &pImageFormatInfo_host);
     convert_VkImageFormatProperties2_win32_to_host(ctx, (VkImageFormatProperties232 *)UlongToPtr(params->pImageFormatProperties), &pImageFormatProperties_host);
-    params->result = vk_funcs->p_vkGetPhysicalDeviceImageFormatProperties2((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pImageFormatInfo_host, &pImageFormatProperties_host);
+    params->result = wine_vkGetPhysicalDeviceImageFormatProperties2((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pImageFormatInfo_host, &pImageFormatProperties_host);
     convert_VkImageFormatProperties2_host_to_win32(&pImageFormatProperties_host, (VkImageFormatProperties232 *)UlongToPtr(params->pImageFormatProperties));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
@@ -56764,7 +57853,7 @@ static NTSTATUS thunk64_vkGetPhysicalDev
 
     init_conversion_context(ctx);
     convert_VkPhysicalDeviceImageFormatInfo2_win64_to_host(ctx, params->pImageFormatInfo, &pImageFormatInfo_host);
-    params->result = vk_funcs->p_vkGetPhysicalDeviceImageFormatProperties2KHR(params->physicalDevice, &pImageFormatInfo_host, params->pImageFormatProperties);
+    params->result = wine_vkGetPhysicalDeviceImageFormatProperties2KHR(params->physicalDevice, &pImageFormatInfo_host, params->pImageFormatProperties);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -56789,7 +57878,7 @@ static NTSTATUS thunk32_vkGetPhysicalDev
     init_conversion_context(ctx);
     convert_VkPhysicalDeviceImageFormatInfo2_win32_to_host(ctx, (const VkPhysicalDeviceImageFormatInfo232 *)UlongToPtr(params->pImageFormatInfo), &pImageFormatInfo_host);
     convert_VkImageFormatProperties2_win32_to_host(ctx, (VkImageFormatProperties232 *)UlongToPtr(params->pImageFormatProperties), &pImageFormatProperties_host);
-    params->result = vk_funcs->p_vkGetPhysicalDeviceImageFormatProperties2KHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pImageFormatInfo_host, &pImageFormatProperties_host);
+    params->result = wine_vkGetPhysicalDeviceImageFormatProperties2KHR((VkPhysicalDevice)UlongToPtr(params->physicalDevice), &pImageFormatInfo_host, &pImageFormatProperties_host);
     convert_VkImageFormatProperties2_host_to_win32(&pImageFormatProperties_host, (VkImageFormatProperties232 *)UlongToPtr(params->pImageFormatProperties));
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
@@ -58542,7 +59631,7 @@ static NTSTATUS thunk64_vkGetSemaphoreCo
 
     TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pValue);
 
-    params->result = vulkan_device_from_handle(params->device)->p_vkGetSemaphoreCounterValue(vulkan_device_from_handle(params->device)->host.device, vulkan_semaphore_from_handle(params->semaphore)->host.semaphore, params->pValue);
+    params->result = wine_vkGetSemaphoreCounterValue(params->device, params->semaphore, params->pValue);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -58559,7 +59648,7 @@ static NTSTATUS thunk32_vkGetSemaphoreCo
 
     TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pValue);
 
-    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetSemaphoreCounterValue(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, vulkan_semaphore_from_handle(params->semaphore)->host.semaphore, (uint64_t *)UlongToPtr(params->pValue));
+    params->result = wine_vkGetSemaphoreCounterValue((VkDevice)UlongToPtr(params->device), params->semaphore, (uint64_t *)UlongToPtr(params->pValue));
     return STATUS_SUCCESS;
 }
 
@@ -58570,7 +59659,7 @@ static NTSTATUS thunk64_vkGetSemaphoreCo
 
     TRACE("%p, 0x%s, %p\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pValue);
 
-    params->result = vulkan_device_from_handle(params->device)->p_vkGetSemaphoreCounterValueKHR(vulkan_device_from_handle(params->device)->host.device, vulkan_semaphore_from_handle(params->semaphore)->host.semaphore, params->pValue);
+    params->result = wine_vkGetSemaphoreCounterValueKHR(params->device, params->semaphore, params->pValue);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -58587,7 +59676,39 @@ static NTSTATUS thunk32_vkGetSemaphoreCo
 
     TRACE("%#x, 0x%s, %#x\n", params->device, wine_dbgstr_longlong(params->semaphore), params->pValue);
 
-    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetSemaphoreCounterValueKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, vulkan_semaphore_from_handle(params->semaphore)->host.semaphore, (uint64_t *)UlongToPtr(params->pValue));
+    params->result = wine_vkGetSemaphoreCounterValueKHR((VkDevice)UlongToPtr(params->device), params->semaphore, (uint64_t *)UlongToPtr(params->pValue));
+    return STATUS_SUCCESS;
+}
+
+#ifdef _WIN64
+static NTSTATUS thunk64_vkGetSemaphoreFdKHR(void *args)
+{
+    struct vkGetSemaphoreFdKHR_params *params = args;
+    VkSemaphoreGetFdInfoKHR pGetFdInfo_host;
+
+    TRACE("%p, %p, %p\n", params->device, params->pGetFdInfo, params->pFd);
+
+    convert_VkSemaphoreGetFdInfoKHR_win64_to_host(params->pGetFdInfo, &pGetFdInfo_host);
+    params->result = vulkan_device_from_handle(params->device)->p_vkGetSemaphoreFdKHR(vulkan_device_from_handle(params->device)->host.device, &pGetFdInfo_host, params->pFd);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+static NTSTATUS thunk32_vkGetSemaphoreFdKHR(void *args)
+{
+    struct
+    {
+        PTR32 device;
+        PTR32 pGetFdInfo;
+        PTR32 pFd;
+        VkResult result;
+    } *params = args;
+    VkSemaphoreGetFdInfoKHR pGetFdInfo_host;
+
+    TRACE("%#x, %#x, %#x\n", params->device, params->pGetFdInfo, params->pFd);
+
+    convert_VkSemaphoreGetFdInfoKHR_win32_to_host((const VkSemaphoreGetFdInfoKHR32 *)UlongToPtr(params->pGetFdInfo), &pGetFdInfo_host);
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkGetSemaphoreFdKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pGetFdInfo_host, (int *)UlongToPtr(params->pFd));
     return STATUS_SUCCESS;
 }
 
@@ -58598,7 +59719,7 @@ static NTSTATUS thunk64_vkGetSemaphoreWi
 
     TRACE("%p, %p, %p\n", params->device, params->pGetWin32HandleInfo, params->pHandle);
 
-    params->result = vk_funcs->p_vkGetSemaphoreWin32HandleKHR(params->device, params->pGetWin32HandleInfo, params->pHandle);
+    params->result = wine_vkGetSemaphoreWin32HandleKHR(params->device, params->pGetWin32HandleInfo, params->pHandle);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -58613,14 +59734,11 @@ static NTSTATUS thunk32_vkGetSemaphoreWi
         VkResult result;
     } *params = args;
     VkSemaphoreGetWin32HandleInfoKHR pGetWin32HandleInfo_host;
-    HANDLE pHandle_host;
 
     TRACE("%#x, %#x, %#x\n", params->device, params->pGetWin32HandleInfo, params->pHandle);
 
     convert_VkSemaphoreGetWin32HandleInfoKHR_win32_to_unwrapped_host((const VkSemaphoreGetWin32HandleInfoKHR32 *)UlongToPtr(params->pGetWin32HandleInfo), &pGetWin32HandleInfo_host);
-    pHandle_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->pHandle));
-    params->result = vk_funcs->p_vkGetSemaphoreWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pGetWin32HandleInfo_host, &pHandle_host);
-    *(PTR32 *)UlongToPtr(params->pHandle) = PtrToUlong(pHandle_host);
+    params->result = wine_vkGetSemaphoreWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pGetWin32HandleInfo_host, (HANDLE *)UlongToPtr(params->pHandle));
     return STATUS_SUCCESS;
 }
 
@@ -58950,31 +60068,33 @@ static NTSTATUS thunk32_vkGetVideoSessio
 }
 
 #ifdef _WIN64
-static NTSTATUS thunk64_vkImportFenceWin32HandleKHR(void *args)
+static NTSTATUS thunk64_vkImportSemaphoreFdKHR(void *args)
 {
-    struct vkImportFenceWin32HandleKHR_params *params = args;
+    struct vkImportSemaphoreFdKHR_params *params = args;
+    VkImportSemaphoreFdInfoKHR pImportSemaphoreFdInfo_host;
 
-    TRACE("%p, %p\n", params->device, params->pImportFenceWin32HandleInfo);
+    TRACE("%p, %p\n", params->device, params->pImportSemaphoreFdInfo);
 
-    params->result = vk_funcs->p_vkImportFenceWin32HandleKHR(params->device, params->pImportFenceWin32HandleInfo);
+    convert_VkImportSemaphoreFdInfoKHR_win64_to_host(params->pImportSemaphoreFdInfo, &pImportSemaphoreFdInfo_host);
+    params->result = vulkan_device_from_handle(params->device)->p_vkImportSemaphoreFdKHR(vulkan_device_from_handle(params->device)->host.device, &pImportSemaphoreFdInfo_host);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
 
-static NTSTATUS thunk32_vkImportFenceWin32HandleKHR(void *args)
+static NTSTATUS thunk32_vkImportSemaphoreFdKHR(void *args)
 {
     struct
     {
         PTR32 device;
-        PTR32 pImportFenceWin32HandleInfo;
+        PTR32 pImportSemaphoreFdInfo;
         VkResult result;
     } *params = args;
-    VkImportFenceWin32HandleInfoKHR pImportFenceWin32HandleInfo_host;
+    VkImportSemaphoreFdInfoKHR pImportSemaphoreFdInfo_host;
 
-    TRACE("%#x, %#x\n", params->device, params->pImportFenceWin32HandleInfo);
+    TRACE("%#x, %#x\n", params->device, params->pImportSemaphoreFdInfo);
 
-    convert_VkImportFenceWin32HandleInfoKHR_win32_to_unwrapped_host((const VkImportFenceWin32HandleInfoKHR32 *)UlongToPtr(params->pImportFenceWin32HandleInfo), &pImportFenceWin32HandleInfo_host);
-    params->result = vk_funcs->p_vkImportFenceWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pImportFenceWin32HandleInfo_host);
+    convert_VkImportSemaphoreFdInfoKHR_win32_to_host((const VkImportSemaphoreFdInfoKHR32 *)UlongToPtr(params->pImportSemaphoreFdInfo), &pImportSemaphoreFdInfo_host);
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkImportSemaphoreFdKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pImportSemaphoreFdInfo_host);
     return STATUS_SUCCESS;
 }
 
@@ -58985,7 +60105,7 @@ static NTSTATUS thunk64_vkImportSemaphor
 
     TRACE("%p, %p\n", params->device, params->pImportSemaphoreWin32HandleInfo);
 
-    params->result = vk_funcs->p_vkImportSemaphoreWin32HandleKHR(params->device, params->pImportSemaphoreWin32HandleInfo);
+    params->result = wine_vkImportSemaphoreWin32HandleKHR(params->device, params->pImportSemaphoreWin32HandleInfo);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -59003,7 +60123,7 @@ static NTSTATUS thunk32_vkImportSemaphor
     TRACE("%#x, %#x\n", params->device, params->pImportSemaphoreWin32HandleInfo);
 
     convert_VkImportSemaphoreWin32HandleInfoKHR_win32_to_unwrapped_host((const VkImportSemaphoreWin32HandleInfoKHR32 *)UlongToPtr(params->pImportSemaphoreWin32HandleInfo), &pImportSemaphoreWin32HandleInfo_host);
-    params->result = vk_funcs->p_vkImportSemaphoreWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pImportSemaphoreWin32HandleInfo_host);
+    params->result = wine_vkImportSemaphoreWin32HandleKHR((VkDevice)UlongToPtr(params->device), &pImportSemaphoreWin32HandleInfo_host);
     return STATUS_SUCCESS;
 }
 
@@ -59115,7 +60235,7 @@ static NTSTATUS thunk64_vkMapMemory(void
 
     TRACE("%p, 0x%s, 0x%s, 0x%s, %#x, %p\n", params->device, wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->offset), wine_dbgstr_longlong(params->size), params->flags, params->ppData);
 
-    params->result = vk_funcs->p_vkMapMemory(params->device, params->memory, params->offset, params->size, params->flags, params->ppData);
+    params->result = wine_vkMapMemory(params->device, params->memory, params->offset, params->size, params->flags, params->ppData);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -59137,7 +60257,7 @@ static NTSTATUS thunk32_vkMapMemory(void
     TRACE("%#x, 0x%s, 0x%s, 0x%s, %#x, %#x\n", params->device, wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->offset), wine_dbgstr_longlong(params->size), params->flags, params->ppData);
 
     ppData_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->ppData));
-    params->result = vk_funcs->p_vkMapMemory((VkDevice)UlongToPtr(params->device), params->memory, params->offset, params->size, params->flags, &ppData_host);
+    params->result = wine_vkMapMemory((VkDevice)UlongToPtr(params->device), params->memory, params->offset, params->size, params->flags, &ppData_host);
     *(PTR32 *)UlongToPtr(params->ppData) = PtrToUlong(ppData_host);
     return STATUS_SUCCESS;
 }
@@ -59184,7 +60304,7 @@ static NTSTATUS thunk64_vkMapMemory2KHR(
 
     TRACE("%p, %p, %p\n", params->device, params->pMemoryMapInfo, params->ppData);
 
-    params->result = vk_funcs->p_vkMapMemory2KHR(params->device, params->pMemoryMapInfo, params->ppData);
+    params->result = wine_vkMapMemory2KHR(params->device, params->pMemoryMapInfo, params->ppData);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -59205,7 +60325,7 @@ static NTSTATUS thunk32_vkMapMemory2KHR(
 
     convert_VkMemoryMapInfo_win32_to_unwrapped_host((const VkMemoryMapInfo32 *)UlongToPtr(params->pMemoryMapInfo), &pMemoryMapInfo_host);
     ppData_host = UlongToPtr(*(PTR32 *)UlongToPtr(params->ppData));
-    params->result = vk_funcs->p_vkMapMemory2KHR((VkDevice)UlongToPtr(params->device), &pMemoryMapInfo_host, &ppData_host);
+    params->result = wine_vkMapMemory2KHR((VkDevice)UlongToPtr(params->device), &pMemoryMapInfo_host, &ppData_host);
     *(PTR32 *)UlongToPtr(params->ppData) = PtrToUlong(ppData_host);
     return STATUS_SUCCESS;
 }
@@ -59307,8 +60427,8 @@ static NTSTATUS thunk64_vkQueueBindSpars
     TRACE("%p, %u, %p, 0x%s\n", params->queue, params->bindInfoCount, params->pBindInfo, wine_dbgstr_longlong(params->fence));
 
     init_conversion_context(ctx);
-    pBindInfo_host = convert_VkBindSparseInfo_array_win64_to_host(ctx, params->pBindInfo, params->bindInfoCount);
-    params->result = vulkan_queue_from_handle(params->queue)->device->p_vkQueueBindSparse(vulkan_queue_from_handle(params->queue)->host.queue, params->bindInfoCount, pBindInfo_host, params->fence ? vulkan_fence_from_handle(params->fence)->host.fence : 0);
+    pBindInfo_host = convert_VkBindSparseInfo_array_win64_to_unwrapped_host(ctx, params->pBindInfo, params->bindInfoCount);
+    params->result = wine_vkQueueBindSparse(params->queue, params->bindInfoCount, pBindInfo_host, params->fence);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -59331,8 +60451,8 @@ static NTSTATUS thunk32_vkQueueBindSpars
     TRACE("%#x, %u, %#x, 0x%s\n", params->queue, params->bindInfoCount, params->pBindInfo, wine_dbgstr_longlong(params->fence));
 
     init_conversion_context(ctx);
-    pBindInfo_host = convert_VkBindSparseInfo_array_win32_to_host(ctx, (const VkBindSparseInfo32 *)UlongToPtr(params->pBindInfo), params->bindInfoCount);
-    params->result = vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->device->p_vkQueueBindSparse(vulkan_queue_from_handle((VkQueue)UlongToPtr(params->queue))->host.queue, params->bindInfoCount, pBindInfo_host, params->fence ? vulkan_fence_from_handle(params->fence)->host.fence : 0);
+    pBindInfo_host = convert_VkBindSparseInfo_array_win32_to_unwrapped_host(ctx, (const VkBindSparseInfo32 *)UlongToPtr(params->pBindInfo), params->bindInfoCount);
+    params->result = wine_vkQueueBindSparse((VkQueue)UlongToPtr(params->queue), params->bindInfoCount, pBindInfo_host, params->fence);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -59422,16 +60542,10 @@ static NTSTATUS thunk32_vkQueueNotifyOut
 static NTSTATUS thunk64_vkQueuePresentKHR(void *args)
 {
     struct vkQueuePresentKHR_params *params = args;
-    VkPresentInfoKHR pPresentInfo_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %p\n", params->queue, params->pPresentInfo);
 
-    init_conversion_context(ctx);
-    convert_VkPresentInfoKHR_win64_to_unwrapped_host(ctx, params->pPresentInfo, &pPresentInfo_host);
-    params->result = vk_funcs->p_vkQueuePresentKHR(params->queue, &pPresentInfo_host);
-    free_conversion_context(ctx);
+    params->result = vk_funcs->p_vkQueuePresentKHR(params->queue, params->pPresentInfo);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -59496,7 +60610,7 @@ static NTSTATUS thunk64_vkQueueSubmit(vo
 
     init_conversion_context(ctx);
     pSubmits_host = convert_VkSubmitInfo_array_win64_to_unwrapped_host(ctx, params->pSubmits, params->submitCount);
-    params->result = vk_funcs->p_vkQueueSubmit(params->queue, params->submitCount, pSubmits_host, params->fence);
+    params->result = wine_vkQueueSubmit(params->queue, params->submitCount, pSubmits_host, params->fence);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -59520,7 +60634,7 @@ static NTSTATUS thunk32_vkQueueSubmit(vo
 
     init_conversion_context(ctx);
     pSubmits_host = convert_VkSubmitInfo_array_win32_to_unwrapped_host(ctx, (const VkSubmitInfo32 *)UlongToPtr(params->pSubmits), params->submitCount);
-    params->result = vk_funcs->p_vkQueueSubmit((VkQueue)UlongToPtr(params->queue), params->submitCount, pSubmits_host, params->fence);
+    params->result = wine_vkQueueSubmit((VkQueue)UlongToPtr(params->queue), params->submitCount, pSubmits_host, params->fence);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -59537,7 +60651,7 @@ static NTSTATUS thunk64_vkQueueSubmit2(v
 
     init_conversion_context(ctx);
     pSubmits_host = convert_VkSubmitInfo2_array_win64_to_unwrapped_host(ctx, params->pSubmits, params->submitCount);
-    params->result = vk_funcs->p_vkQueueSubmit2(params->queue, params->submitCount, pSubmits_host, params->fence);
+    params->result = wine_vkQueueSubmit2(params->queue, params->submitCount, pSubmits_host, params->fence);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -59561,7 +60675,7 @@ static NTSTATUS thunk32_vkQueueSubmit2(v
 
     init_conversion_context(ctx);
     pSubmits_host = convert_VkSubmitInfo2_array_win32_to_unwrapped_host(ctx, (const VkSubmitInfo232 *)UlongToPtr(params->pSubmits), params->submitCount);
-    params->result = vk_funcs->p_vkQueueSubmit2((VkQueue)UlongToPtr(params->queue), params->submitCount, pSubmits_host, params->fence);
+    params->result = wine_vkQueueSubmit2((VkQueue)UlongToPtr(params->queue), params->submitCount, pSubmits_host, params->fence);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -59578,7 +60692,7 @@ static NTSTATUS thunk64_vkQueueSubmit2KH
 
     init_conversion_context(ctx);
     pSubmits_host = convert_VkSubmitInfo2_array_win64_to_unwrapped_host(ctx, params->pSubmits, params->submitCount);
-    params->result = vk_funcs->p_vkQueueSubmit2KHR(params->queue, params->submitCount, pSubmits_host, params->fence);
+    params->result = wine_vkQueueSubmit2KHR(params->queue, params->submitCount, pSubmits_host, params->fence);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -59602,7 +60716,7 @@ static NTSTATUS thunk32_vkQueueSubmit2KH
 
     init_conversion_context(ctx);
     pSubmits_host = convert_VkSubmitInfo2_array_win32_to_unwrapped_host(ctx, (const VkSubmitInfo232 *)UlongToPtr(params->pSubmits), params->submitCount);
-    params->result = vk_funcs->p_vkQueueSubmit2KHR((VkQueue)UlongToPtr(params->queue), params->submitCount, pSubmits_host, params->fence);
+    params->result = wine_vkQueueSubmit2KHR((VkQueue)UlongToPtr(params->queue), params->submitCount, pSubmits_host, params->fence);
     free_conversion_context(ctx);
     return STATUS_SUCCESS;
 }
@@ -59784,7 +60898,7 @@ static NTSTATUS thunk64_vkResetCommandBu
 
     TRACE("%p, %#x\n", params->commandBuffer, params->flags);
 
-    params->result = vulkan_command_buffer_from_handle(params->commandBuffer)->device->p_vkResetCommandBuffer(vulkan_command_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->flags);
+    params->result = wine_cmd_buffer_from_handle(params->commandBuffer)->device->p_vkResetCommandBuffer(wine_cmd_buffer_from_handle(params->commandBuffer)->host.command_buffer, params->flags);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -59800,7 +60914,7 @@ static NTSTATUS thunk32_vkResetCommandBu
 
     TRACE("%#x, %#x\n", params->commandBuffer, params->flags);
 
-    params->result = vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkResetCommandBuffer(vulkan_command_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->flags);
+    params->result = wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->device->p_vkResetCommandBuffer(wine_cmd_buffer_from_handle((VkCommandBuffer)UlongToPtr(params->commandBuffer))->host.command_buffer, params->flags);
     return STATUS_SUCCESS;
 }
 
@@ -59891,16 +61005,10 @@ static NTSTATUS thunk32_vkResetEvent(voi
 static NTSTATUS thunk64_vkResetFences(void *args)
 {
     struct vkResetFences_params *params = args;
-    const VkFence *pFences_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %u, %p\n", params->device, params->fenceCount, params->pFences);
 
-    init_conversion_context(ctx);
-    pFences_host = convert_VkFence_array_win64_to_host(ctx, params->pFences, params->fenceCount);
-    params->result = vulkan_device_from_handle(params->device)->p_vkResetFences(vulkan_device_from_handle(params->device)->host.device, params->fenceCount, pFences_host);
-    free_conversion_context(ctx);
+    params->result = vulkan_device_from_handle(params->device)->p_vkResetFences(vulkan_device_from_handle(params->device)->host.device, params->fenceCount, params->pFences);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -59914,16 +61022,10 @@ static NTSTATUS thunk32_vkResetFences(vo
         PTR32 pFences;
         VkResult result;
     } *params = args;
-    const VkFence *pFences_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%#x, %u, %#x\n", params->device, params->fenceCount, params->pFences);
 
-    init_conversion_context(ctx);
-    pFences_host = convert_VkFence_array_win32_to_host(ctx, (const VkFence *)UlongToPtr(params->pFences), params->fenceCount);
-    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkResetFences(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->fenceCount, pFences_host);
-    free_conversion_context(ctx);
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkResetFences(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->fenceCount, (const VkFence *)UlongToPtr(params->pFences));
     return STATUS_SUCCESS;
 }
 
@@ -60052,7 +61154,7 @@ static NTSTATUS thunk64_vkSetDeviceMemor
 
     TRACE("%p, 0x%s, %f\n", params->device, wine_dbgstr_longlong(params->memory), params->priority);
 
-    vulkan_device_from_handle(params->device)->p_vkSetDeviceMemoryPriorityEXT(vulkan_device_from_handle(params->device)->host.device, vulkan_device_memory_from_handle(params->memory)->host.device_memory, params->priority);
+    vulkan_device_from_handle(params->device)->p_vkSetDeviceMemoryPriorityEXT(vulkan_device_from_handle(params->device)->host.device, wine_device_memory_from_handle(params->memory)->host.device_memory, params->priority);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -60068,7 +61170,7 @@ static NTSTATUS thunk32_vkSetDeviceMemor
 
     TRACE("%#x, 0x%s, %f\n", params->device, wine_dbgstr_longlong(params->memory), params->priority);
 
-    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkSetDeviceMemoryPriorityEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, vulkan_device_memory_from_handle(params->memory)->host.device_memory, params->priority);
+    vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkSetDeviceMemoryPriorityEXT(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, wine_device_memory_from_handle(params->memory)->host.device_memory, params->priority);
     return STATUS_SUCCESS;
 }
 
@@ -60264,12 +61366,10 @@ static NTSTATUS thunk32_vkSetPrivateData
 static NTSTATUS thunk64_vkSignalSemaphore(void *args)
 {
     struct vkSignalSemaphore_params *params = args;
-    VkSemaphoreSignalInfo pSignalInfo_host;
 
     TRACE("%p, %p\n", params->device, params->pSignalInfo);
 
-    convert_VkSemaphoreSignalInfo_win64_to_host(params->pSignalInfo, &pSignalInfo_host);
-    params->result = vulkan_device_from_handle(params->device)->p_vkSignalSemaphore(vulkan_device_from_handle(params->device)->host.device, &pSignalInfo_host);
+    params->result = wine_vkSignalSemaphore(params->device, params->pSignalInfo);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -60286,8 +61386,8 @@ static NTSTATUS thunk32_vkSignalSemaphor
 
     TRACE("%#x, %#x\n", params->device, params->pSignalInfo);
 
-    convert_VkSemaphoreSignalInfo_win32_to_host((const VkSemaphoreSignalInfo32 *)UlongToPtr(params->pSignalInfo), &pSignalInfo_host);
-    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkSignalSemaphore(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pSignalInfo_host);
+    convert_VkSemaphoreSignalInfo_win32_to_unwrapped_host((const VkSemaphoreSignalInfo32 *)UlongToPtr(params->pSignalInfo), &pSignalInfo_host);
+    params->result = wine_vkSignalSemaphore((VkDevice)UlongToPtr(params->device), &pSignalInfo_host);
     return STATUS_SUCCESS;
 }
 
@@ -60295,12 +61395,10 @@ static NTSTATUS thunk32_vkSignalSemaphor
 static NTSTATUS thunk64_vkSignalSemaphoreKHR(void *args)
 {
     struct vkSignalSemaphoreKHR_params *params = args;
-    VkSemaphoreSignalInfo pSignalInfo_host;
 
     TRACE("%p, %p\n", params->device, params->pSignalInfo);
 
-    convert_VkSemaphoreSignalInfo_win64_to_host(params->pSignalInfo, &pSignalInfo_host);
-    params->result = vulkan_device_from_handle(params->device)->p_vkSignalSemaphoreKHR(vulkan_device_from_handle(params->device)->host.device, &pSignalInfo_host);
+    params->result = wine_vkSignalSemaphoreKHR(params->device, params->pSignalInfo);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -60317,8 +61415,8 @@ static NTSTATUS thunk32_vkSignalSemaphor
 
     TRACE("%#x, %#x\n", params->device, params->pSignalInfo);
 
-    convert_VkSemaphoreSignalInfo_win32_to_host((const VkSemaphoreSignalInfo32 *)UlongToPtr(params->pSignalInfo), &pSignalInfo_host);
-    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkSignalSemaphoreKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pSignalInfo_host);
+    convert_VkSemaphoreSignalInfo_win32_to_unwrapped_host((const VkSemaphoreSignalInfo32 *)UlongToPtr(params->pSignalInfo), &pSignalInfo_host);
+    params->result = wine_vkSignalSemaphoreKHR((VkDevice)UlongToPtr(params->device), &pSignalInfo_host);
     return STATUS_SUCCESS;
 }
 
@@ -60516,7 +61614,7 @@ static NTSTATUS thunk64_vkUnmapMemory(vo
 
     TRACE("%p, 0x%s\n", params->device, wine_dbgstr_longlong(params->memory));
 
-    vk_funcs->p_vkUnmapMemory(params->device, params->memory);
+    wine_vkUnmapMemory(params->device, params->memory);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -60531,7 +61629,7 @@ static NTSTATUS thunk32_vkUnmapMemory(vo
 
     TRACE("%#x, 0x%s\n", params->device, wine_dbgstr_longlong(params->memory));
 
-    vk_funcs->p_vkUnmapMemory((VkDevice)UlongToPtr(params->device), params->memory);
+    wine_vkUnmapMemory((VkDevice)UlongToPtr(params->device), params->memory);
     return STATUS_SUCCESS;
 }
 
@@ -60573,7 +61671,7 @@ static NTSTATUS thunk64_vkUnmapMemory2KH
 
     TRACE("%p, %p\n", params->device, params->pMemoryUnmapInfo);
 
-    params->result = vk_funcs->p_vkUnmapMemory2KHR(params->device, params->pMemoryUnmapInfo);
+    params->result = wine_vkUnmapMemory2KHR(params->device, params->pMemoryUnmapInfo);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -60591,7 +61689,7 @@ static NTSTATUS thunk32_vkUnmapMemory2KH
     TRACE("%#x, %#x\n", params->device, params->pMemoryUnmapInfo);
 
     convert_VkMemoryUnmapInfo_win32_to_unwrapped_host((const VkMemoryUnmapInfo32 *)UlongToPtr(params->pMemoryUnmapInfo), &pMemoryUnmapInfo_host);
-    params->result = vk_funcs->p_vkUnmapMemory2KHR((VkDevice)UlongToPtr(params->device), &pMemoryUnmapInfo_host);
+    params->result = wine_vkUnmapMemory2KHR((VkDevice)UlongToPtr(params->device), &pMemoryUnmapInfo_host);
     return STATUS_SUCCESS;
 }
 
@@ -60782,16 +61880,10 @@ static NTSTATUS thunk32_vkUpdateVideoSes
 static NTSTATUS thunk64_vkWaitForFences(void *args)
 {
     struct vkWaitForFences_params *params = args;
-    const VkFence *pFences_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %u, %p, %u, 0x%s\n", params->device, params->fenceCount, params->pFences, params->waitAll, wine_dbgstr_longlong(params->timeout));
 
-    init_conversion_context(ctx);
-    pFences_host = convert_VkFence_array_win64_to_host(ctx, params->pFences, params->fenceCount);
-    params->result = vulkan_device_from_handle(params->device)->p_vkWaitForFences(vulkan_device_from_handle(params->device)->host.device, params->fenceCount, pFences_host, params->waitAll, params->timeout);
-    free_conversion_context(ctx);
+    params->result = vulkan_device_from_handle(params->device)->p_vkWaitForFences(vulkan_device_from_handle(params->device)->host.device, params->fenceCount, params->pFences, params->waitAll, params->timeout);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -60807,16 +61899,10 @@ static NTSTATUS thunk32_vkWaitForFences(
         uint64_t DECLSPEC_ALIGN(8) timeout;
         VkResult result;
     } *params = args;
-    const VkFence *pFences_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%#x, %u, %#x, %u, 0x%s\n", params->device, params->fenceCount, params->pFences, params->waitAll, wine_dbgstr_longlong(params->timeout));
 
-    init_conversion_context(ctx);
-    pFences_host = convert_VkFence_array_win32_to_host(ctx, (const VkFence *)UlongToPtr(params->pFences), params->fenceCount);
-    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkWaitForFences(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->fenceCount, pFences_host, params->waitAll, params->timeout);
-    free_conversion_context(ctx);
+    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkWaitForFences(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, params->fenceCount, (const VkFence *)UlongToPtr(params->pFences), params->waitAll, params->timeout);
     return STATUS_SUCCESS;
 }
 
@@ -60883,16 +61969,10 @@ static NTSTATUS thunk32_vkWaitForPresent
 static NTSTATUS thunk64_vkWaitSemaphores(void *args)
 {
     struct vkWaitSemaphores_params *params = args;
-    VkSemaphoreWaitInfo pWaitInfo_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %p, 0x%s\n", params->device, params->pWaitInfo, wine_dbgstr_longlong(params->timeout));
 
-    init_conversion_context(ctx);
-    convert_VkSemaphoreWaitInfo_win64_to_host(ctx, params->pWaitInfo, &pWaitInfo_host);
-    params->result = vulkan_device_from_handle(params->device)->p_vkWaitSemaphores(vulkan_device_from_handle(params->device)->host.device, &pWaitInfo_host, params->timeout);
-    free_conversion_context(ctx);
+    params->result = wine_vkWaitSemaphores(params->device, params->pWaitInfo, params->timeout);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -60907,15 +61987,11 @@ static NTSTATUS thunk32_vkWaitSemaphores
         VkResult result;
     } *params = args;
     VkSemaphoreWaitInfo pWaitInfo_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%#x, %#x, 0x%s\n", params->device, params->pWaitInfo, wine_dbgstr_longlong(params->timeout));
 
-    init_conversion_context(ctx);
-    convert_VkSemaphoreWaitInfo_win32_to_host(ctx, (const VkSemaphoreWaitInfo32 *)UlongToPtr(params->pWaitInfo), &pWaitInfo_host);
-    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkWaitSemaphores(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pWaitInfo_host, params->timeout);
-    free_conversion_context(ctx);
+    convert_VkSemaphoreWaitInfo_win32_to_unwrapped_host((const VkSemaphoreWaitInfo32 *)UlongToPtr(params->pWaitInfo), &pWaitInfo_host);
+    params->result = wine_vkWaitSemaphores((VkDevice)UlongToPtr(params->device), &pWaitInfo_host, params->timeout);
     return STATUS_SUCCESS;
 }
 
@@ -60923,16 +61999,10 @@ static NTSTATUS thunk32_vkWaitSemaphores
 static NTSTATUS thunk64_vkWaitSemaphoresKHR(void *args)
 {
     struct vkWaitSemaphoresKHR_params *params = args;
-    VkSemaphoreWaitInfo pWaitInfo_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%p, %p, 0x%s\n", params->device, params->pWaitInfo, wine_dbgstr_longlong(params->timeout));
 
-    init_conversion_context(ctx);
-    convert_VkSemaphoreWaitInfo_win64_to_host(ctx, params->pWaitInfo, &pWaitInfo_host);
-    params->result = vulkan_device_from_handle(params->device)->p_vkWaitSemaphoresKHR(vulkan_device_from_handle(params->device)->host.device, &pWaitInfo_host, params->timeout);
-    free_conversion_context(ctx);
+    params->result = wine_vkWaitSemaphoresKHR(params->device, params->pWaitInfo, params->timeout);
     return STATUS_SUCCESS;
 }
 #endif /* _WIN64 */
@@ -60947,15 +62017,11 @@ static NTSTATUS thunk32_vkWaitSemaphores
         VkResult result;
     } *params = args;
     VkSemaphoreWaitInfo pWaitInfo_host;
-    struct conversion_context local_ctx;
-    struct conversion_context *ctx = &local_ctx;
 
     TRACE("%#x, %#x, 0x%s\n", params->device, params->pWaitInfo, wine_dbgstr_longlong(params->timeout));
 
-    init_conversion_context(ctx);
-    convert_VkSemaphoreWaitInfo_win32_to_host(ctx, (const VkSemaphoreWaitInfo32 *)UlongToPtr(params->pWaitInfo), &pWaitInfo_host);
-    params->result = vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->p_vkWaitSemaphoresKHR(vulkan_device_from_handle((VkDevice)UlongToPtr(params->device))->host.device, &pWaitInfo_host, params->timeout);
-    free_conversion_context(ctx);
+    convert_VkSemaphoreWaitInfo_win32_to_unwrapped_host((const VkSemaphoreWaitInfo32 *)UlongToPtr(params->pWaitInfo), &pWaitInfo_host);
+    params->result = wine_vkWaitSemaphoresKHR((VkDevice)UlongToPtr(params->device), &pWaitInfo_host, params->timeout);
     return STATUS_SUCCESS;
 }
 
@@ -61023,6 +62089,63 @@ static NTSTATUS thunk32_vkWriteMicromaps
     return STATUS_SUCCESS;
 }
 
+#ifdef _WIN64
+static NTSTATUS thunk64_wine_vkAcquireKeyedMutex(void *args)
+{
+    struct wine_vkAcquireKeyedMutex_params *params = args;
+
+    TRACE("%p, 0x%s, 0x%s, %u\n", params->device, wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->key), params->timeout_ms);
+
+    params->result = wine_wine_vkAcquireKeyedMutex(params->device, params->memory, params->key, params->timeout_ms);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+static NTSTATUS thunk32_wine_vkAcquireKeyedMutex(void *args)
+{
+    struct
+    {
+        PTR32 device;
+        VkDeviceMemory DECLSPEC_ALIGN(8) memory;
+        uint64_t DECLSPEC_ALIGN(8) key;
+        uint32_t timeout_ms;
+        VkResult result;
+    } *params = args;
+
+    TRACE("%#x, 0x%s, 0x%s, %u\n", params->device, wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->key), params->timeout_ms);
+
+    params->result = wine_wine_vkAcquireKeyedMutex((VkDevice)UlongToPtr(params->device), params->memory, params->key, params->timeout_ms);
+    return STATUS_SUCCESS;
+}
+
+#ifdef _WIN64
+static NTSTATUS thunk64_wine_vkReleaseKeyedMutex(void *args)
+{
+    struct wine_vkReleaseKeyedMutex_params *params = args;
+
+    TRACE("%p, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->key));
+
+    params->result = wine_wine_vkReleaseKeyedMutex(params->device, params->memory, params->key);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+static NTSTATUS thunk32_wine_vkReleaseKeyedMutex(void *args)
+{
+    struct
+    {
+        PTR32 device;
+        VkDeviceMemory DECLSPEC_ALIGN(8) memory;
+        uint64_t DECLSPEC_ALIGN(8) key;
+        VkResult result;
+    } *params = args;
+
+    TRACE("%#x, 0x%s, 0x%s\n", params->device, wine_dbgstr_longlong(params->memory), wine_dbgstr_longlong(params->key));
+
+    params->result = wine_wine_vkReleaseKeyedMutex((VkDevice)UlongToPtr(params->device), params->memory, params->key);
+    return STATUS_SUCCESS;
+}
+
 static const char * const vk_device_extensions[] =
 {
     "VK_AMD_anti_lag",
@@ -61203,10 +62326,11 @@ static const char * const vk_device_exte
     "VK_KHR_dynamic_rendering",
     "VK_KHR_dynamic_rendering_local_read",
     "VK_KHR_external_fence",
-    "VK_KHR_external_fence_win32",
     "VK_KHR_external_memory",
+    "VK_KHR_external_memory_fd",
     "VK_KHR_external_memory_win32",
     "VK_KHR_external_semaphore",
+    "VK_KHR_external_semaphore_fd",
     "VK_KHR_external_semaphore_win32",
     "VK_KHR_format_feature_flags2",
     "VK_KHR_fragment_shader_barycentric",
@@ -61452,7 +62576,6 @@ BOOL wine_vk_is_type_wrapped(VkObjectTyp
         type == VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR ||
         type == VK_OBJECT_TYPE_DEVICE ||
         type == VK_OBJECT_TYPE_DEVICE_MEMORY ||
-        type == VK_OBJECT_TYPE_FENCE ||
         type == VK_OBJECT_TYPE_INSTANCE ||
         type == VK_OBJECT_TYPE_PHYSICAL_DEVICE ||
         type == VK_OBJECT_TYPE_QUEUE ||
@@ -61953,7 +63076,6 @@ const unixlib_entry_t __wine_unix_call_f
     thunk64_vkGetEncodedVideoSessionParametersKHR,
     thunk64_vkGetEventStatus,
     thunk64_vkGetFenceStatus,
-    thunk64_vkGetFenceWin32HandleKHR,
     thunk64_vkGetFramebufferTilePropertiesQCOM,
     thunk64_vkGetGeneratedCommandsMemoryRequirementsEXT,
     thunk64_vkGetGeneratedCommandsMemoryRequirementsNV,
@@ -61973,6 +63095,8 @@ const unixlib_entry_t __wine_unix_call_f
     thunk64_vkGetImageViewHandleNVX,
     thunk64_vkGetImageViewOpaqueCaptureDescriptorDataEXT,
     thunk64_vkGetLatencyTimingsNV,
+    thunk64_vkGetMemoryFdKHR,
+    thunk64_vkGetMemoryFdPropertiesKHR,
     thunk64_vkGetMemoryHostPointerPropertiesEXT,
     thunk64_vkGetMemoryWin32HandleKHR,
     thunk64_vkGetMemoryWin32HandlePropertiesKHR,
@@ -62057,6 +63181,7 @@ const unixlib_entry_t __wine_unix_call_f
     thunk64_vkGetSamplerOpaqueCaptureDescriptorDataEXT,
     thunk64_vkGetSemaphoreCounterValue,
     thunk64_vkGetSemaphoreCounterValueKHR,
+    thunk64_vkGetSemaphoreFdKHR,
     thunk64_vkGetSemaphoreWin32HandleKHR,
     thunk64_vkGetShaderBinaryDataEXT,
     thunk64_vkGetShaderInfoAMD,
@@ -62068,7 +63193,7 @@ const unixlib_entry_t __wine_unix_call_f
     thunk64_vkGetTensorViewOpaqueCaptureDescriptorDataARM,
     thunk64_vkGetValidationCacheDataEXT,
     thunk64_vkGetVideoSessionMemoryRequirementsKHR,
-    thunk64_vkImportFenceWin32HandleKHR,
+    thunk64_vkImportSemaphoreFdKHR,
     thunk64_vkImportSemaphoreWin32HandleKHR,
     thunk64_vkInitializePerformanceApiINTEL,
     thunk64_vkInvalidateMappedMemoryRanges,
@@ -62134,6 +63259,8 @@ const unixlib_entry_t __wine_unix_call_f
     thunk64_vkWaitSemaphoresKHR,
     thunk64_vkWriteAccelerationStructuresPropertiesKHR,
     thunk64_vkWriteMicromapsPropertiesEXT,
+    thunk64_wine_vkAcquireKeyedMutex,
+    thunk64_wine_vkReleaseKeyedMutex,
 };
 C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == unix_count);
 
@@ -62633,7 +63760,6 @@ const unixlib_entry_t __wine_unix_call_f
     thunk32_vkGetEncodedVideoSessionParametersKHR,
     thunk32_vkGetEventStatus,
     thunk32_vkGetFenceStatus,
-    thunk32_vkGetFenceWin32HandleKHR,
     thunk32_vkGetFramebufferTilePropertiesQCOM,
     thunk32_vkGetGeneratedCommandsMemoryRequirementsEXT,
     thunk32_vkGetGeneratedCommandsMemoryRequirementsNV,
@@ -62653,6 +63779,8 @@ const unixlib_entry_t __wine_unix_call_f
     thunk32_vkGetImageViewHandleNVX,
     thunk32_vkGetImageViewOpaqueCaptureDescriptorDataEXT,
     thunk32_vkGetLatencyTimingsNV,
+    thunk32_vkGetMemoryFdKHR,
+    thunk32_vkGetMemoryFdPropertiesKHR,
     thunk32_vkGetMemoryHostPointerPropertiesEXT,
     thunk32_vkGetMemoryWin32HandleKHR,
     thunk32_vkGetMemoryWin32HandlePropertiesKHR,
@@ -62737,6 +63865,7 @@ const unixlib_entry_t __wine_unix_call_f
     thunk32_vkGetSamplerOpaqueCaptureDescriptorDataEXT,
     thunk32_vkGetSemaphoreCounterValue,
     thunk32_vkGetSemaphoreCounterValueKHR,
+    thunk32_vkGetSemaphoreFdKHR,
     thunk32_vkGetSemaphoreWin32HandleKHR,
     thunk32_vkGetShaderBinaryDataEXT,
     thunk32_vkGetShaderInfoAMD,
@@ -62748,7 +63877,7 @@ const unixlib_entry_t __wine_unix_call_f
     thunk32_vkGetTensorViewOpaqueCaptureDescriptorDataARM,
     thunk32_vkGetValidationCacheDataEXT,
     thunk32_vkGetVideoSessionMemoryRequirementsKHR,
-    thunk32_vkImportFenceWin32HandleKHR,
+    thunk32_vkImportSemaphoreFdKHR,
     thunk32_vkImportSemaphoreWin32HandleKHR,
     thunk32_vkInitializePerformanceApiINTEL,
     thunk32_vkInvalidateMappedMemoryRanges,
@@ -62814,5 +63943,7 @@ const unixlib_entry_t __wine_unix_call_f
     thunk32_vkWaitSemaphoresKHR,
     thunk32_vkWriteAccelerationStructuresPropertiesKHR,
     thunk32_vkWriteMicromapsPropertiesEXT,
+    thunk32_wine_vkAcquireKeyedMutex,
+    thunk32_wine_vkReleaseKeyedMutex,
 };
 C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == unix_count);
diff -ruN --show-c-function vanilla-1017/dlls/winevulkan/vulkan_thunks.h protonvulkan-1017/dlls/winevulkan/vulkan_thunks.h
--- vanilla-1017/dlls/winevulkan/vulkan_thunks.h	2025-10-21 17:44:43.707946570 -0700
+++ protonvulkan-1017/dlls/winevulkan/vulkan_thunks.h	2025-10-21 17:23:43.028817540 -0700
@@ -22,18 +22,23 @@
 
 /* Functions for which we have custom implementations outside of the thunks. */
 VkResult wine_vkAllocateCommandBuffers(VkDevice device, const VkCommandBufferAllocateInfo *pAllocateInfo, VkCommandBuffer *pCommandBuffers);
+VkResult wine_vkAllocateMemory(VkDevice device, const VkMemoryAllocateInfo *pAllocateInfo, const VkAllocationCallbacks *pAllocator, VkDeviceMemory *pMemory);
+VkResult wine_vkCreateBuffer(VkDevice device, const VkBufferCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBuffer *pBuffer);
 VkResult wine_vkCreateCommandPool(VkDevice device, const VkCommandPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCommandPool *pCommandPool, void *client_ptr);
 VkResult wine_vkCreateDebugReportCallbackEXT(VkInstance instance, const VkDebugReportCallbackCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugReportCallbackEXT *pCallback);
 VkResult wine_vkCreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugUtilsMessengerEXT *pMessenger);
 VkResult wine_vkCreateDeferredOperationKHR(VkDevice device, const VkAllocationCallbacks *pAllocator, VkDeferredOperationKHR *pDeferredOperation);
 VkResult wine_vkCreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDevice *pDevice, void *client_ptr);
+VkResult wine_vkCreateImage(VkDevice device, const VkImageCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkImage *pImage);
 VkResult wine_vkCreateInstance(const VkInstanceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkInstance *pInstance, void *client_ptr);
+VkResult wine_vkCreateSemaphore(VkDevice device, const VkSemaphoreCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSemaphore *pSemaphore);
 void wine_vkDestroyCommandPool(VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks *pAllocator);
 void wine_vkDestroyDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks *pAllocator);
 void wine_vkDestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT messenger, const VkAllocationCallbacks *pAllocator);
 void wine_vkDestroyDeferredOperationKHR(VkDevice device, VkDeferredOperationKHR operation, const VkAllocationCallbacks *pAllocator);
 void wine_vkDestroyDevice(VkDevice device, const VkAllocationCallbacks *pAllocator);
 void wine_vkDestroyInstance(VkInstance instance, const VkAllocationCallbacks *pAllocator);
+void wine_vkDestroySemaphore(VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks *pAllocator);
 VkResult wine_vkEnumerateDeviceExtensionProperties(VkPhysicalDevice physicalDevice, const char *pLayerName, uint32_t *pPropertyCount, VkExtensionProperties *pProperties);
 VkResult wine_vkEnumerateDeviceLayerProperties(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkLayerProperties *pProperties);
 VkResult wine_vkEnumerateInstanceExtensionProperties(const char *pLayerName, uint32_t *pPropertyCount, VkExtensionProperties *pProperties);
@@ -42,13 +47,40 @@ VkResult wine_vkEnumeratePhysicalDeviceG
 VkResult wine_vkEnumeratePhysicalDeviceGroupsKHR(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties);
 VkResult wine_vkEnumeratePhysicalDevices(VkInstance instance, uint32_t *pPhysicalDeviceCount, VkPhysicalDevice *pPhysicalDevices);
 void wine_vkFreeCommandBuffers(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers);
+void wine_vkFreeMemory(VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks *pAllocator);
 VkResult wine_vkGetCalibratedTimestampsEXT(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR *pTimestampInfos, uint64_t *pTimestamps, uint64_t *pMaxDeviation);
 VkResult wine_vkGetCalibratedTimestampsKHR(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR *pTimestampInfos, uint64_t *pTimestamps, uint64_t *pMaxDeviation);
 void wine_vkGetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue *pQueue);
 void wine_vkGetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2 *pQueueInfo, VkQueue *pQueue);
+VkResult wine_vkGetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle);
+VkResult wine_vkGetMemoryWin32HandlePropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR *pMemoryWin32HandleProperties);
 VkResult wine_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainKHR *pTimeDomains);
 VkResult wine_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainKHR *pTimeDomains);
+void wine_vkGetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties);
+void wine_vkGetPhysicalDeviceExternalBufferPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties);
 void wine_vkGetPhysicalDeviceExternalFenceProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties);
 void wine_vkGetPhysicalDeviceExternalFencePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties);
+void wine_vkGetPhysicalDeviceExternalSemaphoreProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties);
+void wine_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties);
+VkResult wine_vkGetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties);
+VkResult wine_vkGetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties);
+VkResult wine_vkGetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore, uint64_t *pValue);
+VkResult wine_vkGetSemaphoreCounterValueKHR(VkDevice device, VkSemaphore semaphore, uint64_t *pValue);
+VkResult wine_vkGetSemaphoreWin32HandleKHR(VkDevice device, const VkSemaphoreGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle);
+VkResult wine_vkImportSemaphoreWin32HandleKHR(VkDevice device, const VkImportSemaphoreWin32HandleInfoKHR *pImportSemaphoreWin32HandleInfo);
+VkResult wine_vkMapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void **ppData);
+VkResult wine_vkMapMemory2KHR(VkDevice device, const VkMemoryMapInfo *pMemoryMapInfo, void **ppData);
+VkResult wine_vkQueueBindSparse(VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo *pBindInfo, VkFence fence);
+VkResult wine_vkQueueSubmit(VkQueue queue, uint32_t submitCount, const VkSubmitInfo *pSubmits, VkFence fence);
+VkResult wine_vkQueueSubmit2(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2 *pSubmits, VkFence fence);
+VkResult wine_vkQueueSubmit2KHR(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2 *pSubmits, VkFence fence);
+VkResult wine_vkSignalSemaphore(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo);
+VkResult wine_vkSignalSemaphoreKHR(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo);
+void wine_vkUnmapMemory(VkDevice device, VkDeviceMemory memory);
+VkResult wine_vkUnmapMemory2KHR(VkDevice device, const VkMemoryUnmapInfo *pMemoryUnmapInfo);
+VkResult wine_vkWaitSemaphores(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout);
+VkResult wine_vkWaitSemaphoresKHR(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout);
+VkResult wine_wine_vkAcquireKeyedMutex(VkDevice device, VkDeviceMemory memory, uint64_t key, uint32_t timeout_ms);
+VkResult wine_wine_vkReleaseKeyedMutex(VkDevice device, VkDeviceMemory memory, uint64_t key);
 
 #endif /* __WINE_VULKAN_THUNKS_H */
diff -ruN --show-c-function vanilla-1017/dlls/winevulkan/winevk.xml protonvulkan-1017/dlls/winevulkan/winevk.xml
--- vanilla-1017/dlls/winevulkan/winevk.xml	2025-10-21 17:44:36.086775184 -0700
+++ protonvulkan-1017/dlls/winevulkan/winevk.xml	1969-12-31 16:00:00.000000000 -0800
@@ -1,11 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<registry>
-    <types>
-        <type requires="windows.h" name="BOOL"/>
-        <type category="struct" name="SECURITY_ATTRIBUTES">
-            <member><type>DWORD</type> <name>nLength</name></member>
-            <member><type>void</type>* <name>lpSecurityDescriptor</name></member>
-            <member><type>BOOL</type> <name>bInheritHandle</name></member>
-        </type>
-    </types>
-</registry>
diff -ruN --show-c-function vanilla-1017/dlls/winevulkan/winevulkan.spec protonvulkan-1017/dlls/winevulkan/winevulkan.spec
--- vanilla-1017/dlls/winevulkan/winevulkan.spec	2025-10-21 17:44:44.783970737 -0700
+++ protonvulkan-1017/dlls/winevulkan/winevulkan.spec	2025-10-21 17:23:44.107350486 -0700
@@ -279,5 +279,7 @@
 @ stdcall vkUpdateDescriptorSets(ptr long ptr long ptr)
 @ stdcall vkWaitForFences(ptr long ptr long int64)
 @ stdcall vkWaitSemaphores(ptr ptr int64)
+@ stdcall wine_vkAcquireKeyedMutex(ptr int64 int64 long)
+@ stdcall wine_vkReleaseKeyedMutex(ptr int64 int64)
 @ stdcall -private DllRegisterServer()
 @ stdcall -private DllUnregisterServer()
diff -ruN --show-c-function vanilla-1017/dlls/winewayland.drv/vulkan.c protonvulkan-1017/dlls/winewayland.drv/vulkan.c
--- vanilla-1017/dlls/winewayland.drv/vulkan.c	2025-10-21 17:44:36.087775206 -0700
+++ protonvulkan-1017/dlls/winewayland.drv/vulkan.c	2025-10-21 17:23:40.592855504 -0700
@@ -81,20 +81,16 @@ static VkBool32 wayland_get_physical_dev
                                                                         process_wayland.wl_display);
 }
 
-static const char *wayland_get_host_extension(const char *name)
+static const char *wayland_get_host_surface_extension(void)
 {
-    if (!strcmp( name, "VK_KHR_win32_surface" )) return "VK_KHR_wayland_surface";
-    if (!strcmp( name, "VK_KHR_external_memory_win32" )) return "VK_KHR_external_memory_fd";
-    if (!strcmp( name, "VK_KHR_external_semaphore_win32" )) return "VK_KHR_external_semaphore_fd";
-    if (!strcmp( name, "VK_KHR_external_fence_win32" )) return "VK_KHR_external_fence_fd";
-    return name;
+    return "VK_KHR_wayland_surface";
 }
 
 static const struct vulkan_driver_funcs wayland_vulkan_driver_funcs =
 {
     .p_vulkan_surface_create = wayland_vulkan_surface_create,
     .p_get_physical_device_presentation_support = wayland_get_physical_device_presentation_support,
-    .p_get_host_extension = wayland_get_host_extension,
+    .p_get_host_surface_extension = wayland_get_host_surface_extension,
 };
 
 /**********************************************************************
diff -ruN --show-c-function vanilla-1017/dlls/winex11.drv/vulkan.c protonvulkan-1017/dlls/winex11.drv/vulkan.c
--- vanilla-1017/dlls/winex11.drv/vulkan.c	2025-10-21 17:44:36.089775251 -0700
+++ protonvulkan-1017/dlls/winex11.drv/vulkan.c	2025-10-21 17:23:40.592953589 -0700
@@ -78,20 +78,16 @@ static VkBool32 X11DRV_get_physical_devi
                                                                       default_visual.visual->visualid );
 }
 
-static const char *X11DRV_get_host_extension( const char *name )
+static const char *X11DRV_get_host_surface_extension(void)
 {
-    if (!strcmp( name, "VK_KHR_win32_surface" )) return "VK_KHR_xlib_surface";
-    if (!strcmp( name, "VK_KHR_external_memory_win32" )) return "VK_KHR_external_memory_fd";
-    if (!strcmp( name, "VK_KHR_external_semaphore_win32" )) return "VK_KHR_external_semaphore_fd";
-    if (!strcmp( name, "VK_KHR_external_fence_win32" )) return "VK_KHR_external_fence_fd";
-    return name;
+    return "VK_KHR_xlib_surface";
 }
 
 static const struct vulkan_driver_funcs x11drv_vulkan_driver_funcs =
 {
     .p_vulkan_surface_create = X11DRV_vulkan_surface_create,
     .p_get_physical_device_presentation_support = X11DRV_get_physical_device_presentation_support,
-    .p_get_host_extension = X11DRV_get_host_extension,
+    .p_get_host_surface_extension = X11DRV_get_host_surface_extension,
 };
 
 UINT X11DRV_VulkanInit( UINT version, void *vulkan_handle, const struct vulkan_driver_funcs **driver_funcs )
diff -ruN --show-c-function vanilla-1017/include/ddk/wdm.h protonvulkan-1017/include/ddk/wdm.h
--- vanilla-1017/include/ddk/wdm.h	2025-10-21 17:44:36.805791369 -0700
+++ protonvulkan-1017/include/ddk/wdm.h	2025-10-21 17:23:40.638255743 -0700
@@ -1889,6 +1889,7 @@ NTSTATUS  WINAPI ObRegisterCallbacks(POB
 NTSTATUS  WINAPI ObReferenceObjectByHandle(HANDLE,ACCESS_MASK,POBJECT_TYPE,KPROCESSOR_MODE,PVOID*,POBJECT_HANDLE_INFORMATION);
 NTSTATUS  WINAPI ObReferenceObjectByName(UNICODE_STRING*,ULONG,ACCESS_STATE*,ACCESS_MASK,POBJECT_TYPE,KPROCESSOR_MODE,void*,void**);
 NTSTATUS  WINAPI ObReferenceObjectByPointer(void*,ACCESS_MASK,POBJECT_TYPE,KPROCESSOR_MODE);
+NTSTATUS  WINAPI ObOpenObjectByPointer(void *,ULONG,ACCESS_STATE*,ACCESS_MASK,POBJECT_TYPE,KPROCESSOR_MODE,HANDLE*);
 void      WINAPI ObUnRegisterCallbacks(void*);
 
 NTSTATUS  WINAPI PoCallDriver(DEVICE_OBJECT*,IRP*);
diff -ruN --show-c-function vanilla-1017/include/wine/server.h protonvulkan-1017/include/wine/server.h
--- vanilla-1017/include/wine/server.h	2025-10-21 17:44:36.175777187 -0700
+++ protonvulkan-1017/include/wine/server.h	2025-10-21 17:23:40.578717624 -0700
@@ -49,7 +49,6 @@ struct __server_request_info
     struct __server_iovec data[__SERVER_MAX_DATA];  /* request variable size data */
 };
 
-NTSYSAPI void CDECL wine_server_send_fd( int fd );
 NTSYSAPI unsigned int CDECL wine_server_call( void *req_ptr );
 NTSYSAPI NTSTATUS CDECL wine_server_fd_to_handle( int fd, unsigned int access, unsigned int attributes, HANDLE *handle );
 NTSYSAPI NTSTATUS CDECL wine_server_handle_to_fd( HANDLE handle, unsigned int access, int *unix_fd, unsigned int *options );
diff -ruN --show-c-function vanilla-1017/include/wine/server_protocol.h protonvulkan-1017/include/wine/server_protocol.h
--- vanilla-1017/include/wine/server_protocol.h	2025-10-21 17:44:36.806791392 -0700
+++ protonvulkan-1017/include/wine/server_protocol.h	2025-10-21 17:23:40.578888798 -0700
@@ -6014,9 +6014,7 @@ struct d3dkmt_object_create_request
 {
     struct request_header __header;
     unsigned int        type;
-    int                 fd;
     /* VARARG(runtime,bytes); */
-    char __pad_20[4];
 };
 struct d3dkmt_object_create_reply
 {
@@ -6032,8 +6030,8 @@ struct d3dkmt_object_update_request
     struct request_header __header;
     unsigned int        type;
     d3dkmt_handle_t     global;
+    obj_handle_t        handle;
     /* VARARG(runtime,bytes); */
-    char __pad_20[4];
 };
 struct d3dkmt_object_update_reply
 {
diff -ruN --show-c-function vanilla-1017/include/wine/vulkan_driver.h protonvulkan-1017/include/wine/vulkan_driver.h
--- vanilla-1017/include/wine/vulkan_driver.h	2025-10-21 17:44:36.176777210 -0700
+++ protonvulkan-1017/include/wine/vulkan_driver.h	2025-10-21 17:23:40.647755741 -0700
@@ -45,9 +45,10 @@ struct vulkan_client_object
 
 #include "wine/vulkan.h"
 #include "wine/rbtree.h"
+#include "wine/list.h"
 
 /* Wine internal vulkan driver version, needs to be bumped upon vulkan_funcs changes. */
-#define WINE_VULKAN_DRIVER_VERSION 47
+#define WINE_VULKAN_DRIVER_VERSION 40
 
 struct vulkan_object
 {
@@ -79,9 +80,7 @@ struct vulkan_instance
 #undef USE_VK_FUNC
     void (*p_insert_object)( struct vulkan_instance *instance, struct vulkan_object *obj );
     void (*p_remove_object)( struct vulkan_instance *instance, struct vulkan_object *obj );
-
-    struct vulkan_physical_device *physical_devices;
-    uint32_t physical_device_count;
+    uint32_t api_version;
 };
 
 static inline struct vulkan_instance *vulkan_instance_from_handle( VkInstance handle )
@@ -94,16 +93,8 @@ struct vulkan_physical_device
 {
     VULKAN_OBJECT_HEADER( VkPhysicalDevice, physical_device );
     struct vulkan_instance *instance;
-    bool has_surface_maintenance1;
+    uint32_t api_version;
     bool has_swapchain_maintenance1;
-
-    VkExtensionProperties *extensions;
-    uint32_t extension_count;
-
-    /* for WOW64 memory mapping with VK_EXT_external_memory_host */
-    VkPhysicalDeviceMemoryProperties memory_properties;
-    uint32_t external_memory_align;
-    uint32_t map_placed_align;
 };
 
 static inline struct vulkan_physical_device *vulkan_physical_device_from_handle( VkPhysicalDevice handle )
@@ -112,6 +103,12 @@ static inline struct vulkan_physical_dev
     return (struct vulkan_physical_device *)(UINT_PTR)client->unix_handle;
 }
 
+struct local_timeline_semaphore
+{
+    VkSemaphore sem;
+    uint64_t value;
+};
+
 struct vulkan_device
 {
     VULKAN_OBJECT_HEADER( VkDevice, device );
@@ -119,6 +116,21 @@ struct vulkan_device
 #define USE_VK_FUNC(x) PFN_ ## x p_ ## x;
     ALL_VK_DEVICE_FUNCS
 #undef USE_VK_FUNC
+    uint64_t queue_count;
+    struct vulkan_queue *queues;
+    VkQueueFamilyProperties *queue_props;
+
+    pthread_t signaller_thread;
+    pthread_mutex_t signaller_mutex;
+    BOOL stop;
+    struct list free_fence_ops_list;
+    struct list sem_poll_list;
+    struct local_timeline_semaphore sem_poll_update;
+    pthread_cond_t sem_poll_updated_cond;
+    uint64_t sem_poll_update_value; /* set to sem_poll_update.value by signaller thread once update is processed. */
+    unsigned int allocated_fence_ops_count;
+
+    BOOL keyed_mutexes_enabled;
 };
 
 static inline struct vulkan_device *vulkan_device_from_handle( VkDevice handle )
@@ -131,6 +143,9 @@ struct vulkan_queue
 {
     VULKAN_OBJECT_HEADER( VkQueue, queue );
     struct vulkan_device *device;
+    uint32_t family_index;
+    uint32_t queue_index;
+    VkDeviceQueueCreateFlags flags;
 };
 
 static inline struct vulkan_queue *vulkan_queue_from_handle( VkQueue handle )
@@ -139,28 +154,6 @@ static inline struct vulkan_queue *vulka
     return (struct vulkan_queue *)(UINT_PTR)client->unix_handle;
 }
 
-struct vulkan_command_buffer
-{
-    VULKAN_OBJECT_HEADER( VkCommandBuffer, command_buffer );
-    struct vulkan_device *device;
-};
-
-static inline struct vulkan_command_buffer *vulkan_command_buffer_from_handle( VkCommandBuffer handle )
-{
-    struct vulkan_client_object *client = (struct vulkan_client_object *)handle;
-    return (struct vulkan_command_buffer *)(UINT_PTR)client->unix_handle;
-}
-
-struct vulkan_device_memory
-{
-    VULKAN_OBJECT_HEADER( VkDeviceMemory, device_memory );
-};
-
-static inline struct vulkan_device_memory *vulkan_device_memory_from_handle( VkDeviceMemory handle )
-{
-    return (struct vulkan_device_memory *)(UINT_PTR)handle;
-}
-
 struct vulkan_surface
 {
     VULKAN_OBJECT_HEADER( VkSurfaceKHR, surface );
@@ -185,6 +178,7 @@ static inline struct vulkan_swapchain *v
 struct vulkan_semaphore
 {
     VULKAN_OBJECT_HEADER( VkSemaphore, semaphore );
+    BOOL d3d12_fence;
 };
 
 static inline struct vulkan_semaphore *vulkan_semaphore_from_handle( VkSemaphore handle )
@@ -192,16 +186,6 @@ static inline struct vulkan_semaphore *v
     return (struct vulkan_semaphore *)(UINT_PTR)handle;
 }
 
-struct vulkan_fence
-{
-    VULKAN_OBJECT_HEADER( VkFence, fence );
-};
-
-static inline struct vulkan_fence *vulkan_fence_from_handle( VkFence handle )
-{
-    return (struct vulkan_fence *)(UINT_PTR)handle;
-}
-
 struct vulkan_funcs
 {
     /* Vulkan global functions. These are the only calls at this point a graphics driver
@@ -210,34 +194,12 @@ struct vulkan_funcs
      */
     PFN_vkAcquireNextImage2KHR p_vkAcquireNextImage2KHR;
     PFN_vkAcquireNextImageKHR p_vkAcquireNextImageKHR;
-    PFN_vkAllocateMemory p_vkAllocateMemory;
-    PFN_vkCreateBuffer p_vkCreateBuffer;
-    PFN_vkCreateFence p_vkCreateFence;
-    PFN_vkCreateImage p_vkCreateImage;
-    PFN_vkCreateSemaphore p_vkCreateSemaphore;
     PFN_vkCreateSwapchainKHR p_vkCreateSwapchainKHR;
     PFN_vkCreateWin32SurfaceKHR p_vkCreateWin32SurfaceKHR;
-    PFN_vkDestroyFence p_vkDestroyFence;
-    PFN_vkDestroySemaphore p_vkDestroySemaphore;
     PFN_vkDestroySurfaceKHR p_vkDestroySurfaceKHR;
     PFN_vkDestroySwapchainKHR p_vkDestroySwapchainKHR;
-    PFN_vkFreeMemory p_vkFreeMemory;
-    PFN_vkGetDeviceBufferMemoryRequirements p_vkGetDeviceBufferMemoryRequirements;
-    PFN_vkGetDeviceBufferMemoryRequirementsKHR p_vkGetDeviceBufferMemoryRequirementsKHR;
-    PFN_vkGetDeviceImageMemoryRequirements p_vkGetDeviceImageMemoryRequirements;
     PFN_vkGetDeviceProcAddr p_vkGetDeviceProcAddr;
-    PFN_vkGetFenceWin32HandleKHR p_vkGetFenceWin32HandleKHR;
     PFN_vkGetInstanceProcAddr p_vkGetInstanceProcAddr;
-    PFN_vkGetMemoryWin32HandleKHR p_vkGetMemoryWin32HandleKHR;
-    PFN_vkGetMemoryWin32HandlePropertiesKHR p_vkGetMemoryWin32HandlePropertiesKHR;
-    PFN_vkGetPhysicalDeviceExternalBufferProperties p_vkGetPhysicalDeviceExternalBufferProperties;
-    PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR p_vkGetPhysicalDeviceExternalBufferPropertiesKHR;
-    PFN_vkGetPhysicalDeviceExternalFenceProperties p_vkGetPhysicalDeviceExternalFenceProperties;
-    PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR p_vkGetPhysicalDeviceExternalFencePropertiesKHR;
-    PFN_vkGetPhysicalDeviceExternalSemaphoreProperties p_vkGetPhysicalDeviceExternalSemaphoreProperties;
-    PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR p_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR;
-    PFN_vkGetPhysicalDeviceImageFormatProperties2 p_vkGetPhysicalDeviceImageFormatProperties2;
-    PFN_vkGetPhysicalDeviceImageFormatProperties2KHR p_vkGetPhysicalDeviceImageFormatProperties2KHR;
     PFN_vkGetPhysicalDevicePresentRectanglesKHR p_vkGetPhysicalDevicePresentRectanglesKHR;
     PFN_vkGetPhysicalDeviceProperties2 p_vkGetPhysicalDeviceProperties2;
     PFN_vkGetPhysicalDeviceProperties2KHR p_vkGetPhysicalDeviceProperties2KHR;
@@ -246,20 +208,10 @@ struct vulkan_funcs
     PFN_vkGetPhysicalDeviceSurfaceFormats2KHR p_vkGetPhysicalDeviceSurfaceFormats2KHR;
     PFN_vkGetPhysicalDeviceSurfaceFormatsKHR p_vkGetPhysicalDeviceSurfaceFormatsKHR;
     PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR p_vkGetPhysicalDeviceWin32PresentationSupportKHR;
-    PFN_vkGetSemaphoreWin32HandleKHR p_vkGetSemaphoreWin32HandleKHR;
-    PFN_vkImportFenceWin32HandleKHR p_vkImportFenceWin32HandleKHR;
-    PFN_vkImportSemaphoreWin32HandleKHR p_vkImportSemaphoreWin32HandleKHR;
-    PFN_vkMapMemory p_vkMapMemory;
-    PFN_vkMapMemory2KHR p_vkMapMemory2KHR;
     PFN_vkQueuePresentKHR p_vkQueuePresentKHR;
-    PFN_vkQueueSubmit p_vkQueueSubmit;
-    PFN_vkQueueSubmit2 p_vkQueueSubmit2;
-    PFN_vkQueueSubmit2KHR p_vkQueueSubmit2KHR;
-    PFN_vkUnmapMemory p_vkUnmapMemory;
-    PFN_vkUnmapMemory2KHR p_vkUnmapMemory2KHR;
 
     /* winevulkan specific functions */
-    const char *(*p_get_host_extension)( const char *name );
+    const char *(*p_get_host_surface_extension)(void);
 };
 
 /* interface between win32u and the user drivers */
@@ -268,7 +220,7 @@ struct vulkan_driver_funcs
 {
     VkResult (*p_vulkan_surface_create)(HWND, const struct vulkan_instance *, VkSurfaceKHR *, struct client_surface **);
     VkBool32 (*p_get_physical_device_presentation_support)(struct vulkan_physical_device *, uint32_t);
-    const char *(*p_get_host_extension)( const char *name );
+    const char *(*p_get_host_surface_extension)(void);
 };
 
 #endif /* WINE_UNIX_LIB */
diff -ruN --show-c-function vanilla-1017/include/wine/vulkan.h protonvulkan-1017/include/wine/vulkan.h
--- vanilla-1017/include/wine/vulkan.h	2025-10-21 17:44:43.706946548 -0700
+++ protonvulkan-1017/include/wine/vulkan.h	2025-10-21 17:23:43.027817524 -0700
@@ -234,10 +234,6 @@ typedef struct _XDisplay Display;
 #define VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_fence_capabilities"
 #define VK_KHR_EXTERNAL_FENCE_SPEC_VERSION 1
 #define VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME "VK_KHR_external_fence"
-#define VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION 1
-#define VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME "VK_KHR_external_fence_win32"
-#define VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION 1
-#define VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME "VK_KHR_external_fence_fd"
 #define VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION 1
 #define VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME "VK_KHR_performance_query"
 #define VK_KHR_MAINTENANCE2_SPEC_VERSION VK_KHR_MAINTENANCE_2_SPEC_VERSION
@@ -250,8 +246,6 @@ typedef struct _XDisplay Display;
 #define VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME "VK_KHR_variable_pointers"
 #define VK_MVK_MACOS_SURFACE_SPEC_VERSION 3
 #define VK_MVK_MACOS_SURFACE_EXTENSION_NAME "VK_MVK_macos_surface"
-#define VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION 1
-#define VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME "VK_EXT_external_memory_dma_buf"
 #define VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION 1
 #define VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME "VK_EXT_queue_family_foreign"
 #define VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION 3
@@ -298,8 +292,6 @@ typedef struct _XDisplay Display;
 #define VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME "VK_KHR_sampler_ycbcr_conversion"
 #define VK_KHR_BIND_MEMORY_2_SPEC_VERSION 1
 #define VK_KHR_BIND_MEMORY_2_EXTENSION_NAME "VK_KHR_bind_memory2"
-#define VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION 2
-#define VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME "VK_EXT_image_drm_format_modifier"
 #define VK_EXT_VALIDATION_CACHE_SPEC_VERSION 1
 #define VK_EXT_VALIDATION_CACHE_EXTENSION_NAME "VK_EXT_validation_cache"
 #define VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION 2
@@ -811,8 +803,6 @@ typedef struct _XDisplay Display;
 #define VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME "VK_NV_cooperative_matrix2"
 #define VK_ARM_PIPELINE_OPACITY_MICROMAP_SPEC_VERSION 1
 #define VK_ARM_PIPELINE_OPACITY_MICROMAP_EXTENSION_NAME "VK_ARM_pipeline_opacity_micromap"
-#define VK_EXT_EXTERNAL_MEMORY_METAL_SPEC_VERSION 1
-#define VK_EXT_EXTERNAL_MEMORY_METAL_EXTENSION_NAME "VK_EXT_external_memory_metal"
 #define VK_KHR_DEPTH_CLAMP_ZERO_ONE_SPEC_VERSION 1
 #define VK_KHR_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME "VK_KHR_depth_clamp_zero_one"
 #define VK_EXT_VERTEX_ATTRIBUTE_ROBUSTNESS_SPEC_VERSION 1
@@ -3009,10 +2999,6 @@ typedef enum VkExternalMemoryHandleTypeF
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 0x00000040,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = 0x00000080,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 0x00000100,
-    VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = 0x00000200,
-    VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT = 0x00010000,
-    VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT = 0x00020000,
-    VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT = 0x00040000,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
     VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
@@ -3655,10 +3641,6 @@ typedef enum VkImageAspectFlagBits
     VK_IMAGE_ASPECT_PLANE_0_BIT = 0x00000010,
     VK_IMAGE_ASPECT_PLANE_1_BIT = 0x00000020,
     VK_IMAGE_ASPECT_PLANE_2_BIT = 0x00000040,
-    VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT = 0x00000080,
-    VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT = 0x00000100,
-    VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT = 0x00000200,
-    VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT = 0x00000400,
     VK_IMAGE_ASPECT_PLANE_0_BIT_KHR = VK_IMAGE_ASPECT_PLANE_0_BIT,
     VK_IMAGE_ASPECT_PLANE_1_BIT_KHR = VK_IMAGE_ASPECT_PLANE_1_BIT,
     VK_IMAGE_ASPECT_PLANE_2_BIT_KHR = VK_IMAGE_ASPECT_PLANE_2_BIT,
@@ -3787,7 +3769,6 @@ typedef enum VkImageTiling
 {
     VK_IMAGE_TILING_OPTIMAL = 0,
     VK_IMAGE_TILING_LINEAR = 1,
-    VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT = 1000158000,
     VK_IMAGE_TILING_MAX_ENUM = 0x7fffffff,
 } VkImageTiling;
 
@@ -4977,7 +4958,6 @@ typedef enum VkResult
     VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000,
     VK_ERROR_NOT_PERMITTED = -1000174001,
     VK_ERROR_FRAGMENTATION = -1000161000,
-    VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
     VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
     VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
     VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR = -1000023005,
@@ -5519,11 +5499,6 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
     VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001,
     VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000,
-    VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
-    VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
-    VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
-    VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
-    VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR = 1000116000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR = 1000116001,
     VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR = 1000116002,
@@ -5603,12 +5578,6 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
     VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000,
     VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001,
-    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT = 1000158000,
-    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT = 1000158002,
-    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT = 1000158003,
-    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT = 1000158004,
-    VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT = 1000158005,
-    VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT = 1000158006,
     VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
     VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
     VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO = 1000161000,
@@ -6246,9 +6215,6 @@ typedef enum VkStructureType
     VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV = 1000593001,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV = 1000593002,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM = 1000596000,
-    VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT = 1000602000,
-    VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT = 1000602001,
-    VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT = 1000602002,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT = 1000608000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM = 1000609000,
     VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE = 1000611000,
@@ -9349,20 +9315,6 @@ typedef struct VkDeviceQueueCreateInfo
     const float *pQueuePriorities;
 } VkDeviceQueueCreateInfo;
 
-typedef struct VkDrmFormatModifierProperties2EXT
-{
-    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
-    uint32_t drmFormatModifierPlaneCount;
-    VkFormatFeatureFlags2 WINE_VK_ALIGN(8) drmFormatModifierTilingFeatures;
-} VkDrmFormatModifierProperties2EXT;
-
-typedef struct VkDrmFormatModifierPropertiesEXT
-{
-    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
-    uint32_t drmFormatModifierPlaneCount;
-    VkFormatFeatureFlags drmFormatModifierTilingFeatures;
-} VkDrmFormatModifierPropertiesEXT;
-
 typedef struct VkExtensionProperties
 {
     char extensionName[VK_MAX_EXTENSION_NAME_SIZE];
@@ -12048,22 +12000,6 @@ typedef struct VkDrawMeshTasksIndirectCo
     uint32_t firstTask;
 } VkDrawMeshTasksIndirectCommandNV;
 
-typedef struct VkDrmFormatModifierPropertiesList2EXT
-{
-    VkStructureType sType;
-    void *pNext;
-    uint32_t drmFormatModifierCount;
-    VkDrmFormatModifierProperties2EXT *pDrmFormatModifierProperties;
-} VkDrmFormatModifierPropertiesList2EXT;
-
-typedef struct VkDrmFormatModifierPropertiesListEXT
-{
-    VkStructureType sType;
-    void *pNext;
-    uint32_t drmFormatModifierCount;
-    VkDrmFormatModifierPropertiesEXT *pDrmFormatModifierProperties;
-} VkDrmFormatModifierPropertiesListEXT;
-
 typedef struct VkEventCreateInfo
 {
     VkStructureType sType;
@@ -12079,15 +12015,6 @@ typedef struct VkExportFenceCreateInfo
 } VkExportFenceCreateInfo;
 typedef VkExportFenceCreateInfo VkExportFenceCreateInfoKHR;
 
-typedef struct VkExportFenceWin32HandleInfoKHR
-{
-    VkStructureType sType;
-    const void *pNext;
-    const SECURITY_ATTRIBUTES *pAttributes;
-    DWORD dwAccess;
-    LPCWSTR name;
-} VkExportFenceWin32HandleInfoKHR;
-
 typedef struct VkExportMemoryAllocateInfo
 {
     VkStructureType sType;
@@ -12202,22 +12129,6 @@ typedef struct VkFenceCreateInfo
     VkFenceCreateFlags flags;
 } VkFenceCreateInfo;
 
-typedef struct VkFenceGetFdInfoKHR
-{
-    VkStructureType sType;
-    const void *pNext;
-    VkFence WINE_VK_ALIGN(8) fence;
-    VkExternalFenceHandleTypeFlagBits handleType;
-} VkFenceGetFdInfoKHR;
-
-typedef struct VkFenceGetWin32HandleInfoKHR
-{
-    VkStructureType sType;
-    const void *pNext;
-    VkFence WINE_VK_ALIGN(8) fence;
-    VkExternalFenceHandleTypeFlagBits handleType;
-} VkFenceGetWin32HandleInfoKHR;
-
 typedef struct VkFilterCubicImageViewImageFormatPropertiesEXT
 {
     VkStructureType sType;
@@ -12522,30 +12433,6 @@ typedef struct VkImageCopy
     VkExtent3D extent;
 } VkImageCopy;
 
-typedef struct VkImageDrmFormatModifierExplicitCreateInfoEXT
-{
-    VkStructureType sType;
-    const void *pNext;
-    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
-    uint32_t drmFormatModifierPlaneCount;
-    const VkSubresourceLayout *pPlaneLayouts;
-} VkImageDrmFormatModifierExplicitCreateInfoEXT;
-
-typedef struct VkImageDrmFormatModifierListCreateInfoEXT
-{
-    VkStructureType sType;
-    const void *pNext;
-    uint32_t drmFormatModifierCount;
-    const uint64_t *pDrmFormatModifiers;
-} VkImageDrmFormatModifierListCreateInfoEXT;
-
-typedef struct VkImageDrmFormatModifierPropertiesEXT
-{
-    VkStructureType sType;
-    void *pNext;
-    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
-} VkImageDrmFormatModifierPropertiesEXT;
-
 typedef struct VkImageFormatListCreateInfo
 {
     VkStructureType sType;
@@ -12700,27 +12587,6 @@ typedef struct VkImageViewUsageCreateInf
 } VkImageViewUsageCreateInfo;
 typedef VkImageViewUsageCreateInfo VkImageViewUsageCreateInfoKHR;
 
-typedef struct VkImportFenceFdInfoKHR
-{
-    VkStructureType sType;
-    const void *pNext;
-    VkFence WINE_VK_ALIGN(8) fence;
-    VkFenceImportFlags flags;
-    VkExternalFenceHandleTypeFlagBits handleType;
-    int fd;
-} VkImportFenceFdInfoKHR;
-
-typedef struct VkImportFenceWin32HandleInfoKHR
-{
-    VkStructureType sType;
-    const void *pNext;
-    VkFence WINE_VK_ALIGN(8) fence;
-    VkFenceImportFlags flags;
-    VkExternalFenceHandleTypeFlagBits handleType;
-    HANDLE handle;
-    LPCWSTR name;
-} VkImportFenceWin32HandleInfoKHR;
-
 typedef struct VkImportMemoryFdInfoKHR
 {
     VkStructureType sType;
@@ -12737,14 +12603,6 @@ typedef struct VkImportMemoryHostPointer
     void *pHostPointer;
 } VkImportMemoryHostPointerInfoEXT;
 
-typedef struct VkImportMemoryMetalHandleInfoEXT
-{
-    VkStructureType sType;
-    const void *pNext;
-    VkExternalMemoryHandleTypeFlagBits handleType;
-    void *handle;
-} VkImportMemoryMetalHandleInfoEXT;
-
 typedef struct VkImportMemoryWin32HandleInfoKHR
 {
     VkStructureType sType;
@@ -12964,14 +12822,6 @@ typedef struct VkMemoryGetFdInfoKHR
     VkExternalMemoryHandleTypeFlagBits handleType;
 } VkMemoryGetFdInfoKHR;
 
-typedef struct VkMemoryGetMetalHandleInfoEXT
-{
-    VkStructureType sType;
-    const void *pNext;
-    VkDeviceMemory WINE_VK_ALIGN(8) memory;
-    VkExternalMemoryHandleTypeFlagBits handleType;
-} VkMemoryGetMetalHandleInfoEXT;
-
 typedef struct VkMemoryGetWin32HandleInfoKHR
 {
     VkStructureType sType;
@@ -13005,13 +12855,6 @@ typedef struct VkMemoryMapPlacedInfoEXT
     void *pPlacedAddress;
 } VkMemoryMapPlacedInfoEXT;
 
-typedef struct VkMemoryMetalHandlePropertiesEXT
-{
-    VkStructureType sType;
-    void *pNext;
-    uint32_t memoryTypeBits;
-} VkMemoryMetalHandlePropertiesEXT;
-
 typedef struct VkMemoryOpaqueCaptureAddressAllocateInfo
 {
     VkStructureType sType;
@@ -14487,16 +14330,6 @@ typedef struct VkPhysicalDeviceImageComp
     VkBool32 imageCompressionControlSwapchain;
 } VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT;
 
-typedef struct VkPhysicalDeviceImageDrmFormatModifierInfoEXT
-{
-    VkStructureType sType;
-    const void *pNext;
-    uint64_t WINE_VK_ALIGN(8) drmFormatModifier;
-    VkSharingMode sharingMode;
-    uint32_t queueFamilyIndexCount;
-    const uint32_t *pQueueFamilyIndices;
-} VkPhysicalDeviceImageDrmFormatModifierInfoEXT;
-
 typedef struct VkPhysicalDeviceImageFormatInfo2
 {
     VkStructureType sType;
@@ -19439,13 +19272,10 @@ typedef void (VKAPI_PTR *PFN_vkGetDevice
 typedef VkResult (VKAPI_PTR *PFN_vkGetDynamicRenderingTilePropertiesQCOM)(VkDevice, const VkRenderingInfo *, VkTilePropertiesQCOM *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetEncodedVideoSessionParametersKHR)(VkDevice, const VkVideoEncodeSessionParametersGetInfoKHR *, VkVideoEncodeSessionParametersFeedbackInfoKHR *, size_t *, void *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetEventStatus)(VkDevice, VkEvent);
-typedef VkResult (VKAPI_PTR *PFN_vkGetFenceFdKHR)(VkDevice, const VkFenceGetFdInfoKHR *, int *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetFenceStatus)(VkDevice, VkFence);
-typedef VkResult (VKAPI_PTR *PFN_vkGetFenceWin32HandleKHR)(VkDevice, const VkFenceGetWin32HandleInfoKHR *, HANDLE *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetFramebufferTilePropertiesQCOM)(VkDevice, VkFramebuffer, uint32_t *, VkTilePropertiesQCOM *);
 typedef void (VKAPI_PTR *PFN_vkGetGeneratedCommandsMemoryRequirementsEXT)(VkDevice, const VkGeneratedCommandsMemoryRequirementsInfoEXT *, VkMemoryRequirements2 *);
 typedef void (VKAPI_PTR *PFN_vkGetGeneratedCommandsMemoryRequirementsNV)(VkDevice, const VkGeneratedCommandsMemoryRequirementsInfoNV *, VkMemoryRequirements2 *);
-typedef VkResult (VKAPI_PTR *PFN_vkGetImageDrmFormatModifierPropertiesEXT)(VkDevice, VkImage, VkImageDrmFormatModifierPropertiesEXT *);
 typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements)(VkDevice, VkImage, VkMemoryRequirements *);
 typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements2)(VkDevice, const VkImageMemoryRequirementsInfo2 *, VkMemoryRequirements2 *);
 typedef void (VKAPI_PTR *PFN_vkGetImageMemoryRequirements2KHR)(VkDevice, const VkImageMemoryRequirementsInfo2 *, VkMemoryRequirements2 *);
@@ -19466,8 +19296,6 @@ typedef void (VKAPI_PTR *PFN_vkGetLatenc
 typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryFdKHR)(VkDevice, const VkMemoryGetFdInfoKHR *, int *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryFdPropertiesKHR)(VkDevice, VkExternalMemoryHandleTypeFlagBits, int, VkMemoryFdPropertiesKHR *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryHostPointerPropertiesEXT)(VkDevice, VkExternalMemoryHandleTypeFlagBits, const void *, VkMemoryHostPointerPropertiesEXT *);
-typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryMetalHandleEXT)(VkDevice, const VkMemoryGetMetalHandleInfoEXT *, void **);
-typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryMetalHandlePropertiesEXT)(VkDevice, VkExternalMemoryHandleTypeFlagBits, const void *, VkMemoryMetalHandlePropertiesEXT *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandleKHR)(VkDevice, const VkMemoryGetWin32HandleInfoKHR *, HANDLE *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetMemoryWin32HandlePropertiesKHR)(VkDevice, VkExternalMemoryHandleTypeFlagBits, HANDLE, VkMemoryWin32HandlePropertiesKHR *);
 typedef void (VKAPI_PTR *PFN_vkGetMicromapBuildSizesEXT)(VkDevice, VkAccelerationStructureBuildTypeKHR, const VkMicromapBuildInfoEXT *, VkMicromapBuildSizesInfoEXT *);
@@ -19565,8 +19393,6 @@ typedef VkResult (VKAPI_PTR *PFN_vkGetTe
 typedef VkResult (VKAPI_PTR *PFN_vkGetTensorViewOpaqueCaptureDescriptorDataARM)(VkDevice, const VkTensorViewCaptureDescriptorDataInfoARM *, void *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetValidationCacheDataEXT)(VkDevice, VkValidationCacheEXT, size_t *, void *);
 typedef VkResult (VKAPI_PTR *PFN_vkGetVideoSessionMemoryRequirementsKHR)(VkDevice, VkVideoSessionKHR, uint32_t *, VkVideoSessionMemoryRequirementsKHR *);
-typedef VkResult (VKAPI_PTR *PFN_vkImportFenceFdKHR)(VkDevice, const VkImportFenceFdInfoKHR *);
-typedef VkResult (VKAPI_PTR *PFN_vkImportFenceWin32HandleKHR)(VkDevice, const VkImportFenceWin32HandleInfoKHR *);
 typedef VkResult (VKAPI_PTR *PFN_vkImportSemaphoreFdKHR)(VkDevice, const VkImportSemaphoreFdInfoKHR *);
 typedef VkResult (VKAPI_PTR *PFN_vkImportSemaphoreWin32HandleKHR)(VkDevice, const VkImportSemaphoreWin32HandleInfoKHR *);
 typedef VkResult (VKAPI_PTR *PFN_vkInitializePerformanceApiINTEL)(VkDevice, const VkInitializePerformanceApiInfoINTEL *);
@@ -19633,6 +19459,8 @@ typedef VkResult (VKAPI_PTR *PFN_vkWaitS
 typedef VkResult (VKAPI_PTR *PFN_vkWaitSemaphoresKHR)(VkDevice, const VkSemaphoreWaitInfo *, uint64_t);
 typedef VkResult (VKAPI_PTR *PFN_vkWriteAccelerationStructuresPropertiesKHR)(VkDevice, uint32_t, const VkAccelerationStructureKHR *, VkQueryType, size_t, void *, size_t);
 typedef VkResult (VKAPI_PTR *PFN_vkWriteMicromapsPropertiesEXT)(VkDevice, uint32_t, const VkMicromapEXT *, VkQueryType, size_t, void *, size_t);
+typedef VkResult (VKAPI_PTR *PFN_wine_vkAcquireKeyedMutex)(VkDevice, VkDeviceMemory, uint64_t, uint32_t);
+typedef VkResult (VKAPI_PTR *PFN_wine_vkReleaseKeyedMutex)(VkDevice, VkDeviceMemory, uint64_t);
 
 #ifndef VK_NO_PROTOTYPES
 VkResult VKAPI_CALL vkAcquireNextImage2KHR(VkDevice device, const VkAcquireNextImageInfoKHR *pAcquireInfo, uint32_t *pImageIndex);
@@ -20126,13 +19954,10 @@ void VKAPI_CALL vkGetDeviceTensorMemoryR
 VkResult VKAPI_CALL vkGetDynamicRenderingTilePropertiesQCOM(VkDevice device, const VkRenderingInfo *pRenderingInfo, VkTilePropertiesQCOM *pProperties);
 VkResult VKAPI_CALL vkGetEncodedVideoSessionParametersKHR(VkDevice device, const VkVideoEncodeSessionParametersGetInfoKHR *pVideoSessionParametersInfo, VkVideoEncodeSessionParametersFeedbackInfoKHR *pFeedbackInfo, size_t *pDataSize, void *pData);
 VkResult VKAPI_CALL vkGetEventStatus(VkDevice device, VkEvent event);
-VkResult VKAPI_CALL vkGetFenceFdKHR(VkDevice device, const VkFenceGetFdInfoKHR *pGetFdInfo, int *pFd);
 VkResult VKAPI_CALL vkGetFenceStatus(VkDevice device, VkFence fence);
-VkResult VKAPI_CALL vkGetFenceWin32HandleKHR(VkDevice device, const VkFenceGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle);
 VkResult VKAPI_CALL vkGetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer, uint32_t *pPropertiesCount, VkTilePropertiesQCOM *pProperties);
 void VKAPI_CALL vkGetGeneratedCommandsMemoryRequirementsEXT(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoEXT *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
 void VKAPI_CALL vkGetGeneratedCommandsMemoryRequirementsNV(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
-VkResult VKAPI_CALL vkGetImageDrmFormatModifierPropertiesEXT(VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT *pProperties);
 void VKAPI_CALL vkGetImageMemoryRequirements(VkDevice device, VkImage image, VkMemoryRequirements *pMemoryRequirements);
 void VKAPI_CALL vkGetImageMemoryRequirements2(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
 void VKAPI_CALL vkGetImageMemoryRequirements2KHR(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements);
@@ -20153,8 +19978,6 @@ void VKAPI_CALL vkGetLatencyTimingsNV(Vk
 VkResult VKAPI_CALL vkGetMemoryFdKHR(VkDevice device, const VkMemoryGetFdInfoKHR *pGetFdInfo, int *pFd);
 VkResult VKAPI_CALL vkGetMemoryFdPropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR *pMemoryFdProperties);
 VkResult VKAPI_CALL vkGetMemoryHostPointerPropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHostPointer, VkMemoryHostPointerPropertiesEXT *pMemoryHostPointerProperties);
-VkResult VKAPI_CALL vkGetMemoryMetalHandleEXT(VkDevice device, const VkMemoryGetMetalHandleInfoEXT *pGetMetalHandleInfo, void **pHandle);
-VkResult VKAPI_CALL vkGetMemoryMetalHandlePropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHandle, VkMemoryMetalHandlePropertiesEXT *pMemoryMetalHandleProperties);
 VkResult VKAPI_CALL vkGetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle);
 VkResult VKAPI_CALL vkGetMemoryWin32HandlePropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR *pMemoryWin32HandleProperties);
 void VKAPI_CALL vkGetMicromapBuildSizesEXT(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkMicromapBuildInfoEXT *pBuildInfo, VkMicromapBuildSizesInfoEXT *pSizeInfo);
@@ -20252,8 +20075,6 @@ VkResult VKAPI_CALL vkGetTensorOpaqueCap
 VkResult VKAPI_CALL vkGetTensorViewOpaqueCaptureDescriptorDataARM(VkDevice device, const VkTensorViewCaptureDescriptorDataInfoARM *pInfo, void *pData);
 VkResult VKAPI_CALL vkGetValidationCacheDataEXT(VkDevice device, VkValidationCacheEXT validationCache, size_t *pDataSize, void *pData);
 VkResult VKAPI_CALL vkGetVideoSessionMemoryRequirementsKHR(VkDevice device, VkVideoSessionKHR videoSession, uint32_t *pMemoryRequirementsCount, VkVideoSessionMemoryRequirementsKHR *pMemoryRequirements);
-VkResult VKAPI_CALL vkImportFenceFdKHR(VkDevice device, const VkImportFenceFdInfoKHR *pImportFenceFdInfo);
-VkResult VKAPI_CALL vkImportFenceWin32HandleKHR(VkDevice device, const VkImportFenceWin32HandleInfoKHR *pImportFenceWin32HandleInfo);
 VkResult VKAPI_CALL vkImportSemaphoreFdKHR(VkDevice device, const VkImportSemaphoreFdInfoKHR *pImportSemaphoreFdInfo);
 VkResult VKAPI_CALL vkImportSemaphoreWin32HandleKHR(VkDevice device, const VkImportSemaphoreWin32HandleInfoKHR *pImportSemaphoreWin32HandleInfo);
 VkResult VKAPI_CALL vkInitializePerformanceApiINTEL(VkDevice device, const VkInitializePerformanceApiInfoINTEL *pInitializeInfo);
@@ -20320,6 +20141,8 @@ VkResult VKAPI_CALL vkWaitSemaphores(VkD
 VkResult VKAPI_CALL vkWaitSemaphoresKHR(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout);
 VkResult VKAPI_CALL vkWriteAccelerationStructuresPropertiesKHR(VkDevice device, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType, size_t dataSize, void *pData, size_t stride);
 VkResult VKAPI_CALL vkWriteMicromapsPropertiesEXT(VkDevice device, uint32_t micromapCount, const VkMicromapEXT *pMicromaps, VkQueryType queryType, size_t dataSize, void *pData, size_t stride);
+VkResult VKAPI_CALL wine_vkAcquireKeyedMutex(VkDevice device, VkDeviceMemory memory, uint64_t key, uint32_t timeout_ms);
+VkResult VKAPI_CALL wine_vkReleaseKeyedMutex(VkDevice device, VkDeviceMemory memory, uint64_t key);
 #endif /* VK_NO_PROTOTYPES */
 
 #define ALL_VK_DEVICE_FUNCS \
@@ -20789,13 +20612,10 @@ VkResult VKAPI_CALL vkWriteMicromapsProp
     USE_VK_FUNC(vkGetDynamicRenderingTilePropertiesQCOM) \
     USE_VK_FUNC(vkGetEncodedVideoSessionParametersKHR) \
     USE_VK_FUNC(vkGetEventStatus) \
-    USE_VK_FUNC(vkGetFenceFdKHR) \
     USE_VK_FUNC(vkGetFenceStatus) \
-    USE_VK_FUNC(vkGetFenceWin32HandleKHR) \
     USE_VK_FUNC(vkGetFramebufferTilePropertiesQCOM) \
     USE_VK_FUNC(vkGetGeneratedCommandsMemoryRequirementsEXT) \
     USE_VK_FUNC(vkGetGeneratedCommandsMemoryRequirementsNV) \
-    USE_VK_FUNC(vkGetImageDrmFormatModifierPropertiesEXT) \
     USE_VK_FUNC(vkGetImageMemoryRequirements) \
     USE_VK_FUNC(vkGetImageMemoryRequirements2) \
     USE_VK_FUNC(vkGetImageMemoryRequirements2KHR) \
@@ -20815,8 +20635,6 @@ VkResult VKAPI_CALL vkWriteMicromapsProp
     USE_VK_FUNC(vkGetMemoryFdKHR) \
     USE_VK_FUNC(vkGetMemoryFdPropertiesKHR) \
     USE_VK_FUNC(vkGetMemoryHostPointerPropertiesEXT) \
-    USE_VK_FUNC(vkGetMemoryMetalHandleEXT) \
-    USE_VK_FUNC(vkGetMemoryMetalHandlePropertiesEXT) \
     USE_VK_FUNC(vkGetMemoryWin32HandleKHR) \
     USE_VK_FUNC(vkGetMemoryWin32HandlePropertiesKHR) \
     USE_VK_FUNC(vkGetMicromapBuildSizesEXT) \
@@ -20858,8 +20676,6 @@ VkResult VKAPI_CALL vkWriteMicromapsProp
     USE_VK_FUNC(vkGetTensorViewOpaqueCaptureDescriptorDataARM) \
     USE_VK_FUNC(vkGetValidationCacheDataEXT) \
     USE_VK_FUNC(vkGetVideoSessionMemoryRequirementsKHR) \
-    USE_VK_FUNC(vkImportFenceFdKHR) \
-    USE_VK_FUNC(vkImportFenceWin32HandleKHR) \
     USE_VK_FUNC(vkImportSemaphoreFdKHR) \
     USE_VK_FUNC(vkImportSemaphoreWin32HandleKHR) \
     USE_VK_FUNC(vkInitializePerformanceApiINTEL) \
@@ -20924,7 +20740,9 @@ VkResult VKAPI_CALL vkWriteMicromapsProp
     USE_VK_FUNC(vkWaitSemaphores) \
     USE_VK_FUNC(vkWaitSemaphoresKHR) \
     USE_VK_FUNC(vkWriteAccelerationStructuresPropertiesKHR) \
-    USE_VK_FUNC(vkWriteMicromapsPropertiesEXT)
+    USE_VK_FUNC(vkWriteMicromapsPropertiesEXT) \
+    USE_VK_FUNC(wine_vkAcquireKeyedMutex) \
+    USE_VK_FUNC(wine_vkReleaseKeyedMutex)
 
 #define ALL_VK_INSTANCE_FUNCS \
     USE_VK_FUNC(vkCreateDebugReportCallbackEXT) \
@@ -20956,8 +20774,6 @@ VkResult VKAPI_CALL vkWriteMicromapsProp
     USE_VK_FUNC(vkGetPhysicalDeviceCooperativeVectorPropertiesNV) \
     USE_VK_FUNC(vkGetPhysicalDeviceExternalBufferProperties) \
     USE_VK_FUNC(vkGetPhysicalDeviceExternalBufferPropertiesKHR) \
-    USE_VK_FUNC(vkGetPhysicalDeviceExternalFenceProperties) \
-    USE_VK_FUNC(vkGetPhysicalDeviceExternalFencePropertiesKHR) \
     USE_VK_FUNC(vkGetPhysicalDeviceExternalSemaphoreProperties) \
     USE_VK_FUNC(vkGetPhysicalDeviceExternalSemaphorePropertiesKHR) \
     USE_VK_FUNC(vkGetPhysicalDeviceExternalTensorPropertiesARM) \
@@ -21005,4 +20821,23 @@ VkResult VKAPI_CALL vkWriteMicromapsProp
     USE_VK_FUNC(vkGetPhysicalDeviceWin32PresentationSupportKHR) \
     USE_VK_FUNC(vkGetPhysicalDeviceXlibPresentationSupportKHR)
 
+typedef VkResult (*PFN_native_vkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *,
+                                                       void * (*)(VkInstance, const char *), void *);
+typedef VkResult (*PFN_native_vkCreateDevice)(VkPhysicalDevice, const VkDeviceCreateInfo *, const VkAllocationCallbacks *, VkDevice *,
+                                                     void * (*)(VkInstance, const char *), void *);
+
+typedef struct VkCreateInfoWineDeviceCallback {
+    VkStructureType             sType;
+    const void*                 pNext;
+    PFN_native_vkCreateDevice   native_create_callback;
+    void*                       context;
+} VkCreateInfoWineDeviceCallback;
+#define VK_STRUCTURE_TYPE_CREATE_INFO_WINE_DEVICE_CALLBACK 2125312001
+typedef struct VkCreateInfoWineInstanceCallback {
+    VkStructureType             sType;
+    const void*                 pNext;
+    PFN_native_vkCreateInstance native_create_callback;
+    void*                       context;
+} VkCreateInfoWineInstanceCallback;
+#define VK_STRUCTURE_TYPE_CREATE_INFO_WINE_INSTANCE_CALLBACK 2125312002
 #endif /* __WINE_VULKAN_H */
diff -ruN --show-c-function vanilla-1017/loader/wine.inf.in protonvulkan-1017/loader/wine.inf.in
--- vanilla-1017/loader/wine.inf.in	2025-10-21 17:44:36.808791437 -0700
+++ protonvulkan-1017/loader/wine.inf.in	2025-10-21 17:23:40.638407019 -0700
@@ -152,6 +152,7 @@ AddService=Winmgmt,0,WinmgmtService
 AddService=wuauserv,0,wuauService
 AddService=NDIS,0x800,NDISService
 AddService=nsiproxy,0x800,NsiProxyService
+AddService=SharedGpuResources,0x800,SharedGpuResourcesService
 
 [DefaultInstall.ntx86.Services]
 AddService=BITS,0,BITSService
@@ -172,6 +173,7 @@ AddService=Winmgmt,0,WinmgmtService
 AddService=wuauserv,0,wuauService
 AddService=NDIS,0x800,NDISService
 AddService=nsiproxy,0x800,NsiProxyService
+AddService=SharedGpuResources,0x800,SharedGpuResourcesService
 
 [DefaultInstall.ntamd64.Services]
 AddService=BITS,0,BITSService
@@ -192,6 +194,7 @@ AddService=Winmgmt,0,WinmgmtService
 AddService=wuauserv,0,wuauService
 AddService=NDIS,0x800,NDISService
 AddService=nsiproxy,0x800,NsiProxyService
+AddService=SharedGpuResources,0x800,SharedGpuResourcesService
 
 [DefaultInstall.ntarm64.Services]
 AddService=BITS,0,BITSService
@@ -212,6 +215,7 @@ AddService=Winmgmt,0,WinmgmtService
 AddService=wuauserv,0,wuauService
 AddService=NDIS,0x800,NDISService
 AddService=nsiproxy,0x800,NsiProxyService
+AddService=SharedGpuResources,0x800,SharedGpuResourcesService
 
 [Strings]
 MciExtStr="Software\Microsoft\Windows NT\CurrentVersion\MCI Extensions"
@@ -949,6 +953,15 @@ LoadOrderGroup="System Bus Extender"
 [NsiProxyServiceKeys]
 HKR,,"Tag",0x10001,1
 
+[SharedGpuResourcesService]
+Description="Shared GPU Resources Manager Service"
+DisplayName="Shared GPU Resources Manager"
+ServiceBinary="%12%\sharedgpures.sys"
+ServiceType=1
+StartType=2
+ErrorControl=1
+LoadOrderGroup="System Bus Extender"
+
 [RpcSsService]
 Description="RPC service"
 DisplayName="Remote Procedure Call (RPC)"
diff -ruN --show-c-function vanilla-1017/MAINTAINERS protonvulkan-1017/MAINTAINERS
--- vanilla-1017/MAINTAINERS	2025-10-21 17:44:35.602764286 -0700
+++ protonvulkan-1017/MAINTAINERS	2025-10-21 17:23:40.583994665 -0700
@@ -64,12 +64,6 @@ P:	Esme Povirk <esme@codeweavers.com> @m
 F:	dlls/comdlg32/itemdlg.c
 F:	dlls/comdlg32/tests/itemdlg.c
 
-D3DKMT
-M:	Rémi Bernon <rbernon@codeweavers.com> @rbernon
-F:	dlls/win32u/d3dkmt.c
-F:	dlls/win32u/tests/d3dkmt.c
-F:	server/d3dkmt.c
-
 Direct2D
 M:	Nikolay Sivov <nsivov@codeweavers.com> @nsivov
 P:	Henri Verbeet <hverbeet@codeweavers.com> @hverbeet
@@ -277,16 +271,6 @@ OLE Typelibs
 P:	Huw Davies <huw@codeweavers.com> @huw
 F:	dlls/oleaut32/typelib.c
 
-OpenGL
-M:	Rémi Bernon <rbernon@codeweavers.com> @rbernon
-P:	Jacek Caban <jacek@codeweavers.com> @jacek
-F:	dlls/gdi32/opengl.c
-F:	dlls/opengl32/
-F:	dlls/win32u/opengl.c
-F:	dlls/wine*/opengl.c
-F:	include/wine/opengl_driver.h
-F:	include/wine/wgl.h
-
 Plug and Play
 P:	Elizabeth Figura <zfigura@codeweavers.com> @zfigura
 F:	dlls/newdev/
@@ -340,16 +324,6 @@ VBScript
 M:	Jacek Caban <jacek@codeweavers.com> @jacek
 F:	dlls/vbscript/
 
-Vulkan
-M:	Rémi Bernon <rbernon@codeweavers.com> @rbernon
-P:	Jacek Caban <jacek@codeweavers.com> @jacek
-F:	dlls/vulkan-1/
-F:	dlls/win32u/vulkan.c
-F:	dlls/wine*/vulkan.c
-F:	dlls/winevulkan/
-F:	include/wine/vulkan.h
-F:	include/wine/vulkan_driver.h
-
 Web Services
 M:	Hans Leidekker <hans@codeweavers.com> @hans
 F:	dlls/webservices/
diff -ruN --show-c-function vanilla-1017/server/d3dkmt.c protonvulkan-1017/server/d3dkmt.c
--- vanilla-1017/server/d3dkmt.c	2025-10-21 17:44:36.355168673 -0700
+++ protonvulkan-1017/server/d3dkmt.c	2025-10-21 17:23:40.579149190 -0700
@@ -42,11 +42,9 @@ struct d3dkmt_object
     d3dkmt_handle_t     global;         /* object global handle */
     void               *runtime;        /* client runtime data */
     data_size_t         runtime_size;   /* size of client runtime data */
-    struct fd          *fd;             /* fd object for unix fds */
 };
 
 static void d3dkmt_object_dump( struct object *obj, int verbose );
-static struct fd *d3dkmt_object_get_fd( struct object *obj );
 static void d3dkmt_object_destroy( struct object *obj );
 
 static const struct object_ops d3dkmt_object_ops =
@@ -59,7 +57,7 @@ static const struct object_ops d3dkmt_ob
     NULL,                           /* signaled */
     NULL,                           /* satisfied */
     no_signal,                      /* signal */
-    d3dkmt_object_get_fd,           /* get_fd */
+    no_get_fd,                      /* get_fd */
     default_get_sync,               /* get_sync */
     default_map_access,             /* map_access */
     default_get_sd,                 /* get_sd */
@@ -74,27 +72,6 @@ static const struct object_ops d3dkmt_ob
     d3dkmt_object_destroy,          /* destroy */
 };
 
-static enum server_fd_type d3dkmt_get_fd_type( struct fd *fd )
-{
-    return FD_TYPE_INVALID;
-}
-
-static const struct fd_ops d3dkmt_fd_ops =
-{
-    default_fd_get_poll_events,   /* get_poll_events */
-    default_poll_event,           /* poll_event */
-    d3dkmt_get_fd_type,           /* get_fd_type */
-    no_fd_read,                   /* read */
-    no_fd_write,                  /* write */
-    no_fd_flush,                  /* flush */
-    no_fd_get_file_info,          /* get_file_info */
-    no_fd_get_volume_info,        /* get_volume_info */
-    no_fd_ioctl,                  /* ioctl */
-    default_fd_cancel_async,      /* cancel_async */
-    no_fd_queue_async,            /* queue_async */
-    default_fd_reselect_async     /* reselect_async */
-};
-
 #define DXGK_SHARED_SYNC_QUERY_STATE  0x0001
 #define DXGK_SHARED_SYNC_MODIFY_STATE 0x0002
 #define DXGK_SHARED_SYNC_ALL_ACCESS   (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3)
@@ -329,24 +306,12 @@ static void d3dkmt_object_dump( struct o
     fprintf( stderr, "type=%#x global=%#x\n", object->type, object->global );
 }
 
-static struct fd *d3dkmt_object_get_fd( struct object *obj )
-{
-    struct d3dkmt_object *object = (struct d3dkmt_object *)obj;
-    assert( obj->ops == &d3dkmt_object_ops );
-
-    if (object->fd) return (struct fd *)grab_object( object->fd );
-
-    set_error( STATUS_NO_SUCH_FILE );
-    return NULL;
-}
-
 static void d3dkmt_object_destroy( struct object *obj )
 {
     struct d3dkmt_object *object = (struct d3dkmt_object *)obj;
     assert( obj->ops == &d3dkmt_object_ops );
 
     if (object->global) free_object_handle( object->global );
-    if (object->fd) release_object( object->fd );
     free( object->runtime );
 }
 
@@ -358,7 +323,6 @@ static struct d3dkmt_object *d3dkmt_obje
     object->type            = type;
     object->global          = 0;
     object->runtime_size    = runtime_size;
-    object->fd              = NULL;
 
     if (!(object->runtime = memdup( runtime, runtime_size )) ||
         !(object->global = alloc_object_handle( object )))
@@ -417,28 +381,11 @@ static struct d3dkmt_object *d3dkmt_obje
 DECL_HANDLER(d3dkmt_object_create)
 {
     struct d3dkmt_object *object;
-    struct fd *fd = NULL;
-
-    if (req->fd >= 0)
-    {
-        int unix_fd;
-        if ((unix_fd = thread_get_inflight_fd( current, req->fd )) < 0) return;
-        if (!(fd = create_anonymous_fd( NULL, unix_fd, NULL, 0 ))) return;
-    }
-
-    if (!(object = d3dkmt_object_create( req->type, get_req_data_size(), get_req_data() ))) goto done;
-    if (fd)
-    {
-        set_fd_user( fd, &d3dkmt_fd_ops, &object->obj );
-        object->fd = (struct fd *)grab_object( fd );
-    }
 
+    if (!(object = d3dkmt_object_create( req->type, get_req_data_size(), get_req_data() ))) return;
     reply->handle = alloc_handle( current->process, object, STANDARD_RIGHTS_ALL, OBJ_INHERIT );
     reply->global = object->global;
     release_object( object );
-
-done:
-    if (fd) release_object( fd );
 }
 
 /* update a global d3dkmt object */
@@ -451,7 +398,10 @@ DECL_HANDLER(d3dkmt_object_update)
     if (!(size = get_req_data_size())) runtime = NULL;
     else if (!(runtime = memdup( get_req_data(), size ))) return;
 
-    if (!(object = d3dkmt_object_open( req->global, req->type ))) goto done;
+    if (req->global) object = d3dkmt_object_open( req->global, req->type );
+    else object = d3dkmt_object_open_shared( req->handle, req->type );
+    if (!object) goto done;
+
     tmp = object->runtime;
     object->runtime = runtime;
     object->runtime_size = size;
diff -ruN --show-c-function vanilla-1017/server/mapping.c protonvulkan-1017/server/mapping.c
--- vanilla-1017/server/mapping.c	2025-10-21 17:44:36.808791437 -0700
+++ protonvulkan-1017/server/mapping.c	2025-10-21 17:23:40.567674297 -0700
@@ -157,6 +157,7 @@ struct type_descr mapping_type =
 struct mapping
 {
     struct object        obj;        /* object header */
+    struct list          kernel_object;   /* list of kernel object pointers */
     mem_size_t           size;       /* mapping size */
     unsigned int         flags;      /* SEC_* flags */
     struct fd           *fd;         /* fd for mapped file */
@@ -169,6 +170,7 @@ struct mapping
 
 static void mapping_dump( struct object *obj, int verbose );
 static struct fd *mapping_get_fd( struct object *obj );
+static struct list *mapping_get_kernel_obj_list( struct object *obj );
 static void mapping_destroy( struct object *obj );
 static enum server_fd_type mapping_get_fd_type( struct fd *fd );
 
@@ -192,7 +194,7 @@ static const struct object_ops mapping_o
     directory_link_name,         /* link_name */
     default_unlink_name,         /* unlink_name */
     no_open_file,                /* open_file */
-    no_kernel_obj_list,          /* get_kernel_obj_list */
+    mapping_get_kernel_obj_list, /* get_kernel_obj_list */
     no_close_handle,             /* close_handle */
     mapping_destroy              /* destroy */
 };
@@ -1052,6 +1054,8 @@ static struct mapping *create_mapping( s
     if (get_error() == STATUS_OBJECT_NAME_EXISTS)
         return mapping;  /* Nothing else to do */
 
+    list_init( &mapping->kernel_object );
+
     mapping->size        = size;
     mapping->fd          = NULL;
     mapping->shared      = NULL;
@@ -1145,6 +1149,8 @@ struct mapping *create_fd_mapping( struc
     if (!(mapping = create_named_object( root, &mapping_ops, name, attr, sd ))) return NULL;
     if (get_error() == STATUS_OBJECT_NAME_EXISTS) return mapping;  /* Nothing else to do */
 
+    list_init( &mapping->kernel_object );
+
     mapping->shared    = NULL;
     mapping->committed = NULL;
     mapping->exp_name  = NULL;
@@ -1253,6 +1259,12 @@ static struct fd *mapping_get_fd( struct
     return (struct fd *)grab_object( mapping->fd );
 }
 
+static struct list *mapping_get_kernel_obj_list( struct object *obj )
+{
+    struct mapping *mapping = (struct mapping *)obj;
+    return &mapping->kernel_object;
+}
+
 static void mapping_destroy( struct object *obj )
 {
     struct mapping *mapping = (struct mapping *)obj;
diff -ruN --show-c-function vanilla-1017/server/protocol.def protonvulkan-1017/server/protocol.def
--- vanilla-1017/server/protocol.def	2025-10-21 17:44:36.808791437 -0700
+++ protonvulkan-1017/server/protocol.def	2025-10-21 17:23:40.579309934 -0700
@@ -4177,7 +4177,6 @@ enum inproc_sync_type
 /* Create a global d3dkmt object */
 @REQ(d3dkmt_object_create)
     unsigned int        type;           /* d3dkmt object type */
-    int                 fd;             /* host specific fd */
     VARARG(runtime,bytes);              /* client runtime data */
 @REPLY
     d3dkmt_handle_t     global;         /* global d3dkmt handle */
@@ -4189,6 +4188,7 @@ enum inproc_sync_type
 @REQ(d3dkmt_object_update)
     unsigned int        type;           /* d3dkmt object type */
     d3dkmt_handle_t     global;         /* global d3dkmt handle */
+    obj_handle_t        handle;         /* shared object handle */
     VARARG(runtime,bytes);              /* client runtime data */
 @END
 
diff -ruN --show-c-function vanilla-1017/server/request_handlers.h protonvulkan-1017/server/request_handlers.h
--- vanilla-1017/server/request_handlers.h	2025-10-21 17:44:36.809791459 -0700
+++ protonvulkan-1017/server/request_handlers.h	2025-10-21 17:23:40.579540961 -0700
@@ -2310,13 +2310,13 @@ C_ASSERT( sizeof(struct get_inproc_alert
 C_ASSERT( offsetof(struct get_inproc_alert_fd_reply, handle) == 8 );
 C_ASSERT( sizeof(struct get_inproc_alert_fd_reply) == 16 );
 C_ASSERT( offsetof(struct d3dkmt_object_create_request, type) == 12 );
-C_ASSERT( offsetof(struct d3dkmt_object_create_request, fd) == 16 );
-C_ASSERT( sizeof(struct d3dkmt_object_create_request) == 24 );
+C_ASSERT( sizeof(struct d3dkmt_object_create_request) == 16 );
 C_ASSERT( offsetof(struct d3dkmt_object_create_reply, global) == 8 );
 C_ASSERT( offsetof(struct d3dkmt_object_create_reply, handle) == 12 );
 C_ASSERT( sizeof(struct d3dkmt_object_create_reply) == 16 );
 C_ASSERT( offsetof(struct d3dkmt_object_update_request, type) == 12 );
 C_ASSERT( offsetof(struct d3dkmt_object_update_request, global) == 16 );
+C_ASSERT( offsetof(struct d3dkmt_object_update_request, handle) == 20 );
 C_ASSERT( sizeof(struct d3dkmt_object_update_request) == 24 );
 C_ASSERT( offsetof(struct d3dkmt_object_query_request, type) == 12 );
 C_ASSERT( offsetof(struct d3dkmt_object_query_request, global) == 16 );
diff -ruN --show-c-function vanilla-1017/server/request_trace.h protonvulkan-1017/server/request_trace.h
--- vanilla-1017/server/request_trace.h	2025-10-21 17:44:36.809791459 -0700
+++ protonvulkan-1017/server/request_trace.h	2025-10-21 17:23:40.579775194 -0700
@@ -3396,7 +3396,6 @@ static void dump_get_inproc_alert_fd_rep
 static void dump_d3dkmt_object_create_request( const struct d3dkmt_object_create_request *req )
 {
     fprintf( stderr, " type=%08x", req->type );
-    fprintf( stderr, ", fd=%d", req->fd );
     dump_varargs_bytes( ", runtime=", cur_size );
 }
 
@@ -3410,6 +3409,7 @@ static void dump_d3dkmt_object_update_re
 {
     fprintf( stderr, " type=%08x", req->type );
     fprintf( stderr, ", global=%08x", req->global );
+    fprintf( stderr, ", handle=%04x", req->handle );
     dump_varargs_bytes( ", runtime=", cur_size );
 }
 

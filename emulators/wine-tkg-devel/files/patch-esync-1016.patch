diff -ruN --show-c-function configure configure
--- configure	2025-10-10 10:17:59.228002693 -0700
+++ configure	2025-10-10 10:22:24.825522383 -0700
@@ -10004,12 +10004,6 @@ then :
   printf "%s\n" "#define HAVE_LINUX_MAJOR_H 1" >>confdefs.h
 
 fi
-ac_fn_c_check_header_compile "$LINENO" "linux/ntsync.h" "ac_cv_header_linux_ntsync_h" "$ac_includes_default"
-if test "x$ac_cv_header_linux_ntsync_h" = xyes
-then :
-  printf "%s\n" "#define HAVE_LINUX_NTSYNC_H 1" >>confdefs.h
-
-fi
 ac_fn_c_check_header_compile "$LINENO" "linux/param.h" "ac_cv_header_linux_param_h" "$ac_includes_default"
 if test "x$ac_cv_header_linux_param_h" = xyes
 then :
@@ -10184,6 +10178,12 @@ then :
   printf "%s\n" "#define HAVE_SYS_EVENT_H 1" >>confdefs.h
 
 fi
+ac_fn_c_check_header_compile "$LINENO" "sys/eventfd.h" "ac_cv_header_sys_eventfd_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_eventfd_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_EVENTFD_H 1" >>confdefs.h
+
+fi
 ac_fn_c_check_header_compile "$LINENO" "sys/extattr.h" "ac_cv_header_sys_extattr_h" "$ac_includes_default"
 if test "x$ac_cv_header_sys_extattr_h" = xyes
 then :
@@ -21201,6 +21201,12 @@ then :
   printf "%s\n" "#define HAVE_POSIX_FALLOCATE 1" >>confdefs.h
 
 fi
+ac_fn_c_check_func "$LINENO" "ppoll" "ac_cv_func_ppoll"
+if test "x$ac_cv_func_ppoll" = xyes
+then :
+  printf "%s\n" "#define HAVE_PPOLL 1" >>confdefs.h
+
+fi
 ac_fn_c_check_func "$LINENO" "prctl" "ac_cv_func_prctl"
 if test "x$ac_cv_func_prctl" = xyes
 then :
@@ -21332,6 +21338,80 @@ fi
 
 LIBS=$ac_save_LIBS
 
+ac_save_LIBS=$LIBS
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for library containing shm_open" >&5
+printf %s "checking for library containing shm_open... " >&6; }
+if test ${ac_cv_search_shm_open+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_func_search_save_LIBS=$LIBS
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char shm_open (void);
+int
+main (void)
+{
+return shm_open ();
+  ;
+  return 0;
+}
+_ACEOF
+for ac_lib in '' rt
+do
+  if test -z "$ac_lib"; then
+    ac_res="none required"
+  else
+    ac_res=-l$ac_lib
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+  fi
+  if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_search_shm_open=$ac_res
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext
+  if test ${ac_cv_search_shm_open+y}
+then :
+  break
+fi
+done
+if test ${ac_cv_search_shm_open+y}
+then :
+
+else case e in #(
+  e) ac_cv_search_shm_open=no ;;
+esac
+fi
+rm conftest.$ac_ext
+LIBS=$ac_func_search_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_shm_open" >&5
+printf "%s\n" "$ac_cv_search_shm_open" >&6; }
+ac_res=$ac_cv_search_shm_open
+if test "$ac_res" != no
+then :
+  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
+
+printf "%s\n" "#define HAVE_SHM_OPEN 1" >>confdefs.h
+
+                test "$ac_res" = "none required" || RT_LIBS="$ac_res"
+
+fi
+
+LIBS=$ac_save_LIBS
+
 { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for sched_setaffinity" >&5
 printf %s "checking for sched_setaffinity... " >&6; }
 if test ${wine_cv_have_sched_setaffinity+y}
@@ -23436,7 +23516,7 @@ fi
 
 as_fn_append wine_rules "
 dlls/ntdll/unix/version.c: dummy
-	@version=\`(GIT_DIR=${wine_srcdir}.git git describe HEAD 2>/dev/null || echo \"wine-\$(PACKAGE_VERSION)\") | sed -n -e '\$\$s/\(.*\)/const char wine_build[] = \"\\1\";/p'\` && (echo \$\$version | cmp -s - \$@) || echo \$\$version >\$@ || (rm -f \$@ && exit 1)
+	@version=\`(echo \"wine-10.16\") | sed -n -e '\$\$s/\(.*\)/const char wine_build[] = \"\\1  ( FreeBSD TkG Esync )\";/p'\` && (echo \$\$version | cmp -s - \$@) || echo \$\$version >\$@ || (rm -f \$@ && exit 1)
 programs/winetest/build.rc: dummy
 	@build=\"STRINGTABLE { 1 \\\"\`GIT_DIR=${wine_srcdir}.git git rev-parse HEAD 2>/dev/null\`\\\" }\" && (echo \$\$build | cmp -s - \$@) || echo \$\$build >\$@ || (rm -f \$@ && exit 1)
 dlls/wineandroid.drv/wine-debug.apk: dlls/wineandroid.drv/build.gradle ${wine_srcdir}dlls/wineandroid.drv/AndroidManifest.xml ${wine_srcdir}dlls/wineandroid.drv/WineActivity.java ${wine_srcdir}dlls/wineandroid.drv/wine.svg
diff -ruN --show-c-function configure~ configure~
--- configure~	2025-10-10 10:17:48.561774948 -0700
+++ configure~	2025-10-10 10:22:17.130365897 -0700
@@ -10002,12 +10002,6 @@ then :
   printf "%s\n" "#define HAVE_LINUX_MAJOR_H 1" >>confdefs.h
 
 fi
-ac_fn_c_check_header_compile "$LINENO" "linux/ntsync.h" "ac_cv_header_linux_ntsync_h" "$ac_includes_default"
-if test "x$ac_cv_header_linux_ntsync_h" = xyes
-then :
-  printf "%s\n" "#define HAVE_LINUX_NTSYNC_H 1" >>confdefs.h
-
-fi
 ac_fn_c_check_header_compile "$LINENO" "linux/param.h" "ac_cv_header_linux_param_h" "$ac_includes_default"
 if test "x$ac_cv_header_linux_param_h" = xyes
 then :
diff -ruN --show-c-function configure.ac configure.ac
--- configure.ac	2025-10-10 10:17:59.208239483 -0700
+++ configure.ac	2025-10-10 10:22:24.806803320 -0700
@@ -682,7 +682,6 @@ AC_CHECK_HEADERS(\
 	linux/input.h \
 	linux/ioctl.h \
 	linux/major.h \
-	linux/ntsync.h \
 	linux/param.h \
 	linux/serial.h \
 	linux/types.h \
@@ -712,6 +711,7 @@ AC_CHECK_HEADERS(\
 	sys/cdio.h \
 	sys/epoll.h \
 	sys/event.h \
+	sys/eventfd.h \
 	sys/extattr.h \
 	sys/filio.h \
 	sys/ipc.h \
@@ -2114,6 +2114,7 @@ AC_CHECK_FUNCS(\
 	port_create \
 	posix_fadvise \
 	posix_fallocate \
+	ppoll \
 	prctl \
 	sched_getcpu \
 	sched_yield \
@@ -2133,6 +2134,12 @@ AC_SEARCH_LIBS(clock_gettime, rt,
                 test "$ac_res" = "none required" || AC_SUBST(RT_LIBS,"$ac_res")])
 LIBS=$ac_save_LIBS
 
+ac_save_LIBS=$LIBS
+AC_SEARCH_LIBS(shm_open, rt,
+               [AC_DEFINE(HAVE_SHM_OPEN, 1, [Define to 1 if you have the `shm_open' function.])
+                test "$ac_res" = "none required" || AC_SUBST(RT_LIBS,"$ac_res")])
+LIBS=$ac_save_LIBS
+
 AC_CACHE_CHECK([for sched_setaffinity],wine_cv_have_sched_setaffinity,
                 AC_LINK_IFELSE([AC_LANG_PROGRAM(
 [[#include <sched.h>]], [[sched_setaffinity(0, 0, 0);]])],[wine_cv_have_sched_setaffinity=yes],[wine_cv_have_sched_setaffinity=no]))
@@ -3741,7 +3748,7 @@ dnl Rules for generated source files
 
 WINE_APPEND_RULE(
 [dlls/ntdll/unix/version.c: dummy
-	@version=\`(GIT_DIR=${wine_srcdir}.git git describe HEAD 2>/dev/null || echo \"wine-\$(PACKAGE_VERSION)\") | sed -n -e '\$\$s/\(.*\)/const char wine_build[[]] = \"\\1\";/p'\` && (echo \$\$version | cmp -s - \$[@]) || echo \$\$version >\$[@] || (rm -f \$[@] && exit 1)
+	@version=\`(echo \"wine-10.16\") | sed -n -e '\$\$s/\(.*\)/const char wine_build[] = \"\\1  ( FreeBSD TkG Esync )\";/p'\` && (echo \$\$version | cmp -s - \$@) || echo \$\$version >\$@ || (rm -f \$@ && exit 1)
 programs/winetest/build.rc: dummy
 	@build=\"STRINGTABLE { 1 \\\"\`GIT_DIR=${wine_srcdir}.git git rev-parse HEAD 2>/dev/null\`\\\" }\" && (echo \$\$build | cmp -s - \$[@]) || echo \$\$build >\$[@] || (rm -f \$[@] && exit 1)
 dlls/wineandroid.drv/wine-debug.apk: dlls/wineandroid.drv/build.gradle ${wine_srcdir}dlls/wineandroid.drv/AndroidManifest.xml ${wine_srcdir}dlls/wineandroid.drv/WineActivity.java ${wine_srcdir}dlls/wineandroid.drv/wine.svg
diff -ruN --show-c-function configure.orig configure.orig
--- configure.orig	1969-12-31 16:00:00.000000000 -0800
+++ configure.orig	2025-10-10 10:22:13.447290938 -0700
@@ -0,0 +1,24838 @@
+#! /bin/sh
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.72 for Wine 10.16.
+#
+# Report bugs to <wine-devel@winehq.org>.
+#
+#
+# Copyright (C) 1992-1996, 1998-2017, 2020-2023 Free Software Foundation,
+# Inc.
+#
+#
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## -------------------- ##
+## M4sh Initialization. ##
+## -------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test ${ZSH_VERSION+y} && (emulate sh) >/dev/null 2>&1
+then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else case e in #(
+  e) case `(set -o) 2>/dev/null` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac ;;
+esac
+fi
+
+
+
+# Reset variables that may have inherited troublesome values from
+# the environment.
+
+# IFS needs to be set, to space, tab, and newline, in precisely that order.
+# (If _AS_PATH_WALK were called with IFS unset, it would have the
+# side effect of setting IFS to empty, thus disabling word splitting.)
+# Quoting is to prevent editors from complaining about space-tab.
+as_nl='
+'
+export as_nl
+IFS=" ""	$as_nl"
+
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# Ensure predictable behavior from utilities with locale-dependent output.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# We cannot yet rely on "unset" to work, but we need these variables
+# to be unset--not just set to an empty or harmless value--now, to
+# avoid bugs in old shells (e.g. pre-3.0 UWIN ksh).  This construct
+# also avoids known problems related to "unset" and subshell syntax
+# in other old shells (e.g. bash 2.01 and pdksh 5.2.14).
+for as_var in BASH_ENV ENV MAIL MAILPATH CDPATH
+do eval test \${$as_var+y} \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+
+# Ensure that fds 0, 1, and 2 are open.
+if (exec 3>&0) 2>/dev/null; then :; else exec 0</dev/null; fi
+if (exec 3>&1) 2>/dev/null; then :; else exec 1>/dev/null; fi
+if (exec 3>&2)            ; then :; else exec 2>/dev/null; fi
+
+# The user is always right.
+if ${PATH_SEPARATOR+false} :; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
+
+
+# Find who we are.  Look in the path if we contain no directory separator.
+as_myself=
+case $0 in #((
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    test -r "$as_dir$0" && as_myself=$as_dir$0 && break
+  done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as 'sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  printf "%s\n" "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  exit 1
+fi
+
+
+# Use a proper internal environment variable to ensure we don't fall
+  # into an infinite loop, continuously re-executing ourselves.
+  if test x"${_as_can_reexec}" != xno && test "x$CONFIG_SHELL" != x; then
+    _as_can_reexec=no; export _as_can_reexec;
+    # We cannot yet assume a decent shell, so we have to provide a
+# neutralization value for shells without unset; and this also
+# works around shells that cannot unset nonexistent variables.
+# Preserve -v and -x to the replacement shell.
+BASH_ENV=/dev/null
+ENV=/dev/null
+(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+case $- in # ((((
+  *v*x* | *x*v* ) as_opts=-vx ;;
+  *v* ) as_opts=-v ;;
+  *x* ) as_opts=-x ;;
+  * ) as_opts= ;;
+esac
+exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
+# Admittedly, this is quite paranoid, since all the known shells bail
+# out after a failed 'exec'.
+printf "%s\n" "$0: could not re-execute with $CONFIG_SHELL" >&2
+exit 255
+  fi
+  # We don't want this to propagate to other subprocesses.
+          { _as_can_reexec=; unset _as_can_reexec;}
+if test "x$CONFIG_SHELL" = x; then
+  as_bourne_compatible="if test \${ZSH_VERSION+y} && (emulate sh) >/dev/null 2>&1
+then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '\${1+\"\$@\"}'='\"\$@\"'
+  setopt NO_GLOB_SUBST
+else case e in #(
+  e) case \`(set -o) 2>/dev/null\` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac ;;
+esac
+fi
+"
+  as_required="as_fn_return () { (exit \$1); }
+as_fn_success () { as_fn_return 0; }
+as_fn_failure () { as_fn_return 1; }
+as_fn_ret_success () { return 0; }
+as_fn_ret_failure () { return 1; }
+
+exitcode=0
+as_fn_success || { exitcode=1; echo as_fn_success failed.; }
+as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
+as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
+as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
+if ( set x; as_fn_ret_success y && test x = \"\$1\" )
+then :
+
+else case e in #(
+  e) exitcode=1; echo positional parameters were not saved. ;;
+esac
+fi
+test x\$exitcode = x0 || exit 1
+blah=\$(echo \$(echo blah))
+test x\"\$blah\" = xblah || exit 1
+test -x / || exit 1"
+  as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
+  as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
+  eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
+  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1"
+  if (eval "$as_required") 2>/dev/null
+then :
+  as_have_required=yes
+else case e in #(
+  e) as_have_required=no ;;
+esac
+fi
+  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null
+then :
+
+else case e in #(
+  e) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+as_found=false
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+  as_found=:
+  case $as_dir in #(
+	 /*)
+	   for as_base in sh bash ksh sh5; do
+	     # Try only shells that exist, to save several forks.
+	     as_shell=$as_dir$as_base
+	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
+		    as_run=a "$as_shell" -c "$as_bourne_compatible""$as_required" 2>/dev/null
+then :
+  CONFIG_SHELL=$as_shell as_have_required=yes
+		   if as_run=a "$as_shell" -c "$as_bourne_compatible""$as_suggested" 2>/dev/null
+then :
+  break 2
+fi
+fi
+	   done;;
+       esac
+  as_found=false
+done
+IFS=$as_save_IFS
+if $as_found
+then :
+
+else case e in #(
+  e) if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
+	      as_run=a "$SHELL" -c "$as_bourne_compatible""$as_required" 2>/dev/null
+then :
+  CONFIG_SHELL=$SHELL as_have_required=yes
+fi ;;
+esac
+fi
+
+
+      if test "x$CONFIG_SHELL" != x
+then :
+  export CONFIG_SHELL
+             # We cannot yet assume a decent shell, so we have to provide a
+# neutralization value for shells without unset; and this also
+# works around shells that cannot unset nonexistent variables.
+# Preserve -v and -x to the replacement shell.
+BASH_ENV=/dev/null
+ENV=/dev/null
+(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+case $- in # ((((
+  *v*x* | *x*v* ) as_opts=-vx ;;
+  *v* ) as_opts=-v ;;
+  *x* ) as_opts=-x ;;
+  * ) as_opts= ;;
+esac
+exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
+# Admittedly, this is quite paranoid, since all the known shells bail
+# out after a failed 'exec'.
+printf "%s\n" "$0: could not re-execute with $CONFIG_SHELL" >&2
+exit 255
+fi
+
+    if test x$as_have_required = xno
+then :
+  printf "%s\n" "$0: This script requires a shell more modern than all"
+  printf "%s\n" "$0: the shells that I found on your system."
+  if test ${ZSH_VERSION+y} ; then
+    printf "%s\n" "$0: In particular, zsh $ZSH_VERSION has bugs and should"
+    printf "%s\n" "$0: be upgraded to zsh 4.3.4 or later."
+  else
+    printf "%s\n" "$0: Please tell bug-autoconf@gnu.org and
+$0: wine-devel@winehq.org about your system, including any
+$0: error possibly output before this message. Then install
+$0: a modern shell, or manually run the script under such a
+$0: shell if you do have one."
+  fi
+  exit 1
+fi ;;
+esac
+fi
+fi
+SHELL=${CONFIG_SHELL-/bin/sh}
+export SHELL
+# Unset more variables known to interfere with behavior of common tools.
+CLICOLOR_FORCE= GREP_OPTIONS=
+unset CLICOLOR_FORCE GREP_OPTIONS
+
+## --------------------- ##
+## M4sh Shell Functions. ##
+## --------------------- ##
+# as_fn_unset VAR
+# ---------------
+# Portably unset VAR.
+as_fn_unset ()
+{
+  { eval $1=; unset $1;}
+}
+as_unset=as_fn_unset
+
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+
+# as_fn_mkdir_p
+# -------------
+# Create "$as_dir" as a directory, including parents if necessary.
+as_fn_mkdir_p ()
+{
+
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || eval $as_mkdir_p || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`printf "%s\n" "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+printf "%s\n" X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
+
+
+} # as_fn_mkdir_p
+
+# as_fn_executable_p FILE
+# -----------------------
+# Test if FILE is an executable regular file.
+as_fn_executable_p ()
+{
+  test -f "$1" && test -x "$1"
+} # as_fn_executable_p
+# as_fn_append VAR VALUE
+# ----------------------
+# Append the text in VALUE to the end of the definition contained in VAR. Take
+# advantage of any shell optimizations that allow amortized linear growth over
+# repeated appends, instead of the typical quadratic growth present in naive
+# implementations.
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null
+then :
+  eval 'as_fn_append ()
+  {
+    eval $1+=\$2
+  }'
+else case e in #(
+  e) as_fn_append ()
+  {
+    eval $1=\$$1\$2
+  } ;;
+esac
+fi # as_fn_append
+
+# as_fn_arith ARG...
+# ------------------
+# Perform arithmetic evaluation on the ARGs, and store the result in the
+# global $as_val. Take advantage of shells that can avoid forks. The arguments
+# must be portable across $(()) and expr.
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null
+then :
+  eval 'as_fn_arith ()
+  {
+    as_val=$(( $* ))
+  }'
+else case e in #(
+  e) as_fn_arith ()
+  {
+    as_val=`expr "$@" || test $? -eq 1`
+  } ;;
+esac
+fi # as_fn_arith
+
+
+# as_fn_error STATUS ERROR [LINENO LOG_FD]
+# ----------------------------------------
+# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
+# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
+# script with STATUS, using 1 if that was 0.
+as_fn_error ()
+{
+  as_status=$1; test $as_status -eq 0 && as_status=1
+  if test "$4"; then
+    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
+  fi
+  printf "%s\n" "$as_me: error: $2" >&2
+  as_fn_exit $as_status
+} # as_fn_error
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+printf "%s\n" X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+
+  as_lineno_1=$LINENO as_lineno_1a=$LINENO
+  as_lineno_2=$LINENO as_lineno_2a=$LINENO
+  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
+  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
+  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
+  sed -n '
+    p
+    /[$]LINENO/=
+  ' <$as_myself |
+    sed '
+      t clear
+      :clear
+      s/[$]LINENO.*/&-/
+      t lineno
+      b
+      :lineno
+      N
+      :loop
+      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      t loop
+      s/-\n.*//
+    ' >$as_me.lineno &&
+  chmod +x "$as_me.lineno" ||
+    { printf "%s\n" "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
+
+  # If we had to re-execute with $CONFIG_SHELL, we're ensured to have
+  # already done that, so ensure we don't try to do so again and fall
+  # in an infinite loop.  This has already happened in practice.
+  _as_can_reexec=no; export _as_can_reexec
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensitive to this).
+  . "./$as_me.lineno"
+  # Exit status is that of the last command.
+  exit
+}
+
+
+# Determine whether it's possible to make 'echo' print without a newline.
+# These variables are no longer used directly by Autoconf, but are AC_SUBSTed
+# for compatibility with existing Makefiles.
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in #(((((
+-n*)
+  case `echo 'xy\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  xy)  ECHO_C='\c';;
+  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
+       ECHO_T='	';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+# For backward compatibility with old third-party macros, we provide
+# the shell variables $as_echo and $as_echo_n.  New code should use
+# AS_ECHO(["message"]) and AS_ECHO_N(["message"]), respectively.
+as_echo='printf %s\n'
+as_echo_n='printf %s'
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
+fi
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both 'ln -s file dir' and 'ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; 'ln -s' creates a wrapper executable.
+    # In both cases, we have to default to 'cp -pR'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -pR'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -pR'
+  fi
+else
+  as_ln_s='cp -pR'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p='mkdir -p "$as_dir"'
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_test_x='test -x'
+as_executable_p=as_fn_executable_p
+
+# Sed expression to map a string onto a valid CPP name.
+as_sed_cpp="y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g"
+as_tr_cpp="eval sed '$as_sed_cpp'" # deprecated
+
+# Sed expression to map a string onto a valid variable name.
+as_sed_sh="y%*+%pp%;s%[^_$as_cr_alnum]%_%g"
+as_tr_sh="eval sed '$as_sed_sh'" # deprecated
+
+
+test -n "$DJDIR" || exec 7<&0 </dev/null
+exec 6>&1
+
+# Name of the host.
+# hostname on some systems (SVR3.2, old GNU/Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_clean_files=
+ac_config_libobj_dir=.
+LIBOBJS=
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+
+# Identity of this package.
+PACKAGE_NAME='Wine'
+PACKAGE_TARNAME='wine'
+PACKAGE_VERSION='10.16'
+PACKAGE_STRING='Wine 10.16'
+PACKAGE_BUGREPORT='wine-devel@winehq.org'
+PACKAGE_URL='https://www.winehq.org'
+
+ac_unique_file="server/atom.c"
+# Factoring default headers for most tests.
+ac_includes_default="\
+#include <stddef.h>
+#ifdef HAVE_STDIO_H
+# include <stdio.h>
+#endif
+#ifdef HAVE_STDLIB_H
+# include <stdlib.h>
+#endif
+#ifdef HAVE_STRING_H
+# include <string.h>
+#endif
+#ifdef HAVE_INTTYPES_H
+# include <inttypes.h>
+#endif
+#ifdef HAVE_STDINT_H
+# include <stdint.h>
+#endif
+#ifdef HAVE_STRINGS_H
+# include <strings.h>
+#endif
+#ifdef HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif"
+
+ac_header_c_list=
+enable_year2038=yes
+ac_subst_vars='LTLIBOBJS
+LIBOBJS
+TAGSFLAGS
+RT_LIBS
+WINELOADER_PROGRAMS
+DELAYLOADFLAG
+MSVCRTFLAGS
+NETAPI_LIBS
+NETAPI_CFLAGS
+PROCSTAT_LIBS
+GSSAPI_LIBS
+GSSAPI_CFLAGS
+KRB5_LIBS
+KRB5_CFLAGS
+FONTCONFIG_LIBS
+FONTCONFIG_CFLAGS
+CUPS_LIBS
+CUPS_CFLAGS
+CAPI20_LIBS
+CAPI20_CFLAGS
+SDL2_LIBS
+SDL2_CFLAGS
+UNWIND_LIBS
+UNWIND_CFLAGS
+UDEV_LIBS
+UDEV_CFLAGS
+OSS4_LIBS
+OSS4_CFLAGS
+ALSA_CFLAGS
+ALSA_LIBS
+GSTREAMER_LIBS
+GSTREAMER_CFLAGS
+FFMPEG_LIBS
+FFMPEG_CFLAGS
+PULSE_LIBS
+PULSE_CFLAGS
+GETTEXTPO_LIBS
+FREETYPE_LIBS
+FREETYPE_CFLAGS
+RESOLV_LIBS
+GPHOTO2_PORT_LIBS
+GPHOTO2_PORT_CFLAGS
+GPHOTO2_LIBS
+GPHOTO2_CFLAGS
+USB_LIBS
+USB_CFLAGS
+SANE_LIBS
+SANE_CFLAGS
+GNUTLS_LIBS
+GNUTLS_CFLAGS
+DBUS_LIBS
+DBUS_CFLAGS
+INOTIFY_LIBS
+INOTIFY_CFLAGS
+PCSCLITE_LIBS
+PCAP_LIBS
+WAYLAND_EGL_LIBS
+WAYLAND_EGL_CFLAGS
+XKBREGISTRY_LIBS
+XKBREGISTRY_CFLAGS
+XKBCOMMON_LIBS
+XKBCOMMON_CFLAGS
+WAYLAND_SCANNER
+WAYLAND_CLIENT_LIBS
+WAYLAND_CLIENT_CFLAGS
+X_LIBS
+X_CFLAGS
+CPP
+XMKMF
+EGL_LIBS
+EGL_CFLAGS
+PTHREAD_LIBS
+ZLIB_PE_LIBS
+ZLIB_PE_CFLAGS
+XSLT_PE_LIBS
+XSLT_PE_CFLAGS
+XML2_PE_LIBS
+XML2_PE_CFLAGS
+VKD3D_PE_LIBS
+VKD3D_PE_CFLAGS
+TOMCRYPT_PE_LIBS
+TOMCRYPT_PE_CFLAGS
+TIFF_PE_LIBS
+TIFF_PE_CFLAGS
+PNG_PE_LIBS
+PNG_PE_CFLAGS
+MUSL_PE_LIBS
+MUSL_PE_CFLAGS
+MPG123_PE_LIBS
+MPG123_PE_CFLAGS
+LDAP_PE_LIBS
+LDAP_PE_CFLAGS
+LCMS2_PE_LIBS
+LCMS2_PE_CFLAGS
+JXR_PE_LIBS
+JXR_PE_CFLAGS
+JPEG_PE_LIBS
+JPEG_PE_CFLAGS
+GSM_PE_LIBS
+GSM_PE_CFLAGS
+FLUIDSYNTH_PE_LIBS
+FLUIDSYNTH_PE_CFLAGS
+FAUDIO_PE_LIBS
+FAUDIO_PE_CFLAGS
+COMPILER_RT_PE_LIBS
+COMPILER_RT_PE_CFLAGS
+CAPSTONE_PE_LIBS
+CAPSTONE_PE_CFLAGS
+MINGW_PKG_CONFIG
+WINELOADER_DEPENDS
+ac_ct_OBJC
+OBJCFLAGS
+OBJC
+OPENCL_LIBS
+COREAUDIO_LIBS
+SYSTEMCONFIGURATION_LIBS
+SECURITY_LIBS
+APPKIT_LIBS
+CORESERVICES_LIBS
+APPLICATIONSERVICES_LIBS
+IOKIT_LIBS
+DISKARBITRATION_LIBS
+COREFOUNDATION_LIBS
+CORETEXT_LIBS
+CONFIGURE_TARGETS
+DISABLED_SUBDIRS
+SUBDIRS
+READELF
+OTOOL
+LDD
+WINEPRELOADER_LDFLAGS
+WINELOADER_LDFLAGS
+TOP_INSTALL_DEV
+TOP_INSTALL_LIB
+UNIXLDFLAGS
+UNIXDLLFLAGS
+EXTRACFLAGS
+LDEXECFLAGS
+LDDLLFLAGS
+DLLFLAGS
+OPENGL_LIBS
+I386_LIBS
+DLLEXT
+PE_ARCHS
+MSGFMT
+ICOTOOL
+CONVERT
+RSVG
+FONTFORGE
+PKG_CONFIG
+LN_S
+STRIP
+BISON
+FLEX
+SED_CMD
+RUNTESTFLAGS
+wine64dir
+toolsdir
+x86_64_DISABLED_SUBDIRS
+x86_64_DELAYLOADFLAG
+x86_64_STRIP
+x86_64_TARGET
+x86_64_DEBUG
+x86_64_LDFLAGS
+x86_64_EXTRACFLAGS
+x86_64_CFLAGS
+x86_64_CC
+i386_DISABLED_SUBDIRS
+i386_DELAYLOADFLAG
+i386_STRIP
+i386_TARGET
+i386_DEBUG
+i386_LDFLAGS
+i386_EXTRACFLAGS
+i386_CFLAGS
+i386_CC
+arm64ec_DISABLED_SUBDIRS
+arm64ec_DELAYLOADFLAG
+arm64ec_STRIP
+arm64ec_TARGET
+arm64ec_DEBUG
+arm64ec_LDFLAGS
+arm64ec_EXTRACFLAGS
+arm64ec_CFLAGS
+arm64ec_CC
+arm_DISABLED_SUBDIRS
+arm_DELAYLOADFLAG
+arm_STRIP
+arm_TARGET
+arm_DEBUG
+arm_LDFLAGS
+arm_EXTRACFLAGS
+arm_CFLAGS
+arm_CC
+aarch64_DISABLED_SUBDIRS
+aarch64_DELAYLOADFLAG
+aarch64_STRIP
+aarch64_TARGET
+aarch64_DEBUG
+aarch64_LDFLAGS
+aarch64_EXTRACFLAGS
+aarch64_CFLAGS
+aarch64_CC
+HOST_ARCH
+toolsext
+TARGETFLAGS
+LD
+CPPBIN
+ac_ct_CXX
+CXXFLAGS
+CXX
+OBJEXT
+EXEEXT
+ac_ct_CC
+CPPFLAGS
+LDFLAGS
+CFLAGS
+CC
+SARIF_CONVERTER
+srcdir
+host_os
+host_vendor
+host_cpu
+host
+build_os
+build_vendor
+build_cpu
+build
+system_dllpath
+target_alias
+host_alias
+build_alias
+LIBS
+ECHO_T
+ECHO_N
+ECHO_C
+DEFS
+mandir
+localedir
+libdir
+psdir
+pdfdir
+dvidir
+htmldir
+infodir
+docdir
+oldincludedir
+includedir
+runstatedir
+localstatedir
+sharedstatedir
+sysconfdir
+datadir
+datarootdir
+libexecdir
+sbindir
+bindir
+program_transform_name
+prefix
+exec_prefix
+PACKAGE_URL
+PACKAGE_BUGREPORT
+PACKAGE_STRING
+PACKAGE_VERSION
+PACKAGE_TARNAME
+PACKAGE_NAME
+PATH_SEPARATOR
+SHELL'
+ac_subst_files=''
+ac_user_opts='
+enable_option_checking
+enable_archs
+enable_win16
+enable_win64
+enable_tests
+enable_build_id
+enable_maintainer_mode
+enable_sast
+enable_silent_rules
+enable_werror
+with_alsa
+with_capi
+with_coreaudio
+with_cups
+with_dbus
+with_ffmpeg
+with_fontconfig
+with_freetype
+with_gettext
+with_gettextpo
+with_gphoto
+with_gnutls
+with_gssapi
+with_gstreamer
+with_inotify
+with_krb5
+with_mingw
+with_netapi
+with_opencl
+with_opengl
+with_oss
+with_pcap
+with_pcsclite
+with_pthread
+with_pulse
+with_sane
+with_sdl
+with_udev
+with_unwind
+with_usb
+with_v4l2
+with_vulkan
+with_wayland
+with_xcomposite
+with_xcursor
+with_xfixes
+with_xinerama
+with_xinput
+with_xinput2
+with_xrandr
+with_xrender
+with_xshape
+with_xshm
+with_xxf86vm
+with_system_dllpath
+with_wine_tools
+with_wine64
+enable_largefile
+with_x
+enable_acledit
+enable_aclui
+enable_activeds_tlb
+enable_activeds
+enable_actxprxy
+enable_adsldp
+enable_adsldpc
+enable_advapi32
+enable_advpack
+enable_amsi
+enable_amstream
+enable_apisetschema
+enable_apphelp
+enable_appwiz_cpl
+enable_appxdeploymentclient
+enable_atl
+enable_atl100
+enable_atl110
+enable_atl80
+enable_atl90
+enable_atlthunk
+enable_atmlib
+enable_authz
+enable_avicap32
+enable_avifil32
+enable_avrt
+enable_bcp47langs
+enable_bcrypt
+enable_bcryptprimitives
+enable_bluetoothapis
+enable_browseui
+enable_bthprops_cpl
+enable_cabinet
+enable_capi2032
+enable_cards
+enable_cdosys
+enable_cfgmgr32
+enable_clusapi
+enable_cng_sys
+enable_colorcnv
+enable_combase
+enable_comcat
+enable_comctl32
+enable_comdlg32
+enable_coml2
+enable_compstui
+enable_comsvcs
+enable_concrt140
+enable_connect
+enable_coremessaging
+enable_credui
+enable_crtdll
+enable_crypt32
+enable_cryptbase
+enable_cryptdlg
+enable_cryptdll
+enable_cryptext
+enable_cryptnet
+enable_cryptowinrt
+enable_cryptsp
+enable_cryptui
+enable_cryptxml
+enable_ctapi32
+enable_ctl3d32
+enable_d2d1
+enable_d3d10
+enable_d3d10_1
+enable_d3d10core
+enable_d3d11
+enable_d3d12
+enable_d3d12core
+enable_d3d8
+enable_d3d8thk
+enable_d3d9
+enable_d3dcompiler_33
+enable_d3dcompiler_34
+enable_d3dcompiler_35
+enable_d3dcompiler_36
+enable_d3dcompiler_37
+enable_d3dcompiler_38
+enable_d3dcompiler_39
+enable_d3dcompiler_40
+enable_d3dcompiler_41
+enable_d3dcompiler_42
+enable_d3dcompiler_43
+enable_d3dcompiler_46
+enable_d3dcompiler_47
+enable_d3dim
+enable_d3dim700
+enable_d3drm
+enable_d3dx10_33
+enable_d3dx10_34
+enable_d3dx10_35
+enable_d3dx10_36
+enable_d3dx10_37
+enable_d3dx10_38
+enable_d3dx10_39
+enable_d3dx10_40
+enable_d3dx10_41
+enable_d3dx10_42
+enable_d3dx10_43
+enable_d3dx11_42
+enable_d3dx11_43
+enable_d3dx9_24
+enable_d3dx9_25
+enable_d3dx9_26
+enable_d3dx9_27
+enable_d3dx9_28
+enable_d3dx9_29
+enable_d3dx9_30
+enable_d3dx9_31
+enable_d3dx9_32
+enable_d3dx9_33
+enable_d3dx9_34
+enable_d3dx9_35
+enable_d3dx9_36
+enable_d3dx9_37
+enable_d3dx9_38
+enable_d3dx9_39
+enable_d3dx9_40
+enable_d3dx9_41
+enable_d3dx9_42
+enable_d3dx9_43
+enable_d3dxof
+enable_dataexchange
+enable_davclnt
+enable_dbgeng
+enable_dbghelp
+enable_dciman32
+enable_dcomp
+enable_ddraw
+enable_ddrawex
+enable_desk_cpl
+enable_devenum
+enable_dhcpcsvc
+enable_dhcpcsvc6
+enable_dhtmled_ocx
+enable_diasymreader
+enable_difxapi
+enable_dinput
+enable_dinput8
+enable_directmanipulation
+enable_dispex
+enable_dmband
+enable_dmcompos
+enable_dmime
+enable_dmloader
+enable_dmscript
+enable_dmstyle
+enable_dmsynth
+enable_dmusic
+enable_dmusic32
+enable_dnsapi
+enable_dplay
+enable_dplayx
+enable_dpnaddr
+enable_dpnet
+enable_dpnhpast
+enable_dpnhupnp
+enable_dpnlobby
+enable_dpvoice
+enable_dpwsockx
+enable_drmclien
+enable_dsdmo
+enable_dsound
+enable_dsquery
+enable_dssenh
+enable_dsuiext
+enable_dswave
+enable_dwmapi
+enable_dwrite
+enable_dx8vb
+enable_dxcore
+enable_dxdiagn
+enable_dxgi
+enable_dxtrans
+enable_dxva2
+enable_esent
+enable_evr
+enable_explorerframe
+enable_faultrep
+enable_feclient
+enable_fltlib
+enable_fltmgr_sys
+enable_fntcache
+enable_fontsub
+enable_fusion
+enable_fwpuclnt
+enable_gameinput
+enable_gameux
+enable_gamingtcui
+enable_gdi32
+enable_gdiplus
+enable_geolocation
+enable_glu32
+enable_gphoto2_ds
+enable_gpkcsp
+enable_graphicscapture
+enable_hal
+enable_hhctrl_ocx
+enable_hid
+enable_hidclass_sys
+enable_hidparse_sys
+enable_hlink
+enable_hnetcfg
+enable_hrtfapo
+enable_http_sys
+enable_httpapi
+enable_hvsimanagementapi
+enable_ia2comproxy
+enable_iccvid
+enable_icmp
+enable_icmui
+enable_ieframe
+enable_ieproxy
+enable_iertutil
+enable_imaadp32_acm
+enable_imagehlp
+enable_imm32
+enable_inetcomm
+enable_inetcpl_cpl
+enable_inetmib1
+enable_infosoft
+enable_initpki
+enable_inkobj
+enable_inseng
+enable_iphlpapi
+enable_iprop
+enable_ir50_32
+enable_irprops_cpl
+enable_itircl
+enable_itss
+enable_joy_cpl
+enable_jscript
+enable_jsproxy
+enable_kerberos
+enable_kernel32
+enable_kernelbase
+enable_ksecdd_sys
+enable_ksproxy_ax
+enable_ksuser
+enable_ktmw32
+enable_l3codeca_acm
+enable_l3codecx_ax
+enable_light_msstyles
+enable_loadperf
+enable_localspl
+enable_localui
+enable_lz32
+enable_magnification
+enable_mapi32
+enable_mapistub
+enable_mciavi32
+enable_mcicda
+enable_mciqtz32
+enable_mciseq
+enable_mciwave
+enable_mf
+enable_mf3216
+enable_mfasfsrcsnk
+enable_mferror
+enable_mfh264enc
+enable_mfmediaengine
+enable_mfmp4srcsnk
+enable_mfplat
+enable_mfplay
+enable_mfreadwrite
+enable_mfsrcsnk
+enable_mgmtapi
+enable_midimap
+enable_mlang
+enable_mmcndmgr
+enable_mmdevapi
+enable_mouhid_sys
+enable_mountmgr_sys
+enable_mp3dmod
+enable_mpr
+enable_mprapi
+enable_msacm32_drv
+enable_msacm32
+enable_msado15
+enable_msadp32_acm
+enable_msasn1
+enable_msauddecmft
+enable_mscat32
+enable_mscms
+enable_mscoree
+enable_mscorwks
+enable_msctf
+enable_msctfmonitor
+enable_msctfp
+enable_msdaps
+enable_msdasql
+enable_msdelta
+enable_msdmo
+enable_msdrm
+enable_msftedit
+enable_msg711_acm
+enable_msgsm32_acm
+enable_mshtml_tlb
+enable_mshtml
+enable_msi
+enable_msident
+enable_msimg32
+enable_msimsg
+enable_msimtf
+enable_msisip
+enable_msisys_ocx
+enable_msls31
+enable_msmpeg2vdec
+enable_msnet32
+enable_mspatcha
+enable_msports
+enable_msrle32
+enable_msscript_ocx
+enable_mssign32
+enable_mssip32
+enable_mstask
+enable_msttsengine
+enable_msv1_0
+enable_msvcirt
+enable_msvcm80
+enable_msvcm90
+enable_msvcp100
+enable_msvcp110
+enable_msvcp120
+enable_msvcp120_app
+enable_msvcp140
+enable_msvcp140_1
+enable_msvcp140_2
+enable_msvcp140_atomic_wait
+enable_msvcp140_codecvt_ids
+enable_msvcp60
+enable_msvcp70
+enable_msvcp71
+enable_msvcp80
+enable_msvcp90
+enable_msvcp_win
+enable_msvcr100
+enable_msvcr110
+enable_msvcr120
+enable_msvcr120_app
+enable_msvcr70
+enable_msvcr71
+enable_msvcr80
+enable_msvcr90
+enable_msvcrt
+enable_msvcrt20
+enable_msvcrt40
+enable_msvcrtd
+enable_msvfw32
+enable_msvidc32
+enable_msvproc
+enable_mswsock
+enable_msxml
+enable_msxml2
+enable_msxml3
+enable_msxml4
+enable_msxml6
+enable_mtxdm
+enable_ncrypt
+enable_nddeapi
+enable_ndis_sys
+enable_netapi32
+enable_netcfgx
+enable_netio_sys
+enable_netprofm
+enable_netutils
+enable_newdev
+enable_ninput
+enable_normaliz
+enable_npmshtml
+enable_npptools
+enable_nsi
+enable_nsiproxy_sys
+enable_ntdll
+enable_ntdsapi
+enable_ntoskrnl_exe
+enable_ntprint
+enable_objsel
+enable_odbc32
+enable_odbcbcp
+enable_odbccp32
+enable_odbccu32
+enable_ole32
+enable_oleacc
+enable_oleaut32
+enable_olecli32
+enable_oledb32
+enable_oledlg
+enable_olepro32
+enable_olesvr32
+enable_olethk32
+enable_opcservices
+enable_opencl
+enable_opengl32
+enable_packager
+enable_pdh
+enable_photometadatahandler
+enable_pidgen
+enable_powrprof
+enable_printui
+enable_prntvpt
+enable_profapi
+enable_propsys
+enable_psapi
+enable_pstorec
+enable_pwrshplugin
+enable_qasf
+enable_qcap
+enable_qdvd
+enable_qedit
+enable_qmgr
+enable_qmgrprxy
+enable_quartz
+enable_query
+enable_qwave
+enable_rasapi32
+enable_rasdlg
+enable_regapi
+enable_resampledmo
+enable_resutils
+enable_riched20
+enable_riched32
+enable_rometadata
+enable_rpcrt4
+enable_rsabase
+enable_rsaenh
+enable_rstrtmgr
+enable_rtutils
+enable_rtworkq
+enable_samlib
+enable_sane_ds
+enable_sapi
+enable_sas
+enable_scarddlg
+enable_scardsvr
+enable_sccbase
+enable_schannel
+enable_schedsvc
+enable_scrobj
+enable_scrrun
+enable_scsiport_sys
+enable_sechost
+enable_secur32
+enable_security
+enable_sensapi
+enable_serialui
+enable_setupapi
+enable_sfc
+enable_sfc_os
+enable_shcore
+enable_shdoclc
+enable_shdocvw
+enable_shell32
+enable_shfolder
+enable_shlwapi
+enable_slbcsp
+enable_slc
+enable_snmpapi
+enable_softpub
+enable_spoolss
+enable_sppc
+enable_srclient
+enable_srvcli
+enable_srvsvc
+enable_sspicli
+enable_stdole2_tlb
+enable_stdole32_tlb
+enable_sti
+enable_strmdll
+enable_svrapi
+enable_sxs
+enable_t2embed
+enable_tapi32
+enable_taskschd
+enable_tbs
+enable_tdh
+enable_tdi_sys
+enable_threadpoolwinrt
+enable_traffic
+enable_twain_32
+enable_twinapi_appcore
+enable_tzres
+enable_ucrtbase
+enable_uianimation
+enable_uiautomationcore
+enable_uiribbon
+enable_unicows
+enable_updspapi
+enable_url
+enable_urlmon
+enable_usbd_sys
+enable_user32
+enable_userenv
+enable_usp10
+enable_utildll
+enable_uxtheme
+enable_vbscript
+enable_vccorlib140
+enable_vcomp
+enable_vcomp100
+enable_vcomp110
+enable_vcomp120
+enable_vcomp140
+enable_vcomp90
+enable_vcruntime140
+enable_vcruntime140_1
+enable_vdmdbg
+enable_version
+enable_vga
+enable_virtdisk
+enable_vssapi
+enable_vulkan_1
+enable_w32skrnl
+enable_wbemdisp
+enable_wbemprox
+enable_wdscore
+enable_webservices
+enable_websocket
+enable_wer
+enable_wevtapi
+enable_wevtsvc
+enable_wiaservc
+enable_wimgapi
+enable_win32u
+enable_winbio
+enable_windows_applicationmodel
+enable_windows_devices_bluetooth
+enable_windows_devices_enumeration
+enable_windows_devices_usb
+enable_windows_gaming_input
+enable_windows_gaming_ui_gamebar
+enable_windows_globalization
+enable_windows_media_devices
+enable_windows_media_mediacontrol
+enable_windows_media_playback_backgroundmediaplayer
+enable_windows_media_playback_mediaplayer
+enable_windows_media_speech
+enable_windows_media
+enable_windows_networking_connectivity
+enable_windows_networking_hostname
+enable_windows_networking
+enable_windows_perception_stub
+enable_windows_security_authentication_onlineid
+enable_windows_security_credentials_ui_userconsentverifier
+enable_windows_storage_applicationdata
+enable_windows_storage
+enable_windows_system_profile_systemid
+enable_windows_system_profile_systemmanufacturers
+enable_windows_ui_xaml
+enable_windows_ui
+enable_windows_web
+enable_windowscodecs
+enable_windowscodecsext
+enable_winealsa_drv
+enable_wineandroid_drv
+enable_winebth_sys
+enable_winebus_sys
+enable_winecoreaudio_drv
+enable_winecrt0
+enable_wined3d
+enable_winedmo
+enable_winegstreamer
+enable_winehid_sys
+enable_winemac_drv
+enable_winemapi
+enable_wineoss_drv
+enable_wineps_drv
+enable_winepulse_drv
+enable_wineusb_sys
+enable_winevulkan
+enable_winewayland_drv
+enable_winex11_drv
+enable_winexinput_sys
+enable_wing32
+enable_winhttp
+enable_wininet
+enable_winmm
+enable_winnls32
+enable_winprint
+enable_winscard
+enable_winspool_drv
+enable_winsta
+enable_wintab32
+enable_wintrust
+enable_wintypes
+enable_winusb
+enable_wlanapi
+enable_wlanui
+enable_wldap32
+enable_wldp
+enable_wmadmod
+enable_wmasf
+enable_wmi
+enable_wmilib_sys
+enable_wmiutils
+enable_wmp
+enable_wmphoto
+enable_wmvcore
+enable_wmvdecod
+enable_wnaspi32
+enable_wofutil
+enable_wow32
+enable_wow64
+enable_wow64cpu
+enable_wow64win
+enable_wpc
+enable_wpcap
+enable_ws2_32
+enable_wsdapi
+enable_wshom_ocx
+enable_wsnmp32
+enable_wsock32
+enable_wtsapi32
+enable_wuapi
+enable_wuaueng
+enable_x3daudio1_0
+enable_x3daudio1_1
+enable_x3daudio1_2
+enable_x3daudio1_3
+enable_x3daudio1_4
+enable_x3daudio1_5
+enable_x3daudio1_6
+enable_x3daudio1_7
+enable_xactengine2_0
+enable_xactengine2_4
+enable_xactengine2_7
+enable_xactengine2_9
+enable_xactengine3_0
+enable_xactengine3_1
+enable_xactengine3_2
+enable_xactengine3_3
+enable_xactengine3_4
+enable_xactengine3_5
+enable_xactengine3_6
+enable_xactengine3_7
+enable_xapofx1_1
+enable_xapofx1_2
+enable_xapofx1_3
+enable_xapofx1_4
+enable_xapofx1_5
+enable_xaudio2_0
+enable_xaudio2_1
+enable_xaudio2_2
+enable_xaudio2_3
+enable_xaudio2_4
+enable_xaudio2_5
+enable_xaudio2_6
+enable_xaudio2_7
+enable_xaudio2_8
+enable_xaudio2_9
+enable_xinput1_1
+enable_xinput1_2
+enable_xinput1_3
+enable_xinput1_4
+enable_xinput9_1_0
+enable_xinputuap
+enable_xmllite
+enable_xolehlp
+enable_xpsprint
+enable_xpssvcs
+enable_xtajit64
+enable_fonts
+enable_include
+enable_adsiid
+enable_capstone
+enable_compiler_rt
+enable_dmoguids
+enable_dxerr8
+enable_dxerr9
+enable_dxguid
+enable_faudio
+enable_fluidsynth
+enable_gsm
+enable_jpeg
+enable_jxr
+enable_lcms2
+enable_ldap
+enable_mfuuid
+enable_mpg123
+enable_musl
+enable_png
+enable_strmbase
+enable_strmiids
+enable_tiff
+enable_tomcrypt
+enable_uuid
+enable_vkd3d
+enable_wbemuuid
+enable_wmcodecdspuuid
+enable_xml2
+enable_xslt
+enable_zlib
+enable_loader
+enable_nls
+enable_po
+enable_arp
+enable_aspnet_regiis
+enable_attrib
+enable_cabarc
+enable_cacls
+enable_certutil
+enable_chcp_com
+enable_clock
+enable_cmd
+enable_conhost
+enable_control
+enable_cscript
+enable_dism
+enable_dllhost
+enable_dplaysvr
+enable_dpnsvr
+enable_dpvsetup
+enable_dxdiag
+enable_eject
+enable_expand
+enable_explorer
+enable_extrac32
+enable_fc
+enable_find
+enable_findstr
+enable_fsutil
+enable_hh
+enable_hostname
+enable_icacls
+enable_icinfo
+enable_iexplore
+enable_ipconfig
+enable_klist
+enable_lodctr
+enable_makecab
+enable_mofcomp
+enable_mshta
+enable_msidb
+enable_msiexec
+enable_msinfo32
+enable_net
+enable_netsh
+enable_netstat
+enable_ngen
+enable_notepad
+enable_oleview
+enable_ping
+enable_plugplay
+enable_pnputil
+enable_powershell
+enable_presentationfontcache
+enable_progman
+enable_reg
+enable_regasm
+enable_regedit
+enable_regini
+enable_regsvcs
+enable_regsvr32
+enable_robocopy
+enable_rpcss
+enable_runas
+enable_rundll32
+enable_sc
+enable_schtasks
+enable_sdbinst
+enable_secedit
+enable_servicemodelreg
+enable_services
+enable_setx
+enable_shutdown
+enable_sort
+enable_spoolsv
+enable_start
+enable_subst
+enable_svchost
+enable_systeminfo
+enable_taskkill
+enable_tasklist
+enable_taskmgr
+enable_termsv
+enable_timeout
+enable_uninstaller
+enable_unlodctr
+enable_view
+enable_wevtutil
+enable_where
+enable_whoami
+enable_wineboot
+enable_winebrowser
+enable_winecfg
+enable_wineconsole
+enable_winedbg
+enable_winedevice
+enable_winefile
+enable_winemenubuilder
+enable_winemine
+enable_winemsibuilder
+enable_winepath
+enable_winetest
+enable_winevdm
+enable_winhlp32
+enable_winmgmt
+enable_winver
+enable_wmic
+enable_wmplayer
+enable_wordpad
+enable_write
+enable_wscript
+enable_wuauserv
+enable_wusa
+enable_xcopy
+enable_server
+enable_tools
+enable_sfnt2fon
+enable_widl
+enable_wine
+enable_winebuild
+enable_winedump
+enable_winegcc
+enable_winemaker
+enable_wmc
+enable_wrc
+enable_year2038
+'
+      ac_precious_vars='build_alias
+host_alias
+target_alias
+CC
+CFLAGS
+LDFLAGS
+LIBS
+CPPFLAGS
+CXX
+CXXFLAGS
+CCC
+OBJC
+OBJCFLAGS
+CAPSTONE_PE_CFLAGS
+CAPSTONE_PE_LIBS
+COMPILER_RT_PE_CFLAGS
+COMPILER_RT_PE_LIBS
+FAUDIO_PE_CFLAGS
+FAUDIO_PE_LIBS
+FLUIDSYNTH_PE_CFLAGS
+FLUIDSYNTH_PE_LIBS
+GSM_PE_CFLAGS
+GSM_PE_LIBS
+JPEG_PE_CFLAGS
+JPEG_PE_LIBS
+JXR_PE_CFLAGS
+JXR_PE_LIBS
+LCMS2_PE_CFLAGS
+LCMS2_PE_LIBS
+LDAP_PE_CFLAGS
+LDAP_PE_LIBS
+MPG123_PE_CFLAGS
+MPG123_PE_LIBS
+MUSL_PE_CFLAGS
+MUSL_PE_LIBS
+PNG_PE_CFLAGS
+PNG_PE_LIBS
+TIFF_PE_CFLAGS
+TIFF_PE_LIBS
+TOMCRYPT_PE_CFLAGS
+TOMCRYPT_PE_LIBS
+VKD3D_PE_CFLAGS
+VKD3D_PE_LIBS
+XML2_PE_CFLAGS
+XML2_PE_LIBS
+XSLT_PE_CFLAGS
+XSLT_PE_LIBS
+ZLIB_PE_CFLAGS
+ZLIB_PE_LIBS
+EGL_CFLAGS
+EGL_LIBS
+XMKMF
+CPP
+WAYLAND_CLIENT_CFLAGS
+WAYLAND_CLIENT_LIBS
+XKBCOMMON_CFLAGS
+XKBCOMMON_LIBS
+XKBREGISTRY_CFLAGS
+XKBREGISTRY_LIBS
+WAYLAND_EGL_CFLAGS
+WAYLAND_EGL_LIBS
+INOTIFY_CFLAGS
+INOTIFY_LIBS
+DBUS_CFLAGS
+DBUS_LIBS
+GNUTLS_CFLAGS
+GNUTLS_LIBS
+SANE_CFLAGS
+SANE_LIBS
+USB_CFLAGS
+USB_LIBS
+GPHOTO2_CFLAGS
+GPHOTO2_LIBS
+GPHOTO2_PORT_CFLAGS
+GPHOTO2_PORT_LIBS
+FREETYPE_CFLAGS
+FREETYPE_LIBS
+PULSE_CFLAGS
+PULSE_LIBS
+FFMPEG_CFLAGS
+FFMPEG_LIBS
+GSTREAMER_CFLAGS
+GSTREAMER_LIBS
+ALSA_CFLAGS
+ALSA_LIBS
+UDEV_CFLAGS
+UDEV_LIBS
+UNWIND_CFLAGS
+UNWIND_LIBS
+SDL2_CFLAGS
+SDL2_LIBS
+CAPI20_CFLAGS
+CAPI20_LIBS
+CUPS_CFLAGS
+CUPS_LIBS
+FONTCONFIG_CFLAGS
+FONTCONFIG_LIBS
+KRB5_CFLAGS
+KRB5_LIBS
+GSSAPI_CFLAGS
+GSSAPI_LIBS
+NETAPI_CFLAGS
+NETAPI_LIBS'
+
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+ac_unrecognized_opts=
+ac_unrecognized_sep=
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+# (The list follows the same order as the GNU Coding Standards.)
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datarootdir='${prefix}/share'
+datadir='${datarootdir}'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+runstatedir='${localstatedir}/run'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
+infodir='${datarootdir}/info'
+htmldir='${docdir}'
+dvidir='${docdir}'
+pdfdir='${docdir}'
+psdir='${docdir}'
+libdir='${exec_prefix}/lib'
+localedir='${datarootdir}/locale'
+mandir='${datarootdir}/man'
+
+ac_prev=
+ac_dashdash=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval $ac_prev=\$ac_option
+    ac_prev=
+    continue
+  fi
+
+  case $ac_option in
+  *=?*) ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
+  *=)   ac_optarg= ;;
+  *)    ac_optarg=yes ;;
+  esac
+
+  case $ac_dashdash$ac_option in
+  --)
+    ac_dashdash=yes ;;
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=*)
+    datadir=$ac_optarg ;;
+
+  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \
+  | --dataroo | --dataro | --datar)
+    ac_prev=datarootdir ;;
+  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \
+  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)
+    datarootdir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid feature name: '$ac_useropt'"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`printf "%s\n" "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--disable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=no ;;
+
+  -docdir | --docdir | --docdi | --doc | --do)
+    ac_prev=docdir ;;
+  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)
+    docdir=$ac_optarg ;;
+
+  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)
+    ac_prev=dvidir ;;
+  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)
+    dvidir=$ac_optarg ;;
+
+  -enable-* | --enable-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid feature name: '$ac_useropt'"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`printf "%s\n" "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--enable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=\$ac_optarg ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)
+    ac_prev=htmldir ;;
+  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \
+  | --ht=*)
+    htmldir=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localedir | --localedir | --localedi | --localed | --locale)
+    ac_prev=localedir ;;
+  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)
+    localedir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst | --locals)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)
+    ac_prev=pdfdir ;;
+  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)
+    pdfdir=$ac_optarg ;;
+
+  -psdir | --psdir | --psdi | --psd | --ps)
+    ac_prev=psdir ;;
+  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)
+    psdir=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -runstatedir | --runstatedir | --runstatedi | --runstated \
+  | --runstate | --runstat | --runsta | --runst | --runs \
+  | --run | --ru | --r)
+    ac_prev=runstatedir ;;
+  -runstatedir=* | --runstatedir=* | --runstatedi=* | --runstated=* \
+  | --runstate=* | --runstat=* | --runsta=* | --runst=* | --runs=* \
+  | --run=* | --ru=* | --r=*)
+    runstatedir=$ac_optarg ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid package name: '$ac_useropt'"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`printf "%s\n" "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--with-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=\$ac_optarg ;;
+
+  -without-* | --without-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid package name: '$ac_useropt'"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`printf "%s\n" "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--without-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=no ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) as_fn_error $? "unrecognized option: '$ac_option'
+Try '$0 --help' for more information"
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    case $ac_envvar in #(
+      '' | [0-9]* | *[!_$as_cr_alnum]* )
+      as_fn_error $? "invalid variable name: '$ac_envvar'" ;;
+    esac
+    eval $ac_envvar=\$ac_optarg
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    printf "%s\n" "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      printf "%s\n" "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : "${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}"
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  as_fn_error $? "missing argument to $ac_option"
+fi
+
+if test -n "$ac_unrecognized_opts"; then
+  case $enable_option_checking in
+    no) ;;
+    fatal) as_fn_error $? "unrecognized options: $ac_unrecognized_opts" ;;
+    *)     printf "%s\n" "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
+  esac
+fi
+
+# Check all directory arguments for consistency.
+for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
+		datadir sysconfdir sharedstatedir localstatedir includedir \
+		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
+		libdir localedir mandir runstatedir
+do
+  eval ac_val=\$$ac_var
+  # Remove trailing slashes.
+  case $ac_val in
+    */ )
+      ac_val=`expr "X$ac_val" : 'X\(.*[^/]\)' \| "X$ac_val" : 'X\(.*\)'`
+      eval $ac_var=\$ac_val;;
+  esac
+  # Be sure to have absolute directory names.
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* )  continue;;
+    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
+  esac
+  as_fn_error $? "expected an absolute directory name for --$ac_var: $ac_val"
+done
+
+# There might be people who depend on the old broken behavior: '$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+ac_pwd=`pwd` && test -n "$ac_pwd" &&
+ac_ls_di=`ls -di .` &&
+ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
+  as_fn_error $? "working directory cannot be determined"
+test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
+  as_fn_error $? "pwd does not report name of working directory"
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then the parent directory.
+  ac_confdir=`$as_dirname -- "$as_myself" ||
+$as_expr X"$as_myself" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_myself" : 'X\(//\)[^/]' \| \
+	 X"$as_myself" : 'X\(//\)$' \| \
+	 X"$as_myself" : 'X\(/\)' \| . 2>/dev/null ||
+printf "%s\n" X"$as_myself" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r "$srcdir/$ac_unique_file"; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r "$srcdir/$ac_unique_file"; then
+  test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
+  as_fn_error $? "cannot find sources ($ac_unique_file) in $srcdir"
+fi
+ac_msg="sources are in $srcdir, but 'cd $srcdir' does not work"
+ac_abs_confdir=`(
+	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error $? "$ac_msg"
+	pwd)`
+# When building in place, set srcdir=.
+if test "$ac_abs_confdir" = "$ac_pwd"; then
+  srcdir=.
+fi
+# Remove unnecessary trailing slashes from srcdir.
+# Double slashes in file names in object file debugging info
+# mess up M-x gdb in Emacs.
+case $srcdir in
+*/) srcdir=`expr "X$srcdir" : 'X\(.*[^/]\)' \| "X$srcdir" : 'X\(.*\)'`;;
+esac
+for ac_var in $ac_precious_vars; do
+  eval ac_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_env_${ac_var}_value=\$${ac_var}
+  eval ac_cv_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_cv_env_${ac_var}_value=\$${ac_var}
+done
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+'configure' configures Wine 10.16 to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print 'checking ...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for '--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or '..']
+
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+                          [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+                          [PREFIX]
+
+By default, 'make install' will install all the files in
+'$ac_default_prefix/bin', '$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than '$ac_default_prefix' using '--prefix',
+for instance '--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR            user executables [EPREFIX/bin]
+  --sbindir=DIR           system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR        program executables [EPREFIX/libexec]
+  --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
+  --runstatedir=DIR       modifiable per-process data [LOCALSTATEDIR/run]
+  --libdir=DIR            object code libraries [EPREFIX/lib]
+  --includedir=DIR        C header files [PREFIX/include]
+  --oldincludedir=DIR     C header files for non-gcc [/usr/include]
+  --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]
+  --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]
+  --infodir=DIR           info documentation [DATAROOTDIR/info]
+  --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]
+  --mandir=DIR            man documentation [DATAROOTDIR/man]
+  --docdir=DIR            documentation root [DATAROOTDIR/doc/wine]
+  --htmldir=DIR           html documentation [DOCDIR]
+  --dvidir=DIR            dvi documentation [DOCDIR]
+  --pdfdir=DIR            pdf documentation [DOCDIR]
+  --psdir=DIR             ps documentation [DOCDIR]
+_ACEOF
+
+  cat <<\_ACEOF
+
+X features:
+  --x-includes=DIR    X include files are in DIR
+  --x-libraries=DIR   X library files are in DIR
+
+System types:
+  --build=BUILD     configure for building on BUILD [guessed]
+  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+  case $ac_init_help in
+     short | recursive ) echo "Configuration of Wine 10.16:";;
+   esac
+  cat <<\_ACEOF
+
+Optional Features:
+  --disable-option-checking  ignore unrecognized --enable/--with options
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --enable-archs={i386,x86_64,arm,aarch64}
+                          enable multiple architectures for PE compilation
+  --disable-win16         do not include Win16 support
+  --enable-win64          build a Win64 emulator on AMD64 (won't run Win32
+                          binaries)
+  --disable-tests         do not build the regression tests
+  --enable-build-id       include .buildid section in output objects
+  --enable-maintainer-mode
+                          enable maintainer-specific build rules
+  --enable-sast           enable static application security testing using
+                          Clang
+  --enable-silent-rules   use silent build rules (override: "make V=1")
+  --enable-werror         treat compilation warnings as errors
+  --disable-largefile     omit support for large files
+  --disable-year2038      don't support timestamps after 2038
+
+Optional Packages:
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --without-alsa          do not use the Alsa sound support
+  --without-capi          do not use CAPI (ISDN support)
+  --without-coreaudio     do not use the CoreAudio sound support
+  --without-cups          do not use CUPS
+  --without-dbus          do not use DBus (dynamic device support)
+  --without-ffmpeg        do not use the FFmpeg library
+  --without-fontconfig    do not use fontconfig
+  --without-freetype      do not use the FreeType library
+  --without-gettext       do not use gettext
+  --with-gettextpo        use the GetTextPO library to rebuild po files
+  --without-gphoto        do not use gphoto (Digital Camera support)
+  --without-gnutls        do not use GnuTLS (schannel support)
+  --without-gssapi        do not use GSSAPI (Kerberos SSP support)
+  --without-gstreamer     do not use GStreamer (codecs support)
+  --without-inotify       do not use inotify (filesystem change notifications)
+  --without-krb5          do not use krb5 (Kerberos)
+  --without-mingw         do not use the MinGW cross-compiler
+  --without-netapi        do not use the Samba NetAPI library
+  --without-opencl        do not use OpenCL
+  --without-opengl        do not use OpenGL
+  --without-oss           do not use the OSS sound support
+  --without-pcap          do not use the Packet Capture library
+  --without-pcsclite      do not use PCSC lite
+  --without-pthread       do not use the pthread library
+  --without-pulse         do not use PulseAudio sound support
+  --without-sane          do not use SANE (scanner support)
+  --without-sdl           do not use SDL
+  --without-udev          do not use udev (plug and play support)
+  --without-unwind        do not use the libunwind library (exception
+                          handling)
+  --without-usb           do not use the libusb library
+  --without-v4l2          do not use v4l2 (video capture)
+  --without-vulkan        do not use Vulkan
+  --without-wayland       do not build the Wayland driver
+  --without-xcomposite    do not use the Xcomposite extension
+  --without-xcursor       do not use the Xcursor extension
+  --without-xfixes        do not use Xfixes for clipboard change notifications
+  --without-xinerama      do not use Xinerama (legacy multi-monitor support)
+  --without-xinput        do not use the Xinput extension
+  --without-xinput2       do not use the Xinput 2 extension
+  --without-xrandr        do not use Xrandr (multi-monitor support)
+  --without-xrender       do not use the Xrender extension
+  --without-xshape        do not use the Xshape extension
+  --without-xshm          do not use XShm (shared memory extension)
+  --without-xxf86vm       do not use XFree video mode extension
+  --with-system-dllpath=PATH
+                          load external PE dependencies from colon-separated
+                          path PATH
+  --with-wine-tools=DIR   use Wine tools from directory DIR
+  --with-wine64=DIR       use the 64-bit Wine in DIR for a Wow64 build
+  --with-x                use the X Window System
+
+Some influential environment variables:
+  CC          C compiler command
+  CFLAGS      C compiler flags
+  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
+              nonstandard directory <lib dir>
+  LIBS        libraries to pass to the linker, e.g. -l<library>
+  CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I<include dir> if
+              you have headers in a nonstandard directory <include dir>
+  CXX         C++ compiler command
+  CXXFLAGS    C++ compiler flags
+  OBJC        Objective C compiler command
+  OBJCFLAGS   Objective C compiler flags
+  CAPSTONE_PE_CFLAGS
+              C compiler flags for the PE capstone, overriding the bundled
+              version
+  CAPSTONE_PE_LIBS
+              Linker flags for the PE capstone, overriding the bundled version
+  COMPILER_RT_PE_CFLAGS
+              C compiler flags for the PE compiler-rt, overriding the bundled
+              version
+  COMPILER_RT_PE_LIBS
+              Linker flags for the PE compiler-rt, overriding the bundled
+              version
+  FAUDIO_PE_CFLAGS
+              C compiler flags for the PE faudio, overriding the bundled
+              version
+  FAUDIO_PE_LIBS
+              Linker flags for the PE faudio, overriding the bundled version
+  FLUIDSYNTH_PE_CFLAGS
+              C compiler flags for the PE fluidsynth, overriding the bundled
+              version
+  FLUIDSYNTH_PE_LIBS
+              Linker flags for the PE fluidsynth, overriding the bundled
+              version
+  GSM_PE_CFLAGS
+              C compiler flags for the PE gsm, overriding the bundled version
+  GSM_PE_LIBS Linker flags for the PE gsm, overriding the bundled version
+  JPEG_PE_CFLAGS
+              C compiler flags for the PE jpeg, overriding the bundled version
+  JPEG_PE_LIBS
+              Linker flags for the PE jpeg, overriding the bundled version
+  JXR_PE_CFLAGS
+              C compiler flags for the PE jxr, overriding the bundled version
+  JXR_PE_LIBS Linker flags for the PE jxr, overriding the bundled version
+  LCMS2_PE_CFLAGS
+              C compiler flags for the PE lcms2, overriding the bundled
+              version
+  LCMS2_PE_LIBS
+              Linker flags for the PE lcms2, overriding the bundled version
+  LDAP_PE_CFLAGS
+              C compiler flags for the PE ldap, overriding the bundled version
+  LDAP_PE_LIBS
+              Linker flags for the PE ldap, overriding the bundled version
+  MPG123_PE_CFLAGS
+              C compiler flags for the PE mpg123, overriding the bundled
+              version
+  MPG123_PE_LIBS
+              Linker flags for the PE mpg123, overriding the bundled version
+  MUSL_PE_CFLAGS
+              C compiler flags for the PE musl, overriding the bundled version
+  MUSL_PE_LIBS
+              Linker flags for the PE musl, overriding the bundled version
+  PNG_PE_CFLAGS
+              C compiler flags for the PE png, overriding the bundled version
+  PNG_PE_LIBS Linker flags for the PE png, overriding the bundled version
+  TIFF_PE_CFLAGS
+              C compiler flags for the PE tiff, overriding the bundled version
+  TIFF_PE_LIBS
+              Linker flags for the PE tiff, overriding the bundled version
+  TOMCRYPT_PE_CFLAGS
+              C compiler flags for the PE tomcrypt, overriding the bundled
+              version
+  TOMCRYPT_PE_LIBS
+              Linker flags for the PE tomcrypt, overriding the bundled version
+  VKD3D_PE_CFLAGS
+              C compiler flags for the PE vkd3d, overriding the bundled
+              version
+  VKD3D_PE_LIBS
+              Linker flags for the PE vkd3d, overriding the bundled version
+  XML2_PE_CFLAGS
+              C compiler flags for the PE xml2, overriding the bundled version
+  XML2_PE_LIBS
+              Linker flags for the PE xml2, overriding the bundled version
+  XSLT_PE_CFLAGS
+              C compiler flags for the PE xslt, overriding the bundled version
+  XSLT_PE_LIBS
+              Linker flags for the PE xslt, overriding the bundled version
+  ZLIB_PE_CFLAGS
+              C compiler flags for the PE zlib, overriding the bundled version
+  ZLIB_PE_LIBS
+              Linker flags for the PE zlib, overriding the bundled version
+  EGL_CFLAGS  C compiler flags for egl, overriding pkg-config
+  EGL_LIBS    Linker flags for egl, overriding pkg-config
+  XMKMF       Path to xmkmf, Makefile generator for X Window System
+  CPP         C preprocessor
+  WAYLAND_CLIENT_CFLAGS
+              C compiler flags for wayland-client, overriding pkg-config
+  WAYLAND_CLIENT_LIBS
+              Linker flags for wayland-client, overriding pkg-config
+  XKBCOMMON_CFLAGS
+              C compiler flags for xkbcommon, overriding pkg-config
+  XKBCOMMON_LIBS
+              Linker flags for xkbcommon, overriding pkg-config
+  XKBREGISTRY_CFLAGS
+              C compiler flags for xkbregistry, overriding pkg-config
+  XKBREGISTRY_LIBS
+              Linker flags for xkbregistry, overriding pkg-config
+  WAYLAND_EGL_CFLAGS
+              C compiler flags for wayland-egl, overriding pkg-config
+  WAYLAND_EGL_LIBS
+              Linker flags for wayland-egl, overriding pkg-config
+  INOTIFY_CFLAGS
+              C compiler flags for libinotify, overriding pkg-config
+  INOTIFY_LIBS
+              Linker flags for libinotify, overriding pkg-config
+  DBUS_CFLAGS C compiler flags for dbus-1, overriding pkg-config
+  DBUS_LIBS   Linker flags for dbus-1, overriding pkg-config
+  GNUTLS_CFLAGS
+              C compiler flags for gnutls, overriding pkg-config
+  GNUTLS_LIBS Linker flags for gnutls, overriding pkg-config
+  SANE_CFLAGS C compiler flags for sane-backends, overriding pkg-config
+  SANE_LIBS   Linker flags for sane-backends, overriding pkg-config
+  USB_CFLAGS  C compiler flags for libusb-1.0, overriding pkg-config
+  USB_LIBS    Linker flags for libusb-1.0, overriding pkg-config
+  GPHOTO2_CFLAGS
+              C compiler flags for libgphoto2, overriding pkg-config
+  GPHOTO2_LIBS
+              Linker flags for libgphoto2, overriding pkg-config
+  GPHOTO2_PORT_CFLAGS
+              C compiler flags for libgphoto2_port, overriding pkg-config
+  GPHOTO2_PORT_LIBS
+              Linker flags for libgphoto2_port, overriding pkg-config
+  FREETYPE_CFLAGS
+              C compiler flags for freetype2, overriding pkg-config
+  FREETYPE_LIBS
+              Linker flags for freetype2, overriding pkg-config
+  PULSE_CFLAGS
+              C compiler flags for libpulse, overriding pkg-config
+  PULSE_LIBS  Linker flags for libpulse, overriding pkg-config
+  FFMPEG_CFLAGS
+              C compiler flags for libavutil libavformat libavcodec,
+              overriding pkg-config
+  FFMPEG_LIBS Linker flags for libavutil libavformat libavcodec, overriding
+              pkg-config
+  GSTREAMER_CFLAGS
+              C compiler flags for gstreamer-1.0 gstreamer-video-1.0
+              gstreamer-audio-1.0 gstreamer-tag-1.0, overriding pkg-config
+  GSTREAMER_LIBS
+              Linker flags for gstreamer-1.0 gstreamer-video-1.0
+              gstreamer-audio-1.0 gstreamer-tag-1.0, overriding pkg-config
+  ALSA_CFLAGS C compiler flags for alsa, overriding pkg-config
+  ALSA_LIBS   Linker flags for alsa, overriding pkg-config
+  UDEV_CFLAGS C compiler flags for libudev, overriding pkg-config
+  UDEV_LIBS   Linker flags for libudev, overriding pkg-config
+  UNWIND_CFLAGS
+              C compiler flags for libunwind, overriding pkg-config
+  UNWIND_LIBS Linker flags for libunwind, overriding pkg-config
+  SDL2_CFLAGS C compiler flags for sdl2, overriding pkg-config
+  SDL2_LIBS   Linker flags for sdl2, overriding pkg-config
+  CAPI20_CFLAGS
+              C compiler flags for capi20, overriding pkg-config
+  CAPI20_LIBS Linker flags for capi20, overriding pkg-config
+  CUPS_CFLAGS C compiler flags for cups, overriding pkg-config
+  CUPS_LIBS   Linker flags for cups, overriding pkg-config
+  FONTCONFIG_CFLAGS
+              C compiler flags for fontconfig, overriding pkg-config
+  FONTCONFIG_LIBS
+              Linker flags for fontconfig, overriding pkg-config
+  KRB5_CFLAGS C compiler flags for krb5, overriding pkg-config
+  KRB5_LIBS   Linker flags for krb5, overriding pkg-config
+  GSSAPI_CFLAGS
+              C compiler flags for krb5-gssapi, overriding pkg-config
+  GSSAPI_LIBS Linker flags for krb5-gssapi, overriding pkg-config
+  NETAPI_CFLAGS
+              C compiler flags for netapi, overriding pkg-config
+  NETAPI_LIBS Linker flags for netapi, overriding pkg-config
+
+Use these variables to override the choices made by 'configure' or to help
+it to find libraries and programs with nonstandard names/locations.
+
+Report bugs to <wine-devel@winehq.org>.
+Wine home page: <https://www.winehq.org>.
+_ACEOF
+ac_status=$?
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d "$ac_dir" ||
+      { cd "$srcdir" && ac_pwd=`pwd` && srcdir=. && test -d "$ac_dir"; } ||
+      continue
+    ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`printf "%s\n" "$ac_dir" | sed 's|^\.[\\/]||'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`printf "%s\n" "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+    cd "$ac_dir" || { ac_status=$?; continue; }
+    # Check for configure.gnu first; this name is used for a wrapper for
+    # Metaconfig's "Configure" on case-insensitive file systems.
+    if test -f "$ac_srcdir/configure.gnu"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure.gnu" --help=recursive
+    elif test -f "$ac_srcdir/configure"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure" --help=recursive
+    else
+      printf "%s\n" "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi || ac_status=$?
+    cd "$ac_pwd" || { ac_status=$?; break; }
+  done
+fi
+
+test -n "$ac_init_help" && exit $ac_status
+if $ac_init_version; then
+  cat <<\_ACEOF
+Wine configure 10.16
+generated by GNU Autoconf 2.72
+
+Copyright (C) 2023 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit
+fi
+
+## ------------------------ ##
+## Autoconf initialization. ##
+## ------------------------ ##
+
+# ac_fn_c_try_compile LINENO
+# --------------------------
+# Try to compile conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext conftest.beam
+  if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+printf "%s\n" "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext
+then :
+  ac_retval=0
+else case e in #(
+  e) printf "%s\n" "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1 ;;
+esac
+fi
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_compile
+
+# ac_fn_cxx_try_compile LINENO
+# ----------------------------
+# Try to compile conftest.$ac_ext, and return whether this succeeded.
+ac_fn_cxx_try_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext conftest.beam
+  if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+printf "%s\n" "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_cxx_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext
+then :
+  ac_retval=0
+else case e in #(
+  e) printf "%s\n" "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1 ;;
+esac
+fi
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
+
+} # ac_fn_cxx_try_compile
+
+# ac_fn_c_try_link LINENO
+# -----------------------
+# Try to link conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_link ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext conftest.beam conftest$ac_exeext
+  if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+printf "%s\n" "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 test -x conftest$ac_exeext
+       }
+then :
+  ac_retval=0
+else case e in #(
+  e) printf "%s\n" "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1 ;;
+esac
+fi
+  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information
+  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would
+  # interfere with the next link command; also delete a directory that is
+  # left behind by Apple's compiler.  We do this before executing the actions.
+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_link
+
+# ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES
+# -------------------------------------------------------
+# Tests whether HEADER exists and can be compiled using the include files in
+# INCLUDES, setting the cache variable VAR accordingly.
+ac_fn_c_check_header_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+printf %s "checking for $2... " >&6; }
+if eval test \${$3+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+#include <$2>
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  eval "$3=yes"
+else case e in #(
+  e) eval "$3=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;
+esac
+fi
+eval ac_res=\$$3
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+
+} # ac_fn_c_check_header_compile
+
+# ac_fn_objc_try_compile LINENO
+# -----------------------------
+# Try to compile conftest.$ac_ext, and return whether this succeeded.
+ac_fn_objc_try_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext conftest.beam
+  if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+printf "%s\n" "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_objc_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext
+then :
+  ac_retval=0
+else case e in #(
+  e) printf "%s\n" "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1 ;;
+esac
+fi
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
+
+} # ac_fn_objc_try_compile
+
+# ac_fn_c_check_func LINENO FUNC VAR
+# ----------------------------------
+# Tests whether FUNC exists, setting the cache variable VAR accordingly
+ac_fn_c_check_func ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+printf %s "checking for $2... " >&6; }
+if eval test \${$3+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+/* Define $2 to an innocuous variant, in case <limits.h> declares $2.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $2 innocuous_$2
+
+/* System header to define __stub macros and hopefully few prototypes,
+   which can conflict with char $2 (void); below.  */
+
+#include <limits.h>
+#undef $2
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $2 (void);
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$2 || defined __stub___$2
+choke me
+#endif
+
+int
+main (void)
+{
+return $2 ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$3=yes"
+else case e in #(
+  e) eval "$3=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext ;;
+esac
+fi
+eval ac_res=\$$3
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+
+} # ac_fn_c_check_func
+
+# ac_fn_c_try_cpp LINENO
+# ----------------------
+# Try to preprocess conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_cpp ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if { { ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+printf "%s\n" "$ac_try_echo"; } >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } > conftest.i && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }
+then :
+  ac_retval=0
+else case e in #(
+  e) printf "%s\n" "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+    ac_retval=1 ;;
+esac
+fi
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_cpp
+
+# ac_fn_c_check_member LINENO AGGR MEMBER VAR INCLUDES
+# ----------------------------------------------------
+# Tries to find if the field MEMBER exists in type AGGR, after including
+# INCLUDES, setting cache variable VAR accordingly.
+ac_fn_c_check_member ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $2.$3" >&5
+printf %s "checking for $2.$3... " >&6; }
+if eval test \${$4+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$5
+int
+main (void)
+{
+static $2 ac_aggr;
+if (ac_aggr.$3)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  eval "$4=yes"
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$5
+int
+main (void)
+{
+static $2 ac_aggr;
+if (sizeof ac_aggr.$3)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  eval "$4=yes"
+else case e in #(
+  e) eval "$4=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;
+esac
+fi
+eval ac_res=\$$4
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+
+} # ac_fn_c_check_member
+
+# ac_fn_c_check_type LINENO TYPE VAR INCLUDES
+# -------------------------------------------
+# Tests whether TYPE exists after having included INCLUDES, setting cache
+# variable VAR accordingly.
+ac_fn_c_check_type ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+printf %s "checking for $2... " >&6; }
+if eval test \${$3+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) eval "$3=no"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main (void)
+{
+if (sizeof ($2))
+	 return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+int
+main (void)
+{
+if (sizeof (($2)))
+	    return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+
+else case e in #(
+  e) eval "$3=yes" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;
+esac
+fi
+eval ac_res=\$$3
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+
+} # ac_fn_c_check_type
+ac_configure_args_raw=
+for ac_arg
+do
+  case $ac_arg in
+  *\'*)
+    ac_arg=`printf "%s\n" "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+  esac
+  as_fn_append ac_configure_args_raw " '$ac_arg'"
+done
+
+case $ac_configure_args_raw in
+  *$as_nl*)
+    ac_safe_unquote= ;;
+  *)
+    ac_unsafe_z='|&;<>()$`\\"*?[ ''	' # This string ends in space, tab.
+    ac_unsafe_a="$ac_unsafe_z#~"
+    ac_safe_unquote="s/ '\\([^$ac_unsafe_a][^$ac_unsafe_z]*\\)'/ \\1/g"
+    ac_configure_args_raw=`      printf "%s\n" "$ac_configure_args_raw" | sed "$ac_safe_unquote"`;;
+esac
+
+cat >config.log <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by Wine $as_me 10.16, which was
+generated by GNU Autoconf 2.72.  Invocation command line was
+
+  $ $0$ac_configure_args_raw
+
+_ACEOF
+exec 5>>config.log
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    printf "%s\n" "PATH: $as_dir"
+  done
+IFS=$as_save_IFS
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *\'*)
+      ac_arg=`printf "%s\n" "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) as_fn_append ac_configure_args0 " '$ac_arg'" ;;
+    2)
+      as_fn_append ac_configure_args1 " '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      as_fn_append ac_configure_args " '$ac_arg'"
+      ;;
+    esac
+  done
+done
+{ ac_configure_args0=; unset ac_configure_args0;}
+{ ac_configure_args1=; unset ac_configure_args1;}
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Use '\'' to represent an apostrophe within the trap.
+# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
+trap 'exit_status=$?
+  # Sanitize IFS.
+  IFS=" ""	$as_nl"
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    printf "%s\n" "## ---------------- ##
+## Cache variables. ##
+## ---------------- ##"
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+(
+  for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+printf "%s\n" "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) { eval $ac_var=; unset $ac_var;} ;;
+      esac ;;
+    esac
+  done
+  (set) 2>&1 |
+    case $as_nl`(ac_space='\'' '\''; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      sed -n \
+	"s/'\''/'\''\\\\'\'''\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\''\\2'\''/p"
+      ;; #(
+    *)
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+)
+    echo
+
+    printf "%s\n" "## ----------------- ##
+## Output variables. ##
+## ----------------- ##"
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=\$$ac_var
+      case $ac_val in
+      *\'\''*) ac_val=`printf "%s\n" "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+      esac
+      printf "%s\n" "$ac_var='\''$ac_val'\''"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      printf "%s\n" "## ------------------- ##
+## File substitutions. ##
+## ------------------- ##"
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=\$$ac_var
+	case $ac_val in
+	*\'\''*) ac_val=`printf "%s\n" "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+	esac
+	printf "%s\n" "$ac_var='\''$ac_val'\''"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      printf "%s\n" "## ----------- ##
+## confdefs.h. ##
+## ----------- ##"
+      echo
+      cat confdefs.h
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      printf "%s\n" "$as_me: caught signal $ac_signal"
+    printf "%s\n" "$as_me: exit $exit_status"
+  } >&5
+  rm -f core *.core core.conftest.* &&
+    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; as_fn_exit 1' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -f -r conftest* confdefs.h
+
+printf "%s\n" "/* confdefs.h */" > confdefs.h
+
+# Predefined preprocessor variables.
+
+printf "%s\n" "#define PACKAGE_NAME \"$PACKAGE_NAME\"" >>confdefs.h
+
+printf "%s\n" "#define PACKAGE_TARNAME \"$PACKAGE_TARNAME\"" >>confdefs.h
+
+printf "%s\n" "#define PACKAGE_VERSION \"$PACKAGE_VERSION\"" >>confdefs.h
+
+printf "%s\n" "#define PACKAGE_STRING \"$PACKAGE_STRING\"" >>confdefs.h
+
+printf "%s\n" "#define PACKAGE_BUGREPORT \"$PACKAGE_BUGREPORT\"" >>confdefs.h
+
+printf "%s\n" "#define PACKAGE_URL \"$PACKAGE_URL\"" >>confdefs.h
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer an explicitly selected file to automatically selected ones.
+if test -n "$CONFIG_SITE"; then
+  ac_site_files="$CONFIG_SITE"
+elif test "x$prefix" != xNONE; then
+  ac_site_files="$prefix/share/config.site $prefix/etc/config.site"
+else
+  ac_site_files="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
+fi
+
+for ac_site_file in $ac_site_files
+do
+  case $ac_site_file in #(
+  */*) :
+     ;; #(
+  *) :
+    ac_site_file=./$ac_site_file ;;
+esac
+  if test -f "$ac_site_file" && test -r "$ac_site_file"; then
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
+printf "%s\n" "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file" \
+      || { { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in '$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in '$ac_pwd':" >&2;}
+as_fn_error $? "failed to load site script $ac_site_file
+See 'config.log' for more details" "$LINENO" 5; }
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special files
+  # actually), so we avoid doing that.  DJGPP emulates it as a regular file.
+  if test /dev/null != "$cache_file" && test -f "$cache_file"; then
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: loading cache $cache_file" >&5
+printf "%s\n" "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . "$cache_file";;
+      *)                      . "./$cache_file";;
+    esac
+  fi
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: creating cache $cache_file" >&5
+printf "%s\n" "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Test code for whether the C compiler supports C89 (global declarations)
+ac_c_conftest_c89_globals='
+/* Does the compiler advertise C89 conformance?
+   Do not test the value of __STDC__, because some compilers set it to 0
+   while being otherwise adequately conformant. */
+#if !defined __STDC__
+# error "Compiler does not advertise C89 conformance"
+#endif
+
+#include <stddef.h>
+#include <stdarg.h>
+struct stat;
+/* Most of the following tests are stolen from RCS 5.7 src/conf.sh.  */
+struct buf { int x; };
+struct buf * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (char **p, int i)
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* C89 style stringification. */
+#define noexpand_stringify(a) #a
+const char *stringified = noexpand_stringify(arbitrary+token=sequence);
+
+/* C89 style token pasting.  Exercises some of the corner cases that
+   e.g. old MSVC gets wrong, but not very hard. */
+#define noexpand_concat(a,b) a##b
+#define expand_concat(a,b) noexpand_concat(a,b)
+extern int vA;
+extern int vbee;
+#define aye A
+#define bee B
+int *pvA = &expand_concat(v,aye);
+int *pvbee = &noexpand_concat(v,bee);
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not \xHH hex character constants.
+   These do not provoke an error unfortunately, instead are silently treated
+   as an "x".  The following induces an error, until -std is added to get
+   proper ANSI mode.  Curiously \x00 != x always comes out true, for an
+   array size at least.  It is necessary to write \x00 == 0 to get something
+   that is true only with -std.  */
+int osf4_cc_array ['\''\x00'\'' == 0 ? 1 : -1];
+
+/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
+   inside strings and character constants.  */
+#define FOO(x) '\''x'\''
+int xlc6_cc_array[FOO(a) == '\''x'\'' ? 1 : -1];
+
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, int *(*)(struct buf *, struct stat *, int),
+               int, int);'
+
+# Test code for whether the C compiler supports C89 (body of main).
+ac_c_conftest_c89_main='
+ok |= (argc == 0 || f (e, argv, 0) != argv[0] || f (e, argv, 1) != argv[1]);
+'
+
+# Test code for whether the C compiler supports C99 (global declarations)
+ac_c_conftest_c99_globals='
+/* Does the compiler advertise C99 conformance? */
+#if !defined __STDC_VERSION__ || __STDC_VERSION__ < 199901L
+# error "Compiler does not advertise C99 conformance"
+#endif
+
+// See if C++-style comments work.
+
+#include <stdbool.h>
+extern int puts (const char *);
+extern int printf (const char *, ...);
+extern int dprintf (int, const char *, ...);
+extern void *malloc (size_t);
+extern void free (void *);
+
+// Check varargs macros.  These examples are taken from C99 6.10.3.5.
+// dprintf is used instead of fprintf to avoid needing to declare
+// FILE and stderr.
+#define debug(...) dprintf (2, __VA_ARGS__)
+#define showlist(...) puts (#__VA_ARGS__)
+#define report(test,...) ((test) ? puts (#test) : printf (__VA_ARGS__))
+static void
+test_varargs_macros (void)
+{
+  int x = 1234;
+  int y = 5678;
+  debug ("Flag");
+  debug ("X = %d\n", x);
+  showlist (The first, second, and third items.);
+  report (x>y, "x is %d but y is %d", x, y);
+}
+
+// Check long long types.
+#define BIG64 18446744073709551615ull
+#define BIG32 4294967295ul
+#define BIG_OK (BIG64 / BIG32 == 4294967297ull && BIG64 % BIG32 == 0)
+#if !BIG_OK
+  #error "your preprocessor is broken"
+#endif
+#if BIG_OK
+#else
+  #error "your preprocessor is broken"
+#endif
+static long long int bignum = -9223372036854775807LL;
+static unsigned long long int ubignum = BIG64;
+
+struct incomplete_array
+{
+  int datasize;
+  double data[];
+};
+
+struct named_init {
+  int number;
+  const wchar_t *name;
+  double average;
+};
+
+typedef const char *ccp;
+
+static inline int
+test_restrict (ccp restrict text)
+{
+  // Iterate through items via the restricted pointer.
+  // Also check for declarations in for loops.
+  for (unsigned int i = 0; *(text+i) != '\''\0'\''; ++i)
+    continue;
+  return 0;
+}
+
+// Check varargs and va_copy.
+static bool
+test_varargs (const char *format, ...)
+{
+  va_list args;
+  va_start (args, format);
+  va_list args_copy;
+  va_copy (args_copy, args);
+
+  const char *str = "";
+  int number = 0;
+  float fnumber = 0;
+
+  while (*format)
+    {
+      switch (*format++)
+	{
+	case '\''s'\'': // string
+	  str = va_arg (args_copy, const char *);
+	  break;
+	case '\''d'\'': // int
+	  number = va_arg (args_copy, int);
+	  break;
+	case '\''f'\'': // float
+	  fnumber = va_arg (args_copy, double);
+	  break;
+	default:
+	  break;
+	}
+    }
+  va_end (args_copy);
+  va_end (args);
+
+  return *str && number && fnumber;
+}
+'
+
+# Test code for whether the C compiler supports C99 (body of main).
+ac_c_conftest_c99_main='
+  // Check bool.
+  _Bool success = false;
+  success |= (argc != 0);
+
+  // Check restrict.
+  if (test_restrict ("String literal") == 0)
+    success = true;
+  char *restrict newvar = "Another string";
+
+  // Check varargs.
+  success &= test_varargs ("s, d'\'' f .", "string", 65, 34.234);
+  test_varargs_macros ();
+
+  // Check flexible array members.
+  struct incomplete_array *ia =
+    malloc (sizeof (struct incomplete_array) + (sizeof (double) * 10));
+  ia->datasize = 10;
+  for (int i = 0; i < ia->datasize; ++i)
+    ia->data[i] = i * 1.234;
+  // Work around memory leak warnings.
+  free (ia);
+
+  // Check named initializers.
+  struct named_init ni = {
+    .number = 34,
+    .name = L"Test wide string",
+    .average = 543.34343,
+  };
+
+  ni.number = 58;
+
+  int dynamic_array[ni.number];
+  dynamic_array[0] = argv[0][0];
+  dynamic_array[ni.number - 1] = 543;
+
+  // work around unused variable warnings
+  ok |= (!success || bignum == 0LL || ubignum == 0uLL || newvar[0] == '\''x'\''
+	 || dynamic_array[ni.number - 1] != 543);
+'
+
+# Test code for whether the C compiler supports C11 (global declarations)
+ac_c_conftest_c11_globals='
+/* Does the compiler advertise C11 conformance? */
+#if !defined __STDC_VERSION__ || __STDC_VERSION__ < 201112L
+# error "Compiler does not advertise C11 conformance"
+#endif
+
+// Check _Alignas.
+char _Alignas (double) aligned_as_double;
+char _Alignas (0) no_special_alignment;
+extern char aligned_as_int;
+char _Alignas (0) _Alignas (int) aligned_as_int;
+
+// Check _Alignof.
+enum
+{
+  int_alignment = _Alignof (int),
+  int_array_alignment = _Alignof (int[100]),
+  char_alignment = _Alignof (char)
+};
+_Static_assert (0 < -_Alignof (int), "_Alignof is signed");
+
+// Check _Noreturn.
+int _Noreturn does_not_return (void) { for (;;) continue; }
+
+// Check _Static_assert.
+struct test_static_assert
+{
+  int x;
+  _Static_assert (sizeof (int) <= sizeof (long int),
+                  "_Static_assert does not work in struct");
+  long int y;
+};
+
+// Check UTF-8 literals.
+#define u8 syntax error!
+char const utf8_literal[] = u8"happens to be ASCII" "another string";
+
+// Check duplicate typedefs.
+typedef long *long_ptr;
+typedef long int *long_ptr;
+typedef long_ptr long_ptr;
+
+// Anonymous structures and unions -- taken from C11 6.7.2.1 Example 1.
+struct anonymous
+{
+  union {
+    struct { int i; int j; };
+    struct { int k; long int l; } w;
+  };
+  int m;
+} v1;
+'
+
+# Test code for whether the C compiler supports C11 (body of main).
+ac_c_conftest_c11_main='
+  _Static_assert ((offsetof (struct anonymous, i)
+		   == offsetof (struct anonymous, w.k)),
+		  "Anonymous union alignment botch");
+  v1.i = 2;
+  v1.w.k = 5;
+  ok |= v1.i != 5;
+'
+
+# Test code for whether the C compiler supports C11 (complete).
+ac_c_conftest_c11_program="${ac_c_conftest_c89_globals}
+${ac_c_conftest_c99_globals}
+${ac_c_conftest_c11_globals}
+
+int
+main (int argc, char **argv)
+{
+  int ok = 0;
+  ${ac_c_conftest_c89_main}
+  ${ac_c_conftest_c99_main}
+  ${ac_c_conftest_c11_main}
+  return ok;
+}
+"
+
+# Test code for whether the C compiler supports C99 (complete).
+ac_c_conftest_c99_program="${ac_c_conftest_c89_globals}
+${ac_c_conftest_c99_globals}
+
+int
+main (int argc, char **argv)
+{
+  int ok = 0;
+  ${ac_c_conftest_c89_main}
+  ${ac_c_conftest_c99_main}
+  return ok;
+}
+"
+
+# Test code for whether the C compiler supports C89 (complete).
+ac_c_conftest_c89_program="${ac_c_conftest_c89_globals}
+
+int
+main (int argc, char **argv)
+{
+  int ok = 0;
+  ${ac_c_conftest_c89_main}
+  return ok;
+}
+"
+
+# Test code for whether the C++ compiler supports C++98 (global declarations)
+ac_cxx_conftest_cxx98_globals='
+// Does the compiler advertise C++98 conformance?
+#if !defined __cplusplus || __cplusplus < 199711L
+# error "Compiler does not advertise C++98 conformance"
+#endif
+
+// These inclusions are to reject old compilers that
+// lack the unsuffixed header files.
+#include <cstdlib>
+#include <exception>
+
+// <cassert> and <cstring> are *not* freestanding headers in C++98.
+extern void assert (int);
+namespace std {
+  extern int strcmp (const char *, const char *);
+}
+
+// Namespaces, exceptions, and templates were all added after "C++ 2.0".
+using std::exception;
+using std::strcmp;
+
+namespace {
+
+void test_exception_syntax()
+{
+  try {
+    throw "test";
+  } catch (const char *s) {
+    // Extra parentheses suppress a warning when building autoconf itself,
+    // due to lint rules shared with more typical C programs.
+    assert (!(strcmp) (s, "test"));
+  }
+}
+
+template <typename T> struct test_template
+{
+  T const val;
+  explicit test_template(T t) : val(t) {}
+  template <typename U> T add(U u) { return static_cast<T>(u) + val; }
+};
+
+} // anonymous namespace
+'
+
+# Test code for whether the C++ compiler supports C++98 (body of main)
+ac_cxx_conftest_cxx98_main='
+  assert (argc);
+  assert (! argv[0]);
+{
+  test_exception_syntax ();
+  test_template<double> tt (2.0);
+  assert (tt.add (4) == 6.0);
+  assert (true && !false);
+}
+'
+
+# Test code for whether the C++ compiler supports C++11 (global declarations)
+ac_cxx_conftest_cxx11_globals='
+// Does the compiler advertise C++ 2011 conformance?
+#if !defined __cplusplus || __cplusplus < 201103L
+# error "Compiler does not advertise C++11 conformance"
+#endif
+
+namespace cxx11test
+{
+  constexpr int get_val() { return 20; }
+
+  struct testinit
+  {
+    int i;
+    double d;
+  };
+
+  class delegate
+  {
+  public:
+    delegate(int n) : n(n) {}
+    delegate(): delegate(2354) {}
+
+    virtual int getval() { return this->n; };
+  protected:
+    int n;
+  };
+
+  class overridden : public delegate
+  {
+  public:
+    overridden(int n): delegate(n) {}
+    virtual int getval() override final { return this->n * 2; }
+  };
+
+  class nocopy
+  {
+  public:
+    nocopy(int i): i(i) {}
+    nocopy() = default;
+    nocopy(const nocopy&) = delete;
+    nocopy & operator=(const nocopy&) = delete;
+  private:
+    int i;
+  };
+
+  // for testing lambda expressions
+  template <typename Ret, typename Fn> Ret eval(Fn f, Ret v)
+  {
+    return f(v);
+  }
+
+  // for testing variadic templates and trailing return types
+  template <typename V> auto sum(V first) -> V
+  {
+    return first;
+  }
+  template <typename V, typename... Args> auto sum(V first, Args... rest) -> V
+  {
+    return first + sum(rest...);
+  }
+}
+'
+
+# Test code for whether the C++ compiler supports C++11 (body of main)
+ac_cxx_conftest_cxx11_main='
+{
+  // Test auto and decltype
+  auto a1 = 6538;
+  auto a2 = 48573953.4;
+  auto a3 = "String literal";
+
+  int total = 0;
+  for (auto i = a3; *i; ++i) { total += *i; }
+
+  decltype(a2) a4 = 34895.034;
+}
+{
+  // Test constexpr
+  short sa[cxx11test::get_val()] = { 0 };
+}
+{
+  // Test initializer lists
+  cxx11test::testinit il = { 4323, 435234.23544 };
+}
+{
+  // Test range-based for
+  int array[] = {9, 7, 13, 15, 4, 18, 12, 10, 5, 3,
+                 14, 19, 17, 8, 6, 20, 16, 2, 11, 1};
+  for (auto &x : array) { x += 23; }
+}
+{
+  // Test lambda expressions
+  using cxx11test::eval;
+  assert (eval ([](int x) { return x*2; }, 21) == 42);
+  double d = 2.0;
+  assert (eval ([&](double x) { return d += x; }, 3.0) == 5.0);
+  assert (d == 5.0);
+  assert (eval ([=](double x) mutable { return d += x; }, 4.0) == 9.0);
+  assert (d == 5.0);
+}
+{
+  // Test use of variadic templates
+  using cxx11test::sum;
+  auto a = sum(1);
+  auto b = sum(1, 2);
+  auto c = sum(1.0, 2.0, 3.0);
+}
+{
+  // Test constructor delegation
+  cxx11test::delegate d1;
+  cxx11test::delegate d2();
+  cxx11test::delegate d3(45);
+}
+{
+  // Test override and final
+  cxx11test::overridden o1(55464);
+}
+{
+  // Test nullptr
+  char *c = nullptr;
+}
+{
+  // Test template brackets
+  test_template<::test_template<int>> v(test_template<int>(12));
+}
+{
+  // Unicode literals
+  char const *utf8 = u8"UTF-8 string \u2500";
+  char16_t const *utf16 = u"UTF-8 string \u2500";
+  char32_t const *utf32 = U"UTF-32 string \u2500";
+}
+'
+
+# Test code for whether the C compiler supports C++11 (complete).
+ac_cxx_conftest_cxx11_program="${ac_cxx_conftest_cxx98_globals}
+${ac_cxx_conftest_cxx11_globals}
+
+int
+main (int argc, char **argv)
+{
+  int ok = 0;
+  ${ac_cxx_conftest_cxx98_main}
+  ${ac_cxx_conftest_cxx11_main}
+  return ok;
+}
+"
+
+# Test code for whether the C compiler supports C++98 (complete).
+ac_cxx_conftest_cxx98_program="${ac_cxx_conftest_cxx98_globals}
+int
+main (int argc, char **argv)
+{
+  int ok = 0;
+  ${ac_cxx_conftest_cxx98_main}
+  return ok;
+}
+"
+
+as_fn_append ac_header_c_list " stdio.h stdio_h HAVE_STDIO_H"
+as_fn_append ac_header_c_list " stdlib.h stdlib_h HAVE_STDLIB_H"
+as_fn_append ac_header_c_list " string.h string_h HAVE_STRING_H"
+as_fn_append ac_header_c_list " inttypes.h inttypes_h HAVE_INTTYPES_H"
+as_fn_append ac_header_c_list " stdint.h stdint_h HAVE_STDINT_H"
+as_fn_append ac_header_c_list " strings.h strings_h HAVE_STRINGS_H"
+as_fn_append ac_header_c_list " sys/stat.h sys_stat_h HAVE_SYS_STAT_H"
+as_fn_append ac_header_c_list " sys/types.h sys_types_h HAVE_SYS_TYPES_H"
+as_fn_append ac_header_c_list " unistd.h unistd_h HAVE_UNISTD_H"
+
+# Auxiliary files required by this configure script.
+ac_aux_files="config.guess config.sub"
+
+# Locations in which to look for auxiliary files.
+ac_aux_dir_candidates="${srcdir}/tools"
+
+# Search for a directory containing all of the required auxiliary files,
+# $ac_aux_files, from the $PATH-style list $ac_aux_dir_candidates.
+# If we don't find one directory that contains all the files we need,
+# we report the set of missing files from the *first* directory in
+# $ac_aux_dir_candidates and give up.
+ac_missing_aux_files=""
+ac_first_candidate=:
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: looking for aux files: $ac_aux_files" >&5
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+as_found=false
+for as_dir in $ac_aux_dir_candidates
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+  as_found=:
+
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}:  trying $as_dir" >&5
+  ac_aux_dir_found=yes
+  ac_install_sh=
+  for ac_aux in $ac_aux_files
+  do
+    # As a special case, if "install-sh" is required, that requirement
+    # can be satisfied by any of "install-sh", "install.sh", or "shtool",
+    # and $ac_install_sh is set appropriately for whichever one is found.
+    if test x"$ac_aux" = x"install-sh"
+    then
+      if test -f "${as_dir}install-sh"; then
+        printf "%s\n" "$as_me:${as_lineno-$LINENO}:   ${as_dir}install-sh found" >&5
+        ac_install_sh="${as_dir}install-sh -c"
+      elif test -f "${as_dir}install.sh"; then
+        printf "%s\n" "$as_me:${as_lineno-$LINENO}:   ${as_dir}install.sh found" >&5
+        ac_install_sh="${as_dir}install.sh -c"
+      elif test -f "${as_dir}shtool"; then
+        printf "%s\n" "$as_me:${as_lineno-$LINENO}:   ${as_dir}shtool found" >&5
+        ac_install_sh="${as_dir}shtool install -c"
+      else
+        ac_aux_dir_found=no
+        if $ac_first_candidate; then
+          ac_missing_aux_files="${ac_missing_aux_files} install-sh"
+        else
+          break
+        fi
+      fi
+    else
+      if test -f "${as_dir}${ac_aux}"; then
+        printf "%s\n" "$as_me:${as_lineno-$LINENO}:   ${as_dir}${ac_aux} found" >&5
+      else
+        ac_aux_dir_found=no
+        if $ac_first_candidate; then
+          ac_missing_aux_files="${ac_missing_aux_files} ${ac_aux}"
+        else
+          break
+        fi
+      fi
+    fi
+  done
+  if test "$ac_aux_dir_found" = yes; then
+    ac_aux_dir="$as_dir"
+    break
+  fi
+  ac_first_candidate=false
+
+  as_found=false
+done
+IFS=$as_save_IFS
+if $as_found
+then :
+
+else case e in #(
+  e) as_fn_error $? "cannot find required auxiliary files:$ac_missing_aux_files" "$LINENO" 5 ;;
+esac
+fi
+
+
+# These three variables are undocumented and unsupported,
+# and are intended to be withdrawn in a future Autoconf release.
+# They can cause serious problems if a builder's source tree is in a directory
+# whose full name contains unusual characters.
+if test -f "${ac_aux_dir}config.guess"; then
+  ac_config_guess="$SHELL ${ac_aux_dir}config.guess"
+fi
+if test -f "${ac_aux_dir}config.sub"; then
+  ac_config_sub="$SHELL ${ac_aux_dir}config.sub"
+fi
+if test -f "$ac_aux_dir/configure"; then
+  ac_configure="$SHELL ${ac_aux_dir}configure"
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in $ac_precious_vars; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val=\$ac_cv_env_${ac_var}_value
+  eval ac_new_val=\$ac_env_${ac_var}_value
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: '$ac_var' was set to '$ac_old_val' in the previous run" >&5
+printf "%s\n" "$as_me: error: '$ac_var' was set to '$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: '$ac_var' was not set in the previous run" >&5
+printf "%s\n" "$as_me: error: '$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	# differences in whitespace do not lead to failure.
+	ac_old_val_w=`echo x $ac_old_val`
+	ac_new_val_w=`echo x $ac_new_val`
+	if test "$ac_old_val_w" != "$ac_new_val_w"; then
+	  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: '$ac_var' has changed since the previous run:" >&5
+printf "%s\n" "$as_me: error: '$ac_var' has changed since the previous run:" >&2;}
+	  ac_cache_corrupted=:
+	else
+	  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in '$ac_var' since the previous run:" >&5
+printf "%s\n" "$as_me: warning: ignoring whitespace changes in '$ac_var' since the previous run:" >&2;}
+	  eval $ac_var=\$ac_old_val
+	fi
+	{ printf "%s\n" "$as_me:${as_lineno-$LINENO}:   former value:  '$ac_old_val'" >&5
+printf "%s\n" "$as_me:   former value:  '$ac_old_val'" >&2;}
+	{ printf "%s\n" "$as_me:${as_lineno-$LINENO}:   current value: '$ac_new_val'" >&5
+printf "%s\n" "$as_me:   current value: '$ac_new_val'" >&2;}
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *\'*) ac_arg=$ac_var=`printf "%s\n" "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) as_fn_append ac_configure_args " '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in '$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in '$ac_pwd':" >&2;}
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
+printf "%s\n" "$as_me: error: changes in the environment can compromise the build" >&2;}
+  as_fn_error $? "run '${MAKE-make} distclean' and/or 'rm $cache_file'
+	    and start over" "$LINENO" 5
+fi
+## -------------------- ##
+## Main body of script. ##
+## -------------------- ##
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+ac_config_headers="$ac_config_headers include/config.h"
+
+
+
+libwine_version="1.0"
+
+
+# Check whether --enable-archs was given.
+if test ${enable_archs+y}
+then :
+  enableval=$enable_archs;
+fi
+
+# Check whether --enable-win16 was given.
+if test ${enable_win16+y}
+then :
+  enableval=$enable_win16;
+fi
+
+# Check whether --enable-win64 was given.
+if test ${enable_win64+y}
+then :
+  enableval=$enable_win64;
+fi
+
+# Check whether --enable-tests was given.
+if test ${enable_tests+y}
+then :
+  enableval=$enable_tests;
+fi
+
+# Check whether --enable-build-id was given.
+if test ${enable_build_id+y}
+then :
+  enableval=$enable_build_id;
+fi
+
+# Check whether --enable-maintainer-mode was given.
+if test ${enable_maintainer_mode+y}
+then :
+  enableval=$enable_maintainer_mode;
+fi
+
+# Check whether --enable-sast was given.
+if test ${enable_sast+y}
+then :
+  enableval=$enable_sast;
+fi
+
+# Check whether --enable-silent-rules was given.
+if test ${enable_silent_rules+y}
+then :
+  enableval=$enable_silent_rules;
+fi
+
+# Check whether --enable-werror was given.
+if test ${enable_werror+y}
+then :
+  enableval=$enable_werror;
+fi
+
+
+
+# Check whether --with-alsa was given.
+if test ${with_alsa+y}
+then :
+  withval=$with_alsa;
+fi
+
+
+# Check whether --with-capi was given.
+if test ${with_capi+y}
+then :
+  withval=$with_capi;
+fi
+
+
+# Check whether --with-coreaudio was given.
+if test ${with_coreaudio+y}
+then :
+  withval=$with_coreaudio;
+fi
+
+
+# Check whether --with-cups was given.
+if test ${with_cups+y}
+then :
+  withval=$with_cups;
+fi
+
+
+# Check whether --with-dbus was given.
+if test ${with_dbus+y}
+then :
+  withval=$with_dbus;
+fi
+
+
+# Check whether --with-ffmpeg was given.
+if test ${with_ffmpeg+y}
+then :
+  withval=$with_ffmpeg;
+fi
+
+
+# Check whether --with-fontconfig was given.
+if test ${with_fontconfig+y}
+then :
+  withval=$with_fontconfig;
+fi
+
+
+# Check whether --with-freetype was given.
+if test ${with_freetype+y}
+then :
+  withval=$with_freetype;
+fi
+
+
+# Check whether --with-gettext was given.
+if test ${with_gettext+y}
+then :
+  withval=$with_gettext;
+fi
+
+
+# Check whether --with-gettextpo was given.
+if test ${with_gettextpo+y}
+then :
+  withval=$with_gettextpo; if test "x$withval" = "xno"; then ac_cv_header_gettext_po_h=no; fi
+fi
+
+
+# Check whether --with-gphoto was given.
+if test ${with_gphoto+y}
+then :
+  withval=$with_gphoto;
+fi
+
+
+# Check whether --with-gnutls was given.
+if test ${with_gnutls+y}
+then :
+  withval=$with_gnutls;
+fi
+
+
+# Check whether --with-gssapi was given.
+if test ${with_gssapi+y}
+then :
+  withval=$with_gssapi;
+fi
+
+
+# Check whether --with-gstreamer was given.
+if test ${with_gstreamer+y}
+then :
+  withval=$with_gstreamer;
+fi
+
+
+# Check whether --with-inotify was given.
+if test ${with_inotify+y}
+then :
+  withval=$with_inotify;
+fi
+
+
+# Check whether --with-krb5 was given.
+if test ${with_krb5+y}
+then :
+  withval=$with_krb5;
+fi
+
+
+# Check whether --with-mingw was given.
+if test ${with_mingw+y}
+then :
+  withval=$with_mingw;
+fi
+
+
+# Check whether --with-netapi was given.
+if test ${with_netapi+y}
+then :
+  withval=$with_netapi;
+fi
+
+
+# Check whether --with-opencl was given.
+if test ${with_opencl+y}
+then :
+  withval=$with_opencl; if test "x$withval" = "xno"; then ac_cv_header_CL_cl_h=no; ac_cv_header_OpenCL_opencl_h=no; fi
+fi
+
+
+# Check whether --with-opengl was given.
+if test ${with_opengl+y}
+then :
+  withval=$with_opengl;
+fi
+
+
+# Check whether --with-oss was given.
+if test ${with_oss+y}
+then :
+  withval=$with_oss;
+fi
+
+
+# Check whether --with-pcap was given.
+if test ${with_pcap+y}
+then :
+  withval=$with_pcap; if test "x$withval" = "xno"; then ac_cv_header_pcap_pcap_h=no; fi
+fi
+
+
+# Check whether --with-pcsclite was given.
+if test ${with_pcsclite+y}
+then :
+  withval=$with_pcsclite;
+fi
+
+
+# Check whether --with-pthread was given.
+if test ${with_pthread+y}
+then :
+  withval=$with_pthread;
+fi
+
+
+# Check whether --with-pulse was given.
+if test ${with_pulse+y}
+then :
+  withval=$with_pulse;
+fi
+
+
+# Check whether --with-sane was given.
+if test ${with_sane+y}
+then :
+  withval=$with_sane;
+fi
+
+
+# Check whether --with-sdl was given.
+if test ${with_sdl+y}
+then :
+  withval=$with_sdl;
+fi
+
+
+# Check whether --with-udev was given.
+if test ${with_udev+y}
+then :
+  withval=$with_udev;
+fi
+
+
+# Check whether --with-unwind was given.
+if test ${with_unwind+y}
+then :
+  withval=$with_unwind;
+fi
+
+
+# Check whether --with-usb was given.
+if test ${with_usb+y}
+then :
+  withval=$with_usb;
+fi
+
+
+# Check whether --with-v4l2 was given.
+if test ${with_v4l2+y}
+then :
+  withval=$with_v4l2;
+fi
+
+
+# Check whether --with-vulkan was given.
+if test ${with_vulkan+y}
+then :
+  withval=$with_vulkan;
+fi
+
+
+# Check whether --with-wayland was given.
+if test ${with_wayland+y}
+then :
+  withval=$with_wayland;
+fi
+
+
+# Check whether --with-xcomposite was given.
+if test ${with_xcomposite+y}
+then :
+  withval=$with_xcomposite; if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xcomposite_h=no; fi
+fi
+
+
+# Check whether --with-xcursor was given.
+if test ${with_xcursor+y}
+then :
+  withval=$with_xcursor; if test "x$withval" = "xno"; then ac_cv_header_X11_Xcursor_Xcursor_h=no; fi
+fi
+
+
+# Check whether --with-xfixes was given.
+if test ${with_xfixes+y}
+then :
+  withval=$with_xfixes; if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xfixes_h=no; fi
+fi
+
+
+# Check whether --with-xinerama was given.
+if test ${with_xinerama+y}
+then :
+  withval=$with_xinerama; if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xinerama_h=no; fi
+fi
+
+
+# Check whether --with-xinput was given.
+if test ${with_xinput+y}
+then :
+  withval=$with_xinput; if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_XInput_h=no; fi
+fi
+
+
+# Check whether --with-xinput2 was given.
+if test ${with_xinput2+y}
+then :
+  withval=$with_xinput2; if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_XInput2_h=no; fi
+fi
+
+
+# Check whether --with-xrandr was given.
+if test ${with_xrandr+y}
+then :
+  withval=$with_xrandr; if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xrandr_h=no; fi
+fi
+
+
+# Check whether --with-xrender was given.
+if test ${with_xrender+y}
+then :
+  withval=$with_xrender; if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xrender_h=no; fi
+fi
+
+
+# Check whether --with-xshape was given.
+if test ${with_xshape+y}
+then :
+  withval=$with_xshape; if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_shape_h=no; fi
+fi
+
+
+# Check whether --with-xshm was given.
+if test ${with_xshm+y}
+then :
+  withval=$with_xshm; if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_XShm_h=no; fi
+fi
+
+
+# Check whether --with-xxf86vm was given.
+if test ${with_xxf86vm+y}
+then :
+  withval=$with_xxf86vm; if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_xf86vmode_h=no; ac_cv_header_X11_extensions_xf86vmproto_h=no; fi
+fi
+
+
+
+# Check whether --with-system-dllpath was given.
+if test ${with_system_dllpath+y}
+then :
+  withval=$with_system_dllpath; system_dllpath=$withval
+
+fi
+
+
+# Check whether --with-wine-tools was given.
+if test ${with_wine_tools+y}
+then :
+  withval=$with_wine_tools;
+fi
+
+
+# Check whether --with-wine64 was given.
+if test ${with_wine64+y}
+then :
+  withval=$with_wine64;
+fi
+
+
+
+
+
+  # Make sure we can run config.sub.
+$SHELL "${ac_aux_dir}config.sub" sun4 >/dev/null 2>&1 ||
+  as_fn_error $? "cannot run $SHELL ${ac_aux_dir}config.sub" "$LINENO" 5
+
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
+printf %s "checking build system type... " >&6; }
+if test ${ac_cv_build+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_build_alias=$build_alias
+test "x$ac_build_alias" = x &&
+  ac_build_alias=`$SHELL "${ac_aux_dir}config.guess"`
+test "x$ac_build_alias" = x &&
+  as_fn_error $? "cannot guess build type; you must specify one" "$LINENO" 5
+ac_cv_build=`$SHELL "${ac_aux_dir}config.sub" $ac_build_alias` ||
+  as_fn_error $? "$SHELL ${ac_aux_dir}config.sub $ac_build_alias failed" "$LINENO" 5
+ ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_build" >&5
+printf "%s\n" "$ac_cv_build" >&6; }
+case $ac_cv_build in
+*-*-*) ;;
+*) as_fn_error $? "invalid value of canonical build" "$LINENO" 5;;
+esac
+build=$ac_cv_build
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_build
+shift
+build_cpu=$1
+build_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+build_os=$*
+IFS=$ac_save_IFS
+case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
+
+
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking host system type" >&5
+printf %s "checking host system type... " >&6; }
+if test ${ac_cv_host+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test "x$host_alias" = x; then
+  ac_cv_host=$ac_cv_build
+else
+  ac_cv_host=`$SHELL "${ac_aux_dir}config.sub" $host_alias` ||
+    as_fn_error $? "$SHELL ${ac_aux_dir}config.sub $host_alias failed" "$LINENO" 5
+fi
+ ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_host" >&5
+printf "%s\n" "$ac_cv_host" >&6; }
+case $ac_cv_host in
+*-*-*) ;;
+*) as_fn_error $? "invalid value of canonical host" "$LINENO" 5;;
+esac
+host=$ac_cv_host
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_host
+shift
+host_cpu=$1
+host_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+host_os=$*
+IFS=$ac_save_IFS
+case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
+
+
+
+
+if test "x$enable_sast" = xyes
+then :
+  CC=${CC:-clang}
+with_mingw=${with_mingw:-clang}
+for ac_prog in sarif-converter
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_SARIF_CONVERTER+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$SARIF_CONVERTER"; then
+  ac_cv_prog_SARIF_CONVERTER="$SARIF_CONVERTER" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_SARIF_CONVERTER="$ac_prog"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+SARIF_CONVERTER=$ac_cv_prog_SARIF_CONVERTER
+if test -n "$SARIF_CONVERTER"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $SARIF_CONVERTER" >&5
+printf "%s\n" "$SARIF_CONVERTER" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+  test -n "$SARIF_CONVERTER" && break
+done
+test -n "$SARIF_CONVERTER" || SARIF_CONVERTER="false"
+
+fi
+
+
+
+
+
+
+
+
+
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CC+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+printf "%s\n" "$CC" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_CC+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="gcc"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+printf "%s\n" "$ac_ct_CC" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+if test -z "$CC"; then
+          if test -n "$ac_tool_prefix"; then
+    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CC+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}cc"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+printf "%s\n" "$CC" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+  fi
+fi
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CC+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    if test "$as_dir$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir$ac_word${1+' '}$@"
+  fi
+fi
+fi ;;
+esac
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+printf "%s\n" "$CC" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in cl.exe
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CC+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+printf "%s\n" "$CC" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+    test -n "$CC" && break
+  done
+fi
+if test -z "$CC"; then
+  ac_ct_CC=$CC
+  for ac_prog in cl.exe
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_CC+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="$ac_prog"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+printf "%s\n" "$ac_ct_CC" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_CC" && break
+done
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+fi
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}clang", so it can be a program name with args.
+set dummy ${ac_tool_prefix}clang; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CC+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}clang"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+printf "%s\n" "$CC" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "clang", so it can be a program name with args.
+set dummy clang; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_CC+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="clang"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+printf "%s\n" "$ac_ct_CC" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+fi
+
+
+test -z "$CC" && { { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in '$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in '$ac_pwd':" >&2;}
+as_fn_error $? "no acceptable C compiler found in \$PATH
+See 'config.log' for more details" "$LINENO" 5; }
+
+# Provide some information about the compiler.
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+for ac_option in --version -v -V -qversion -version; do
+  { { ac_try="$ac_compiler $ac_option >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+printf "%s\n" "$ac_try_echo"; } >&5
+  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    sed '10a\
+... rest of stderr output deleted ...
+         10q' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+  fi
+  rm -f conftest.er1 conftest.err
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+done
+
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out"
+# Try to create an executable without -o first, disregard a.out.
+# It will help us diagnose broken compilers, and finding out an intuition
+# of exeext.
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the C compiler works" >&5
+printf %s "checking whether the C compiler works... " >&6; }
+ac_link_default=`printf "%s\n" "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
+
+# The possible output files:
+ac_files="a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*"
+
+ac_rmfiles=
+for ac_file in $ac_files
+do
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
+    * ) ac_rmfiles="$ac_rmfiles $ac_file";;
+  esac
+done
+rm -f $ac_rmfiles
+
+if { { ac_try="$ac_link_default"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+printf "%s\n" "$ac_try_echo"; } >&5
+  (eval "$ac_link_default") 2>&5
+  ac_status=$?
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+then :
+  # Autoconf-2.13 could set the ac_cv_exeext variable to 'no'.
+# So ignore a value of 'no', otherwise this would lead to 'EXEEXT = no'
+# in a Makefile.  We should not override ac_cv_exeext if it was cached,
+# so that the user can short-circuit this test for compilers unknown to
+# Autoconf.
+for ac_file in $ac_files ''
+do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )
+	;;
+    [ab].out )
+	# We found the default executable, but exeext='' is most
+	# certainly right.
+	break;;
+    *.* )
+	if test ${ac_cv_exeext+y} && test "$ac_cv_exeext" != no;
+	then :; else
+	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	fi
+	# We set ac_cv_exeext here because the later test for it is not
+	# safe: cross compilers may not add the suffix if given an '-o'
+	# argument, so we may need to know it at that point already.
+	# Even if this section looks crufty: it has the advantage of
+	# actually working.
+	break;;
+    * )
+	break;;
+  esac
+done
+test "$ac_cv_exeext" = no && ac_cv_exeext=
+
+else case e in #(
+  e) ac_file='' ;;
+esac
+fi
+if test -z "$ac_file"
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+printf "%s\n" "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in '$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in '$ac_pwd':" >&2;}
+as_fn_error 77 "C compiler cannot create executables
+See 'config.log' for more details" "$LINENO" 5; }
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+printf "%s\n" "yes" >&6; } ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for C compiler default output file name" >&5
+printf %s "checking for C compiler default output file name... " >&6; }
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_file" >&5
+printf "%s\n" "$ac_file" >&6; }
+ac_exeext=$ac_cv_exeext
+
+rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out
+ac_clean_files=$ac_clean_files_save
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for suffix of executables" >&5
+printf %s "checking for suffix of executables... " >&6; }
+if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+printf "%s\n" "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+then :
+  # If both 'conftest.exe' and 'conftest' are 'present' (well, observable)
+# catch 'conftest.exe'.  For instance with Cygwin, 'ls conftest' will
+# work properly (i.e., refer to 'conftest.exe'), while it won't with
+# 'rm'.
+for ac_file in conftest.exe conftest conftest.*; do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
+    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	  break;;
+    * ) break;;
+  esac
+done
+else case e in #(
+  e) { { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in '$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in '$ac_pwd':" >&2;}
+as_fn_error $? "cannot compute suffix of executables: cannot compile and link
+See 'config.log' for more details" "$LINENO" 5; } ;;
+esac
+fi
+rm -f conftest conftest$ac_cv_exeext
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
+printf "%s\n" "$ac_cv_exeext" >&6; }
+
+rm -f conftest.$ac_ext
+EXEEXT=$ac_cv_exeext
+ac_exeext=$EXEEXT
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdio.h>
+int
+main (void)
+{
+FILE *f = fopen ("conftest.out", "w");
+ if (!f)
+  return 1;
+ return ferror (f) || fclose (f) != 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files="$ac_clean_files conftest.out"
+# Check that the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether we are cross compiling" >&5
+printf %s "checking whether we are cross compiling... " >&6; }
+if test "$cross_compiling" != yes; then
+  { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+printf "%s\n" "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+  if { ac_try='./conftest$ac_cv_exeext'
+  { { case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+printf "%s\n" "$ac_try_echo"; } >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then
+    cross_compiling=no
+  else
+    if test "$cross_compiling" = maybe; then
+	cross_compiling=yes
+    else
+	{ { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in '$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in '$ac_pwd':" >&2;}
+as_fn_error 77 "cannot run C compiled programs.
+If you meant to cross compile, use '--host'.
+See 'config.log' for more details" "$LINENO" 5; }
+    fi
+  fi
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $cross_compiling" >&5
+printf "%s\n" "$cross_compiling" >&6; }
+
+rm -f conftest.$ac_ext conftest$ac_cv_exeext \
+  conftest.o conftest.obj conftest.out
+ac_clean_files=$ac_clean_files_save
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for suffix of object files" >&5
+printf %s "checking for suffix of object files... " >&6; }
+if test ${ac_cv_objext+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.o conftest.obj
+if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+printf "%s\n" "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>&5
+  ac_status=$?
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+then :
+  for ac_file in conftest.o conftest.obj conftest.*; do
+  test -f "$ac_file" || continue;
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;
+    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
+       break;;
+  esac
+done
+else case e in #(
+  e) printf "%s\n" "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in '$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in '$ac_pwd':" >&2;}
+as_fn_error $? "cannot compute suffix of object files: cannot compile
+See 'config.log' for more details" "$LINENO" 5; } ;;
+esac
+fi
+rm -f conftest.$ac_cv_objext conftest.$ac_ext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_objext" >&5
+printf "%s\n" "$ac_cv_objext" >&6; }
+OBJEXT=$ac_cv_objext
+ac_objext=$OBJEXT
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports GNU C" >&5
+printf %s "checking whether the compiler supports GNU C... " >&6; }
+if test ${ac_cv_c_compiler_gnu+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main (void)
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_compiler_gnu=yes
+else case e in #(
+  e) ac_compiler_gnu=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+ ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
+printf "%s\n" "$ac_cv_c_compiler_gnu" >&6; }
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+if test $ac_compiler_gnu = yes; then
+  GCC=yes
+else
+  GCC=
+fi
+ac_test_CFLAGS=${CFLAGS+y}
+ac_save_CFLAGS=$CFLAGS
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
+printf %s "checking whether $CC accepts -g... " >&6; }
+if test ${ac_cv_prog_cc_g+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_save_c_werror_flag=$ac_c_werror_flag
+   ac_c_werror_flag=yes
+   ac_cv_prog_cc_g=no
+   CFLAGS="-g"
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_prog_cc_g=yes
+else case e in #(
+  e) CFLAGS=""
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+
+else case e in #(
+  e) ac_c_werror_flag=$ac_save_c_werror_flag
+	 CFLAGS="-g"
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_prog_cc_g=yes
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+   ac_c_werror_flag=$ac_save_c_werror_flag ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
+printf "%s\n" "$ac_cv_prog_cc_g" >&6; }
+if test $ac_test_CFLAGS; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+ac_prog_cc_stdc=no
+if test x$ac_prog_cc_stdc = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C11 features" >&5
+printf %s "checking for $CC option to enable C11 features... " >&6; }
+if test ${ac_cv_prog_cc_c11+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_cv_prog_cc_c11=no
+ac_save_CC=$CC
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$ac_c_conftest_c11_program
+_ACEOF
+for ac_arg in '' -std=gnu11
+do
+  CC="$ac_save_CC $ac_arg"
+  if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_prog_cc_c11=$ac_arg
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam
+  test "x$ac_cv_prog_cc_c11" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CC=$ac_save_CC ;;
+esac
+fi
+
+if test "x$ac_cv_prog_cc_c11" = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+printf "%s\n" "unsupported" >&6; }
+else case e in #(
+  e) if test "x$ac_cv_prog_cc_c11" = x
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+printf "%s\n" "none needed" >&6; }
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c11" >&5
+printf "%s\n" "$ac_cv_prog_cc_c11" >&6; }
+     CC="$CC $ac_cv_prog_cc_c11" ;;
+esac
+fi
+  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c11
+  ac_prog_cc_stdc=c11 ;;
+esac
+fi
+fi
+if test x$ac_prog_cc_stdc = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C99 features" >&5
+printf %s "checking for $CC option to enable C99 features... " >&6; }
+if test ${ac_cv_prog_cc_c99+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_cv_prog_cc_c99=no
+ac_save_CC=$CC
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$ac_c_conftest_c99_program
+_ACEOF
+for ac_arg in '' -std=gnu99 -std=c99 -c99 -qlanglvl=extc1x -qlanglvl=extc99 -AC99 -D_STDC_C99=
+do
+  CC="$ac_save_CC $ac_arg"
+  if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_prog_cc_c99=$ac_arg
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam
+  test "x$ac_cv_prog_cc_c99" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CC=$ac_save_CC ;;
+esac
+fi
+
+if test "x$ac_cv_prog_cc_c99" = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+printf "%s\n" "unsupported" >&6; }
+else case e in #(
+  e) if test "x$ac_cv_prog_cc_c99" = x
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+printf "%s\n" "none needed" >&6; }
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c99" >&5
+printf "%s\n" "$ac_cv_prog_cc_c99" >&6; }
+     CC="$CC $ac_cv_prog_cc_c99" ;;
+esac
+fi
+  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c99
+  ac_prog_cc_stdc=c99 ;;
+esac
+fi
+fi
+if test x$ac_prog_cc_stdc = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C89 features" >&5
+printf %s "checking for $CC option to enable C89 features... " >&6; }
+if test ${ac_cv_prog_cc_c89+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_cv_prog_cc_c89=no
+ac_save_CC=$CC
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$ac_c_conftest_c89_program
+_ACEOF
+for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std -Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_prog_cc_c89=$ac_arg
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam
+  test "x$ac_cv_prog_cc_c89" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CC=$ac_save_CC ;;
+esac
+fi
+
+if test "x$ac_cv_prog_cc_c89" = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+printf "%s\n" "unsupported" >&6; }
+else case e in #(
+  e) if test "x$ac_cv_prog_cc_c89" = x
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+printf "%s\n" "none needed" >&6; }
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
+printf "%s\n" "$ac_cv_prog_cc_c89" >&6; }
+     CC="$CC $ac_cv_prog_cc_c89" ;;
+esac
+fi
+  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c89
+  ac_prog_cc_stdc=c89 ;;
+esac
+fi
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+
+
+
+
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+if test -z "$CXX"; then
+  if test -n "$CCC"; then
+    CXX=$CCC
+  else
+    if test -n "$ac_tool_prefix"; then
+  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC clang++
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CXX+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$CXX"; then
+  ac_cv_prog_CXX="$CXX" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CXX="$ac_tool_prefix$ac_prog"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+CXX=$ac_cv_prog_CXX
+if test -n "$CXX"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CXX" >&5
+printf "%s\n" "$CXX" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+    test -n "$CXX" && break
+  done
+fi
+if test -z "$CXX"; then
+  ac_ct_CXX=$CXX
+  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC clang++
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_CXX+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$ac_ct_CXX"; then
+  ac_cv_prog_ac_ct_CXX="$ac_ct_CXX" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CXX="$ac_prog"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+ac_ct_CXX=$ac_cv_prog_ac_ct_CXX
+if test -n "$ac_ct_CXX"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CXX" >&5
+printf "%s\n" "$ac_ct_CXX" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_CXX" && break
+done
+
+  if test "x$ac_ct_CXX" = x; then
+    CXX="g++"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CXX=$ac_ct_CXX
+  fi
+fi
+
+  fi
+fi
+# Provide some information about the compiler.
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for C++ compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+for ac_option in --version -v -V -qversion; do
+  { { ac_try="$ac_compiler $ac_option >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+printf "%s\n" "$ac_try_echo"; } >&5
+  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    sed '10a\
+... rest of stderr output deleted ...
+         10q' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+  fi
+  rm -f conftest.er1 conftest.err
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+done
+
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports GNU C++" >&5
+printf %s "checking whether the compiler supports GNU C++... " >&6; }
+if test ${ac_cv_cxx_compiler_gnu+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main (void)
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"
+then :
+  ac_compiler_gnu=yes
+else case e in #(
+  e) ac_compiler_gnu=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+ac_cv_cxx_compiler_gnu=$ac_compiler_gnu
+ ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cxx_compiler_gnu" >&5
+printf "%s\n" "$ac_cv_cxx_compiler_gnu" >&6; }
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+if test $ac_compiler_gnu = yes; then
+  GXX=yes
+else
+  GXX=
+fi
+ac_test_CXXFLAGS=${CXXFLAGS+y}
+ac_save_CXXFLAGS=$CXXFLAGS
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CXX accepts -g" >&5
+printf %s "checking whether $CXX accepts -g... " >&6; }
+if test ${ac_cv_prog_cxx_g+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_save_cxx_werror_flag=$ac_cxx_werror_flag
+   ac_cxx_werror_flag=yes
+   ac_cv_prog_cxx_g=no
+   CXXFLAGS="-g"
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"
+then :
+  ac_cv_prog_cxx_g=yes
+else case e in #(
+  e) CXXFLAGS=""
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"
+then :
+
+else case e in #(
+  e) ac_cxx_werror_flag=$ac_save_cxx_werror_flag
+	 CXXFLAGS="-g"
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_compile "$LINENO"
+then :
+  ac_cv_prog_cxx_g=yes
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+   ac_cxx_werror_flag=$ac_save_cxx_werror_flag ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cxx_g" >&5
+printf "%s\n" "$ac_cv_prog_cxx_g" >&6; }
+if test $ac_test_CXXFLAGS; then
+  CXXFLAGS=$ac_save_CXXFLAGS
+elif test $ac_cv_prog_cxx_g = yes; then
+  if test "$GXX" = yes; then
+    CXXFLAGS="-g -O2"
+  else
+    CXXFLAGS="-g"
+  fi
+else
+  if test "$GXX" = yes; then
+    CXXFLAGS="-O2"
+  else
+    CXXFLAGS=
+  fi
+fi
+ac_prog_cxx_stdcxx=no
+if test x$ac_prog_cxx_stdcxx = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CXX option to enable C++11 features" >&5
+printf %s "checking for $CXX option to enable C++11 features... " >&6; }
+if test ${ac_cv_prog_cxx_cxx11+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_cv_prog_cxx_cxx11=no
+ac_save_CXX=$CXX
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$ac_cxx_conftest_cxx11_program
+_ACEOF
+for ac_arg in '' -std=gnu++11 -std=gnu++0x -std=c++11 -std=c++0x -qlanglvl=extended0x -AA
+do
+  CXX="$ac_save_CXX $ac_arg"
+  if ac_fn_cxx_try_compile "$LINENO"
+then :
+  ac_cv_prog_cxx_cxx11=$ac_arg
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam
+  test "x$ac_cv_prog_cxx_cxx11" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CXX=$ac_save_CXX ;;
+esac
+fi
+
+if test "x$ac_cv_prog_cxx_cxx11" = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+printf "%s\n" "unsupported" >&6; }
+else case e in #(
+  e) if test "x$ac_cv_prog_cxx_cxx11" = x
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+printf "%s\n" "none needed" >&6; }
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cxx_cxx11" >&5
+printf "%s\n" "$ac_cv_prog_cxx_cxx11" >&6; }
+     CXX="$CXX $ac_cv_prog_cxx_cxx11" ;;
+esac
+fi
+  ac_cv_prog_cxx_stdcxx=$ac_cv_prog_cxx_cxx11
+  ac_prog_cxx_stdcxx=cxx11 ;;
+esac
+fi
+fi
+if test x$ac_prog_cxx_stdcxx = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CXX option to enable C++98 features" >&5
+printf %s "checking for $CXX option to enable C++98 features... " >&6; }
+if test ${ac_cv_prog_cxx_cxx98+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_cv_prog_cxx_cxx98=no
+ac_save_CXX=$CXX
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$ac_cxx_conftest_cxx98_program
+_ACEOF
+for ac_arg in '' -std=gnu++98 -std=c++98 -qlanglvl=extended -AA
+do
+  CXX="$ac_save_CXX $ac_arg"
+  if ac_fn_cxx_try_compile "$LINENO"
+then :
+  ac_cv_prog_cxx_cxx98=$ac_arg
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam
+  test "x$ac_cv_prog_cxx_cxx98" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CXX=$ac_save_CXX ;;
+esac
+fi
+
+if test "x$ac_cv_prog_cxx_cxx98" = xno
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+printf "%s\n" "unsupported" >&6; }
+else case e in #(
+  e) if test "x$ac_cv_prog_cxx_cxx98" = x
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+printf "%s\n" "none needed" >&6; }
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cxx_cxx98" >&5
+printf "%s\n" "$ac_cv_prog_cxx_cxx98" >&6; }
+     CXX="$CXX $ac_cv_prog_cxx_cxx98" ;;
+esac
+fi
+  ac_cv_prog_cxx_stdcxx=$ac_cv_prog_cxx_cxx98
+  ac_prog_cxx_stdcxx=cxx98 ;;
+esac
+fi
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}cpp", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cpp; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CPPBIN+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$CPPBIN"; then
+  ac_cv_prog_CPPBIN="$CPPBIN" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CPPBIN="${ac_tool_prefix}cpp"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+CPPBIN=$ac_cv_prog_CPPBIN
+if test -n "$CPPBIN"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CPPBIN" >&5
+printf "%s\n" "$CPPBIN" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_CPPBIN"; then
+  ac_ct_CPPBIN=$CPPBIN
+  # Extract the first word of "cpp", so it can be a program name with args.
+set dummy cpp; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_CPPBIN+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$ac_ct_CPPBIN"; then
+  ac_cv_prog_ac_ct_CPPBIN="$ac_ct_CPPBIN" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CPPBIN="cpp"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+ac_ct_CPPBIN=$ac_cv_prog_ac_ct_CPPBIN
+if test -n "$ac_ct_CPPBIN"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CPPBIN" >&5
+printf "%s\n" "$ac_ct_CPPBIN" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+  if test "x$ac_ct_CPPBIN" = x; then
+    CPPBIN="cpp"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CPPBIN=$ac_ct_CPPBIN
+  fi
+else
+  CPPBIN="$ac_cv_prog_CPPBIN"
+fi
+
+
+printf "%s\n" "#define EXEEXT \"$ac_exeext\"" >>confdefs.h
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ld", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ld; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_LD+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$LD"; then
+  ac_cv_prog_LD="$LD" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_LD="${ac_tool_prefix}ld"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+LD=$ac_cv_prog_LD
+if test -n "$LD"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $LD" >&5
+printf "%s\n" "$LD" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_LD"; then
+  ac_ct_LD=$LD
+  # Extract the first word of "ld", so it can be a program name with args.
+set dummy ld; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_LD+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$ac_ct_LD"; then
+  ac_cv_prog_ac_ct_LD="$ac_ct_LD" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_LD="ld"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+ac_ct_LD=$ac_cv_prog_ac_ct_LD
+if test -n "$ac_ct_LD"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_LD" >&5
+printf "%s\n" "$ac_ct_LD" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+  if test "x$ac_ct_LD" = x; then
+    LD=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    LD=$ac_ct_LD
+  fi
+else
+  LD="$ac_cv_prog_LD"
+fi
+
+
+case $host in
+  *-darwin*)
+    with_fontconfig=${with_fontconfig:-no}
+    ;;
+  *-mingw32*|*-cygwin*)
+    enable_win16=${enable_win16:-no}
+    with_mingw=${with_mingw:-no}
+    ;;
+esac
+
+
+case $host in
+  x86_64*|amd64*)
+    if test "x$enable_win64" != "xyes" -a "$cross_compiling" != "yes" -a x"$enable_archs" = x
+    then
+      CC="$CC -m32"
+      CXX="$CXX -m32"
+
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC works" >&5
+printf %s "checking whether $CC works... " >&6; }
+if test ${wine_cv_cc_m32+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  wine_cv_cc_m32=yes
+else case e in #(
+  e) wine_cv_cc_m32=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_cc_m32" >&5
+printf "%s\n" "$wine_cv_cc_m32" >&6; }
+      test $wine_cv_cc_m32 != no || as_fn_error $? "Cannot build a 32-bit program, you need to install 32-bit development libraries." "$LINENO" 5
+      host_cpu="i386"
+      notice_platform="32-bit "
+      TARGETFLAGS="$TARGETFLAGS -m32"
+      PKG_CONFIG_LIBDIR=${PKG_CONFIG_LIBDIR:-/usr/lib/i386-linux-gnu/pkgconfig:/usr/lib32/pkgconfig:/usr/lib/pkgconfig:/usr/share/pkgconfig}
+      export PKG_CONFIG_LIBDIR
+    else
+      CC="$CC -m64"
+      CXX="$CXX -m64"
+      host_cpu="x86_64"
+      notice_platform="64-bit "
+      TARGETFLAGS="$TARGETFLAGS -m64"
+    fi
+    ;;
+  arm*)
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports Thumb-2" >&5
+printf %s "checking whether $CC supports Thumb-2... " >&6; }
+if test ${wine_cv_thumb2+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main (void)
+{
+asm(".syntax unified\n\t.thumb\n\tldm r0,{r0-r8}");
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  wine_cv_thumb2=yes
+else case e in #(
+  e) wine_cv_thumb2=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_thumb2" >&5
+printf "%s\n" "$wine_cv_thumb2" >&6; }
+    if test x"$wine_cv_thumb2" = xyes
+    then
+        CFLAGS="$CFLAGS -mthumb"
+    else
+        CFLAGS="$CFLAGS -marm"
+    fi
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports floating point instructions" >&5
+printf %s "checking whether $CC supports floating point instructions... " >&6; }
+if test ${wine_cv_float_abi+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main (void)
+{
+asm("vmrs r2,fpscr");
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  wine_cv_float_abi=yes
+else case e in #(
+  e) wine_cv_float_abi=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_float_abi" >&5
+printf "%s\n" "$wine_cv_float_abi" >&6; }
+    test $wine_cv_float_abi != no || as_fn_error $? "The ARM target needs to support floating point instructions." "$LINENO" 5
+    ;;
+esac
+
+if test "x$enable_win64" = "xyes"
+then
+    test -z "$with_wine64" || as_fn_error $? "--enable-win64 and --with-wine64 are mutually exclusive.
+--enable-win64 should be used in the 64-bit build tree, --with-wine64 in the 32-bit Wow64 build tree." "$LINENO" 5
+elif test -n "$with_wine64"
+then
+    test -f "$with_wine64/Makefile" || as_fn_error $? "the 64-bit tree in $with_wine64 has not been configured yet." "$LINENO" 5
+    libdir64=$(grep "^libdir *=" "$with_wine64/Makefile" | sed 's/^libdir *= *//')
+    if test "$libdir64" != "$libdir"; then
+        printf "%s\n" "$as_me:${as_lineno-$LINENO}: libdir64: $libdir64" >&5
+        as_fn_error $? "when using --with-wine64 you must use the same --libdir in both build trees." "$LINENO" 5
+    fi
+fi
+
+case $build_os in
+  cygwin*|mingw32*) toolsext=".exe"
+ ;;
+  *) toolsext=""
+ ;;
+esac
+
+HOST_ARCH=unknown
+case "$host_cpu" in
+  aarch64*)        HOST_ARCH=aarch64 ;;
+  arm*)            HOST_ARCH=arm ;;
+  i[3456789]86*) HOST_ARCH=i386 ;;
+  x86_64)          HOST_ARCH=x86_64 ;;
+esac
+
+
+toolsdir=$with_wine_tools
+
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for the directory containing the Wine tools" >&5
+printf %s "checking for the directory containing the Wine tools... " >&6; }
+if test -z "$toolsdir"; then
+    if test "$cross_compiling" = "yes"; then
+        as_fn_error $? "you must use the --with-wine-tools option when cross-compiling." "$LINENO" 5
+    elif test -n "$with_wine64" -a "x$enable_tools" != xyes; then
+        toolsdir="$with_wine64"
+    fi
+fi
+if test -z "$toolsdir"; then
+    wine_makedep=tools/makedep$toolsext
+elif test -d "$toolsdir/tools/winebuild"; then
+    wine_makedep=$toolsdir/tools/makedep$toolsext
+    enable_tools=${enable_tools:-no}
+    test -f "$wine_makedep" || as_fn_error $? "the Wine tools have not yet been built in $toolsdir" "$LINENO" 5
+else
+    as_fn_error $? "could not find Wine tools in $toolsdir" "$LINENO" 5
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: ${toolsdir:-none needed}" >&5
+printf "%s\n" "${toolsdir:-none needed}" >&6; }
+wine64dir=$with_wine64
+
+RUNTESTFLAGS="-q -P wine"
+
+SED_CMD="LC_ALL=C sed -e 's,@bindir@,\${bindir},g' -e 's,@PACKAGE_STRING@,$PACKAGE_STRING,g' -e 's,@PACKAGE_VERSION@,$PACKAGE_VERSION,g'"
+
+
+if test -n "$host_alias" -a "$host_alias" != "$build_alias"
+then
+    TARGETFLAGS="-b $host_alias $TARGETFLAGS"
+fi
+
+for ac_prog in flex
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_FLEX+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$FLEX"; then
+  ac_cv_prog_FLEX="$FLEX" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_FLEX="$ac_prog"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+FLEX=$ac_cv_prog_FLEX
+if test -n "$FLEX"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $FLEX" >&5
+printf "%s\n" "$FLEX" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+  test -n "$FLEX" && break
+done
+test -n "$FLEX" || FLEX="none"
+
+if test "$FLEX" = "none"
+then
+  as_fn_error $? "no suitable flex found. Please install the 'flex' package." "$LINENO" 5
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether flex is recent enough" >&5
+printf %s "checking whether flex is recent enough... " >&6; }
+if test ${wine_cv_recent_flex+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat >conftest.l <<EOF
+%top{
+#include "prediluvian.h"
+}
+%%
+EOF
+    if $FLEX -t conftest.l >/dev/null 2>&5
+    then
+      wine_cv_recent_flex=yes
+    else
+      wine_cv_recent_flex=no
+    fi ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_recent_flex" >&5
+printf "%s\n" "$wine_cv_recent_flex" >&6; }
+test $wine_cv_recent_flex != no || as_fn_error $? "Your flex version is too old. Please install flex version 2.5.33 or newer." "$LINENO" 5
+
+for ac_prog in bison
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_BISON+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$BISON"; then
+  ac_cv_prog_BISON="$BISON" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_BISON="$ac_prog"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+BISON=$ac_cv_prog_BISON
+if test -n "$BISON"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $BISON" >&5
+printf "%s\n" "$BISON" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+  test -n "$BISON" && break
+done
+test -n "$BISON" || BISON="none"
+
+if test "$BISON" = "none"
+then
+  as_fn_error $? "no suitable bison found. Please install the 'bison' package." "$LINENO" 5
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether bison is recent enough" >&5
+printf %s "checking whether bison is recent enough... " >&6; }
+if test ${wine_cv_recent_bison+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat >conftest.y <<EOF
+%define parse.error verbose
+%%
+empty: ;
+EOF
+    if $BISON conftest.y >/dev/null 2>&5
+    then
+      wine_cv_recent_bison=yes
+    else
+      wine_cv_recent_bison=no
+    fi ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_recent_bison" >&5
+printf "%s\n" "$wine_cv_recent_bison" >&6; }
+test $wine_cv_recent_bison != no || as_fn_error $? "Your bison version is too old. Please install bison version 3.0 or newer." "$LINENO" 5
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
+set dummy ${ac_tool_prefix}strip; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_STRIP+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$STRIP"; then
+  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+STRIP=$ac_cv_prog_STRIP
+if test -n "$STRIP"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
+printf "%s\n" "$STRIP" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_STRIP"; then
+  ac_ct_STRIP=$STRIP
+  # Extract the first word of "strip", so it can be a program name with args.
+set dummy strip; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_STRIP+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$ac_ct_STRIP"; then
+  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_STRIP="strip"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
+if test -n "$ac_ct_STRIP"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
+printf "%s\n" "$ac_ct_STRIP" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+  if test "x$ac_ct_STRIP" = x; then
+    STRIP="strip"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    STRIP=$ac_ct_STRIP
+  fi
+else
+  STRIP="$ac_cv_prog_STRIP"
+fi
+
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether ln -s works" >&5
+printf %s "checking whether ln -s works... " >&6; }
+LN_S=$as_ln_s
+if test "$LN_S" = "ln -s"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+printf "%s\n" "yes" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no, using $LN_S" >&5
+printf "%s\n" "no, using $LN_S" >&6; }
+fi
+
+if test ${ac_tool_prefix+y}
+then :
+  # Extract the first word of "${ac_tool_prefix}pkg-config", so it can be a program name with args.
+set dummy ${ac_tool_prefix}pkg-config; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_PKG_CONFIG+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$PKG_CONFIG"; then
+  ac_cv_prog_PKG_CONFIG="$PKG_CONFIG" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_PKG_CONFIG="${ac_tool_prefix}pkg-config"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+PKG_CONFIG=$ac_cv_prog_PKG_CONFIG
+if test -n "$PKG_CONFIG"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $PKG_CONFIG" >&5
+printf "%s\n" "$PKG_CONFIG" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+fi
+if ${ac_cv_prog_PKG_CONFIG:+false} :
+then :
+  if test "x$cross_compiling" = xyes
+then :
+
+else case e in #(
+  e) { ac_cv_prog_PKG_CONFIG=; unset ac_cv_prog_PKG_CONFIG;}
+     # Extract the first word of "pkg-config", so it can be a program name with args.
+set dummy pkg-config; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_PKG_CONFIG+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$PKG_CONFIG"; then
+  ac_cv_prog_PKG_CONFIG="$PKG_CONFIG" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_PKG_CONFIG="pkg-config"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+PKG_CONFIG=$ac_cv_prog_PKG_CONFIG
+if test -n "$PKG_CONFIG"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $PKG_CONFIG" >&5
+printf "%s\n" "$PKG_CONFIG" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+ ;;
+esac
+fi
+else case e in #(
+  e) PKG_CONFIG=$ac_cv_prog_PKG_CONFIG ;;
+esac
+fi
+
+if test "x$enable_maintainer_mode" != "xyes"
+then
+  FONTFORGE=""
+  RSVG=""
+  CONVERT=""
+  ICOTOOL=""
+else
+  test "$srcdir" = . || as_fn_error $? "Maintainer mode cannot work out of tree." "$LINENO" 5
+  for ac_prog in fontforge
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_FONTFORGE+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$FONTFORGE"; then
+  ac_cv_prog_FONTFORGE="$FONTFORGE" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_FONTFORGE="$ac_prog"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+FONTFORGE=$ac_cv_prog_FONTFORGE
+if test -n "$FONTFORGE"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $FONTFORGE" >&5
+printf "%s\n" "$FONTFORGE" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+  test -n "$FONTFORGE" && break
+done
+test -n "$FONTFORGE" || FONTFORGE="false"
+
+  for ac_prog in rsvg-convert rsvg
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_RSVG+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$RSVG"; then
+  ac_cv_prog_RSVG="$RSVG" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_RSVG="$ac_prog"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+RSVG=$ac_cv_prog_RSVG
+if test -n "$RSVG"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $RSVG" >&5
+printf "%s\n" "$RSVG" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+  test -n "$RSVG" && break
+done
+test -n "$RSVG" || RSVG="false"
+
+  for ac_prog in convert
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_CONVERT+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$CONVERT"; then
+  ac_cv_prog_CONVERT="$CONVERT" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CONVERT="$ac_prog"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+CONVERT=$ac_cv_prog_CONVERT
+if test -n "$CONVERT"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CONVERT" >&5
+printf "%s\n" "$CONVERT" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+  test -n "$CONVERT" && break
+done
+test -n "$CONVERT" || CONVERT="false"
+
+  for ac_prog in icotool
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ICOTOOL+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$ICOTOOL"; then
+  ac_cv_prog_ICOTOOL="$ICOTOOL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ICOTOOL="$ac_prog"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+ICOTOOL=$ac_cv_prog_ICOTOOL
+if test -n "$ICOTOOL"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ICOTOOL" >&5
+printf "%s\n" "$ICOTOOL" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+  test -n "$ICOTOOL" && break
+done
+test -n "$ICOTOOL" || ICOTOOL="false"
+
+  test "$FONTFORGE" != "false" || as_fn_error $? "You need fontforge to rebuild fonts in maintainer mode." "$LINENO" 5
+  test "$RSVG" != "false" || as_fn_error $? "You need rsvg to rebuild icons in maintainer mode." "$LINENO" 5
+
+    if test "$CONVERT" = false
+  then
+    as_fn_error $? "You need imagemagick to rebuild icons in maintainer mode." "$LINENO" 5
+  else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for recent enough imagemagick" >&5
+printf %s "checking for recent enough imagemagick... " >&6; }
+    convert_version=`convert --version | head -n1`
+    if test "x$convert_version" != "x"
+    then
+      convert_version_major=`expr "$convert_version" : '.* \([0-9]*\)\.[0-9]*'`
+      convert_version_minor=`expr "$convert_version" : '.* [0-9]*\.\([0-9]*\)'`
+      if test "$convert_version_major" -eq 6 -a "$convert_version_minor" -lt 6
+      then
+        CONVERT=false
+      fi
+    fi
+    if test "$CONVERT" = false
+    then
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no ($convert_version_major.$convert_version_minor)" >&5
+printf "%s\n" "no ($convert_version_major.$convert_version_minor)" >&6; }
+      as_fn_error $? "You need imagemagick version 6.6 or newer to rebuild icons in maintainer mode." "$LINENO" 5
+    else
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes ($convert_version_major.$convert_version_minor)" >&5
+printf "%s\n" "yes ($convert_version_major.$convert_version_minor)" >&6; }
+    fi
+  fi
+
+    if test "$ICOTOOL" = false
+  then
+    as_fn_error $? "You need icotool to rebuild icons in maintainer mode." "$LINENO" 5
+  else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for recent enough icotool" >&5
+printf %s "checking for recent enough icotool... " >&6; }
+    icotool_version=`icotool --version | head -n1`
+    if test "x$icotool_version" != "x"
+    then
+      icotool_version_major=`expr "$icotool_version" : '.* \([0-9]*\)\.[0-9]*'`
+      icotool_version_minor=`expr "$icotool_version" : '.* [0-9]*\.\([0-9]*\)'`
+      if test "$icotool_version_major" -eq 0 -a "$icotool_version_minor" -lt 29
+      then
+        ICOTOOL=false
+        as_fn_append wine_warnings "|icotool version 0.29.0 or newer is needed to rebuild icons."
+      fi
+    fi
+    if test "$ICOTOOL" = false
+    then
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no ($icotool_version_major.$icotool_version_minor)" >&5
+printf "%s\n" "no ($icotool_version_major.$icotool_version_minor)" >&6; }
+      as_fn_error $? "You need icotool version 0.29.0 or newer to rebuild icons in maintainer mode." "$LINENO" 5
+    else
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes ($icotool_version_major.$icotool_version_minor)" >&5
+printf "%s\n" "yes ($icotool_version_major.$icotool_version_minor)" >&6; }
+    fi
+  fi
+
+    with_gettext=yes
+  with_gettextpo=yes
+
+    enable_werror=yes
+fi
+
+if test "x$with_gettext" != xno
+then
+  for ac_prog in msgfmt
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_MSGFMT+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$MSGFMT"; then
+  ac_cv_prog_MSGFMT="$MSGFMT" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_MSGFMT="$ac_prog"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+MSGFMT=$ac_cv_prog_MSGFMT
+if test -n "$MSGFMT"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $MSGFMT" >&5
+printf "%s\n" "$MSGFMT" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+  test -n "$MSGFMT" && break
+done
+test -n "$MSGFMT" || MSGFMT="false"
+
+  if test "$MSGFMT" != "false"
+  then
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether msgfmt supports contexts" >&5
+printf %s "checking whether msgfmt supports contexts... " >&6; }
+if test ${wine_cv_msgfmt_contexts+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat >conftest.po <<EOF
+# comment
+msgctxt "ctxt"
+msgid "id"
+msgstr "str"
+EOF
+    if $MSGFMT -o /dev/null conftest.po 2>&5
+    then
+      wine_cv_msgfmt_contexts=yes
+    else
+      wine_cv_msgfmt_contexts=no
+    fi ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_msgfmt_contexts" >&5
+printf "%s\n" "$wine_cv_msgfmt_contexts" >&6; }
+    test $wine_cv_msgfmt_contexts != no || MSGFMT=false
+  fi
+else
+  MSGFMT=false
+fi
+if test "$MSGFMT" = false
+then :
+  case "x$with_gettext" in
+  x)   as_fn_append wine_warnings "|gettext tools not found (or too old), translations won't be built." ;;
+  xno) ;;
+  *)   as_fn_error $? "gettext tools not found (or too old), translations won't be built.
+This is an error since --with-gettext was requested." "$LINENO" 5 ;;
+esac
+enable_po=${enable_po:-no}
+fi
+
+
+PE_ARCHS=""
+
+cross_archs=
+if test ${enable_archs+y}
+then :
+  test "x$with_system_dllpath" = "x" || as_fn_error $? "\"The --with-system-dllpath option is not compatible with --enable-archs\"" "$LINENO" 5
+     ac_save_IFS=$IFS
+     IFS=' ,'
+     set x $enable_archs
+     IFS=$ac_save_IFS
+     shift
+     for arch
+     do
+         case $arch in
+           i386|x86_64|arm|aarch64|arm64ec) cross_archs="$cross_archs $arch" ;;
+           no|none) PE_ARCHS=none ;;
+           *) as_fn_error $? "Unknown cross-compilation architecture '$arch'" "$LINENO" 5 ;;
+         esac
+     done
+else case e in #(
+  e) if test "x$with_mingw" != xno
+     then
+         test $HOST_ARCH = unknown || cross_archs=$HOST_ARCH
+     fi ;;
+esac
+fi
+
+if test "x$PE_ARCHS" = xnone
+then :
+  cross_archs=
+fi
+
+saved_CC=$CC
+saved_CFLAGS=$CFLAGS
+saved_CPPFLAGS=$CPPFLAGS
+saved_LDFLAGS=$LDFLAGS
+
+{ extra_arch=; unset extra_arch;}
+for arch in $cross_archs
+do
+  case $arch in
+    arm64ec) test ${extra_arch+y} || extra_arch=x86_64 ;;
+    x86_64) extra_arch="" ;;
+  esac
+done
+
+for wine_arch in $cross_archs $extra_arch
+do
+    case $wine_arch in
+      i386) mingw_cpu=i686 ;;
+      arm)  mingw_cpu=armv7 ;;
+      *)    mingw_cpu=$wine_arch ;;
+    esac
+    case "x$with_mingw" in
+      xclang|x*/clang) eval "${wine_arch}_CC=\$with_mingw" ;;
+      xllvm-mingw)     eval "${wine_arch}_CC=\${mingw_cpu}-w64-mingw32-clang" ;;
+    esac
+    if eval \${${wine_arch}_CC:+false} :
+then :
+  case $wine_arch in
+          aarch64)
+            for ac_prog in aarch64-w64-mingw32-clang aarch64-w64-mingw32-gcc clang
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_aarch64_CC+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$aarch64_CC"; then
+  ac_cv_prog_aarch64_CC="$aarch64_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_aarch64_CC="$ac_prog"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+aarch64_CC=$ac_cv_prog_aarch64_CC
+if test -n "$aarch64_CC"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $aarch64_CC" >&5
+printf "%s\n" "$aarch64_CC" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+  test -n "$aarch64_CC" && break
+done
+test -n "$aarch64_CC" || aarch64_CC="false"
+
+            ;;
+          arm64ec)
+            for ac_prog in arm64ec-w64-mingw32-clang arm64ec-w64-mingw32-gcc clang
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_arm64ec_CC+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$arm64ec_CC"; then
+  ac_cv_prog_arm64ec_CC="$arm64ec_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_arm64ec_CC="$ac_prog"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+arm64ec_CC=$ac_cv_prog_arm64ec_CC
+if test -n "$arm64ec_CC"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $arm64ec_CC" >&5
+printf "%s\n" "$arm64ec_CC" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+  test -n "$arm64ec_CC" && break
+done
+test -n "$arm64ec_CC" || arm64ec_CC="false"
+
+            ;;
+          arm)
+            for ac_prog in armv7-w64-mingw32-clang armv7-w64-mingw32-gcc clang
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_arm_CC+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$arm_CC"; then
+  ac_cv_prog_arm_CC="$arm_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_arm_CC="$ac_prog"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+arm_CC=$ac_cv_prog_arm_CC
+if test -n "$arm_CC"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $arm_CC" >&5
+printf "%s\n" "$arm_CC" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+  test -n "$arm_CC" && break
+done
+test -n "$arm_CC" || arm_CC="false"
+
+            ;;
+          i386)
+            ac_prefix_list="i686-w64-mingw32-gcc i586-w64-mingw32-gcc i486-w64-mingw32-gcc i386-w64-mingw32-gcc i686-w64-mingw32-clang i586-w64-mingw32-clang i486-w64-mingw32-clang i386-w64-mingw32-clang "
+            for ac_prog in $ac_prefix_list clang
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_i386_CC+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$i386_CC"; then
+  ac_cv_prog_i386_CC="$i386_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_i386_CC="$ac_prog"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+i386_CC=$ac_cv_prog_i386_CC
+if test -n "$i386_CC"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $i386_CC" >&5
+printf "%s\n" "$i386_CC" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+  test -n "$i386_CC" && break
+done
+test -n "$i386_CC" || i386_CC="false"
+
+            ;;
+          x86_64)
+            ac_prefix_list="x86_64-w64-mingw32-gcc amd64-w64-mingw32-gcc x86_64-w64-mingw32-clang amd64-w64-mingw32-clang "
+            for ac_prog in $ac_prefix_list clang
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_x86_64_CC+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$x86_64_CC"; then
+  ac_cv_prog_x86_64_CC="$x86_64_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_x86_64_CC="$ac_prog"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+x86_64_CC=$ac_cv_prog_x86_64_CC
+if test -n "$x86_64_CC"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $x86_64_CC" >&5
+printf "%s\n" "$x86_64_CC" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+  test -n "$x86_64_CC" && break
+done
+test -n "$x86_64_CC" || x86_64_CC="false"
+
+            ;;
+         esac
+         wine_try_msvc=yes
+else case e in #(
+  e) wine_try_msvc=no ;;
+esac
+fi
+
+    CPPFLAGS=""
+    if eval test \${${wine_arch}_CFLAGS+y}
+then :
+
+else case e in #(
+  e) eval "${wine_arch}_CFLAGS=\${CROSSCFLAGS:-\"-g -O2\"}" ;;
+esac
+fi
+    if eval test \${${wine_arch}_LDFLAGS+y}
+then :
+
+else case e in #(
+  e) eval "${wine_arch}_LDFLAGS=\$CROSSLDFLAGS" ;;
+esac
+fi
+    eval CC=\$${wine_arch}_CC
+    eval CFLAGS=\$${wine_arch}_CFLAGS
+    eval LDFLAGS=\$${wine_arch}_LDFLAGS
+    eval "${wine_arch}_EXTRACFLAGS=\"-D__WINE_PE_BUILD -Wall\""
+
+    target=""
+    set x $CC
+    shift
+    while test $# -ge 1
+    do
+        case "$1" in
+            */*-gcc) target=`expr "$1" : '.*/\(.*\)-gcc'` ;;
+            */*-clang) target=`expr "$1" : '.*/\(.*\)-clang'` ;;
+            *-gcc) target=`expr "$1" : '\(.*\)-gcc'` ;;
+            *-clang) target=`expr "$1" : '\(.*\)-clang'` ;;
+        esac
+        shift
+    done
+
+        target_strip=${target:-llvm}-strip
+    if test "$wine_try_msvc" = yes -o -z "$target"
+    then
+        llvm_target="$mingw_cpu-windows"
+        llvm_extra_cflags="-target $llvm_target -fuse-ld=lld"
+        llvm_cflags="-Wl,-subsystem:console -Wl,-WX"
+    else
+        llvm_target=$target
+        llvm_extra_cflags="-fuse-ld=lld"
+        llvm_cflags="-target $target"
+    fi
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_$llvm_extra_cflags $llvm_cflags --no-default-config" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports $llvm_extra_cflags $llvm_cflags --no-default-config" >&5
+printf %s "checking whether $CC supports $llvm_extra_cflags $llvm_cflags --no-default-config... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs $llvm_extra_cflags $llvm_cflags --no-default-config"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  llvm_extra_cflags="$llvm_extra_cflags --no-default-config"
+                        llvm_extra_ldflags="--no-default-config"
+else case e in #(
+  e) { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_$llvm_extra_cflags $llvm_cflags" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports $llvm_extra_cflags $llvm_cflags" >&5
+printf %s "checking whether $CC supports $llvm_extra_cflags $llvm_cflags... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs $llvm_extra_cflags $llvm_cflags"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  :
+else case e in #(
+  e) llvm_extra_cflags="" ;;
+esac
+fi } ;;
+esac
+fi }
+    if test -n "$llvm_extra_cflags"
+    then
+        target=$llvm_target
+        eval "${wine_arch}_DELAYLOADFLAG=\"-Wl,-delayload,\""
+        as_fn_append ${wine_arch}_EXTRACFLAGS " $llvm_extra_cflags"
+        as_fn_append ${wine_arch}_LDFLAGS " $llvm_extra_ldflags"
+        CFLAGS="$CFLAGS $llvm_extra_cflags $llvm_cflags"
+    else
+        as_wine_cv_crosscc=`printf "%s\n" "wine_cv_${wine_arch}_crosscc" | sed "$as_sed_sh"`
+
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC works" >&5
+printf %s "checking whether $CC works... " >&6; }
+if eval test \${$as_wine_cv_crosscc+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  eval "$as_wine_cv_crosscc=yes"
+else case e in #(
+  e) eval "$as_wine_cv_crosscc=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;
+esac
+fi
+eval ac_res=\$$as_wine_cv_crosscc
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+        if eval test \"x\$"$as_wine_cv_crosscc"\" = x"no"
+then :
+  target=
+fi
+
+    fi
+
+    if test -z "$target"
+    then
+        if test ${enable_archs+y}
+then :
+  as_fn_error $? "$wine_arch PE cross-compiler not found.
+This is an error since --enable-archs=$wine_arch was requested." "$LINENO" 5
+fi
+        continue
+    fi
+
+    eval "${wine_arch}_TARGET=\$target"
+    eval "${wine_arch}_STRIP=\$target_strip"
+    as_wine_cv_crosscc_c99=`printf "%s\n" "ac_cv_${wine_arch}_crosscc_c99" | sed "$as_sed_sh"`
+
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C99 features" >&5
+printf %s "checking for $CC option to enable C99 features... " >&6; }
+    if eval test \${$as_wine_cv_crosscc_c99+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) eval "$as_wine_cv_crosscc_c99=no"
+         for arg in '' '-std=gnu99' '-D__STDC__'
+         do
+             test -z "$arg" || CC="$CC $arg"
+             cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$ac_c_conftest_c99_program
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  eval "$as_wine_cv_crosscc_c99=\$arg"
+else case e in #(
+  e) eval "$as_wine_cv_crosscc_c99=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+             eval CC=\$${wine_arch}_CC
+             if eval test \"x\$"$as_wine_cv_crosscc_c99"\" = x"no"
+then :
+
+else case e in #(
+  e) break ;;
+esac
+fi
+         done ;;
+esac
+fi
+
+    eval res=\$$as_wine_cv_crosscc_c99
+
+    case "x$res" in
+      x) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+printf "%s\n" "none needed" >&6; } ;;
+      xno) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+printf "%s\n" "unsupported" >&6; }
+           if test ${enable_archs+y}
+then :
+  as_fn_error $? "$wine_arch PE cross-compiler supporting C99 not found.
+This is an error since --enable-archs=$wine_arch was requested." "$LINENO" 5
+fi
+           continue
+           ;;
+      x*) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $res" >&5
+printf "%s\n" "$res" >&6; }
+          as_fn_append ${wine_arch}_CC " $res" ;;
+    esac
+
+    if test "x$wine_arch" = xi386
+then :
+
+else case e in #(
+  e) as_wine_cv_seh_support=`printf "%s\n" "ac_cv_${wine_arch}_seh_support" | sed "$as_sed_sh"`
+
+               { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports SEH directives" >&5
+printf %s "checking whether $CC supports SEH directives... " >&6; }
+if eval test \${$as_wine_cv_seh_support+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+asm(".text\nac_test:\t.seh_proc ac_test\n\tnop\n\t.seh_stackalloc 16\n\t.seh_endprologue\n\t.seh_endproc");
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  eval "$as_wine_cv_seh_support=yes"
+else case e in #(
+  e) eval "$as_wine_cv_seh_support=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;
+esac
+fi
+eval ac_res=\$$as_wine_cv_seh_support
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+               eval res=\$$as_wine_cv_seh_support
+
+               if test "x$res" = xyes
+then :
+
+else case e in #(
+  e) if test ${enable_archs+y}
+then :
+  as_fn_error $? "The $wine_arch PE cross-compiler doesn't support SEH directives.
+This is an error since --enable-archs=$wine_arch was requested." "$LINENO" 5
+fi
+                          continue ;;
+esac
+fi ;;
+esac
+fi
+
+    if test "x$wine_arch" = x$extra_arch
+then :
+
+else case e in #(
+  e) as_fn_append PE_ARCHS " $wine_arch" ;;
+esac
+fi
+
+    case "$target" in
+      *-windows) wine_compiler_rt_libs="compiler-rt" ;;
+    esac
+
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-fno-strict-aliasing" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -fno-strict-aliasing" >&5
+printf %s "checking whether $CC supports -fno-strict-aliasing... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -fno-strict-aliasing"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -fno-strict-aliasing"
+fi }
+        { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Werror=unknown-warning-option" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Werror=unknown-warning-option" >&5
+printf %s "checking whether $CC supports -Werror=unknown-warning-option... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Werror=unknown-warning-option"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  CFLAGS="$CFLAGS -Werror=unknown-warning-option"
+fi }
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Werror=unused-command-line-argument" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Werror=unused-command-line-argument" >&5
+printf %s "checking whether $CC supports -Werror=unused-command-line-argument... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Werror=unused-command-line-argument"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  CFLAGS="$CFLAGS -Werror=unused-command-line-argument"
+fi }
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Werror=ignored-optimization-argument" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Werror=ignored-optimization-argument" >&5
+printf %s "checking whether $CC supports -Werror=ignored-optimization-argument... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Werror=ignored-optimization-argument"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  CFLAGS="$CFLAGS -Werror=ignored-optimization-argument"
+fi }
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Werror=unsupported-floating-point-opt" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Werror=unsupported-floating-point-opt" >&5
+printf %s "checking whether $CC supports -Werror=unsupported-floating-point-opt... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Werror=unsupported-floating-point-opt"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  CFLAGS="$CFLAGS -Werror=unsupported-floating-point-opt"
+fi }
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Wdeclaration-after-statement" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Wdeclaration-after-statement" >&5
+printf %s "checking whether $CC supports -Wdeclaration-after-statement... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Wdeclaration-after-statement"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -Wdeclaration-after-statement"
+fi }
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Wempty-body" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Wempty-body" >&5
+printf %s "checking whether $CC supports -Wempty-body... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Wempty-body"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -Wempty-body"
+fi }
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Wignored-qualifiers" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Wignored-qualifiers" >&5
+printf %s "checking whether $CC supports -Wignored-qualifiers... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Wignored-qualifiers"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -Wignored-qualifiers"
+fi }
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Winit-self" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Winit-self" >&5
+printf %s "checking whether $CC supports -Winit-self... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Winit-self"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -Winit-self"
+fi }
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Wpacked-not-aligned" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Wpacked-not-aligned" >&5
+printf %s "checking whether $CC supports -Wpacked-not-aligned... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Wpacked-not-aligned"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -Wno-packed-not-aligned"
+fi }
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Wmicrosoft-enum-forward-reference" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Wmicrosoft-enum-forward-reference" >&5
+printf %s "checking whether $CC supports -Wmicrosoft-enum-forward-reference... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Wmicrosoft-enum-forward-reference"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -Wno-microsoft-enum-forward-reference"
+fi }
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Wshift-overflow=2" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Wshift-overflow=2" >&5
+printf %s "checking whether $CC supports -Wshift-overflow=2... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Wshift-overflow=2"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -Wshift-overflow=2"
+fi }
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Wstrict-prototypes" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Wstrict-prototypes" >&5
+printf %s "checking whether $CC supports -Wstrict-prototypes... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Wstrict-prototypes"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -Wstrict-prototypes"
+fi }
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Wtype-limits" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Wtype-limits" >&5
+printf %s "checking whether $CC supports -Wtype-limits... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Wtype-limits"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -Wtype-limits"
+fi }
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Wunused-but-set-parameter" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Wunused-but-set-parameter" >&5
+printf %s "checking whether $CC supports -Wunused-but-set-parameter... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Wunused-but-set-parameter"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -Wunused-but-set-parameter"
+fi }
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Wvla" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Wvla" >&5
+printf %s "checking whether $CC supports -Wvla... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Wvla"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -Wvla"
+fi }
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Wwrite-strings" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Wwrite-strings" >&5
+printf %s "checking whether $CC supports -Wwrite-strings... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Wwrite-strings"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -Wwrite-strings"
+fi }
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Wpointer-arith" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Wpointer-arith" >&5
+printf %s "checking whether $CC supports -Wpointer-arith... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Wpointer-arith"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -Wpointer-arith"
+fi }
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Wlogical-op" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Wlogical-op" >&5
+printf %s "checking whether $CC supports -Wlogical-op... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Wlogical-op"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -Wlogical-op"
+fi }
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Wabsolute-value" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Wabsolute-value" >&5
+printf %s "checking whether $CC supports -Wabsolute-value... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Wabsolute-value"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -Wabsolute-value"
+fi }
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Wenum-enum-conversion" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Wenum-enum-conversion" >&5
+printf %s "checking whether $CC supports -Wenum-enum-conversion... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Wenum-enum-conversion"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  :
+else case e in #(
+  e) { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Wenum-conversion" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Wenum-conversion" >&5
+printf %s "checking whether $CC supports -Wenum-conversion... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Wenum-conversion"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used0x50 = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -Wenum-conversion"
+fi } ;;
+esac
+fi }
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-ffunction-sections" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -ffunction-sections" >&5
+printf %s "checking whether $CC supports -ffunction-sections... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -ffunction-sections"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -ffunction-sections"
+fi }
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-fasync-exceptions -DMIN_CLANG_VERSION=19" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -fasync-exceptions -DMIN_CLANG_VERSION=19" >&5
+printf %s "checking whether $CC supports -fasync-exceptions -DMIN_CLANG_VERSION=19... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -fasync-exceptions -DMIN_CLANG_VERSION=19"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -fasync-exceptions"
+fi }
+    { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-ffp-exception-behavior=maytrap" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -ffp-exception-behavior=maytrap" >&5
+printf %s "checking whether $CC supports -ffp-exception-behavior=maytrap... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -ffp-exception-behavior=maytrap"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -ffp-exception-behavior=maytrap"
+fi }
+
+        { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-fms-hotpatch -DMIN_CLANG_VERSION=18" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -fms-hotpatch -DMIN_CLANG_VERSION=18" >&5
+printf %s "checking whether $CC supports -fms-hotpatch -DMIN_CLANG_VERSION=18... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -fms-hotpatch -DMIN_CLANG_VERSION=18"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -fms-hotpatch"
+                        as_fn_append ${wine_arch}_LDFLAGS " -fms-hotpatch"
+fi }
+
+        { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-flarge-source-files -Wmisleading-indentation" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -flarge-source-files -Wmisleading-indentation" >&5
+printf %s "checking whether $CC supports -flarge-source-files -Wmisleading-indentation... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -flarge-source-files -Wmisleading-indentation"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -Wno-misleading-indentation"
+fi }
+
+    case $wine_arch in
+      i386) { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-fno-omit-frame-pointer" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -fno-omit-frame-pointer" >&5
+printf %s "checking whether $CC supports -fno-omit-frame-pointer... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -fno-omit-frame-pointer"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -fno-omit-frame-pointer"
+fi }
+            { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-mpreferred-stack-boundary=2" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -mpreferred-stack-boundary=2" >&5
+printf %s "checking whether $CC supports -mpreferred-stack-boundary=2... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -mpreferred-stack-boundary=2"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -mpreferred-stack-boundary=2"
+fi }
+            { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Wl,--disable-stdcall-fixup" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Wl,--disable-stdcall-fixup" >&5
+printf %s "checking whether $CC supports -Wl,--disable-stdcall-fixup... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Wl,--disable-stdcall-fixup"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_LDFLAGS " -Wl,--disable-stdcall-fixup"
+fi } ;;
+      x86_64) { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Wformat-overflow" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Wformat-overflow" >&5
+printf %s "checking whether $CC supports -Wformat-overflow... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Wformat-overflow"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -Wformat-overflow"
+fi }
+              { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Wnonnull" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Wnonnull" >&5
+printf %s "checking whether $CC supports -Wnonnull... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Wnonnull"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -Wnonnull"
+fi }
+              { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-mcx16" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -mcx16" >&5
+printf %s "checking whether $CC supports -mcx16... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -mcx16"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -mcx16"
+fi }
+              { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-mcmodel=small" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -mcmodel=small" >&5
+printf %s "checking whether $CC supports -mcmodel=small... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -mcmodel=small"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -mcmodel=small"
+fi } ;;
+    esac
+
+        wine_crossdebug=$CROSSDEBUG
+    if test -z "$wine_crossdebug"
+    then
+      ac_g_flag_seen=""
+      for ac_flag in $CFLAGS; do
+        case $ac_flag in
+         -gdwarf*)    as_fn_append wine_crossdebug " dwarf" ;;
+         -gcodeview)  as_fn_append wine_crossdebug " pdb" ;;
+         -g)          ac_g_flag_seen=$ac_flag ;;
+        esac
+      done
+      if test -n "$ac_g_flag_seen" -a -z "$wine_crossdebug"
+      then
+        wine_crossdebug=dwarf
+      fi
+    fi
+
+    ac_debug_format_seen=""
+    for ac_flag in $CFLAGS; do
+      case $ac_flag in
+       -gdwarf*|-gcodeview)  ac_debug_format_seen=$ac_flag ;;
+      esac
+    done
+    if test "x$ac_debug_format_seen" = x
+    then
+      for wine_debug_format in $wine_crossdebug
+      do
+        case $wine_debug_format in
+          *dwarf)                     { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Wl,-debug:dwarf" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Wl,-debug:dwarf" >&5
+printf %s "checking whether $CC supports -Wl,-debug:dwarf... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Wl,-debug:dwarf"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_LDFLAGS " -Wl,-debug:dwarf"
+                                                          CFLAGS="$CFLAGS -Wl,-debug:dwarf"
+fi }
+                   { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-gdwarf-4" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -gdwarf-4" >&5
+printf %s "checking whether $CC supports -gdwarf-4... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -gdwarf-4"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -gdwarf-4"
+fi } ;;
+          pdb)     { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-gcodeview" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -gcodeview" >&5
+printf %s "checking whether $CC supports -gcodeview... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -gcodeview"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -gcodeview"
+fi } ;;
+        esac
+      done
+    fi
+    eval "${wine_arch}_DEBUG=\$wine_crossdebug"
+
+    test "x$enable_werror" != xyes || { as_ac_var=`printf "%s\n" "ac_cv_${wine_arch}_cflags_-Werror" | sed "$as_sed_sh"`
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $CC supports -Werror" >&5
+printf %s "checking whether $CC supports -Werror... " >&6; }
+if eval test \${$as_ac_var+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+ac_wine_try_cflags_saved_exeext=$ac_exeext
+CFLAGS="$CFLAGS -nostdlib -nodefaultlibs -Werror"
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+void *__os_arm64x_dispatch_ret = 0;
+const unsigned int _load_config_used[0x50] = { sizeof(_load_config_used) };
+#if defined(__clang_major__) && defined(MIN_CLANG_VERSION) && __clang_major__ < MIN_CLANG_VERSION
+#error Too old clang version
+#endif
+int __cdecl mainCRTStartup(void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  eval "$as_ac_var=yes"
+else case e in #(
+  e) eval "$as_ac_var=no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved
+ac_exeext=$ac_wine_try_cflags_saved_exeext ;;
+esac
+fi
+eval ac_res=\$$as_ac_var
+	       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+printf "%s\n" "$ac_res" >&6; }
+if eval test \"x\$"$as_ac_var"\" = x"yes"
+then :
+  as_fn_append ${wine_arch}_EXTRACFLAGS " -Werror"
+fi }
+            test "x$enable_build_id" != xyes || as_fn_append ${wine_arch}_LDFLAGS " -Wl,--build-id"
+
+done
+
+CC=$saved_CC
+CFLAGS=$saved_CFLAGS
+CPPFLAGS=$saved_CPPFLAGS
+LDFLAGS=$saved_LDFLAGS
+
+case $HOST_ARCH in
+  arm|aarch64)
+    test "x$PE_ARCHS" != x || as_fn_error $? "PE cross-compilation is required for $HOST_ARCH, please install clang/llvm-dlltool/lld, or llvm-mingw." "$LINENO" 5
+    DLLEXT="" ;;
+  *)
+    DLLEXT=".so"
+
+    if test "x$PE_ARCHS" = "x"
+then :
+  case "x$with_mingw" in
+  x)   as_fn_append wine_warnings "|Suitable PE cross-compiler not found, you should install mingw-w64 or llvm-mingw." ;;
+  xno) ;;
+  *)   as_fn_error $? "Suitable PE cross-compiler not found, you should install mingw-w64 or llvm-mingw.
+This is an error since --with-mingw was requested." "$LINENO" 5 ;;
+esac
+
+fi ;;
+esac
+
+
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for i386_set_ldt in -li386" >&5
+printf %s "checking for i386_set_ldt in -li386... " >&6; }
+if test ${ac_cv_lib_i386_i386_set_ldt+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-li386  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char i386_set_ldt (void);
+int
+main (void)
+{
+return i386_set_ldt ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_i386_i386_set_ldt=yes
+else case e in #(
+  e) ac_cv_lib_i386_i386_set_ldt=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_i386_i386_set_ldt" >&5
+printf "%s\n" "$ac_cv_lib_i386_i386_set_ldt" >&6; }
+if test "x$ac_cv_lib_i386_i386_set_ldt" = xyes
+then :
+  I386_LIBS="-li386"
+
+fi
+
+
+OPENGL_LIBS=""
+
+
+
+# Check whether --enable-largefile was given.
+if test ${enable_largefile+y}
+then :
+  enableval=$enable_largefile;
+fi
+if test "$enable_largefile,$enable_year2038" != no,no
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CPPFLAGS option for large files" >&5
+printf %s "checking for $CPPFLAGS option for large files... " >&6; }
+if test ${ac_cv_sys_largefile_opts+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_save_CPPFLAGS=$CPPFLAGS
+  ac_opt_found=no
+  for ac_opt in "none needed" "-D_FILE_OFFSET_BITS=64" "-D_LARGE_FILES=1"; do
+    if test x"$ac_opt" != x"none needed"
+then :
+  CPPFLAGS="$ac_save_CPPFLAGS $ac_opt"
+fi
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/types.h>
+#ifndef FTYPE
+# define FTYPE off_t
+#endif
+ /* Check that FTYPE can represent 2**63 - 1 correctly.
+    We can't simply define LARGE_FTYPE to be 9223372036854775807,
+    since some C++ compilers masquerading as C compilers
+    incorrectly reject 9223372036854775807.  */
+#define LARGE_FTYPE (((FTYPE) 1 << 31 << 31) - 1 + ((FTYPE) 1 << 31 << 31))
+  int FTYPE_is_large[(LARGE_FTYPE % 2147483629 == 721
+		       && LARGE_FTYPE % 2147483647 == 1)
+		      ? 1 : -1];
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  if test x"$ac_opt" = x"none needed"
+then :
+  # GNU/Linux s390x and alpha need _FILE_OFFSET_BITS=64 for wide ino_t.
+	 CPPFLAGS="$CPPFLAGS -DFTYPE=ino_t"
+	 if ac_fn_c_try_compile "$LINENO"
+then :
+
+else case e in #(
+  e) CPPFLAGS="$CPPFLAGS -D_FILE_OFFSET_BITS=64"
+	    if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_opt='-D_FILE_OFFSET_BITS=64'
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam
+fi
+      ac_cv_sys_largefile_opts=$ac_opt
+      ac_opt_found=yes
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+    test $ac_opt_found = no || break
+  done
+  CPPFLAGS=$ac_save_CPPFLAGS
+
+  test $ac_opt_found = yes || ac_cv_sys_largefile_opts="support not detected" ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_largefile_opts" >&5
+printf "%s\n" "$ac_cv_sys_largefile_opts" >&6; }
+
+ac_have_largefile=yes
+case $ac_cv_sys_largefile_opts in #(
+  "none needed") :
+     ;; #(
+  "supported through gnulib") :
+     ;; #(
+  "support not detected") :
+    ac_have_largefile=no ;; #(
+  "-D_FILE_OFFSET_BITS=64") :
+
+printf "%s\n" "#define _FILE_OFFSET_BITS 64" >>confdefs.h
+ ;; #(
+  "-D_LARGE_FILES=1") :
+
+printf "%s\n" "#define _LARGE_FILES 1" >>confdefs.h
+ ;; #(
+  *) :
+    as_fn_error $? "internal error: bad value for \$ac_cv_sys_largefile_opts" "$LINENO" 5 ;;
+esac
+
+if test "$enable_year2038" != no
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $CPPFLAGS option for timestamps after 2038" >&5
+printf %s "checking for $CPPFLAGS option for timestamps after 2038... " >&6; }
+if test ${ac_cv_sys_year2038_opts+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_save_CPPFLAGS="$CPPFLAGS"
+  ac_opt_found=no
+  for ac_opt in "none needed" "-D_TIME_BITS=64" "-D__MINGW_USE_VC2005_COMPAT" "-U_USE_32_BIT_TIME_T -D__MINGW_USE_VC2005_COMPAT"; do
+    if test x"$ac_opt" != x"none needed"
+then :
+  CPPFLAGS="$ac_save_CPPFLAGS $ac_opt"
+fi
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+  #include <time.h>
+  /* Check that time_t can represent 2**32 - 1 correctly.  */
+  #define LARGE_TIME_T \\
+    ((time_t) (((time_t) 1 << 30) - 1 + 3 * ((time_t) 1 << 30)))
+  int verify_time_t_range[(LARGE_TIME_T / 65537 == 65535
+                           && LARGE_TIME_T % 65537 == 0)
+                          ? 1 : -1];
+
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_sys_year2038_opts="$ac_opt"
+      ac_opt_found=yes
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+    test $ac_opt_found = no || break
+  done
+  CPPFLAGS="$ac_save_CPPFLAGS"
+  test $ac_opt_found = yes || ac_cv_sys_year2038_opts="support not detected" ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_sys_year2038_opts" >&5
+printf "%s\n" "$ac_cv_sys_year2038_opts" >&6; }
+
+ac_have_year2038=yes
+case $ac_cv_sys_year2038_opts in #(
+  "none needed") :
+     ;; #(
+  "support not detected") :
+    ac_have_year2038=no ;; #(
+  "-D_TIME_BITS=64") :
+
+printf "%s\n" "#define _TIME_BITS 64" >>confdefs.h
+ ;; #(
+  "-D__MINGW_USE_VC2005_COMPAT") :
+
+printf "%s\n" "#define __MINGW_USE_VC2005_COMPAT 1" >>confdefs.h
+ ;; #(
+  "-U_USE_32_BIT_TIME_T"*) :
+    { { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in '$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in '$ac_pwd':" >&2;}
+as_fn_error $? "the 'time_t' type is currently forced to be 32-bit. It
+will stop working after mid-January 2038. Remove
+_USE_32BIT_TIME_T from the compiler flags.
+See 'config.log' for more details" "$LINENO" 5; } ;; #(
+  *) :
+    as_fn_error $? "internal error: bad value for \$ac_cv_sys_year2038_opts" "$LINENO" 5 ;;
+esac
+
+fi
+
+fi
+if false
+then :
+  if test "$enable_year2038,$ac_have_year2038,$cross_compiling" = yes,no,no
+then :
+  # If we're not cross compiling and 'touch' works with a large
+  # timestamp, then we can presume the system supports wider time_t
+  # *somehow* and we just weren't able to detect it.  One common
+  # case that we deliberately *don't* probe for is a system that
+  # supports both 32- and 64-bit ABIs but only the 64-bit ABI offers
+  # wide time_t.  (It would be inappropriate for us to override an
+  # intentional use of -m32.)  Error out, demanding use of
+  # --disable-year2038 if this is intentional.
+  if TZ=UTC0 touch -t 210602070628.15 conftest.time 2>/dev/null
+then :
+  case `TZ=UTC0 LC_ALL=C ls -l conftest.time 2>/dev/null` in #(
+  *'Feb  7  2106'* | *'Feb  7 17:10'*) :
+    { { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in '$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in '$ac_pwd':" >&2;}
+as_fn_error $? "this system appears to support timestamps after
+mid-January 2038, but no mechanism for enabling wide
+'time_t' was detected. Did you mean to build a 64-bit
+binary? (E.g., 'CC=\"${CC} -m64\"'.) To proceed with
+32-bit time_t, configure with '--disable-year2038'.
+See 'config.log' for more details" "$LINENO" 5; } ;; #(
+  *) :
+     ;;
+esac
+fi
+fi
+fi
+
+ac_header= ac_cache=
+for ac_item in $ac_header_c_list
+do
+  if test $ac_cache; then
+    ac_fn_c_check_header_compile "$LINENO" $ac_header ac_cv_header_$ac_cache "$ac_includes_default"
+    if eval test \"x\$ac_cv_header_$ac_cache\" = xyes; then
+      printf "%s\n" "#define $ac_item 1" >> confdefs.h
+    fi
+    ac_header= ac_cache=
+  elif test $ac_header; then
+    ac_cache=$ac_item
+  else
+    ac_header=$ac_item
+  fi
+done
+
+
+
+
+
+
+
+
+if test $ac_cv_header_stdlib_h = yes && test $ac_cv_header_string_h = yes
+then :
+
+printf "%s\n" "#define STDC_HEADERS 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "CL/cl.h" "ac_cv_header_CL_cl_h" "$ac_includes_default"
+if test "x$ac_cv_header_CL_cl_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_CL_CL_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "OpenCL/opencl.h" "ac_cv_header_OpenCL_opencl_h" "$ac_includes_default"
+if test "x$ac_cv_header_OpenCL_opencl_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_OPENCL_OPENCL_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "arpa/inet.h" "ac_cv_header_arpa_inet_h" "$ac_includes_default"
+if test "x$ac_cv_header_arpa_inet_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_ARPA_INET_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "arpa/nameser.h" "ac_cv_header_arpa_nameser_h" "$ac_includes_default"
+if test "x$ac_cv_header_arpa_nameser_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_ARPA_NAMESER_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "asm/termbits.h" "ac_cv_header_asm_termbits_h" "$ac_includes_default"
+if test "x$ac_cv_header_asm_termbits_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_ASM_TERMBITS_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "asm/types.h" "ac_cv_header_asm_types_h" "$ac_includes_default"
+if test "x$ac_cv_header_asm_types_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_ASM_TYPES_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "asm/user.h" "ac_cv_header_asm_user_h" "$ac_includes_default"
+if test "x$ac_cv_header_asm_user_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_ASM_USER_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "bluetooth/bluetooth.h" "ac_cv_header_bluetooth_bluetooth_h" "$ac_includes_default"
+if test "x$ac_cv_header_bluetooth_bluetooth_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_BLUETOOTH_BLUETOOTH_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "elf.h" "ac_cv_header_elf_h" "$ac_includes_default"
+if test "x$ac_cv_header_elf_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_ELF_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "gettext-po.h" "ac_cv_header_gettext_po_h" "$ac_includes_default"
+if test "x$ac_cv_header_gettext_po_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_GETTEXT_PO_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "link.h" "ac_cv_header_link_h" "$ac_includes_default"
+if test "x$ac_cv_header_link_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINK_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/cdrom.h" "ac_cv_header_linux_cdrom_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_cdrom_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_CDROM_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/filter.h" "ac_cv_header_linux_filter_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_filter_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_FILTER_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/fs.h" "ac_cv_header_linux_fs_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_fs_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_FS_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/hdreg.h" "ac_cv_header_linux_hdreg_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_hdreg_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_HDREG_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/hidraw.h" "ac_cv_header_linux_hidraw_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_hidraw_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_HIDRAW_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/input.h" "ac_cv_header_linux_input_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_input_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_INPUT_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/ioctl.h" "ac_cv_header_linux_ioctl_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_ioctl_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_IOCTL_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/major.h" "ac_cv_header_linux_major_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_major_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_MAJOR_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/ntsync.h" "ac_cv_header_linux_ntsync_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_ntsync_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_NTSYNC_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/param.h" "ac_cv_header_linux_param_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_param_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_PARAM_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/serial.h" "ac_cv_header_linux_serial_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_serial_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_SERIAL_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/types.h" "ac_cv_header_linux_types_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_types_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_TYPES_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/ucdrom.h" "ac_cv_header_linux_ucdrom_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_ucdrom_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_UCDROM_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/userfaultfd.h" "ac_cv_header_linux_userfaultfd_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_userfaultfd_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_USERFAULTFD_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/wireless.h" "ac_cv_header_linux_wireless_h" "$ac_includes_default"
+if test "x$ac_cv_header_linux_wireless_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_WIRELESS_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "lwp.h" "ac_cv_header_lwp_h" "$ac_includes_default"
+if test "x$ac_cv_header_lwp_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LWP_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "mach-o/loader.h" "ac_cv_header_mach_o_loader_h" "$ac_includes_default"
+if test "x$ac_cv_header_mach_o_loader_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_MACH_O_LOADER_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "mach/mach.h" "ac_cv_header_mach_mach_h" "$ac_includes_default"
+if test "x$ac_cv_header_mach_mach_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_MACH_MACH_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "machine/cpu.h" "ac_cv_header_machine_cpu_h" "$ac_includes_default"
+if test "x$ac_cv_header_machine_cpu_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_MACHINE_CPU_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "machine/sysarch.h" "ac_cv_header_machine_sysarch_h" "$ac_includes_default"
+if test "x$ac_cv_header_machine_sysarch_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_MACHINE_SYSARCH_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "mntent.h" "ac_cv_header_mntent_h" "$ac_includes_default"
+if test "x$ac_cv_header_mntent_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_MNTENT_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "netdb.h" "ac_cv_header_netdb_h" "$ac_includes_default"
+if test "x$ac_cv_header_netdb_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETDB_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "netinet/in.h" "ac_cv_header_netinet_in_h" "$ac_includes_default"
+if test "x$ac_cv_header_netinet_in_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_IN_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "netinet/in_systm.h" "ac_cv_header_netinet_in_systm_h" "$ac_includes_default"
+if test "x$ac_cv_header_netinet_in_systm_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_IN_SYSTM_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "netinet/tcp.h" "ac_cv_header_netinet_tcp_h" "$ac_includes_default"
+if test "x$ac_cv_header_netinet_tcp_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_TCP_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "netinet/tcp_fsm.h" "ac_cv_header_netinet_tcp_fsm_h" "$ac_includes_default"
+if test "x$ac_cv_header_netinet_tcp_fsm_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_TCP_FSM_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "pcap/pcap.h" "ac_cv_header_pcap_pcap_h" "$ac_includes_default"
+if test "x$ac_cv_header_pcap_pcap_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_PCAP_PCAP_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "port.h" "ac_cv_header_port_h" "$ac_includes_default"
+if test "x$ac_cv_header_port_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_PORT_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "pwd.h" "ac_cv_header_pwd_h" "$ac_includes_default"
+if test "x$ac_cv_header_pwd_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_PWD_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sched.h" "ac_cv_header_sched_h" "$ac_includes_default"
+if test "x$ac_cv_header_sched_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SCHED_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "scsi/scsi.h" "ac_cv_header_scsi_scsi_h" "$ac_includes_default"
+if test "x$ac_cv_header_scsi_scsi_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SCSI_SCSI_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "scsi/scsi_ioctl.h" "ac_cv_header_scsi_scsi_ioctl_h" "$ac_includes_default"
+if test "x$ac_cv_header_scsi_scsi_ioctl_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SCSI_SCSI_IOCTL_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "scsi/sg.h" "ac_cv_header_scsi_sg_h" "$ac_includes_default"
+if test "x$ac_cv_header_scsi_sg_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SCSI_SG_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/attr.h" "ac_cv_header_sys_attr_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_attr_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_ATTR_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/auxv.h" "ac_cv_header_sys_auxv_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_auxv_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_AUXV_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/cdio.h" "ac_cv_header_sys_cdio_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_cdio_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_CDIO_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/epoll.h" "ac_cv_header_sys_epoll_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_epoll_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_EPOLL_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/event.h" "ac_cv_header_sys_event_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_event_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_EVENT_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/extattr.h" "ac_cv_header_sys_extattr_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_extattr_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_EXTATTR_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/filio.h" "ac_cv_header_sys_filio_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_filio_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_FILIO_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/ipc.h" "ac_cv_header_sys_ipc_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_ipc_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_IPC_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/link.h" "ac_cv_header_sys_link_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_link_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_LINK_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/modem.h" "ac_cv_header_sys_modem_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_modem_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_MODEM_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/mtio.h" "ac_cv_header_sys_mtio_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_mtio_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_MTIO_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/param.h" "ac_cv_header_sys_param_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_param_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_PARAM_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/prctl.h" "ac_cv_header_sys_prctl_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_prctl_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_PRCTL_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/ptrace.h" "ac_cv_header_sys_ptrace_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_ptrace_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_PTRACE_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/queue.h" "ac_cv_header_sys_queue_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_queue_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_QUEUE_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/random.h" "ac_cv_header_sys_random_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_random_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_RANDOM_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/resource.h" "ac_cv_header_sys_resource_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_resource_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_RESOURCE_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/scsiio.h" "ac_cv_header_sys_scsiio_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_scsiio_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_SCSIIO_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/shm.h" "ac_cv_header_sys_shm_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_shm_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_SHM_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/signal.h" "ac_cv_header_sys_signal_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_signal_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_SIGNAL_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/socketvar.h" "ac_cv_header_sys_socketvar_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_socketvar_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_SOCKETVAR_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/sockio.h" "ac_cv_header_sys_sockio_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_sockio_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_SOCKIO_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/statvfs.h" "ac_cv_header_sys_statvfs_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_statvfs_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_STATVFS_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/strtio.h" "ac_cv_header_sys_strtio_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_strtio_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_STRTIO_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/syscall.h" "ac_cv_header_sys_syscall_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_syscall_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_SYSCALL_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/sysinfo.h" "ac_cv_header_sys_sysinfo_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_sysinfo_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_SYSINFO_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/times.h" "ac_cv_header_sys_times_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_times_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_TIMES_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/uio.h" "ac_cv_header_sys_uio_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_uio_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_UIO_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/user.h" "ac_cv_header_sys_user_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_user_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_USER_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/utsname.h" "ac_cv_header_sys_utsname_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_utsname_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_UTSNAME_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/vnode.h" "ac_cv_header_sys_vnode_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_vnode_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_VNODE_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/xattr.h" "ac_cv_header_sys_xattr_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_xattr_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_XATTR_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "syscall.h" "ac_cv_header_syscall_h" "$ac_includes_default"
+if test "x$ac_cv_header_syscall_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYSCALL_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "utime.h" "ac_cv_header_utime_h" "$ac_includes_default"
+if test "x$ac_cv_header_utime_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_UTIME_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "valgrind/memcheck.h" "ac_cv_header_valgrind_memcheck_h" "$ac_includes_default"
+if test "x$ac_cv_header_valgrind_memcheck_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_VALGRIND_MEMCHECK_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "valgrind/valgrind.h" "ac_cv_header_valgrind_valgrind_h" "$ac_includes_default"
+if test "x$ac_cv_header_valgrind_valgrind_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_VALGRIND_VALGRIND_H 1" >>confdefs.h
+
+fi
+
+
+ac_fn_c_check_header_compile "$LINENO" "sys/mkdev.h" "ac_cv_header_sys_mkdev_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_mkdev_h" = xyes
+then :
+
+printf "%s\n" "#define MAJOR_IN_MKDEV 1" >>confdefs.h
+
+fi
+
+if test $ac_cv_header_sys_mkdev_h = no; then
+  ac_fn_c_check_header_compile "$LINENO" "sys/sysmacros.h" "ac_cv_header_sys_sysmacros_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_sysmacros_h" = xyes
+then :
+
+printf "%s\n" "#define MAJOR_IN_SYSMACROS 1" >>confdefs.h
+
+fi
+
+fi
+
+
+
+ac_fn_c_check_header_compile "$LINENO" "sys/conf.h" "ac_cv_header_sys_conf_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_PARAM_H
+     # include <sys/param.h>
+     #endif
+"
+if test "x$ac_cv_header_sys_conf_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_CONF_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/mount.h" "ac_cv_header_sys_mount_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_PARAM_H
+     # include <sys/param.h>
+     #endif
+"
+if test "x$ac_cv_header_sys_mount_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_MOUNT_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/statfs.h" "ac_cv_header_sys_statfs_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_PARAM_H
+     # include <sys/param.h>
+     #endif
+"
+if test "x$ac_cv_header_sys_statfs_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_STATFS_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/user.h" "ac_cv_header_sys_user_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_PARAM_H
+     # include <sys/param.h>
+     #endif
+"
+if test "x$ac_cv_header_sys_user_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_USER_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/vfs.h" "ac_cv_header_sys_vfs_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_PARAM_H
+     # include <sys/param.h>
+     #endif
+"
+if test "x$ac_cv_header_sys_vfs_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_VFS_H 1" >>confdefs.h
+
+fi
+
+
+saved_sysctl_h_CFLAGS=$CFLAGS
+test "x${GCC}" != xyes || CFLAGS="$CFLAGS -Werror"
+ac_fn_c_check_header_compile "$LINENO" "sys/sysctl.h" "ac_cv_header_sys_sysctl_h" "#include <sys/types.h>
+     #ifdef HAVE_SYS_PARAM_H
+     # include <sys/param.h>
+     #endif
+"
+if test "x$ac_cv_header_sys_sysctl_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_SYSCTL_H 1" >>confdefs.h
+
+fi
+
+CFLAGS=$saved_sysctl_h_CFLAGS
+
+ac_fn_c_check_header_compile "$LINENO" "netinet/ip.h" "ac_cv_header_netinet_ip_h" "#include <sys/types.h>
+     #include <sys/socket.h>
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_netinet_ip_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_IP_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "net/if.h" "ac_cv_header_net_if_h" "#include <sys/types.h>
+     #include <sys/socket.h>
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_net_if_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NET_IF_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "net/if_arp.h" "ac_cv_header_net_if_arp_h" "#include <sys/types.h>
+     #include <sys/socket.h>
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_net_if_arp_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NET_IF_ARP_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "net/if_dl.h" "ac_cv_header_net_if_dl_h" "#include <sys/types.h>
+     #include <sys/socket.h>
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_net_if_dl_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NET_IF_DL_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "net/if_types.h" "ac_cv_header_net_if_types_h" "#include <sys/types.h>
+     #include <sys/socket.h>
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_net_if_types_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NET_IF_TYPES_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "net/route.h" "ac_cv_header_net_route_h" "#include <sys/types.h>
+     #include <sys/socket.h>
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_net_route_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NET_ROUTE_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "netinet/if_ether.h" "ac_cv_header_netinet_if_ether_h" "#include <sys/types.h>
+     #include <sys/socket.h>
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_netinet_if_ether_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_IF_ETHER_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "netinet/in_pcb.h" "ac_cv_header_netinet_in_pcb_h" "#include <sys/types.h>
+     #include <sys/socket.h>
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_netinet_in_pcb_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_IN_PCB_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "netinet/ip_icmp.h" "ac_cv_header_netinet_ip_icmp_h" "#include <sys/types.h>
+     #include <sys/socket.h>
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_netinet_ip_icmp_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_IP_ICMP_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "netinet/ip_var.h" "ac_cv_header_netinet_ip_var_h" "#include <sys/types.h>
+     #include <sys/socket.h>
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_netinet_ip_var_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_IP_VAR_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "netinet/udp.h" "ac_cv_header_netinet_udp_h" "#include <sys/types.h>
+     #include <sys/socket.h>
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_netinet_udp_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_UDP_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "netinet6/ip6_var.h" "ac_cv_header_netinet6_ip6_var_h" "#include <sys/types.h>
+     #include <sys/socket.h>
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_netinet6_ip6_var_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET6_IP6_VAR_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "netipx/ipx.h" "ac_cv_header_netipx_ipx_h" "#include <sys/types.h>
+     #include <sys/socket.h>
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_netipx_ipx_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETIPX_IPX_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "sys/un.h" "ac_cv_header_sys_un_h" "#include <sys/types.h>
+     #include <sys/socket.h>
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NET_ROUTE_H
+     # include <net/route.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NET_IF_H
+     # include <net/if.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+"
+if test "x$ac_cv_header_sys_un_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_UN_H 1" >>confdefs.h
+
+fi
+
+
+ac_fn_c_check_header_compile "$LINENO" "netinet/udp_var.h" "ac_cv_header_netinet_udp_var_h" "#include <sys/types.h>
+     #include <sys/socket.h>
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_VAR_H
+     # include <netinet/ip_var.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_ICMP_H
+     # include <netinet/ip_icmp.h>
+     #endif
+     #ifdef HAVE_NETINET_UDP_H
+     # include <netinet/udp.h>
+     #endif
+     #ifdef HAVE_NETINET_TCP_H
+     # include <netinet/tcp.h>
+     #endif
+"
+if test "x$ac_cv_header_netinet_udp_var_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_UDP_VAR_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "netinet/icmp_var.h" "ac_cv_header_netinet_icmp_var_h" "#include <sys/types.h>
+     #include <sys/socket.h>
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_VAR_H
+     # include <netinet/ip_var.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_ICMP_H
+     # include <netinet/ip_icmp.h>
+     #endif
+     #ifdef HAVE_NETINET_UDP_H
+     # include <netinet/udp.h>
+     #endif
+     #ifdef HAVE_NETINET_TCP_H
+     # include <netinet/tcp.h>
+     #endif
+"
+if test "x$ac_cv_header_netinet_icmp_var_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_ICMP_VAR_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "netinet/icmp6.h" "ac_cv_header_netinet_icmp6_h" "#include <sys/types.h>
+     #include <sys/socket.h>
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_VAR_H
+     # include <netinet/ip_var.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_ICMP_H
+     # include <netinet/ip_icmp.h>
+     #endif
+     #ifdef HAVE_NETINET_UDP_H
+     # include <netinet/udp.h>
+     #endif
+     #ifdef HAVE_NETINET_TCP_H
+     # include <netinet/tcp.h>
+     #endif
+"
+if test "x$ac_cv_header_netinet_icmp6_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_ICMP6_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "netinet/tcp_var.h" "ac_cv_header_netinet_tcp_var_h" "#include <sys/types.h>
+     #include <sys/socket.h>
+     #ifdef HAVE_SYS_SOCKETVAR_H
+     # include <sys/socketvar.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_NETINET_IN_SYSTM_H
+     # include <netinet/in_systm.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_H
+     # include <netinet/ip.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_VAR_H
+     # include <netinet/ip_var.h>
+     #endif
+     #ifdef HAVE_NETINET_IP_ICMP_H
+     # include <netinet/ip_icmp.h>
+     #endif
+     #ifdef HAVE_NETINET_UDP_H
+     # include <netinet/udp.h>
+     #endif
+     #ifdef HAVE_NETINET_TCP_H
+     # include <netinet/tcp.h>
+     #endif
+"
+if test "x$ac_cv_header_netinet_tcp_var_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_NETINET_TCP_VAR_H 1" >>confdefs.h
+
+fi
+
+
+ac_fn_c_check_header_compile "$LINENO" "linux/ipx.h" "ac_cv_header_linux_ipx_h" "#include <sys/types.h>
+     #include <sys/socket.h>
+     #ifdef HAVE_ASM_TYPES_H
+     # include <asm/types.h>
+     #endif
+     #ifdef HAVE_LINUX_TYPES_H
+     # include <linux/types.h>
+     #endif
+"
+if test "x$ac_cv_header_linux_ipx_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_IPX_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/irda.h" "ac_cv_header_linux_irda_h" "#include <sys/types.h>
+     #include <sys/socket.h>
+     #ifdef HAVE_ASM_TYPES_H
+     # include <asm/types.h>
+     #endif
+     #ifdef HAVE_LINUX_TYPES_H
+     # include <linux/types.h>
+     #endif
+"
+if test "x$ac_cv_header_linux_irda_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_IRDA_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/rtnetlink.h" "ac_cv_header_linux_rtnetlink_h" "#include <sys/types.h>
+     #include <sys/socket.h>
+     #ifdef HAVE_ASM_TYPES_H
+     # include <asm/types.h>
+     #endif
+     #ifdef HAVE_LINUX_TYPES_H
+     # include <linux/types.h>
+     #endif
+"
+if test "x$ac_cv_header_linux_rtnetlink_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_RTNETLINK_H 1" >>confdefs.h
+
+fi
+
+
+ac_fn_c_check_header_compile "$LINENO" "resolv.h" "ac_cv_header_resolv_h" "#include <sys/types.h>
+     #include <sys/socket.h>
+     #ifdef HAVE_NETINET_IN_H
+     # include <netinet/in.h>
+     #endif
+     #ifdef HAVE_ARPA_NAMESER_H
+     # include <arpa/nameser.h>
+     #endif
+"
+if test "x$ac_cv_header_resolv_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_RESOLV_H 1" >>confdefs.h
+
+fi
+
+
+ac_fn_c_check_header_compile "$LINENO" "ifaddrs.h" "ac_cv_header_ifaddrs_h" "#include <sys/types.h>
+"
+if test "x$ac_cv_header_ifaddrs_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_IFADDRS_H 1" >>confdefs.h
+
+fi
+
+
+ac_fn_c_check_header_compile "$LINENO" "sys/ucontext.h" "ac_cv_header_sys_ucontext_h" "#include <signal.h>
+"
+if test "x$ac_cv_header_sys_ucontext_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_UCONTEXT_H 1" >>confdefs.h
+
+fi
+
+
+ac_fn_c_check_header_compile "$LINENO" "sys/thr.h" "ac_cv_header_sys_thr_h" "#include <sys/types.h>
+#ifdef HAVE_SYS_UCONTEXT_H
+#include <sys/ucontext.h>
+#endif
+"
+if test "x$ac_cv_header_sys_thr_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_THR_H 1" >>confdefs.h
+
+fi
+
+
+ac_fn_c_check_header_compile "$LINENO" "pthread_np.h" "ac_cv_header_pthread_np_h" "#include <pthread.h>
+"
+if test "x$ac_cv_header_pthread_np_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_PTHREAD_NP_H 1" >>confdefs.h
+
+fi
+
+
+ac_fn_c_check_header_compile "$LINENO" "linux/videodev2.h" "ac_cv_header_linux_videodev2_h" "#include <sys/time.h>
+#include <sys/types.h>
+#ifdef HAVE_ASM_TYPES_H
+#include <asm/types.h>
+#endif
+"
+if test "x$ac_cv_header_linux_videodev2_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_VIDEODEV2_H 1" >>confdefs.h
+
+fi
+
+
+ac_fn_c_check_header_compile "$LINENO" "libprocstat.h" "ac_cv_header_libprocstat_h" "#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#include <sys/socket.h>
+#ifdef HAVE_SYS_QUEUE_H
+#include <sys/queue.h>
+#endif
+"
+if test "x$ac_cv_header_libprocstat_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LIBPROCSTAT_H 1" >>confdefs.h
+
+fi
+
+
+ac_fn_c_check_header_compile "$LINENO" "bluetooth/rfcomm.h" "ac_cv_header_bluetooth_rfcomm_h" "#ifdef HAVE_BLUETOOTH_BLUETOOTH_H
+#include <bluetooth/bluetooth.h>
+#endif
+"
+if test "x$ac_cv_header_bluetooth_rfcomm_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_BLUETOOTH_RFCOMM_H 1" >>confdefs.h
+
+fi
+
+
+if test "x$ac_cv_header_sys_xattr_h" = xyes
+then
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether getxattr takes additional arguments" >&5
+printf %s "checking whether getxattr takes additional arguments... " >&6; }
+if test ${wine_cv_xattr_extra_args+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/xattr.h>
+int
+main (void)
+{
+getxattr("", "", "", 0, 0, 0);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  wine_cv_xattr_extra_args=yes
+else case e in #(
+  e) wine_cv_xattr_extra_args=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_xattr_extra_args" >&5
+printf "%s\n" "$wine_cv_xattr_extra_args" >&6; }
+    test $wine_cv_xattr_extra_args != yes ||
+printf "%s\n" "#define XATTR_ADDITIONAL_OPTIONS 1" >>confdefs.h
+
+fi
+
+
+DLLFLAGS=""
+
+LDDLLFLAGS=""
+
+LDEXECFLAGS=""
+
+EXTRACFLAGS=""
+
+UNIXDLLFLAGS="-fPIC"
+
+UNIXLDFLAGS="-shared -Wl,-Bsymbolic -Wl,-soname,\$(UNIXLIB)"
+
+TOP_INSTALL_LIB=""
+
+TOP_INSTALL_DEV=""
+
+WINELOADER_LDFLAGS=""
+
+WINEPRELOADER_LDFLAGS=""
+
+LIBEXT="so"
+# Extract the first word of "ldd", so it can be a program name with args.
+set dummy ldd; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_path_LDD+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) case $LDD in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_LDD="$LDD" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+as_dummy="/sbin:/usr/sbin:$PATH"
+for as_dir in $as_dummy
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_path_LDD="$as_dir$ac_word$ac_exec_ext"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_LDD" && ac_cv_path_LDD="true"
+  ;;
+esac ;;
+esac
+fi
+LDD=$ac_cv_path_LDD
+if test -n "$LDD"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $LDD" >&5
+printf "%s\n" "$LDD" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}otool", so it can be a program name with args.
+set dummy ${ac_tool_prefix}otool; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_OTOOL+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$OTOOL"; then
+  ac_cv_prog_OTOOL="$OTOOL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_OTOOL="${ac_tool_prefix}otool"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+OTOOL=$ac_cv_prog_OTOOL
+if test -n "$OTOOL"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $OTOOL" >&5
+printf "%s\n" "$OTOOL" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_OTOOL"; then
+  ac_ct_OTOOL=$OTOOL
+  # Extract the first word of "otool", so it can be a program name with args.
+set dummy otool; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_OTOOL+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$ac_ct_OTOOL"; then
+  ac_cv_prog_ac_ct_OTOOL="$ac_ct_OTOOL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_OTOOL="otool"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+ac_ct_OTOOL=$ac_cv_prog_ac_ct_OTOOL
+if test -n "$ac_ct_OTOOL"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL" >&5
+printf "%s\n" "$ac_ct_OTOOL" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+  if test "x$ac_ct_OTOOL" = x; then
+    OTOOL="otool"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    OTOOL=$ac_ct_OTOOL
+  fi
+else
+  OTOOL="$ac_cv_prog_OTOOL"
+fi
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}readelf", so it can be a program name with args.
+set dummy ${ac_tool_prefix}readelf; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_READELF+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$READELF"; then
+  ac_cv_prog_READELF="$READELF" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_READELF="${ac_tool_prefix}readelf"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+READELF=$ac_cv_prog_READELF
+if test -n "$READELF"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $READELF" >&5
+printf "%s\n" "$READELF" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_READELF"; then
+  ac_ct_READELF=$READELF
+  # Extract the first word of "readelf", so it can be a program name with args.
+set dummy readelf; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_READELF+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$ac_ct_READELF"; then
+  ac_cv_prog_ac_ct_READELF="$ac_ct_READELF" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_READELF="readelf"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+ac_ct_READELF=$ac_cv_prog_ac_ct_READELF
+if test -n "$ac_ct_READELF"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_READELF" >&5
+printf "%s\n" "$ac_ct_READELF" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+  if test "x$ac_ct_READELF" = x; then
+    READELF="true"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    READELF=$ac_ct_READELF
+  fi
+else
+  READELF="$ac_cv_prog_READELF"
+fi
+
+wine_rules="all:
+	@echo 'Wine build complete.'"
+SUBDIRS=""
+
+DISABLED_SUBDIRS=""
+
+CONFIGURE_TARGETS=""
+
+
+wine_fn_config_makefile ()
+{
+    as_fn_append SUBDIRS " \\$as_nl	$1"
+    eval enable=\$$2
+    case "$enable" in
+      no) as_fn_append DISABLED_SUBDIRS " $1" ;;
+      yes) ;;
+      *aarch64*|*arm*|*i386*|*x86_64*)
+        if test -n "$PE_ARCHS" -a "$PE_ARCHS" != none
+        then
+            for i in $PE_ARCHS
+            do
+                test $(expr ",$enable," : ".*,$i,") -gt 0 || as_fn_append ${i}_DISABLED_SUBDIRS " $1"
+            done
+        else
+            test $(expr ",$enable," : ".*,$HOST_ARCH,") -gt 0 || as_fn_append DISABLED_SUBDIRS " $1"
+        fi ;;
+      "")
+        case "$1, $PE_ARCHS " in
+          programs/*,*\ arm64ec\ *) as_fn_append arm64ec_DISABLED_SUBDIRS " $1" ;;
+        esac ;;
+    esac
+}
+
+case $host_os in
+  cygwin*|mingw32*)
+    LIBEXT="dll"
+    DLLEXT=""
+    EXTRACFLAGS="-D__WINE_PE_BUILD"
+        enable_loader=${enable_loader:-no}
+    enable_server=${enable_server:-no}
+    enable_wine=${enable_wine:-no}
+        with_x=${with_x:-no}
+    with_pthread=${with_pthread:-no}
+    ;;
+
+  darwin*)
+    LIBEXT="dylib"
+    DLLFLAGS="$DLLFLAGS -fPIC"
+    LDDLLFLAGS="-fPIC"
+    enable_winemac_drv=${enable_winemac_drv:-yes}
+        CORETEXT_LIBS="-framework CoreText"
+
+    COREFOUNDATION_LIBS="-framework CoreFoundation"
+
+    DISKARBITRATION_LIBS="-framework DiskArbitration -framework CoreFoundation"
+
+    IOKIT_LIBS="-framework IOKit -framework CoreFoundation"
+
+    APPLICATIONSERVICES_LIBS="-framework ApplicationServices"
+
+    CORESERVICES_LIBS="-framework CoreServices"
+
+    APPKIT_LIBS="-framework AppKit"
+
+    SECURITY_LIBS="-framework Security -framework CoreFoundation"
+
+    SYSTEMCONFIGURATION_LIBS="-framework SystemConfiguration"
+
+
+    WINELOADER_LDFLAGS="-Wl,-segalign,0x1000,-pagezero_size,0x1000,-sectcreate,__TEXT,__info_plist,loader/wine_info.plist"
+
+    case $HOST_ARCH in
+      i386) wine_use_preloader=yes ;;
+      x86_64)
+                { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,-no_huge" >&5
+printf %s "checking whether the compiler supports -Wl,-no_huge... " >&6; }
+if test ${ac_cv_cflags__Wl__no_huge+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wl,-no_huge"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Wl__no_huge=yes
+else case e in #(
+  e) ac_cv_cflags__Wl__no_huge=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl__no_huge" >&5
+printf "%s\n" "$ac_cv_cflags__Wl__no_huge" >&6; }
+if test "x$ac_cv_cflags__Wl__no_huge" = xyes
+then :
+  wine_use_preloader=no
+            WINELOADER_LDFLAGS="$WINELOADER_LDFLAGS -Wl,-no_pie,-image_base,0x200000000,-no_huge,-no_fixup_chains,-segalign,0x1000,-segaddr,WINE_RESERVE,0x1000,-segaddr,WINE_TOP_DOWN,0x7ff000000000"
+else case e in #(
+  e) wine_use_preloader=yes ;;
+esac
+fi
+        ;;
+      *)    wine_use_preloader=no ;;
+    esac
+
+    if test "$wine_use_preloader" = "yes"
+    then
+        WINEPRELOADER_LDFLAGS="-nostartfiles -nodefaultlibs -e _start -ldylib1.o -mmacosx-version-min=10.7 -Wl,-no_new_main,-segalign,0x1000,-pagezero_size,0x1000,-sectcreate,__TEXT,__info_plist,loader/wine_info.plist"
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,-no_pie" >&5
+printf %s "checking whether the compiler supports -Wl,-no_pie... " >&6; }
+if test ${ac_cv_cflags__Wl__no_pie+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wl,-no_pie"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Wl__no_pie=yes
+else case e in #(
+  e) ac_cv_cflags__Wl__no_pie=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl__no_pie" >&5
+printf "%s\n" "$ac_cv_cflags__Wl__no_pie" >&6; }
+if test "x$ac_cv_cflags__Wl__no_pie" = xyes
+then :
+  WINEPRELOADER_LDFLAGS="-Wl,-no_pie $WINEPRELOADER_LDFLAGS"
+fi
+        case $HOST_ARCH in
+          i386)
+            WINEPRELOADER_LDFLAGS="-Wl,-image_base,0x7d400000 $WINEPRELOADER_LDFLAGS"
+            ;;
+          x86_64)
+            WINEPRELOADER_LDFLAGS="-Wl,-image_base,0x200000000,-segalign,0x1000,-segaddr,WINE_RESERVE,0x1000 $WINEPRELOADER_LDFLAGS"
+            ;;
+        esac
+                WINELOADER_LDFLAGS="$WINELOADER_LDFLAGS -mmacosx-version-min=10.7"
+    fi
+
+    if test "x$with_coreaudio" != "xno";
+    then
+        COREAUDIO_LIBS="-framework CoreFoundation -framework CoreAudio -framework AudioUnit -framework AudioToolbox -framework CoreMIDI"
+
+        enable_winecoreaudio_drv=${enable_winecoreaudio_drv:-yes}
+    fi
+    if test "$ac_cv_header_OpenCL_opencl_h" = "yes"
+    then
+        OPENCL_LIBS="-framework OpenCL"
+
+        ac_cv_lib_OpenCL_clGetPlatformInfo=yes
+    fi
+
+        ac_ext=m
+ac_cpp='$OBJCPP $CPPFLAGS'
+ac_compile='$OBJC -c $OBJCFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$OBJC -o conftest$ac_exeext $OBJCFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_objc_compiler_gnu
+
+    ac_ext=m
+ac_cpp='$OBJCPP $CPPFLAGS'
+ac_compile='$OBJC -c $OBJCFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$OBJC -o conftest$ac_exeext $OBJCFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_objc_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  for ac_prog in gcc objcc objc cc CC clang
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_OBJC+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$OBJC"; then
+  ac_cv_prog_OBJC="$OBJC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_OBJC="$ac_tool_prefix$ac_prog"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+OBJC=$ac_cv_prog_OBJC
+if test -n "$OBJC"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $OBJC" >&5
+printf "%s\n" "$OBJC" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+    test -n "$OBJC" && break
+  done
+fi
+if test -z "$OBJC"; then
+  ac_ct_OBJC=$OBJC
+  for ac_prog in gcc objcc objc cc CC clang
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_ac_ct_OBJC+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$ac_ct_OBJC"; then
+  ac_cv_prog_ac_ct_OBJC="$ac_ct_OBJC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_OBJC="$ac_prog"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+ac_ct_OBJC=$ac_cv_prog_ac_ct_OBJC
+if test -n "$ac_ct_OBJC"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OBJC" >&5
+printf "%s\n" "$ac_ct_OBJC" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_OBJC" && break
+done
+
+  if test "x$ac_ct_OBJC" = x; then
+    OBJC="gcc"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+printf "%s\n" "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    OBJC=$ac_ct_OBJC
+  fi
+fi
+
+# Provide some information about the compiler.
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for Objective C compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+for ac_option in --version -v -V -qversion; do
+  { { ac_try="$ac_compiler $ac_option >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+printf "%s\n" "$ac_try_echo"; } >&5
+  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    sed '10a\
+... rest of stderr output deleted ...
+         10q' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+  fi
+  rm -f conftest.er1 conftest.err
+  printf "%s\n" "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+done
+
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports GNU Objective C" >&5
+printf %s "checking whether the compiler supports GNU Objective C... " >&6; }
+if test ${ac_cv_objc_compiler_gnu+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main (void)
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_objc_try_compile "$LINENO"
+then :
+  ac_compiler_gnu=yes
+else case e in #(
+  e) ac_compiler_gnu=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+ac_cv_objc_compiler_gnu=$ac_compiler_gnu
+ ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_objc_compiler_gnu" >&5
+printf "%s\n" "$ac_cv_objc_compiler_gnu" >&6; }
+ac_compiler_gnu=$ac_cv_objc_compiler_gnu
+
+if test $ac_compiler_gnu = yes; then
+  GOBJC=yes
+else
+  GOBJC=
+fi
+ac_test_OBJCFLAGS=${OBJCFLAGS+y}
+ac_save_OBJCFLAGS=$OBJCFLAGS
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether $OBJC accepts -g" >&5
+printf %s "checking whether $OBJC accepts -g... " >&6; }
+if test ${ac_cv_prog_objc_g+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_save_objc_werror_flag=$ac_objc_werror_flag
+   ac_objc_werror_flag=yes
+   ac_cv_prog_objc_g=no
+   OBJCFLAGS="-g"
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_objc_try_compile "$LINENO"
+then :
+  ac_cv_prog_objc_g=yes
+else case e in #(
+  e) OBJCFLAGS=""
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_objc_try_compile "$LINENO"
+then :
+
+else case e in #(
+  e) ac_objc_werror_flag=$ac_save_objc_werror_flag
+	 OBJCFLAGS="-g"
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_objc_try_compile "$LINENO"
+then :
+  ac_cv_prog_objc_g=yes
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+   ac_objc_werror_flag=$ac_save_objc_werror_flag ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_objc_g" >&5
+printf "%s\n" "$ac_cv_prog_objc_g" >&6; }
+if test $ac_test_OBJCFLAGS; then
+  OBJCFLAGS=$ac_save_OBJCFLAGS
+elif test $ac_cv_prog_objc_g = yes; then
+  if test "$GOBJC" = yes; then
+    OBJCFLAGS="-g -O2"
+  else
+    OBJCFLAGS="-g"
+  fi
+else
+  if test "$GOBJC" = yes; then
+    OBJCFLAGS="-O2"
+  else
+    OBJCFLAGS=
+  fi
+fi
+ac_ext=m
+ac_cpp='$OBJCPP $CPPFLAGS'
+ac_compile='$OBJC -c $OBJCFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$OBJC -o conftest$ac_exeext $OBJCFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_objc_compiler_gnu
+
+
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether MTLDevice protocol supports registryID property" >&5
+printf %s "checking whether MTLDevice protocol supports registryID property... " >&6; }
+if test ${ac_cv_mtldevice_registryid+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <Metal/Metal.h>
+int
+main (void)
+{
+id<MTLDevice> device; device.registryID;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_objc_try_compile "$LINENO"
+then :
+  ac_cv_mtldevice_registryid=yes
+else case e in #(
+  e) ac_cv_mtldevice_registryid=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mtldevice_registryid" >&5
+printf "%s\n" "$ac_cv_mtldevice_registryid" >&6; }
+    ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+    test $ac_cv_mtldevice_registryid != yes ||
+printf "%s\n" "#define HAVE_MTLDEVICE_REGISTRYID 1" >>confdefs.h
+
+
+    UNIXLDFLAGS="-dynamiclib -install_name @rpath/\$(UNIXLIB) -Wl,-rpath,@loader_path\/"
+    WINELOADER_DEPENDS="wine_info.plist"
+
+    ;;
+
+  linux-android*)
+
+printf "%s\n" "#define _GNU_SOURCE 1" >>confdefs.h
+
+    DLLFLAGS="$DLLFLAGS -fPIC"
+    LDDLLFLAGS="-fPIC"
+    LDEXECFLAGS="-Wl,-pie"
+    enable_wineandroid_drv=${enable_wineandroid_drv:-yes}
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,-z,defs" >&5
+printf %s "checking whether the compiler supports -Wl,-z,defs... " >&6; }
+if test ${ac_cv_cflags__Wl__z_defs+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wl,-z,defs"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Wl__z_defs=yes
+else case e in #(
+  e) ac_cv_cflags__Wl__z_defs=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl__z_defs" >&5
+printf "%s\n" "$ac_cv_cflags__Wl__z_defs" >&6; }
+if test "x$ac_cv_cflags__Wl__z_defs" = xyes
+then :
+  UNIXLDFLAGS="$UNIXLDFLAGS -Wl,-z,defs"
+fi
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fPIC -Wl,--export-dynamic" >&5
+printf %s "checking whether the compiler supports -fPIC -Wl,--export-dynamic... " >&6; }
+if test ${ac_cv_cflags__fPIC__Wl___export_dynamic+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -fPIC -Wl,--export-dynamic"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__fPIC__Wl___export_dynamic=yes
+else case e in #(
+  e) ac_cv_cflags__fPIC__Wl___export_dynamic=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fPIC__Wl___export_dynamic" >&5
+printf "%s\n" "$ac_cv_cflags__fPIC__Wl___export_dynamic" >&6; }
+if test "x$ac_cv_cflags__fPIC__Wl___export_dynamic" = xyes
+then :
+  WINELOADER_LDFLAGS="-Wl,--export-dynamic"
+fi
+    WINEPRELOADER_LDFLAGS="-static -nostartfiles -nodefaultlibs -Wl,-Ttext=0x7d400000"
+
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lGLESv2" >&5
+printf %s "checking for -lGLESv2... " >&6; }
+if test ${ac_cv_lib_soname_GLESv2+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lGLESv2  $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char glFlush (void);
+int
+main (void)
+{
+return glFlush ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_GLESv2=`$ac_cv_path_LDD conftest.exe | grep "GLESv2" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_GLESv2=`$OTOOL -L conftest$ac_exeext | grep "libGLESv2\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libGLESv2\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_GLESv2=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libGLESv2\\.$LIBEXT" | sed -e "s/^.*\\[\\(libGLESv2\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_GLESv2:+false} :
+then :
+  ac_cv_lib_soname_GLESv2=`$LDD conftest$ac_exeext | grep "libGLESv2\\.$LIBEXT" | sed -e "s/^.*\(libGLESv2\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_GLESv2= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_GLESv2:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_GLESv2" >&5
+printf "%s\n" "$ac_cv_lib_soname_GLESv2" >&6; }
+
+printf "%s\n" "#define SONAME_LIBGLESV2 \"$ac_cv_lib_soname_GLESv2\"" >>confdefs.h
+
+        ;;
+esac
+fi
+
+    if test "x$exec_prefix" = xNONE
+    then
+      case $HOST_ARCH in
+        i386)    exec_prefix='${prefix}/x86' ;;
+        x86_64)  exec_prefix='${prefix}/x86_64' ;;
+        arm)     exec_prefix='${prefix}/armeabi-v7a' ;;
+        aarch64) exec_prefix='${prefix}/arm64-v8a' ;;
+      esac
+    fi
+    ;;
+
+  *)
+
+printf "%s\n" "#define _GNU_SOURCE 1" >>confdefs.h
+
+    if test $HOST_ARCH = i386
+    then
+        DLLFLAGS="$DLLFLAGS -fno-PIC"
+        LDDLLFLAGS="-fno-PIC"
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fno-PIC -Wl,-z,notext" >&5
+printf %s "checking whether the compiler supports -fno-PIC -Wl,-z,notext... " >&6; }
+if test ${ac_cv_cflags__fno_PIC__Wl__z_notext+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -fno-PIC -Wl,-z,notext"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__fno_PIC__Wl__z_notext=yes
+else case e in #(
+  e) ac_cv_cflags__fno_PIC__Wl__z_notext=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fno_PIC__Wl__z_notext" >&5
+printf "%s\n" "$ac_cv_cflags__fno_PIC__Wl__z_notext" >&6; }
+if test "x$ac_cv_cflags__fno_PIC__Wl__z_notext" = xyes
+then :
+  LDDLLFLAGS="$LDDLLFLAGS -Wl,-z,notext"
+fi
+    else
+        DLLFLAGS="$DLLFLAGS -fPIC"
+        LDDLLFLAGS="-fPIC"
+    fi
+
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether -Wl,-z,defs works correctly" >&5
+printf %s "checking whether -Wl,-z,defs works correctly... " >&6; }
+if test ${ac_cv_wl_z_defs+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_save_CFLAGS="$CFLAGS"
+                    CFLAGS="$CFLAGS $UNIXDLLFLAGS $UNIXLDFLAGS -Wl,-z,defs"
+                                        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+extern char **environ; char **envp; void myfunc(void) { envp = environ; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_wl_z_defs=yes
+else case e in #(
+  e) ac_cv_wl_z_defs=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+                    CFLAGS=$ac_save_CFLAGS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_wl_z_defs" >&5
+printf "%s\n" "$ac_cv_wl_z_defs" >&6; }
+    test $ac_cv_wl_z_defs != yes || as_fn_append UNIXLDFLAGS " -Wl,-z,defs"
+
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,--export-dynamic" >&5
+printf %s "checking whether the compiler supports -Wl,--export-dynamic... " >&6; }
+if test ${ac_cv_cflags__Wl___export_dynamic+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wl,--export-dynamic"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Wl___export_dynamic=yes
+else case e in #(
+  e) ac_cv_cflags__Wl___export_dynamic=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl___export_dynamic" >&5
+printf "%s\n" "$ac_cv_cflags__Wl___export_dynamic" >&6; }
+if test "x$ac_cv_cflags__Wl___export_dynamic" = xyes
+then :
+  WINELOADER_LDFLAGS="-Wl,--export-dynamic"
+fi
+    WINEPRELOADER_LDFLAGS="-nostartfiles -nodefaultlibs"
+
+    case $host_os in
+      linux*)
+        as_fn_append WINELOADER_LDFLAGS " -pie"
+        case $HOST_ARCH in
+          i386|arm)
+            as_fn_append WINEPRELOADER_LDFLAGS " -static -Wl,-Ttext=0x7d400000" ;;
+          *)
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -static-pie" >&5
+printf %s "checking whether the compiler supports -static-pie... " >&6; }
+if test ${ac_cv_cflags__static_pie+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -static-pie"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__static_pie=yes
+else case e in #(
+  e) ac_cv_cflags__static_pie=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__static_pie" >&5
+printf "%s\n" "$ac_cv_cflags__static_pie" >&6; }
+if test "x$ac_cv_cflags__static_pie" = xyes
+then :
+  as_fn_append WINEPRELOADER_LDFLAGS " -static-pie"
+else case e in #(
+  e) as_fn_append WINEPRELOADER_LDFLAGS " -static -Wl,-Ttext=0x7d7d00000000" ;;
+esac
+fi
+            ;;
+        esac
+        ;;
+      *)
+        case $HOST_ARCH in
+          i386|arm)
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,-Ttext-segment=0x60000000" >&5
+printf %s "checking whether the compiler supports -Wl,-Ttext-segment=0x60000000... " >&6; }
+if test ${ac_cv_cflags__Wl__Ttext_segment_0x60000000+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wl,-Ttext-segment=0x60000000"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Wl__Ttext_segment_0x60000000=yes
+else case e in #(
+  e) ac_cv_cflags__Wl__Ttext_segment_0x60000000=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl__Ttext_segment_0x60000000" >&5
+printf "%s\n" "$ac_cv_cflags__Wl__Ttext_segment_0x60000000" >&6; }
+if test "x$ac_cv_cflags__Wl__Ttext_segment_0x60000000" = xyes
+then :
+  as_fn_append WINELOADER_LDFLAGS " -Wl,-Ttext-segment=0x60000000"
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,--section-start,.interp=0x60000400" >&5
+printf %s "checking whether the compiler supports -Wl,--section-start,.interp=0x60000400... " >&6; }
+if test ${ac_cv_cflags__Wl___section_start__interp_0x60000400+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wl,--section-start,.interp=0x60000400"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Wl___section_start__interp_0x60000400=yes
+else case e in #(
+  e) ac_cv_cflags__Wl___section_start__interp_0x60000400=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl___section_start__interp_0x60000400" >&5
+printf "%s\n" "$ac_cv_cflags__Wl___section_start__interp_0x60000400" >&6; }
+if test "x$ac_cv_cflags__Wl___section_start__interp_0x60000400" = xyes
+then :
+  as_fn_append WINELOADER_LDFLAGS " -Wl,--section-start,.interp=0x60000400"
+fi ;;
+esac
+fi
+            ;;
+          *)
+            as_fn_append WINELOADER_LDFLAGS " -pie"
+            ;;
+        esac
+        ;;
+    esac
+    ;;
+esac
+
+enable_winecoreaudio_drv=${enable_winecoreaudio_drv:-no}
+enable_wineandroid_drv=${enable_wineandroid_drv:-no}
+enable_winemac_drv=${enable_winemac_drv:-no}
+
+
+if test "x$with_system_dllpath" != "x" -a -n "$PE_ARCHS"
+then
+    if test "x$HOST_ARCH" = xi386
+then :
+  ac_prefix_list="i686-w64-mingw32-pkg-config i586-w64-mingw32-pkg-config i486-w64-mingw32-pkg-config i386-w64-mingw32-pkg-config "
+else case e in #(
+  e) ac_prefix_list="$host_cpu-w64-mingw32-pkg-config" ;;
+esac
+fi
+for ac_prog in $ac_prefix_list
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_prog_MINGW_PKG_CONFIG+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) if test -n "$MINGW_PKG_CONFIG"; then
+  ac_cv_prog_MINGW_PKG_CONFIG="$MINGW_PKG_CONFIG" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_prog_MINGW_PKG_CONFIG="$ac_prog"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi ;;
+esac
+fi
+MINGW_PKG_CONFIG=$ac_cv_prog_MINGW_PKG_CONFIG
+if test -n "$MINGW_PKG_CONFIG"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $MINGW_PKG_CONFIG" >&5
+printf "%s\n" "$MINGW_PKG_CONFIG" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+  test -n "$MINGW_PKG_CONFIG" && break
+done
+test -n "$MINGW_PKG_CONFIG" || MINGW_PKG_CONFIG="false"
+
+if ${FAUDIO_PE_CFLAGS:+false} :
+then :
+  if test ${MINGW_PKG_CONFIG+y}
+then :
+  FAUDIO_PE_CFLAGS=`$MINGW_PKG_CONFIG --cflags FAudio 2>/dev/null`
+fi
+fi
+if ${FAUDIO_PE_LIBS:+false} :
+then :
+  if test ${MINGW_PKG_CONFIG+y}
+then :
+  FAUDIO_PE_LIBS=`$MINGW_PKG_CONFIG --libs FAudio 2>/dev/null`
+fi
+fi
+FAUDIO_PE_LIBS=${FAUDIO_PE_LIBS:-"-lFAudio"}
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $FAUDIO_PE_CFLAGS"
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for MinGW FAudio.h" >&5
+printf %s "checking for MinGW FAudio.h... " >&6; }
+if test ${ac_cv_mingw_header_FAudio_h+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <FAudio.h>
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_mingw_header_FAudio_h=yes
+else case e in #(
+  e) ac_cv_mingw_header_FAudio_h=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_header_FAudio_h" >&5
+printf "%s\n" "$ac_cv_mingw_header_FAudio_h" >&6; }
+if test "x$ac_cv_mingw_header_FAudio_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for FAudio_CommitOperationSet in MinGW -lFAudio" >&5
+printf %s "checking for FAudio_CommitOperationSet in MinGW -lFAudio... " >&6; }
+if test ${ac_cv_mingw_lib_FAudio+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+ac_wine_check_headers_saved_libs=$LIBS
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+LIBS="-lFAudio $FAUDIO_PE_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char FAudio_CommitOperationSet (void);
+int
+main (void)
+{
+return FAudio_CommitOperationSet ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_mingw_lib_FAudio=yes
+else case e in #(
+  e) ac_cv_mingw_lib_FAudio=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext
+LIBS=$ac_wine_check_headers_saved_libs ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_lib_FAudio" >&5
+printf "%s\n" "$ac_cv_mingw_lib_FAudio" >&6; }
+if test "x$ac_cv_mingw_lib_FAudio" = xyes
+then :
+  :
+else case e in #(
+  e) FAUDIO_PE_CFLAGS=""; FAUDIO_PE_LIBS="" ;;
+esac
+fi
+else case e in #(
+  e) FAUDIO_PE_CFLAGS=""; FAUDIO_PE_LIBS="" ;;
+esac
+fi
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    if test "x$FAUDIO_PE_LIBS" = "x"
+    then
+        as_fn_append wine_notices "|FAudio ${notice_platform}MinGW development files not found (or too old); using bundled version."
+    fi
+
+    if ${FLUIDSYNTH_PE_CFLAGS:+false} :
+then :
+  if test ${MINGW_PKG_CONFIG+y}
+then :
+  FLUIDSYNTH_PE_CFLAGS=`$MINGW_PKG_CONFIG --cflags fluidsynth 2>/dev/null`
+fi
+fi
+if ${FLUIDSYNTH_PE_LIBS:+false} :
+then :
+  if test ${MINGW_PKG_CONFIG+y}
+then :
+  FLUIDSYNTH_PE_LIBS=`$MINGW_PKG_CONFIG --libs fluidsynth 2>/dev/null`
+fi
+fi
+FLUIDSYNTH_PE_LIBS=${FLUIDSYNTH_PE_LIBS:-"-lfluidsynth"}
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $FLUIDSYNTH_PE_CFLAGS"
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for MinGW fluidsynth.h" >&5
+printf %s "checking for MinGW fluidsynth.h... " >&6; }
+if test ${ac_cv_mingw_header_fluidsynth_h+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <fluidsynth.h>
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_mingw_header_fluidsynth_h=yes
+else case e in #(
+  e) ac_cv_mingw_header_fluidsynth_h=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_header_fluidsynth_h" >&5
+printf "%s\n" "$ac_cv_mingw_header_fluidsynth_h" >&6; }
+if test "x$ac_cv_mingw_header_fluidsynth_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for new_fluid_synth in MinGW -lfluidsynth" >&5
+printf %s "checking for new_fluid_synth in MinGW -lfluidsynth... " >&6; }
+if test ${ac_cv_mingw_lib_fluidsynth+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+ac_wine_check_headers_saved_libs=$LIBS
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+LIBS="-lfluidsynth $FLUIDSYNTH_PE_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char new_fluid_synth (void);
+int
+main (void)
+{
+return new_fluid_synth ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_mingw_lib_fluidsynth=yes
+else case e in #(
+  e) ac_cv_mingw_lib_fluidsynth=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext
+LIBS=$ac_wine_check_headers_saved_libs ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_lib_fluidsynth" >&5
+printf "%s\n" "$ac_cv_mingw_lib_fluidsynth" >&6; }
+if test "x$ac_cv_mingw_lib_fluidsynth" = xyes
+then :
+  :
+else case e in #(
+  e) FLUIDSYNTH_PE_CFLAGS=""; FLUIDSYNTH_PE_LIBS="" ;;
+esac
+fi
+else case e in #(
+  e) FLUIDSYNTH_PE_CFLAGS=""; FLUIDSYNTH_PE_LIBS="" ;;
+esac
+fi
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    if test "x$FLUIDSYNTH_PE_LIBS" = "x"
+    then
+        as_fn_append wine_notices "|Fluidsynth ${notice_platform}MinGW development files not found (or too old); using bundled version."
+    fi
+
+    if ${JPEG_PE_CFLAGS:+false} :
+then :
+  if test ${MINGW_PKG_CONFIG+y}
+then :
+  JPEG_PE_CFLAGS=`$MINGW_PKG_CONFIG --cflags libjpeg 2>/dev/null`
+fi
+fi
+if ${JPEG_PE_LIBS:+false} :
+then :
+  if test ${MINGW_PKG_CONFIG+y}
+then :
+  JPEG_PE_LIBS=`$MINGW_PKG_CONFIG --libs libjpeg 2>/dev/null`
+fi
+fi
+
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $JPEG_PE_CFLAGS"
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for MinGW jpeglib.h" >&5
+printf %s "checking for MinGW jpeglib.h... " >&6; }
+if test ${ac_cv_mingw_header_jpeglib_h+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stddef.h>
+             #include <stdio.h>
+#include <jpeglib.h>
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_mingw_header_jpeglib_h=yes
+else case e in #(
+  e) ac_cv_mingw_header_jpeglib_h=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_header_jpeglib_h" >&5
+printf "%s\n" "$ac_cv_mingw_header_jpeglib_h" >&6; }
+if test "x$ac_cv_mingw_header_jpeglib_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for jpeg_start_decompress in MinGW -ljpeg" >&5
+printf %s "checking for jpeg_start_decompress in MinGW -ljpeg... " >&6; }
+if test ${ac_cv_mingw_lib_jpeg+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+ac_wine_check_headers_saved_libs=$LIBS
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+LIBS="-ljpeg $JPEG_PE_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char jpeg_start_decompress (void);
+int
+main (void)
+{
+return jpeg_start_decompress ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_mingw_lib_jpeg=yes
+else case e in #(
+  e) ac_cv_mingw_lib_jpeg=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext
+LIBS=$ac_wine_check_headers_saved_libs ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_lib_jpeg" >&5
+printf "%s\n" "$ac_cv_mingw_lib_jpeg" >&6; }
+if test "x$ac_cv_mingw_lib_jpeg" = xyes
+then :
+  :
+else case e in #(
+  e) JPEG_PE_CFLAGS=""; JPEG_PE_LIBS="" ;;
+esac
+fi
+else case e in #(
+  e) JPEG_PE_CFLAGS=""; JPEG_PE_LIBS="" ;;
+esac
+fi
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    if test "x$JPEG_PE_LIBS" = "x"
+    then
+        as_fn_append wine_notices "|libjpeg ${notice_platform}MinGW development files not found; using bundled version."
+    fi
+
+    if ${LCMS2_PE_CFLAGS:+false} :
+then :
+  if test ${MINGW_PKG_CONFIG+y}
+then :
+  LCMS2_PE_CFLAGS=`$MINGW_PKG_CONFIG --cflags lcms2 2>/dev/null`
+fi
+fi
+if ${LCMS2_PE_LIBS:+false} :
+then :
+  if test ${MINGW_PKG_CONFIG+y}
+then :
+  LCMS2_PE_LIBS=`$MINGW_PKG_CONFIG --libs lcms2 2>/dev/null`
+fi
+fi
+LCMS2_PE_LIBS=${LCMS2_PE_LIBS:-"-llcms2"}
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $LCMS2_PE_CFLAGS"
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for MinGW lcms2.h" >&5
+printf %s "checking for MinGW lcms2.h... " >&6; }
+if test ${ac_cv_mingw_header_lcms2_h+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <lcms2.h>
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_mingw_header_lcms2_h=yes
+else case e in #(
+  e) ac_cv_mingw_header_lcms2_h=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_header_lcms2_h" >&5
+printf "%s\n" "$ac_cv_mingw_header_lcms2_h" >&6; }
+if test "x$ac_cv_mingw_header_lcms2_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for cmsOpenProfileFromFile in MinGW -llcms2" >&5
+printf %s "checking for cmsOpenProfileFromFile in MinGW -llcms2... " >&6; }
+if test ${ac_cv_mingw_lib_lcms2+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+ac_wine_check_headers_saved_libs=$LIBS
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+LIBS="-llcms2 $LCMS2_PE_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char cmsOpenProfileFromFile (void);
+int
+main (void)
+{
+return cmsOpenProfileFromFile ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_mingw_lib_lcms2=yes
+else case e in #(
+  e) ac_cv_mingw_lib_lcms2=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext
+LIBS=$ac_wine_check_headers_saved_libs ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_lib_lcms2" >&5
+printf "%s\n" "$ac_cv_mingw_lib_lcms2" >&6; }
+if test "x$ac_cv_mingw_lib_lcms2" = xyes
+then :
+  :
+else case e in #(
+  e) LCMS2_PE_CFLAGS=""; LCMS2_PE_LIBS="" ;;
+esac
+fi
+else case e in #(
+  e) LCMS2_PE_CFLAGS=""; LCMS2_PE_LIBS="" ;;
+esac
+fi
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    if test "x$LCMS2_PE_LIBS" = "x"
+    then
+        as_fn_append wine_notices "|liblcms2 ${notice_platform}MinGW development files not found; using bundled version."
+    fi
+
+    if ${MPG123_PE_CFLAGS:+false} :
+then :
+  if test ${MINGW_PKG_CONFIG+y}
+then :
+  MPG123_PE_CFLAGS=`$MINGW_PKG_CONFIG --cflags libmpg123 2>/dev/null`
+fi
+fi
+if ${MPG123_PE_LIBS:+false} :
+then :
+  if test ${MINGW_PKG_CONFIG+y}
+then :
+  MPG123_PE_LIBS=`$MINGW_PKG_CONFIG --libs libmpg123 2>/dev/null`
+fi
+fi
+MPG123_PE_LIBS=${MPG123_PE_LIBS:-"-lmpg123"}
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $MPG123_PE_CFLAGS"
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for MinGW mpg123.h" >&5
+printf %s "checking for MinGW mpg123.h... " >&6; }
+if test ${ac_cv_mingw_header_mpg123_h+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <mpg123.h>
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_mingw_header_mpg123_h=yes
+else case e in #(
+  e) ac_cv_mingw_header_mpg123_h=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_header_mpg123_h" >&5
+printf "%s\n" "$ac_cv_mingw_header_mpg123_h" >&6; }
+if test "x$ac_cv_mingw_header_mpg123_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for mpg123_feed in MinGW -lmpg123" >&5
+printf %s "checking for mpg123_feed in MinGW -lmpg123... " >&6; }
+if test ${ac_cv_mingw_lib_mpg123+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+ac_wine_check_headers_saved_libs=$LIBS
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+LIBS="-lmpg123 $MPG123_PE_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char mpg123_feed (void);
+int
+main (void)
+{
+return mpg123_feed ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_mingw_lib_mpg123=yes
+else case e in #(
+  e) ac_cv_mingw_lib_mpg123=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext
+LIBS=$ac_wine_check_headers_saved_libs ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_lib_mpg123" >&5
+printf "%s\n" "$ac_cv_mingw_lib_mpg123" >&6; }
+if test "x$ac_cv_mingw_lib_mpg123" = xyes
+then :
+  :
+else case e in #(
+  e) MPG123_PE_CFLAGS=""; MPG123_PE_LIBS="" ;;
+esac
+fi
+else case e in #(
+  e) MPG123_PE_CFLAGS=""; MPG123_PE_LIBS="" ;;
+esac
+fi
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    if test "x$MPG123_PE_LIBS" = "x"
+    then
+        as_fn_append wine_notices "|libmpg123 ${notice_platform}MinGW development files not found (or too old); using bundled version."
+    fi
+
+    if ${PNG_PE_CFLAGS:+false} :
+then :
+  if test ${MINGW_PKG_CONFIG+y}
+then :
+  PNG_PE_CFLAGS=`$MINGW_PKG_CONFIG --cflags libpng 2>/dev/null`
+fi
+fi
+if ${PNG_PE_LIBS:+false} :
+then :
+  if test ${MINGW_PKG_CONFIG+y}
+then :
+  PNG_PE_LIBS=`$MINGW_PKG_CONFIG --libs libpng 2>/dev/null`
+fi
+fi
+
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $PNG_PE_CFLAGS"
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for MinGW png.h" >&5
+printf %s "checking for MinGW png.h... " >&6; }
+if test ${ac_cv_mingw_header_png_h+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <png.h>
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_mingw_header_png_h=yes
+else case e in #(
+  e) ac_cv_mingw_header_png_h=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_header_png_h" >&5
+printf "%s\n" "$ac_cv_mingw_header_png_h" >&6; }
+if test "x$ac_cv_mingw_header_png_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for png_create_read_struct in MinGW -lpng" >&5
+printf %s "checking for png_create_read_struct in MinGW -lpng... " >&6; }
+if test ${ac_cv_mingw_lib_png+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+ac_wine_check_headers_saved_libs=$LIBS
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+LIBS="-lpng $PNG_PE_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char png_create_read_struct (void);
+int
+main (void)
+{
+return png_create_read_struct ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_mingw_lib_png=yes
+else case e in #(
+  e) ac_cv_mingw_lib_png=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext
+LIBS=$ac_wine_check_headers_saved_libs ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_lib_png" >&5
+printf "%s\n" "$ac_cv_mingw_lib_png" >&6; }
+if test "x$ac_cv_mingw_lib_png" = xyes
+then :
+  :
+else case e in #(
+  e) PNG_PE_CFLAGS=""; PNG_PE_LIBS="" ;;
+esac
+fi
+else case e in #(
+  e) PNG_PE_CFLAGS=""; PNG_PE_LIBS="" ;;
+esac
+fi
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    if test "x$PNG_PE_LIBS" = "x"
+    then
+        as_fn_append wine_notices "|libpng ${notice_platform}MinGW development files not found; using bundled version."
+    fi
+
+    if ${TIFF_PE_CFLAGS:+false} :
+then :
+  if test ${MINGW_PKG_CONFIG+y}
+then :
+  TIFF_PE_CFLAGS=`$MINGW_PKG_CONFIG --cflags libtiff-4 2>/dev/null`
+fi
+fi
+if ${TIFF_PE_LIBS:+false} :
+then :
+  if test ${MINGW_PKG_CONFIG+y}
+then :
+  TIFF_PE_LIBS=`$MINGW_PKG_CONFIG --libs libtiff-4 2>/dev/null`
+fi
+fi
+
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $TIFF_PE_CFLAGS"
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for MinGW tiffio.h" >&5
+printf %s "checking for MinGW tiffio.h... " >&6; }
+if test ${ac_cv_mingw_header_tiffio_h+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <tiffio.h>
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_mingw_header_tiffio_h=yes
+else case e in #(
+  e) ac_cv_mingw_header_tiffio_h=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_header_tiffio_h" >&5
+printf "%s\n" "$ac_cv_mingw_header_tiffio_h" >&6; }
+if test "x$ac_cv_mingw_header_tiffio_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for TIFFClientOpen in MinGW -ltiff" >&5
+printf %s "checking for TIFFClientOpen in MinGW -ltiff... " >&6; }
+if test ${ac_cv_mingw_lib_tiff+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+ac_wine_check_headers_saved_libs=$LIBS
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+LIBS="-ltiff $TIFF_PE_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char TIFFClientOpen (void);
+int
+main (void)
+{
+return TIFFClientOpen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_mingw_lib_tiff=yes
+else case e in #(
+  e) ac_cv_mingw_lib_tiff=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext
+LIBS=$ac_wine_check_headers_saved_libs ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_lib_tiff" >&5
+printf "%s\n" "$ac_cv_mingw_lib_tiff" >&6; }
+if test "x$ac_cv_mingw_lib_tiff" = xyes
+then :
+  :
+else case e in #(
+  e) TIFF_PE_CFLAGS=""; TIFF_PE_LIBS="" ;;
+esac
+fi
+else case e in #(
+  e) TIFF_PE_CFLAGS=""; TIFF_PE_LIBS="" ;;
+esac
+fi
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    if test "x$TIFF_PE_LIBS" = "x"
+    then
+        as_fn_append wine_notices "|libtiff ${notice_platform}MinGW development files not found; using bundled version."
+    fi
+
+    if ${XML2_PE_CFLAGS:+false} :
+then :
+  if test ${MINGW_PKG_CONFIG+y}
+then :
+  XML2_PE_CFLAGS=`$MINGW_PKG_CONFIG --cflags libxml-2.0 2>/dev/null`
+fi
+fi
+if ${XML2_PE_LIBS:+false} :
+then :
+  if test ${MINGW_PKG_CONFIG+y}
+then :
+  XML2_PE_LIBS=`$MINGW_PKG_CONFIG --libs libxml-2.0 2>/dev/null`
+fi
+fi
+XML2_PE_LIBS=${XML2_PE_LIBS:-"-lxml2"}
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $XML2_PE_CFLAGS"
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for MinGW libxml/parser.h" >&5
+printf %s "checking for MinGW libxml/parser.h... " >&6; }
+if test ${ac_cv_mingw_header_libxml_parser_h+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <libxml/parser.h>
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_mingw_header_libxml_parser_h=yes
+else case e in #(
+  e) ac_cv_mingw_header_libxml_parser_h=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_header_libxml_parser_h" >&5
+printf "%s\n" "$ac_cv_mingw_header_libxml_parser_h" >&6; }
+if test "x$ac_cv_mingw_header_libxml_parser_h" = xyes
+then :
+
+fi
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for MinGW libxml/xmlsave.h" >&5
+printf %s "checking for MinGW libxml/xmlsave.h... " >&6; }
+if test ${ac_cv_mingw_header_libxml_xmlsave_h+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <libxml/xmlsave.h>
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_mingw_header_libxml_xmlsave_h=yes
+else case e in #(
+  e) ac_cv_mingw_header_libxml_xmlsave_h=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_header_libxml_xmlsave_h" >&5
+printf "%s\n" "$ac_cv_mingw_header_libxml_xmlsave_h" >&6; }
+if test "x$ac_cv_mingw_header_libxml_xmlsave_h" = xyes
+then :
+
+fi
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for MinGW libxml/SAX2.h" >&5
+printf %s "checking for MinGW libxml/SAX2.h... " >&6; }
+if test ${ac_cv_mingw_header_libxml_SAX2_h+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <libxml/SAX2.h>
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_mingw_header_libxml_SAX2_h=yes
+else case e in #(
+  e) ac_cv_mingw_header_libxml_SAX2_h=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_header_libxml_SAX2_h" >&5
+printf "%s\n" "$ac_cv_mingw_header_libxml_SAX2_h" >&6; }
+if test "x$ac_cv_mingw_header_libxml_SAX2_h" = xyes
+then :
+
+fi
+        if test "$ac_cv_mingw_header_libxml_parser_h" = "yes" -a "$ac_cv_mingw_header_libxml_xmlsave_h" = "yes" -a "$ac_cv_mingw_header_libxml_SAX2_h" = "yes"
+        then
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for xmlFirstElementChild in MinGW -lxml2" >&5
+printf %s "checking for xmlFirstElementChild in MinGW -lxml2... " >&6; }
+if test ${ac_cv_mingw_lib_xml2+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+ac_wine_check_headers_saved_libs=$LIBS
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+LIBS="-lxml2 $XML2_PE_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char xmlFirstElementChild (void);
+int
+main (void)
+{
+return xmlFirstElementChild ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_mingw_lib_xml2=yes
+else case e in #(
+  e) ac_cv_mingw_lib_xml2=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext
+LIBS=$ac_wine_check_headers_saved_libs ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_lib_xml2" >&5
+printf "%s\n" "$ac_cv_mingw_lib_xml2" >&6; }
+if test "x$ac_cv_mingw_lib_xml2" = xyes
+then :
+  :
+else case e in #(
+  e) XML2_PE_CFLAGS=""; XML2_PE_LIBS="" ;;
+esac
+fi
+        else
+            XML2_PE_CFLAGS=""
+            XML2_PE_LIBS=""
+        fi
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    if test "x$XML2_PE_LIBS" = "x"
+    then
+        as_fn_append wine_notices "|libxml2 ${notice_platform}MinGW development files not found (or too old); using bundled version."
+    fi
+
+    if ${XSLT_PE_CFLAGS:+false} :
+then :
+  if test ${MINGW_PKG_CONFIG+y}
+then :
+  XSLT_PE_CFLAGS=`$MINGW_PKG_CONFIG --cflags libxslt 2>/dev/null`
+fi
+fi
+if ${XSLT_PE_LIBS:+false} :
+then :
+  if test ${MINGW_PKG_CONFIG+y}
+then :
+  XSLT_PE_LIBS=`$MINGW_PKG_CONFIG --libs libxslt 2>/dev/null`
+fi
+fi
+XSLT_PE_LIBS=${XSLT_PE_LIBS:-"-lxslt"}
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $XSLT_PE_CFLAGS"
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for MinGW libxslt/pattern.h" >&5
+printf %s "checking for MinGW libxslt/pattern.h... " >&6; }
+if test ${ac_cv_mingw_header_libxslt_pattern_h+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <libxslt/pattern.h>
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_mingw_header_libxslt_pattern_h=yes
+else case e in #(
+  e) ac_cv_mingw_header_libxslt_pattern_h=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_header_libxslt_pattern_h" >&5
+printf "%s\n" "$ac_cv_mingw_header_libxslt_pattern_h" >&6; }
+if test "x$ac_cv_mingw_header_libxslt_pattern_h" = xyes
+then :
+
+fi
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for MinGW libxslt/transform.h" >&5
+printf %s "checking for MinGW libxslt/transform.h... " >&6; }
+if test ${ac_cv_mingw_header_libxslt_transform_h+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <libxslt/transform.h>
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_mingw_header_libxslt_transform_h=yes
+else case e in #(
+  e) ac_cv_mingw_header_libxslt_transform_h=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_header_libxslt_transform_h" >&5
+printf "%s\n" "$ac_cv_mingw_header_libxslt_transform_h" >&6; }
+if test "x$ac_cv_mingw_header_libxslt_transform_h" = xyes
+then :
+
+fi
+        if test "$ac_cv_mingw_header_libxslt_pattern_h" = "yes" -a "$ac_cv_mingw_header_libxslt_transform_h" = "yes"
+        then
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for xsltCompilePattern in MinGW -lxslt" >&5
+printf %s "checking for xsltCompilePattern in MinGW -lxslt... " >&6; }
+if test ${ac_cv_mingw_lib_xslt+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+ac_wine_check_headers_saved_libs=$LIBS
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+LIBS="-lxslt $XSLT_PE_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char xsltCompilePattern (void);
+int
+main (void)
+{
+return xsltCompilePattern ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_mingw_lib_xslt=yes
+else case e in #(
+  e) ac_cv_mingw_lib_xslt=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext
+LIBS=$ac_wine_check_headers_saved_libs ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_lib_xslt" >&5
+printf "%s\n" "$ac_cv_mingw_lib_xslt" >&6; }
+if test "x$ac_cv_mingw_lib_xslt" = xyes
+then :
+  :
+else case e in #(
+  e) XSLT_PE_CFLAGS=""; XSLT_PE_LIBS="" ;;
+esac
+fi
+        else
+            XSLT_PE_CFLAGS=""
+            XSLT_PE_LIBS=""
+        fi
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    if test "x$XSLT_PE_LIBS" = "x"
+    then
+        as_fn_append wine_notices "|libxslt ${notice_platform}MinGW development files not found; using bundled version."
+    fi
+
+    if ${VKD3D_PE_CFLAGS:+false} :
+then :
+  if test ${MINGW_PKG_CONFIG+y}
+then :
+  VKD3D_PE_CFLAGS=`$MINGW_PKG_CONFIG --cflags libvkd3d-utils libvkd3d libvkd3d-shader 2>/dev/null`
+fi
+fi
+if ${VKD3D_PE_LIBS:+false} :
+then :
+  if test ${MINGW_PKG_CONFIG+y}
+then :
+  VKD3D_PE_LIBS=`$MINGW_PKG_CONFIG --libs libvkd3d-utils libvkd3d libvkd3d-shader 2>/dev/null`
+fi
+fi
+VKD3D_PE_LIBS=${VKD3D_PE_LIBS:-"-lvkd3d-utils -lvkd3d -lvkd3d-shader"}
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $VKD3D_PE_CFLAGS"
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for MinGW vkd3d_utils.h" >&5
+printf %s "checking for MinGW vkd3d_utils.h... " >&6; }
+if test ${ac_cv_mingw_header_vkd3d_utils_h+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <vkd3d_utils.h>
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_mingw_header_vkd3d_utils_h=yes
+else case e in #(
+  e) ac_cv_mingw_header_vkd3d_utils_h=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_header_vkd3d_utils_h" >&5
+printf "%s\n" "$ac_cv_mingw_header_vkd3d_utils_h" >&6; }
+if test "x$ac_cv_mingw_header_vkd3d_utils_h" = xyes
+then :
+
+fi
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for MinGW vkd3d_shader.h" >&5
+printf %s "checking for MinGW vkd3d_shader.h... " >&6; }
+if test ${ac_cv_mingw_header_vkd3d_shader_h+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <vkd3d_shader.h>
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_mingw_header_vkd3d_shader_h=yes
+else case e in #(
+  e) ac_cv_mingw_header_vkd3d_shader_h=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_header_vkd3d_shader_h" >&5
+printf "%s\n" "$ac_cv_mingw_header_vkd3d_shader_h" >&6; }
+if test "x$ac_cv_mingw_header_vkd3d_shader_h" = xyes
+then :
+
+fi
+        if test "$ac_cv_mingw_header_vkd3d_utils_h" = "yes" -a "$ac_cv_mingw_header_vkd3d_shader_h" = "yes"
+        then
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for vkd3d_utils_set_log_callback in MinGW -lvkd3d-utils" >&5
+printf %s "checking for vkd3d_utils_set_log_callback in MinGW -lvkd3d-utils... " >&6; }
+if test ${ac_cv_mingw_lib_vkd3d_utils+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+ac_wine_check_headers_saved_libs=$LIBS
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+LIBS="-lvkd3d-utils $VKD3D_PE_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char vkd3d_utils_set_log_callback (void);
+int
+main (void)
+{
+return vkd3d_utils_set_log_callback ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_mingw_lib_vkd3d_utils=yes
+else case e in #(
+  e) ac_cv_mingw_lib_vkd3d_utils=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext
+LIBS=$ac_wine_check_headers_saved_libs ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_lib_vkd3d_utils" >&5
+printf "%s\n" "$ac_cv_mingw_lib_vkd3d_utils" >&6; }
+if test "x$ac_cv_mingw_lib_vkd3d_utils" = xyes
+then :
+  :
+else case e in #(
+  e) : ;;
+esac
+fi
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for vkd3d_shader_build_varying_map in MinGW -lvkd3d-shader" >&5
+printf %s "checking for vkd3d_shader_build_varying_map in MinGW -lvkd3d-shader... " >&6; }
+if test ${ac_cv_mingw_lib_vkd3d_shader+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+ac_wine_check_headers_saved_libs=$LIBS
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+LIBS="-lvkd3d-shader $VKD3D_PE_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char vkd3d_shader_build_varying_map (void);
+int
+main (void)
+{
+return vkd3d_shader_build_varying_map ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_mingw_lib_vkd3d_shader=yes
+else case e in #(
+  e) ac_cv_mingw_lib_vkd3d_shader=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext
+LIBS=$ac_wine_check_headers_saved_libs ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_lib_vkd3d_shader" >&5
+printf "%s\n" "$ac_cv_mingw_lib_vkd3d_shader" >&6; }
+if test "x$ac_cv_mingw_lib_vkd3d_shader" = xyes
+then :
+  :
+else case e in #(
+  e) : ;;
+esac
+fi
+            if test "$ac_cv_mingw_lib_vkd3d_utils" = "no" -o "$ac_cv_mingw_lib_vkd3d_shader" = "no"
+            then
+                VKD3D_PE_CFLAGS=""
+                VKD3D_PE_LIBS=""
+            fi
+        else
+            VKD3D_PE_CFLAGS=""
+            VKD3D_PE_LIBS=""
+        fi
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    if test "x$VKD3D_PE_LIBS" = "x"
+    then
+        as_fn_append wine_notices "|libvkd3d ${notice_platform}MinGW development files not found (or too old); using bundled version."
+    fi
+
+    if ${ZLIB_PE_CFLAGS:+false} :
+then :
+  if test ${MINGW_PKG_CONFIG+y}
+then :
+  ZLIB_PE_CFLAGS=`$MINGW_PKG_CONFIG --cflags zlib 2>/dev/null`
+fi
+fi
+if ${ZLIB_PE_LIBS:+false} :
+then :
+  if test ${MINGW_PKG_CONFIG+y}
+then :
+  ZLIB_PE_LIBS=`$MINGW_PKG_CONFIG --libs zlib 2>/dev/null`
+fi
+fi
+ZLIB_PE_LIBS=${ZLIB_PE_LIBS:-"-lz"}
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $ZLIB_PE_CFLAGS"
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for MinGW zlib.h" >&5
+printf %s "checking for MinGW zlib.h... " >&6; }
+if test ${ac_cv_mingw_header_zlib_h+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <zlib.h>
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_mingw_header_zlib_h=yes
+else case e in #(
+  e) ac_cv_mingw_header_zlib_h=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_header_zlib_h" >&5
+printf "%s\n" "$ac_cv_mingw_header_zlib_h" >&6; }
+if test "x$ac_cv_mingw_header_zlib_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for inflate in MinGW -lz" >&5
+printf %s "checking for inflate in MinGW -lz... " >&6; }
+if test ${ac_cv_mingw_lib_z+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_check_headers_saved_cc=$CC
+ac_wine_check_headers_saved_exeext=$ac_exeext
+ac_wine_check_headers_saved_libs=$LIBS
+eval CC=\$${wine_arch}_CC
+ac_exeext=".exe"
+LIBS="-lz $ZLIB_PE_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char inflate (void);
+int
+main (void)
+{
+return inflate ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_mingw_lib_z=yes
+else case e in #(
+  e) ac_cv_mingw_lib_z=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CC=$ac_wine_check_headers_saved_cc
+ac_exeext=$ac_wine_check_headers_saved_exeext
+LIBS=$ac_wine_check_headers_saved_libs ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mingw_lib_z" >&5
+printf "%s\n" "$ac_cv_mingw_lib_z" >&6; }
+if test "x$ac_cv_mingw_lib_z" = xyes
+then :
+  :
+else case e in #(
+  e) ZLIB_PE_CFLAGS=""; ZLIB_PE_LIBS="" ;;
+esac
+fi
+else case e in #(
+  e) ZLIB_PE_CFLAGS=""; ZLIB_PE_LIBS="" ;;
+esac
+fi
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    if test "x$ZLIB_PE_LIBS" = "x"
+    then
+        as_fn_append wine_notices "|zlib ${notice_platform}MinGW development files not found; using bundled version."
+    fi
+fi
+
+if ${CAPSTONE_PE_LIBS:+false} :
+then :
+  CAPSTONE_PE_LIBS=capstone
+   if ${CAPSTONE_PE_CFLAGS:+false} :
+then :
+  CAPSTONE_PE_CFLAGS="-I\$(top_srcdir)/libs/capstone/include"
+else case e in #(
+  e) enable_capstone=no ;;
+esac
+fi
+else case e in #(
+  e) enable_capstone=no ;;
+esac
+fi
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: capstone cflags: $CAPSTONE_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: capstone libs: $CAPSTONE_PE_LIBS" >&5
+
+if ${COMPILER_RT_PE_LIBS:+false} :
+then :
+  COMPILER_RT_PE_LIBS="$wine_compiler_rt_libs"
+   if ${COMPILER_RT_PE_CFLAGS:+false} :
+then :
+  COMPILER_RT_PE_CFLAGS=
+else case e in #(
+  e) enable_compiler_rt=no ;;
+esac
+fi
+else case e in #(
+  e) enable_compiler_rt=no ;;
+esac
+fi
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: compiler-rt cflags: $COMPILER_RT_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: compiler-rt libs: $COMPILER_RT_PE_LIBS" >&5
+
+if ${FAUDIO_PE_LIBS:+false} :
+then :
+  FAUDIO_PE_LIBS="faudio mfplat mfreadwrite mfuuid propsys"
+   if ${FAUDIO_PE_CFLAGS:+false} :
+then :
+  FAUDIO_PE_CFLAGS="-I\$(top_srcdir)/libs/faudio/include"
+else case e in #(
+  e) enable_faudio=no ;;
+esac
+fi
+else case e in #(
+  e) enable_faudio=no ;;
+esac
+fi
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: faudio cflags: $FAUDIO_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: faudio libs: $FAUDIO_PE_LIBS" >&5
+
+if ${FLUIDSYNTH_PE_LIBS:+false} :
+then :
+  FLUIDSYNTH_PE_LIBS="fluidsynth"
+   if ${FLUIDSYNTH_PE_CFLAGS:+false} :
+then :
+  FLUIDSYNTH_PE_CFLAGS="-I\$(top_srcdir)/libs/fluidsynth/include"
+else case e in #(
+  e) enable_fluidsynth=no ;;
+esac
+fi
+else case e in #(
+  e) enable_fluidsynth=no ;;
+esac
+fi
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: fluidsynth cflags: $FLUIDSYNTH_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: fluidsynth libs: $FLUIDSYNTH_PE_LIBS" >&5
+
+if ${GSM_PE_LIBS:+false} :
+then :
+  GSM_PE_LIBS=gsm
+   if ${GSM_PE_CFLAGS:+false} :
+then :
+  GSM_PE_CFLAGS="-I\$(top_srcdir)/libs/gsm/inc"
+else case e in #(
+  e) enable_gsm=no ;;
+esac
+fi
+else case e in #(
+  e) enable_gsm=no ;;
+esac
+fi
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gsm cflags: $GSM_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gsm libs: $GSM_PE_LIBS" >&5
+
+if ${JPEG_PE_LIBS:+false} :
+then :
+  JPEG_PE_LIBS=jpeg
+   if ${JPEG_PE_CFLAGS:+false} :
+then :
+  JPEG_PE_CFLAGS="-I\$(top_srcdir)/libs/jpeg"
+else case e in #(
+  e) enable_jpeg=no ;;
+esac
+fi
+else case e in #(
+  e) enable_jpeg=no ;;
+esac
+fi
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: jpeg cflags: $JPEG_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: jpeg libs: $JPEG_PE_LIBS" >&5
+
+if ${JXR_PE_LIBS:+false} :
+then :
+  JXR_PE_LIBS=jxr
+   if ${JXR_PE_CFLAGS:+false} :
+then :
+  JXR_PE_CFLAGS="-I\$(top_srcdir)/libs/jxr/jxrgluelib -I\$(top_srcdir)/libs/jxr/image/sys"
+else case e in #(
+  e) enable_jxr=no ;;
+esac
+fi
+else case e in #(
+  e) enable_jxr=no ;;
+esac
+fi
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: jxr cflags: $JXR_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: jxr libs: $JXR_PE_LIBS" >&5
+
+if ${LCMS2_PE_LIBS:+false} :
+then :
+  LCMS2_PE_LIBS=lcms2
+   if ${LCMS2_PE_CFLAGS:+false} :
+then :
+  LCMS2_PE_CFLAGS="-I\$(top_srcdir)/libs/lcms2/include"
+else case e in #(
+  e) enable_lcms2=no ;;
+esac
+fi
+else case e in #(
+  e) enable_lcms2=no ;;
+esac
+fi
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: lcms2 cflags: $LCMS2_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: lcms2 libs: $LCMS2_PE_LIBS" >&5
+
+if ${LDAP_PE_LIBS:+false} :
+then :
+  LDAP_PE_LIBS=ldap
+   if ${LDAP_PE_CFLAGS:+false} :
+then :
+  LDAP_PE_CFLAGS="-I\$(top_srcdir)/libs/ldap/include"
+else case e in #(
+  e) enable_ldap=no ;;
+esac
+fi
+else case e in #(
+  e) enable_ldap=no ;;
+esac
+fi
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: ldap cflags: $LDAP_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: ldap libs: $LDAP_PE_LIBS" >&5
+
+if ${MPG123_PE_LIBS:+false} :
+then :
+  MPG123_PE_LIBS=mpg123
+   if ${MPG123_PE_CFLAGS:+false} :
+then :
+  MPG123_PE_CFLAGS="-I\$(top_srcdir)/libs/mpg123/src/include"
+else case e in #(
+  e) enable_mpg123=no ;;
+esac
+fi
+else case e in #(
+  e) enable_mpg123=no ;;
+esac
+fi
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: mpg123 cflags: $MPG123_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: mpg123 libs: $MPG123_PE_LIBS" >&5
+
+if ${MUSL_PE_LIBS:+false} :
+then :
+  MUSL_PE_LIBS=musl
+   if ${MUSL_PE_CFLAGS:+false} :
+then :
+  MUSL_PE_CFLAGS=
+else case e in #(
+  e) enable_musl=no ;;
+esac
+fi
+else case e in #(
+  e) enable_musl=no ;;
+esac
+fi
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: musl cflags: $MUSL_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: musl libs: $MUSL_PE_LIBS" >&5
+
+if ${PNG_PE_LIBS:+false} :
+then :
+  PNG_PE_LIBS="png \$(ZLIB_PE_LIBS)"
+   if ${PNG_PE_CFLAGS:+false} :
+then :
+  PNG_PE_CFLAGS="-I\$(top_srcdir)/libs/png"
+else case e in #(
+  e) enable_png=no ;;
+esac
+fi
+else case e in #(
+  e) enable_png=no ;;
+esac
+fi
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: png cflags: $PNG_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: png libs: $PNG_PE_LIBS" >&5
+
+if ${TIFF_PE_LIBS:+false} :
+then :
+  TIFF_PE_LIBS="tiff \$(ZLIB_PE_LIBS)"
+   if ${TIFF_PE_CFLAGS:+false} :
+then :
+  TIFF_PE_CFLAGS="-I\$(top_srcdir)/libs/tiff/libtiff"
+else case e in #(
+  e) enable_tiff=no ;;
+esac
+fi
+else case e in #(
+  e) enable_tiff=no ;;
+esac
+fi
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: tiff cflags: $TIFF_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: tiff libs: $TIFF_PE_LIBS" >&5
+
+if ${TOMCRYPT_PE_LIBS:+false} :
+then :
+  TOMCRYPT_PE_LIBS=tomcrypt
+   if ${TOMCRYPT_PE_CFLAGS:+false} :
+then :
+  TOMCRYPT_PE_CFLAGS="-I\$(top_srcdir)/libs/tomcrypt/src/headers -DLTC_NO_PROTOTYPES -DLTC_SOURCE"
+else case e in #(
+  e) enable_tomcrypt=no ;;
+esac
+fi
+else case e in #(
+  e) enable_tomcrypt=no ;;
+esac
+fi
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: tomcrypt cflags: $TOMCRYPT_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: tomcrypt libs: $TOMCRYPT_PE_LIBS" >&5
+
+if ${VKD3D_PE_LIBS:+false} :
+then :
+  VKD3D_PE_LIBS=vkd3d
+   if ${VKD3D_PE_CFLAGS:+false} :
+then :
+  VKD3D_PE_CFLAGS="-I\$(top_srcdir)/libs/vkd3d/include"
+else case e in #(
+  e) enable_vkd3d=no ;;
+esac
+fi
+else case e in #(
+  e) enable_vkd3d=no ;;
+esac
+fi
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: vkd3d cflags: $VKD3D_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: vkd3d libs: $VKD3D_PE_LIBS" >&5
+
+if ${XML2_PE_LIBS:+false} :
+then :
+  XML2_PE_LIBS=xml2
+   if ${XML2_PE_CFLAGS:+false} :
+then :
+  XML2_PE_CFLAGS="-I\$(top_srcdir)/libs/xml2/include -DLIBXML_STATIC"
+else case e in #(
+  e) enable_xml2=no ;;
+esac
+fi
+else case e in #(
+  e) enable_xml2=no ;;
+esac
+fi
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: xml2 cflags: $XML2_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: xml2 libs: $XML2_PE_LIBS" >&5
+
+if ${XSLT_PE_LIBS:+false} :
+then :
+  XSLT_PE_LIBS=xslt
+   if ${XSLT_PE_CFLAGS:+false} :
+then :
+  XSLT_PE_CFLAGS="-I\$(top_srcdir)/libs/xslt/libxslt -I\$(top_srcdir)/libs/xslt -DLIBXSLT_STATIC"
+else case e in #(
+  e) enable_xslt=no ;;
+esac
+fi
+else case e in #(
+  e) enable_xslt=no ;;
+esac
+fi
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: xslt cflags: $XSLT_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: xslt libs: $XSLT_PE_LIBS" >&5
+
+if ${ZLIB_PE_LIBS:+false} :
+then :
+  ZLIB_PE_LIBS=z
+   if ${ZLIB_PE_CFLAGS:+false} :
+then :
+  ZLIB_PE_CFLAGS="-I\$(top_srcdir)/libs/zlib -DFAR= -DZ_SOLO"
+else case e in #(
+  e) enable_zlib=no ;;
+esac
+fi
+else case e in #(
+  e) enable_zlib=no ;;
+esac
+fi
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: zlib cflags: $ZLIB_PE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: zlib libs: $ZLIB_PE_LIBS" >&5
+
+
+
+if test "x$with_pthread" = xno
+then :
+
+else case e in #(
+  e) ac_fn_c_check_func "$LINENO" "pthread_create" "ac_cv_func_pthread_create"
+if test "x$ac_cv_func_pthread_create" = xyes
+then :
+
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for pthread_create in -lpthread" >&5
+printf %s "checking for pthread_create in -lpthread... " >&6; }
+if test ${ac_cv_lib_pthread_pthread_create+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpthread  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char pthread_create (void);
+int
+main (void)
+{
+return pthread_create ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_pthread_pthread_create=yes
+else case e in #(
+  e) ac_cv_lib_pthread_pthread_create=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pthread_pthread_create" >&5
+printf "%s\n" "$ac_cv_lib_pthread_pthread_create" >&6; }
+if test "x$ac_cv_lib_pthread_pthread_create" = xyes
+then :
+  PTHREAD_LIBS="-lpthread"
+
+fi
+ ;;
+esac
+fi
+ ;;
+esac
+fi
+if test "x$ac_cv_func_pthread_create" != xyes -a "x$PTHREAD_LIBS" = x
+then :
+  case "x$with_pthread" in
+  xno) ;;
+  *)   as_fn_error $? "pthread ${notice_platform}development files not found.
+Wine cannot support threads without libpthread.
+Use the --without-pthread option if you really want this." "$LINENO" 5 ;;
+esac
+
+fi
+
+
+if test "x$with_opengl" != "xno"
+then
+    rm -f conftest.err
+if ${EGL_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  EGL_CFLAGS=`$PKG_CONFIG --cflags egl 2>conftest.err`
+fi
+fi
+
+if ${EGL_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  EGL_LIBS=`$PKG_CONFIG --libs egl 2>/dev/null`
+fi
+fi
+
+EGL_LIBS=${EGL_LIBS:-"-lEGL"}
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: egl cflags: $EGL_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: egl libs: $EGL_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: egl errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $EGL_CFLAGS"
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lEGL" >&5
+printf %s "checking for -lEGL... " >&6; }
+if test ${ac_cv_lib_soname_EGL+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lEGL $EGL_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char eglGetProcAddress (void);
+int
+main (void)
+{
+return eglGetProcAddress ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_EGL=`$ac_cv_path_LDD conftest.exe | grep "EGL" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_EGL=`$OTOOL -L conftest$ac_exeext | grep "libEGL\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libEGL\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_EGL=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libEGL\\.$LIBEXT" | sed -e "s/^.*\\[\\(libEGL\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_EGL:+false} :
+then :
+  ac_cv_lib_soname_EGL=`$LDD conftest$ac_exeext | grep "libEGL\\.$LIBEXT" | sed -e "s/^.*\(libEGL\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_EGL= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_EGL:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_EGL" >&5
+printf "%s\n" "$ac_cv_lib_soname_EGL" >&6; }
+
+printf "%s\n" "#define SONAME_LIBEGL \"$ac_cv_lib_soname_EGL\"" >>confdefs.h
+
+        ;;
+esac
+fi
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+if test -z "$ac_cv_lib_soname_EGL"
+then :
+  case "x$with_opengl" in
+  x)   as_fn_append wine_notices "|EGL ${notice_platform}development files not found" ;;
+  xno) ;;
+  *)   as_fn_error $? "EGL ${notice_platform}development files not found
+This is an error since --with-opengl was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
+printf %s "checking how to run the C preprocessor... " >&6; }
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+  if test ${ac_cv_prog_CPP+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e)     # Double quotes because $CC needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" cpp /lib/cpp
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <limits.h>
+		     Syntax error
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"
+then :
+
+else case e in #(
+  e) # Broken: fails on valid input.
+continue ;;
+esac
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"
+then :
+  # Broken: success on invalid input.
+continue
+else case e in #(
+  e) # Passes both tests.
+ac_preproc_ok=:
+break ;;
+esac
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+
+done
+# Because of 'break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.i conftest.err conftest.$ac_ext
+if $ac_preproc_ok
+then :
+  break
+fi
+
+    done
+    ac_cv_prog_CPP=$CPP
+   ;;
+esac
+fi
+  CPP=$ac_cv_prog_CPP
+else
+  ac_cv_prog_CPP=$CPP
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
+printf "%s\n" "$CPP" >&6; }
+ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <limits.h>
+		     Syntax error
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"
+then :
+
+else case e in #(
+  e) # Broken: fails on valid input.
+continue ;;
+esac
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"
+then :
+  # Broken: success on invalid input.
+continue
+else case e in #(
+  e) # Passes both tests.
+ac_preproc_ok=:
+break ;;
+esac
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+
+done
+# Because of 'break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.i conftest.err conftest.$ac_ext
+if $ac_preproc_ok
+then :
+
+else case e in #(
+  e) { { printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: in '$ac_pwd':" >&5
+printf "%s\n" "$as_me: error: in '$ac_pwd':" >&2;}
+as_fn_error $? "C preprocessor \"$CPP\" fails sanity check
+See 'config.log' for more details" "$LINENO" 5; } ;;
+esac
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for X" >&5
+printf %s "checking for X... " >&6; }
+
+
+# Check whether --with-x was given.
+if test ${with_x+y}
+then :
+  withval=$with_x;
+fi
+
+# $have_x is 'yes', 'no', 'disabled', or empty when we do not yet know.
+if test "x$with_x" = xno; then
+  # The user explicitly disabled X.
+  have_x=disabled
+else
+  case $x_includes,$x_libraries in #(
+    *\'*) as_fn_error $? "cannot use X directory names containing '" "$LINENO" 5;; #(
+    *,NONE | NONE,*) if test ${ac_cv_have_x+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) # One or both of the vars are not set, and there is no cached value.
+ac_x_includes=no
+ac_x_libraries=no
+# Do we need to do anything special at all?
+ac_save_LIBS=$LIBS
+LIBS="-lX11 $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <X11/Xlib.h>
+int
+main (void)
+{
+XrmInitialize ()
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  # We can compile and link X programs with no special options.
+  ac_x_includes=
+  ac_x_libraries=
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS="$ac_save_LIBS"
+# If that didn't work, only try xmkmf and file system searches
+# for native compilation.
+if test x"$ac_x_includes" = xno && test "$cross_compiling" = no
+then :
+  rm -f -r conftest.dir
+if mkdir conftest.dir; then
+  cd conftest.dir
+  cat >Imakefile <<'_ACEOF'
+incroot:
+	@echo incroot='${INCROOT}'
+usrlibdir:
+	@echo usrlibdir='${USRLIBDIR}'
+libdir:
+	@echo libdir='${LIBDIR}'
+_ACEOF
+  if (export CC; ${XMKMF-xmkmf}) >/dev/null 2>/dev/null && test -f Makefile; then
+    # GNU make sometimes prints "make[1]: Entering ...", which would confuse us.
+    for ac_var in incroot usrlibdir libdir; do
+      eval "ac_im_$ac_var=\`\${MAKE-make} $ac_var 2>/dev/null | sed -n 's/^$ac_var=//p'\`"
+    done
+    # Open Windows xmkmf reportedly sets LIBDIR instead of USRLIBDIR.
+    for ac_extension in a so sl dylib la dll; do
+      if test ! -f "$ac_im_usrlibdir/libX11.$ac_extension" &&
+	 test -f "$ac_im_libdir/libX11.$ac_extension"; then
+	ac_im_usrlibdir=$ac_im_libdir; break
+      fi
+    done
+    # Screen out bogus values from the imake configuration.  They are
+    # bogus both because they are the default anyway, and because
+    # using them would break gcc on systems where it needs fixed includes.
+    case $ac_im_incroot in
+	/usr/include) ac_x_includes= ;;
+	*) test -f "$ac_im_incroot/X11/Xos.h" && ac_x_includes=$ac_im_incroot;;
+    esac
+    case $ac_im_usrlibdir in
+	/usr/lib | /usr/lib64 | /lib | /lib64) ;;
+	*) test -d "$ac_im_usrlibdir" && ac_x_libraries=$ac_im_usrlibdir ;;
+    esac
+  fi
+  cd ..
+  rm -f -r conftest.dir
+fi
+
+  # Standard set of common directories for X headers.
+# Check X11 before X11Rn because it is often a symlink to the current release.
+ac_x_header_dirs='
+/usr/X11/include
+/usr/X11R7/include
+/usr/X11R6/include
+/usr/X11R5/include
+/usr/X11R4/include
+
+/usr/include/X11
+/usr/include/X11R7
+/usr/include/X11R6
+/usr/include/X11R5
+/usr/include/X11R4
+
+/usr/local/X11/include
+/usr/local/X11R7/include
+/usr/local/X11R6/include
+/usr/local/X11R5/include
+/usr/local/X11R4/include
+
+/usr/local/include/X11
+/usr/local/include/X11R7
+/usr/local/include/X11R6
+/usr/local/include/X11R5
+/usr/local/include/X11R4
+
+/opt/X11/include
+
+/usr/X386/include
+/usr/x386/include
+/usr/XFree86/include/X11
+
+/usr/include
+/usr/local/include
+/usr/unsupported/include
+/usr/athena/include
+/usr/local/x11r5/include
+/usr/lpp/Xamples/include
+
+/usr/openwin/include
+/usr/openwin/share/include'
+
+if test "$ac_x_includes" = no; then
+  # Guess where to find include files, by looking for Xlib.h.
+  # First, try using that file with no special directory specified.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <X11/Xlib.h>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"
+then :
+  # We can compile using X headers with no special include directory.
+ac_x_includes=
+else case e in #(
+  e) for ac_dir in $ac_x_header_dirs; do
+  if test -r "$ac_dir/X11/Xlib.h"; then
+    ac_x_includes=$ac_dir
+    break
+  fi
+done ;;
+esac
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+fi # $ac_x_includes = no
+
+if test "$ac_x_libraries" = no; then
+  # Check for the libraries.
+  # See if we find them without any special options.
+  # Don't add to $LIBS permanently.
+  ac_save_LIBS=$LIBS
+  LIBS="-lX11 $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <X11/Xlib.h>
+int
+main (void)
+{
+XrmInitialize ()
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  LIBS=$ac_save_LIBS
+# We can link X programs with no special library path.
+ac_x_libraries=
+else case e in #(
+  e) LIBS=$ac_save_LIBS
+for ac_dir in `printf "%s\n" "$ac_x_includes $ac_x_header_dirs" | sed s/include/lib/g`
+do
+  # Don't even attempt the hair of trying to link an X program!
+  for ac_extension in a so sl dylib la dll; do
+    if test -r "$ac_dir/libX11.$ac_extension"; then
+      ac_x_libraries=$ac_dir
+      break 2
+    fi
+  done
+done ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+fi # $ac_x_libraries = no
+
+fi
+# Record the results.
+case $ac_x_includes,$ac_x_libraries in #(
+  no,* | *,no | *\'*) :
+    # Didn't find X, or a directory has "'" in its name.
+    ac_cv_have_x="have_x=no" ;; #(
+  *) :
+    # Record where we found X for the cache.
+    ac_cv_have_x="have_x=yes\
+	ac_x_includes='$ac_x_includes'\
+	ac_x_libraries='$ac_x_libraries'" ;;
+esac ;;
+esac
+fi
+;; #(
+    *) have_x=yes;;
+  esac
+  eval "$ac_cv_have_x"
+fi # $with_x != no
+
+if test "$have_x" != yes; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $have_x" >&5
+printf "%s\n" "$have_x" >&6; }
+  no_x=yes
+else
+  # If each of the values was on the command line, it overrides each guess.
+  test "x$x_includes" = xNONE && x_includes=$ac_x_includes
+  test "x$x_libraries" = xNONE && x_libraries=$ac_x_libraries
+  # Update the cache value to reflect the command line values.
+  ac_cv_have_x="have_x=yes\
+	ac_x_includes='$x_includes'\
+	ac_x_libraries='$x_libraries'"
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: libraries $x_libraries, headers $x_includes" >&5
+printf "%s\n" "libraries $x_libraries, headers $x_includes" >&6; }
+fi
+
+if test "$have_x" = "yes"
+then
+    test -z "$x_includes" || X_CFLAGS="$X_CFLAGS -I$x_includes"
+
+    test -z "$x_libraries" || X_LIBS="$X_LIBS -L$x_libraries"
+
+
+    ac_save_CPPFLAGS="$CPPFLAGS"
+    CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lX11" >&5
+printf %s "checking for -lX11... " >&6; }
+if test ${ac_cv_lib_soname_X11+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lX11 $X_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char XCreateWindow (void);
+int
+main (void)
+{
+return XCreateWindow ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_X11=`$ac_cv_path_LDD conftest.exe | grep "X11" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_X11=`$OTOOL -L conftest$ac_exeext | grep "libX11\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libX11\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_X11=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libX11\\.$LIBEXT" | sed -e "s/^.*\\[\\(libX11\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_X11:+false} :
+then :
+  ac_cv_lib_soname_X11=`$LDD conftest$ac_exeext | grep "libX11\\.$LIBEXT" | sed -e "s/^.*\(libX11\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_X11= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_X11:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_X11" >&5
+printf "%s\n" "$ac_cv_lib_soname_X11" >&6; }
+
+printf "%s\n" "#define SONAME_LIBX11 \"$ac_cv_lib_soname_X11\"" >>confdefs.h
+
+        ;;
+esac
+fi
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lXext" >&5
+printf %s "checking for -lXext... " >&6; }
+if test ${ac_cv_lib_soname_Xext+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lXext $X_LIBS -lX11 $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char XextCreateExtension (void);
+int
+main (void)
+{
+return XextCreateExtension ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_Xext=`$ac_cv_path_LDD conftest.exe | grep "Xext" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_Xext=`$OTOOL -L conftest$ac_exeext | grep "libXext\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libXext\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_Xext=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libXext\\.$LIBEXT" | sed -e "s/^.*\\[\\(libXext\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_Xext:+false} :
+then :
+  ac_cv_lib_soname_Xext=`$LDD conftest$ac_exeext | grep "libXext\\.$LIBEXT" | sed -e "s/^.*\(libXext\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_Xext= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_Xext:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xext" >&5
+printf "%s\n" "$ac_cv_lib_soname_Xext" >&6; }
+
+printf "%s\n" "#define SONAME_LIBXEXT \"$ac_cv_lib_soname_Xext\"" >>confdefs.h
+
+       X_LIBS="$X_LIBS -lXext" ;;
+esac
+fi
+    X_LIBS="$X_LIBS -lX11"
+
+    xlib_includes="#include <X11/Xlib.h>
+#include <X11/Xutil.h>"
+
+        ac_fn_c_check_header_compile "$LINENO" "X11/extensions/shape.h" "ac_cv_header_X11_extensions_shape_h" "$xlib_includes
+"
+if test "x$ac_cv_header_X11_extensions_shape_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_EXTENSIONS_SHAPE_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "X11/extensions/XInput2.h" "ac_cv_header_X11_extensions_XInput2_h" "$xlib_includes
+"
+if test "x$ac_cv_header_X11_extensions_XInput2_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_EXTENSIONS_XINPUT2_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "X11/extensions/XShm.h" "ac_cv_header_X11_extensions_XShm_h" "$xlib_includes
+"
+if test "x$ac_cv_header_X11_extensions_XShm_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_EXTENSIONS_XSHM_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "X11/extensions/Xfixes.h" "ac_cv_header_X11_extensions_Xfixes_h" "$xlib_includes
+"
+if test "x$ac_cv_header_X11_extensions_Xfixes_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_EXTENSIONS_XFIXES_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "X11/extensions/Xinerama.h" "ac_cv_header_X11_extensions_Xinerama_h" "$xlib_includes
+"
+if test "x$ac_cv_header_X11_extensions_Xinerama_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_EXTENSIONS_XINERAMA_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "X11/extensions/Xrandr.h" "ac_cv_header_X11_extensions_Xrandr_h" "$xlib_includes
+"
+if test "x$ac_cv_header_X11_extensions_Xrandr_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_EXTENSIONS_XRANDR_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "X11/extensions/Xrender.h" "ac_cv_header_X11_extensions_Xrender_h" "$xlib_includes
+"
+if test "x$ac_cv_header_X11_extensions_Xrender_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_EXTENSIONS_XRENDER_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "X11/extensions/xf86vmode.h" "ac_cv_header_X11_extensions_xf86vmode_h" "$xlib_includes
+"
+if test "x$ac_cv_header_X11_extensions_xf86vmode_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_EXTENSIONS_XF86VMODE_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "X11/extensions/xf86vmproto.h" "ac_cv_header_X11_extensions_xf86vmproto_h" "$xlib_includes
+"
+if test "x$ac_cv_header_X11_extensions_xf86vmproto_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_X11_EXTENSIONS_XF86VMPROTO_H 1" >>confdefs.h
+
+fi
+
+
+                ac_fn_c_check_header_compile "$LINENO" "X11/Xcursor/Xcursor.h" "ac_cv_header_X11_Xcursor_Xcursor_h" "$xlib_includes
+"
+if test "x$ac_cv_header_X11_Xcursor_Xcursor_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lXcursor" >&5
+printf %s "checking for -lXcursor... " >&6; }
+if test ${ac_cv_lib_soname_Xcursor+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lXcursor $X_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char XcursorImageLoadCursor (void);
+int
+main (void)
+{
+return XcursorImageLoadCursor ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_Xcursor=`$ac_cv_path_LDD conftest.exe | grep "Xcursor" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_Xcursor=`$OTOOL -L conftest$ac_exeext | grep "libXcursor\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libXcursor\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_Xcursor=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libXcursor\\.$LIBEXT" | sed -e "s/^.*\\[\\(libXcursor\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_Xcursor:+false} :
+then :
+  ac_cv_lib_soname_Xcursor=`$LDD conftest$ac_exeext | grep "libXcursor\\.$LIBEXT" | sed -e "s/^.*\(libXcursor\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_Xcursor= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_Xcursor:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xcursor" >&5
+printf "%s\n" "$ac_cv_lib_soname_Xcursor" >&6; }
+
+printf "%s\n" "#define SONAME_LIBXCURSOR \"$ac_cv_lib_soname_Xcursor\"" >>confdefs.h
+
+        ;;
+esac
+fi
+fi
+
+        if test "x$ac_cv_lib_soname_Xcursor" = "x"
+then :
+  case "x$with_xcursor" in
+  x)   as_fn_append wine_notices "|libxcursor ${notice_platform}development files not found, the Xcursor extension won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libxcursor ${notice_platform}development files not found, the Xcursor extension won't be supported.
+This is an error since --with-xcursor was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+                ac_fn_c_check_header_compile "$LINENO" "X11/extensions/XInput.h" "ac_cv_header_X11_extensions_XInput_h" "$xlib_includes
+"
+if test "x$ac_cv_header_X11_extensions_XInput_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lXi" >&5
+printf %s "checking for -lXi... " >&6; }
+if test ${ac_cv_lib_soname_Xi+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lXi $X_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char XOpenDevice (void);
+int
+main (void)
+{
+return XOpenDevice ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_Xi=`$ac_cv_path_LDD conftest.exe | grep "Xi" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_Xi=`$OTOOL -L conftest$ac_exeext | grep "libXi\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libXi\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_Xi=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libXi\\.$LIBEXT" | sed -e "s/^.*\\[\\(libXi\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_Xi:+false} :
+then :
+  ac_cv_lib_soname_Xi=`$LDD conftest$ac_exeext | grep "libXi\\.$LIBEXT" | sed -e "s/^.*\(libXi\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_Xi= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_Xi:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xi" >&5
+printf "%s\n" "$ac_cv_lib_soname_Xi" >&6; }
+
+printf "%s\n" "#define SONAME_LIBXI \"$ac_cv_lib_soname_Xi\"" >>confdefs.h
+
+        ;;
+esac
+fi
+fi
+
+        if test "x$ac_cv_lib_soname_Xi" = "x"
+then :
+  case "x$with_xinput" in
+  x)   as_fn_append wine_notices "|libxi ${notice_platform}development files not found, the Xinput extension won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libxi ${notice_platform}development files not found, the Xinput extension won't be supported.
+This is an error since --with-xinput was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+                if test "x$ac_cv_lib_soname_Xi" != x
+        then
+            if test "$ac_cv_header_X11_extensions_XInput2_h" != "yes"
+then :
+  case "x$with_xinput2" in
+  x)   as_fn_append wine_notices "|XInput2 headers not found, the XInput 2 extension won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "XInput2 headers not found, the XInput 2 extension won't be supported.
+This is an error since --with-xinput2 was requested." "$LINENO" 5 ;;
+esac
+
+fi
+        fi
+
+                if test "$ac_cv_header_X11_extensions_XShm_h" = "yes"
+        then
+              { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for XShmQueryExtension in -lXext" >&5
+printf %s "checking for XShmQueryExtension in -lXext... " >&6; }
+if test ${ac_cv_lib_Xext_XShmQueryExtension+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lXext $X_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char XShmQueryExtension (void);
+int
+main (void)
+{
+return XShmQueryExtension ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_Xext_XShmQueryExtension=yes
+else case e in #(
+  e) ac_cv_lib_Xext_XShmQueryExtension=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Xext_XShmQueryExtension" >&5
+printf "%s\n" "$ac_cv_lib_Xext_XShmQueryExtension" >&6; }
+if test "x$ac_cv_lib_Xext_XShmQueryExtension" = xyes
+then :
+
+printf "%s\n" "#define HAVE_LIBXXSHM 1" >>confdefs.h
+
+fi
+
+        fi
+        if test "$ac_cv_lib_Xext_XShmQueryExtension" != "yes"
+then :
+  case "x$with_xshm" in
+  x)   as_fn_append wine_notices "|XShm ${notice_platform}development files not found, X Shared Memory won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "XShm ${notice_platform}development files not found, X Shared Memory won't be supported.
+This is an error since --with-xshm was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+                if test "$ac_cv_header_X11_extensions_shape_h" = "yes"
+        then
+              { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for XShapeQueryExtension in -lXext" >&5
+printf %s "checking for XShapeQueryExtension in -lXext... " >&6; }
+if test ${ac_cv_lib_Xext_XShapeQueryExtension+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lXext $X_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char XShapeQueryExtension (void);
+int
+main (void)
+{
+return XShapeQueryExtension ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_Xext_XShapeQueryExtension=yes
+else case e in #(
+  e) ac_cv_lib_Xext_XShapeQueryExtension=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Xext_XShapeQueryExtension" >&5
+printf "%s\n" "$ac_cv_lib_Xext_XShapeQueryExtension" >&6; }
+if test "x$ac_cv_lib_Xext_XShapeQueryExtension" = xyes
+then :
+
+printf "%s\n" "#define HAVE_LIBXSHAPE 1" >>confdefs.h
+
+fi
+
+        fi
+        if test "$ac_cv_lib_Xext_XShapeQueryExtension" != "yes"
+then :
+  case "x$with_xshape" in
+  x)   as_fn_append wine_notices "|XShape ${notice_platform}development files not found, XShape won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "XShape ${notice_platform}development files not found, XShape won't be supported.
+This is an error since --with-xshape was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+                if test "$ac_cv_header_X11_extensions_xf86vmode_h" = "yes" -o "$ac_cv_header_X11_extensions_xf86vmproto_h" = "yes"
+        then
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lXxf86vm" >&5
+printf %s "checking for -lXxf86vm... " >&6; }
+if test ${ac_cv_lib_soname_Xxf86vm+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lXxf86vm $X_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char XF86VidModeQueryExtension (void);
+int
+main (void)
+{
+return XF86VidModeQueryExtension ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_Xxf86vm=`$ac_cv_path_LDD conftest.exe | grep "Xxf86vm" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_Xxf86vm=`$OTOOL -L conftest$ac_exeext | grep "libXxf86vm\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libXxf86vm\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_Xxf86vm=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libXxf86vm\\.$LIBEXT" | sed -e "s/^.*\\[\\(libXxf86vm\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_Xxf86vm:+false} :
+then :
+  ac_cv_lib_soname_Xxf86vm=`$LDD conftest$ac_exeext | grep "libXxf86vm\\.$LIBEXT" | sed -e "s/^.*\(libXxf86vm\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_Xxf86vm= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_Xxf86vm:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xxf86vm" >&5
+printf "%s\n" "$ac_cv_lib_soname_Xxf86vm" >&6; }
+
+printf "%s\n" "#define SONAME_LIBXXF86VM \"$ac_cv_lib_soname_Xxf86vm\"" >>confdefs.h
+
+        ;;
+esac
+fi
+        fi
+        if test "x$ac_cv_lib_soname_Xxf86vm" = "x"
+then :
+  case "x$with_xxf86vm" in
+  x)   as_fn_append wine_notices "|libXxf86vm ${notice_platform}development files not found, XFree86 Vidmode won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libXxf86vm ${notice_platform}development files not found, XFree86 Vidmode won't be supported.
+This is an error since --with-xxf86vm was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+                if test "$ac_cv_header_X11_extensions_Xrender_h" = "yes" -a "x$ac_cv_lib_soname_X11" != "x"
+        then
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lXrender" >&5
+printf %s "checking for -lXrender... " >&6; }
+if test ${ac_cv_lib_soname_Xrender+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lXrender $X_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char XRenderQueryExtension (void);
+int
+main (void)
+{
+return XRenderQueryExtension ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_Xrender=`$ac_cv_path_LDD conftest.exe | grep "Xrender" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_Xrender=`$OTOOL -L conftest$ac_exeext | grep "libXrender\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libXrender\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_Xrender=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libXrender\\.$LIBEXT" | sed -e "s/^.*\\[\\(libXrender\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_Xrender:+false} :
+then :
+  ac_cv_lib_soname_Xrender=`$LDD conftest$ac_exeext | grep "libXrender\\.$LIBEXT" | sed -e "s/^.*\(libXrender\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_Xrender= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_Xrender:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xrender" >&5
+printf "%s\n" "$ac_cv_lib_soname_Xrender" >&6; }
+
+printf "%s\n" "#define SONAME_LIBXRENDER \"$ac_cv_lib_soname_Xrender\"" >>confdefs.h
+
+       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for XRenderSetPictureTransform in -lXrender" >&5
+printf %s "checking for XRenderSetPictureTransform in -lXrender... " >&6; }
+if test ${ac_cv_lib_Xrender_XRenderSetPictureTransform+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lXrender $X_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char XRenderSetPictureTransform (void);
+int
+main (void)
+{
+return XRenderSetPictureTransform ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_Xrender_XRenderSetPictureTransform=yes
+else case e in #(
+  e) ac_cv_lib_Xrender_XRenderSetPictureTransform=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Xrender_XRenderSetPictureTransform" >&5
+printf "%s\n" "$ac_cv_lib_Xrender_XRenderSetPictureTransform" >&6; }
+if test "x$ac_cv_lib_Xrender_XRenderSetPictureTransform" = xyes
+then :
+
+printf "%s\n" "#define HAVE_XRENDERSETPICTURETRANSFORM 1" >>confdefs.h
+
+fi
+
+               { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for XRenderCreateLinearGradient in -lXrender" >&5
+printf %s "checking for XRenderCreateLinearGradient in -lXrender... " >&6; }
+if test ${ac_cv_lib_Xrender_XRenderCreateLinearGradient+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lXrender $X_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char XRenderCreateLinearGradient (void);
+int
+main (void)
+{
+return XRenderCreateLinearGradient ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_Xrender_XRenderCreateLinearGradient=yes
+else case e in #(
+  e) ac_cv_lib_Xrender_XRenderCreateLinearGradient=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Xrender_XRenderCreateLinearGradient" >&5
+printf "%s\n" "$ac_cv_lib_Xrender_XRenderCreateLinearGradient" >&6; }
+if test "x$ac_cv_lib_Xrender_XRenderCreateLinearGradient" = xyes
+then :
+
+printf "%s\n" "#define HAVE_XRENDERCREATELINEARGRADIENT 1" >>confdefs.h
+
+fi
+ ;;
+esac
+fi
+
+        fi
+        if test "x$ac_cv_lib_soname_Xrender" = "x"
+then :
+  case "x$with_xrender" in
+  x)   as_fn_append wine_warnings "|libxrender ${notice_platform}development files not found, XRender won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libxrender ${notice_platform}development files not found, XRender won't be supported.
+This is an error since --with-xrender was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+                if test "$ac_cv_header_X11_extensions_Xrandr_h" = "yes" -a "x$ac_cv_lib_soname_Xrender" != "x"
+        then
+                cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <X11/Xlib.h>
+#include <X11/extensions/Xrandr.h>
+int
+main (void)
+{
+static typeof(XRRSetScreenConfigAndRate) * func; if (func) return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lXrandr" >&5
+printf %s "checking for -lXrandr... " >&6; }
+if test ${ac_cv_lib_soname_Xrandr+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lXrandr $X_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char XRRQueryExtension (void);
+int
+main (void)
+{
+return XRRQueryExtension ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_Xrandr=`$ac_cv_path_LDD conftest.exe | grep "Xrandr" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_Xrandr=`$OTOOL -L conftest$ac_exeext | grep "libXrandr\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libXrandr\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_Xrandr=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libXrandr\\.$LIBEXT" | sed -e "s/^.*\\[\\(libXrandr\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_Xrandr:+false} :
+then :
+  ac_cv_lib_soname_Xrandr=`$LDD conftest$ac_exeext | grep "libXrandr\\.$LIBEXT" | sed -e "s/^.*\(libXrandr\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_Xrandr= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_Xrandr:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xrandr" >&5
+printf "%s\n" "$ac_cv_lib_soname_Xrandr" >&6; }
+
+printf "%s\n" "#define SONAME_LIBXRANDR \"$ac_cv_lib_soname_Xrandr\"" >>confdefs.h
+
+       cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <X11/Xlib.h>
+#include <X11/extensions/Xrandr.h>
+int
+main (void)
+{
+static typeof(XRRGetProviderResources) *f; if (f) return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+
+printf "%s\n" "#define HAVE_XRRGETPROVIDERRESOURCES 1" >>confdefs.h
+
+else case e in #(
+  e) as_fn_append wine_notices "|libxrandr ${notice_platform}development files too old, XRandR display device handler won't be supported." ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;
+esac
+fi
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+        fi
+        if test "x$ac_cv_lib_soname_Xrandr" = "x"
+then :
+  case "x$with_xrandr" in
+  x)   as_fn_append wine_notices "|libxrandr ${notice_platform}development files not found, XRandr won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libxrandr ${notice_platform}development files not found, XRandr won't be supported.
+This is an error since --with-xrandr was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+                if test "$ac_cv_header_X11_extensions_Xfixes_h" = "yes"
+        then
+                cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <X11/Xlib.h>
+#include <X11/extensions/Xfixes.h>
+int
+main (void)
+{
+static typeof(XFixesQueryVersion) * func; if (func) return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lXfixes" >&5
+printf %s "checking for -lXfixes... " >&6; }
+if test ${ac_cv_lib_soname_Xfixes+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lXfixes $X_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char XFixesQueryVersion (void);
+int
+main (void)
+{
+return XFixesQueryVersion ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_Xfixes=`$ac_cv_path_LDD conftest.exe | grep "Xfixes" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_Xfixes=`$OTOOL -L conftest$ac_exeext | grep "libXfixes\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libXfixes\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_Xfixes=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libXfixes\\.$LIBEXT" | sed -e "s/^.*\\[\\(libXfixes\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_Xfixes:+false} :
+then :
+  ac_cv_lib_soname_Xfixes=`$LDD conftest$ac_exeext | grep "libXfixes\\.$LIBEXT" | sed -e "s/^.*\(libXfixes\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_Xfixes= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_Xfixes:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xfixes" >&5
+printf "%s\n" "$ac_cv_lib_soname_Xfixes" >&6; }
+
+printf "%s\n" "#define SONAME_LIBXFIXES \"$ac_cv_lib_soname_Xfixes\"" >>confdefs.h
+
+        ;;
+esac
+fi
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+        fi
+        if test "x$ac_cv_lib_soname_Xfixes" = "x"
+then :
+  case "x$with_xfixes" in
+  x)   as_fn_append wine_notices "|libxfixes ${notice_platform}development files not found, Xfixes won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libxfixes ${notice_platform}development files not found, Xfixes won't be supported.
+This is an error since --with-xfixes was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+                if test "$ac_cv_header_X11_extensions_Xinerama_h" = "yes"
+        then
+                cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <X11/Xlib.h>
+#include <X11/extensions/Xinerama.h>
+int
+main (void)
+{
+static typeof(XineramaQueryScreens) * func; if (func) return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lXinerama" >&5
+printf %s "checking for -lXinerama... " >&6; }
+if test ${ac_cv_lib_soname_Xinerama+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lXinerama $X_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char XineramaQueryScreens (void);
+int
+main (void)
+{
+return XineramaQueryScreens ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_Xinerama=`$ac_cv_path_LDD conftest.exe | grep "Xinerama" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_Xinerama=`$OTOOL -L conftest$ac_exeext | grep "libXinerama\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libXinerama\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_Xinerama=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libXinerama\\.$LIBEXT" | sed -e "s/^.*\\[\\(libXinerama\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_Xinerama:+false} :
+then :
+  ac_cv_lib_soname_Xinerama=`$LDD conftest$ac_exeext | grep "libXinerama\\.$LIBEXT" | sed -e "s/^.*\(libXinerama\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_Xinerama= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_Xinerama:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xinerama" >&5
+printf "%s\n" "$ac_cv_lib_soname_Xinerama" >&6; }
+
+printf "%s\n" "#define SONAME_LIBXINERAMA \"$ac_cv_lib_soname_Xinerama\"" >>confdefs.h
+
+        ;;
+esac
+fi
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+        fi
+        if test "x$ac_cv_lib_soname_Xinerama" = "x"
+then :
+  case "x$with_xinerama" in
+  x)   as_fn_append wine_notices "|libxinerama ${notice_platform}development files not found, multi-monitor setups won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libxinerama ${notice_platform}development files not found, multi-monitor setups won't be supported.
+This is an error since --with-xinerama was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+                ac_fn_c_check_header_compile "$LINENO" "X11/extensions/Xcomposite.h" "ac_cv_header_X11_extensions_Xcomposite_h" "$xlib_includes
+"
+if test "x$ac_cv_header_X11_extensions_Xcomposite_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lXcomposite" >&5
+printf %s "checking for -lXcomposite... " >&6; }
+if test ${ac_cv_lib_soname_Xcomposite+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lXcomposite $X_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char XCompositeRedirectWindow (void);
+int
+main (void)
+{
+return XCompositeRedirectWindow ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_Xcomposite=`$ac_cv_path_LDD conftest.exe | grep "Xcomposite" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_Xcomposite=`$OTOOL -L conftest$ac_exeext | grep "libXcomposite\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libXcomposite\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_Xcomposite=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libXcomposite\\.$LIBEXT" | sed -e "s/^.*\\[\\(libXcomposite\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_Xcomposite:+false} :
+then :
+  ac_cv_lib_soname_Xcomposite=`$LDD conftest$ac_exeext | grep "libXcomposite\\.$LIBEXT" | sed -e "s/^.*\(libXcomposite\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_Xcomposite= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_Xcomposite:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_Xcomposite" >&5
+printf "%s\n" "$ac_cv_lib_soname_Xcomposite" >&6; }
+
+printf "%s\n" "#define SONAME_LIBXCOMPOSITE \"$ac_cv_lib_soname_Xcomposite\"" >>confdefs.h
+
+        ;;
+esac
+fi
+fi
+
+        if test "x$ac_cv_lib_soname_Xcomposite" = "x"
+then :
+  case "x$with_xcomposite" in
+  x)   as_fn_append wine_notices "|libxcomposite ${notice_platform}development files not found, Xcomposite won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libxcomposite ${notice_platform}development files not found, Xcomposite won't be supported.
+This is an error since --with-xcomposite was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+                ac_fn_c_check_member "$LINENO" "XICCallback" "callback" "ac_cv_member_XICCallback_callback" "$xlib_includes
+"
+if test "x$ac_cv_member_XICCallback_callback" = xyes
+then :
+
+printf "%s\n" "#define HAVE_XICCALLBACK_CALLBACK 1" >>confdefs.h
+
+
+fi
+ac_fn_c_check_member "$LINENO" "XEvent" "xcookie" "ac_cv_member_XEvent_xcookie" "$xlib_includes
+"
+if test "x$ac_cv_member_XEvent_xcookie" = xyes
+then :
+
+printf "%s\n" "#define HAVE_XEVENT_XCOOKIE 1" >>confdefs.h
+
+
+fi
+
+
+
+        opengl_msg=""
+    if test "x$with_opengl" != "xno"
+    then
+	{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lGL" >&5
+printf %s "checking for -lGL... " >&6; }
+if test ${ac_cv_lib_soname_GL+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lGL $X_LIBS -lm $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char glXCreateContext (void);
+int
+main (void)
+{
+return glXCreateContext ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_GL=`$ac_cv_path_LDD conftest.exe | grep "GL" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_GL=`$OTOOL -L conftest$ac_exeext | grep "libGL\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libGL\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_GL=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libGL\\.$LIBEXT" | sed -e "s/^.*\\[\\(libGL\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_GL:+false} :
+then :
+  ac_cv_lib_soname_GL=`$LDD conftest$ac_exeext | grep "libGL\\.$LIBEXT" | sed -e "s/^.*\(libGL\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_GL= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_GL:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lGL" >&5
+printf %s "checking for -lGL... " >&6; }
+if test ${ac_cv_lib_soname_GL+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lGL $X_LIBS -lm -dylib_file /System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib:/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char glXCreateContext (void);
+int
+main (void)
+{
+return glXCreateContext ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_GL=`$ac_cv_path_LDD conftest.exe | grep "GL" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_GL=`$OTOOL -L conftest$ac_exeext | grep "libGL\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libGL\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_GL=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libGL\\.$LIBEXT" | sed -e "s/^.*\\[\\(libGL\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_GL:+false} :
+then :
+  ac_cv_lib_soname_GL=`$LDD conftest$ac_exeext | grep "libGL\\.$LIBEXT" | sed -e "s/^.*\(libGL\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_GL= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_GL:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+       if test -f /usr/X11R6/lib/libGL.a
+                            then
+	                        opengl_msg="/usr/X11R6/lib/libGL.a is present on your system.
+This probably prevents linking to OpenGL. Try deleting the file and restarting configure."
+                            else
+                                opengl_msg="No OpenGL library found on this system."
+                            fi
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_GL" >&5
+printf "%s\n" "$ac_cv_lib_soname_GL" >&6; }
+
+printf "%s\n" "#define SONAME_LIBGL \"$ac_cv_lib_soname_GL\"" >>confdefs.h
+
+       OPENGL_LIBS="-Xlinker -dylib_file -Xlinker /System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib:/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib -lGL" ;;
+esac
+fi
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_GL" >&5
+printf "%s\n" "$ac_cv_lib_soname_GL" >&6; }
+
+printf "%s\n" "#define SONAME_LIBGL \"$ac_cv_lib_soname_GL\"" >>confdefs.h
+
+       OPENGL_LIBS="-lGL" ;;
+esac
+fi
+    fi
+    if test -n "$opengl_msg"
+then :
+  case "x$with_opengl" in
+  x)   as_fn_append wine_warnings "|$opengl_msg
+OpenGL and Direct3D won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "$opengl_msg
+OpenGL and Direct3D won't be supported.
+This is an error since --with-opengl was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+    CPPFLAGS="$ac_save_CPPFLAGS"
+else
+    X_CFLAGS=""
+    X_LIBS=""
+fi
+
+if test "x$with_wayland" != "xno"
+then
+    rm -f conftest.err
+if ${WAYLAND_CLIENT_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_CLIENT_CFLAGS=`$PKG_CONFIG --cflags wayland-client 2>conftest.err`
+fi
+fi
+
+if ${WAYLAND_CLIENT_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_CLIENT_LIBS=`$PKG_CONFIG --libs wayland-client 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-client cflags: $WAYLAND_CLIENT_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-client libs: $WAYLAND_CLIENT_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: wayland-client errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $WAYLAND_CLIENT_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "wayland-client.h" "ac_cv_header_wayland_client_h" "$ac_includes_default"
+if test "x$ac_cv_header_wayland_client_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for wl_display_connect in -lwayland-client" >&5
+printf %s "checking for wl_display_connect in -lwayland-client... " >&6; }
+if test ${ac_cv_lib_wayland_client_wl_display_connect+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lwayland-client $WAYLAND_CLIENT_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char wl_display_connect (void);
+int
+main (void)
+{
+return wl_display_connect ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_wayland_client_wl_display_connect=yes
+else case e in #(
+  e) ac_cv_lib_wayland_client_wl_display_connect=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_wayland_client_wl_display_connect" >&5
+printf "%s\n" "$ac_cv_lib_wayland_client_wl_display_connect" >&6; }
+if test "x$ac_cv_lib_wayland_client_wl_display_connect" = xyes
+then :
+  # Extract the first word of "wayland-scanner", so it can be a program name with args.
+set dummy wayland-scanner; ac_word=$2
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+printf %s "checking for $ac_word... " >&6; }
+if test ${ac_cv_path_WAYLAND_SCANNER+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) case $WAYLAND_SCANNER in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_WAYLAND_SCANNER="$WAYLAND_SCANNER" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir$ac_word$ac_exec_ext"; then
+    ac_cv_path_WAYLAND_SCANNER="$as_dir$ac_word$ac_exec_ext"
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_WAYLAND_SCANNER" && ac_cv_path_WAYLAND_SCANNER="`test -n "$PKG_CONFIG" && $PKG_CONFIG --variable=wayland_scanner wayland-scanner 2>/dev/null`"
+  ;;
+esac ;;
+esac
+fi
+WAYLAND_SCANNER=$ac_cv_path_WAYLAND_SCANNER
+if test -n "$WAYLAND_SCANNER"; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $WAYLAND_SCANNER" >&5
+printf "%s\n" "$WAYLAND_SCANNER" >&6; }
+else
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+fi
+
+
+else case e in #(
+  e) WAYLAND_CLIENT_LIBS="" ;;
+esac
+fi
+
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    rm -f conftest.err
+if ${XKBCOMMON_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  XKBCOMMON_CFLAGS=`$PKG_CONFIG --cflags xkbcommon 2>conftest.err`
+fi
+fi
+
+if ${XKBCOMMON_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  XKBCOMMON_LIBS=`$PKG_CONFIG --libs xkbcommon 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: xkbcommon cflags: $XKBCOMMON_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: xkbcommon libs: $XKBCOMMON_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: xkbcommon errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $XKBCOMMON_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "xkbcommon/xkbcommon.h" "ac_cv_header_xkbcommon_xkbcommon_h" "$ac_includes_default"
+if test "x$ac_cv_header_xkbcommon_xkbcommon_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_XKBCOMMON_XKBCOMMON_H 1" >>confdefs.h
+
+fi
+
+         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for xkb_context_new in -lxkbcommon" >&5
+printf %s "checking for xkb_context_new in -lxkbcommon... " >&6; }
+if test ${ac_cv_lib_xkbcommon_xkb_context_new+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lxkbcommon $XKBCOMMON_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char xkb_context_new (void);
+int
+main (void)
+{
+return xkb_context_new ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_xkbcommon_xkb_context_new=yes
+else case e in #(
+  e) ac_cv_lib_xkbcommon_xkb_context_new=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_xkbcommon_xkb_context_new" >&5
+printf "%s\n" "$ac_cv_lib_xkbcommon_xkb_context_new" >&6; }
+if test "x$ac_cv_lib_xkbcommon_xkb_context_new" = xyes
+then :
+  :
+else case e in #(
+  e) XKBCOMMON_LIBS="" ;;
+esac
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    rm -f conftest.err
+if ${XKBREGISTRY_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  XKBREGISTRY_CFLAGS=`$PKG_CONFIG --cflags xkbregistry 2>conftest.err`
+fi
+fi
+
+if ${XKBREGISTRY_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  XKBREGISTRY_LIBS=`$PKG_CONFIG --libs xkbregistry 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: xkbregistry cflags: $XKBREGISTRY_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: xkbregistry libs: $XKBREGISTRY_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: xkbregistry errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $XKBREGISTRY_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "xkbcommon/xkbregistry.h" "ac_cv_header_xkbcommon_xkbregistry_h" "$ac_includes_default"
+if test "x$ac_cv_header_xkbcommon_xkbregistry_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_XKBCOMMON_XKBREGISTRY_H 1" >>confdefs.h
+
+fi
+
+         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for rxkb_context_new in -lxkbregistry" >&5
+printf %s "checking for rxkb_context_new in -lxkbregistry... " >&6; }
+if test ${ac_cv_lib_xkbregistry_rxkb_context_new+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lxkbregistry $XKBREGISTRY_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char rxkb_context_new (void);
+int
+main (void)
+{
+return rxkb_context_new ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_xkbregistry_rxkb_context_new=yes
+else case e in #(
+  e) ac_cv_lib_xkbregistry_rxkb_context_new=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_xkbregistry_rxkb_context_new" >&5
+printf "%s\n" "$ac_cv_lib_xkbregistry_rxkb_context_new" >&6; }
+if test "x$ac_cv_lib_xkbregistry_rxkb_context_new" = xyes
+then :
+  :
+else case e in #(
+  e) XKBREGISTRY_LIBS="" ;;
+esac
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    if test "x$with_opengl" != "xno"
+    then
+        rm -f conftest.err
+if ${WAYLAND_EGL_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_EGL_CFLAGS=`$PKG_CONFIG --cflags wayland-egl 2>conftest.err`
+fi
+fi
+
+if ${WAYLAND_EGL_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_EGL_LIBS=`$PKG_CONFIG --libs wayland-egl 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-egl cflags: $WAYLAND_EGL_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-egl libs: $WAYLAND_EGL_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: wayland-egl errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $WAYLAND_EGL_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "wayland-egl.h" "ac_cv_header_wayland_egl_h" "$ac_includes_default"
+if test "x$ac_cv_header_wayland_egl_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for wl_egl_window_create in -lwayland-egl" >&5
+printf %s "checking for wl_egl_window_create in -lwayland-egl... " >&6; }
+if test ${ac_cv_lib_wayland_egl_wl_egl_window_create+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lwayland-egl $WAYLAND_EGL_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char wl_egl_window_create (void);
+int
+main (void)
+{
+return wl_egl_window_create ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_wayland_egl_wl_egl_window_create=yes
+else case e in #(
+  e) ac_cv_lib_wayland_egl_wl_egl_window_create=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_wayland_egl_wl_egl_window_create" >&5
+printf "%s\n" "$ac_cv_lib_wayland_egl_wl_egl_window_create" >&6; }
+if test "x$ac_cv_lib_wayland_egl_wl_egl_window_create" = xyes
+then :
+
+printf "%s\n" "#define HAVE_LIBWAYLAND_EGL 1" >>confdefs.h
+
+else case e in #(
+  e) WAYLAND_EGL_LIBS="" ;;
+esac
+fi
+
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+        if test "x$with_wayland" != "x"
+        then
+            if test -z "$ac_cv_lib_soname_EGL" -o "$ac_cv_lib_wayland_egl_wl_egl_window_create" != yes
+then :
+  case "x$with_opengl" in
+  x)   as_fn_append wine_notices "|EGL ${notice_platform}development files not found, the Wayland driver won't support OpenGL" ;;
+  xno) ;;
+  *)   as_fn_error $? "EGL ${notice_platform}development files not found, the Wayland driver won't support OpenGL
+This is an error since --with-opengl was requested." "$LINENO" 5 ;;
+esac
+
+fi
+        fi
+    fi
+fi
+if test -z "$WAYLAND_CLIENT_LIBS" -o -z "$WAYLAND_SCANNER" -o -z "$XKBCOMMON_LIBS" -o -z "$XKBREGISTRY_LIBS" -o "$ac_cv_header_linux_input_h" = "no"
+then :
+  case "x$with_wayland" in
+  x)   as_fn_append wine_notices "|Wayland ${notice_platform}development files not found, the Wayland driver won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "Wayland ${notice_platform}development files not found, the Wayland driver won't be supported.
+This is an error since --with-wayland was requested." "$LINENO" 5 ;;
+esac
+enable_winewayland_drv=${enable_winewayland_drv:-no}
+fi
+
+if test "$enable_wineandroid_drv$enable_winemac_drv$enable_winewayland_drv" = "nonono"
+then
+    if test "x$X_LIBS" = "x"
+then :
+  case "x$with_x" in
+  xno) ;;
+  *)   as_fn_error $? "X ${notice_platform}development files not found. Wine will be built
+without X support, which probably isn't what you want. You will need
+to install ${notice_platform}development packages of Xlib at the very least.
+Use the --without-x option if you really want this." "$LINENO" 5 ;;
+esac
+enable_winex11_drv=${enable_winex11_drv:-no}
+fi
+else
+    if test "x$X_LIBS" = "x"
+then :
+  case "x$with_x" in
+  x)   as_fn_append wine_notices "|X ${notice_platform}development files not found, the X11 driver won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "X ${notice_platform}development files not found, the X11 driver won't be supported.
+This is an error since --with-x was requested." "$LINENO" 5 ;;
+esac
+enable_winex11_drv=${enable_winex11_drv:-no}
+fi
+fi
+
+if test "$ac_cv_header_CL_cl_h" = "yes"
+then
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for clGetPlatformInfo in -lOpenCL" >&5
+printf %s "checking for clGetPlatformInfo in -lOpenCL... " >&6; }
+if test ${ac_cv_lib_OpenCL_clGetPlatformInfo+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lOpenCL  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char clGetPlatformInfo (void);
+int
+main (void)
+{
+return clGetPlatformInfo ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_OpenCL_clGetPlatformInfo=yes
+else case e in #(
+  e) ac_cv_lib_OpenCL_clGetPlatformInfo=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_OpenCL_clGetPlatformInfo" >&5
+printf "%s\n" "$ac_cv_lib_OpenCL_clGetPlatformInfo" >&6; }
+if test "x$ac_cv_lib_OpenCL_clGetPlatformInfo" = xyes
+then :
+  OPENCL_LIBS="-lOpenCL"
+
+fi
+
+fi
+if test "x$ac_cv_lib_OpenCL_clGetPlatformInfo" != xyes
+then :
+  case "x$with_opencl" in
+  x)   as_fn_append wine_notices "|OpenCL ${notice_platform}development files not found, OpenCL won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "OpenCL ${notice_platform}development files not found, OpenCL won't be supported.
+This is an error since --with-opencl was requested." "$LINENO" 5 ;;
+esac
+enable_opencl=${enable_opencl:-no}
+fi
+
+if test "$ac_cv_header_pcap_pcap_h" = "yes"
+then
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for pcap_init in -lpcap" >&5
+printf %s "checking for pcap_init in -lpcap... " >&6; }
+if test ${ac_cv_lib_pcap_pcap_init+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpcap  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char pcap_init (void);
+int
+main (void)
+{
+return pcap_init ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_pcap_pcap_init=yes
+else case e in #(
+  e) ac_cv_lib_pcap_pcap_init=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pcap_pcap_init" >&5
+printf "%s\n" "$ac_cv_lib_pcap_pcap_init" >&6; }
+if test "x$ac_cv_lib_pcap_pcap_init" = xyes
+then :
+  PCAP_LIBS="-lpcap"
+
+fi
+
+fi
+if test "x$ac_cv_lib_pcap_pcap_init" != xyes
+then :
+  case "x$with_pcap" in
+  x)   as_fn_append wine_notices "|pcap ${notice_platform}development files not found, wpcap won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "pcap ${notice_platform}development files not found, wpcap won't be supported.
+This is an error since --with-pcap was requested." "$LINENO" 5 ;;
+esac
+enable_wpcap=${enable_wpcap:-no}
+fi
+
+if test "x$with_pcsclite" != "xno"
+then
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for SCardEstablishContext in -lpcsclite" >&5
+printf %s "checking for SCardEstablishContext in -lpcsclite... " >&6; }
+if test ${ac_cv_lib_pcsclite_SCardEstablishContext+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpcsclite  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char SCardEstablishContext (void);
+int
+main (void)
+{
+return SCardEstablishContext ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_pcsclite_SCardEstablishContext=yes
+else case e in #(
+  e) ac_cv_lib_pcsclite_SCardEstablishContext=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pcsclite_SCardEstablishContext" >&5
+printf "%s\n" "$ac_cv_lib_pcsclite_SCardEstablishContext" >&6; }
+if test "x$ac_cv_lib_pcsclite_SCardEstablishContext" = xyes
+then :
+  PCSCLITE_LIBS="-lpcsclite"
+
+else case e in #(
+  e) case $host_os in
+                    darwin*) PCSCLITE_LIBS="-framework PCSC"
+ ;;
+                  esac ;;
+esac
+fi
+
+fi
+if test "x$PCSCLITE_LIBS" = x
+then :
+  case "x$with_pcsclite" in
+  x)   as_fn_append wine_notices "|libpcsclite not found, smart cards won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libpcsclite not found, smart cards won't be supported.
+This is an error since --with-pcsclite was requested." "$LINENO" 5 ;;
+esac
+enable_winscard=${enable_winscard:-no}
+fi
+
+if test "x$with_inotify" != "xno"
+then
+    rm -f conftest.err
+if ${INOTIFY_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  INOTIFY_CFLAGS=`$PKG_CONFIG --cflags libinotify 2>conftest.err`
+fi
+fi
+
+if ${INOTIFY_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  INOTIFY_LIBS=`$PKG_CONFIG --libs libinotify 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libinotify cflags: $INOTIFY_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libinotify libs: $INOTIFY_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: libinotify errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $INOTIFY_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "sys/inotify.h" "ac_cv_header_sys_inotify_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_inotify_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYS_INOTIFY_H 1" >>confdefs.h
+
+fi
+
+         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for inotify_add_watch in -linotify" >&5
+printf %s "checking for inotify_add_watch in -linotify... " >&6; }
+if test ${ac_cv_lib_inotify_inotify_add_watch+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-linotify $INOTIFY_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char inotify_add_watch (void);
+int
+main (void)
+{
+return inotify_add_watch ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_inotify_inotify_add_watch=yes
+else case e in #(
+  e) ac_cv_lib_inotify_inotify_add_watch=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_inotify_inotify_add_watch" >&5
+printf "%s\n" "$ac_cv_lib_inotify_inotify_add_watch" >&6; }
+if test "x$ac_cv_lib_inotify_inotify_add_watch" = xyes
+then :
+  :
+else case e in #(
+  e) INOTIFY_LIBS="" ;;
+esac
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+if test "$ac_cv_header_sys_inotify_h" != "yes"
+then :
+  case "x$with_inotify" in
+  x)   as_fn_append wine_notices "|libinotify ${notice_platform}development files not found (or too old), filesystem change notifications won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libinotify ${notice_platform}development files not found (or too old), filesystem change notifications won't be supported.
+This is an error since --with-inotify was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+if test "x$with_dbus" != "xno"
+then
+    rm -f conftest.err
+if ${DBUS_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  DBUS_CFLAGS=`$PKG_CONFIG --cflags dbus-1 2>conftest.err`
+fi
+fi
+
+if ${DBUS_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  DBUS_LIBS=`$PKG_CONFIG --libs dbus-1 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: dbus-1 cflags: $DBUS_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: dbus-1 libs: $DBUS_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: dbus-1 errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $DBUS_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "dbus/dbus.h" "ac_cv_header_dbus_dbus_h" "$ac_includes_default"
+if test "x$ac_cv_header_dbus_dbus_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -ldbus-1" >&5
+printf %s "checking for -ldbus-1... " >&6; }
+if test ${ac_cv_lib_soname_dbus_1+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-ldbus-1 $DBUS_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dbus_connection_close (void);
+int
+main (void)
+{
+return dbus_connection_close ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_dbus_1=`$ac_cv_path_LDD conftest.exe | grep "dbus-1" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_dbus_1=`$OTOOL -L conftest$ac_exeext | grep "libdbus-1\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libdbus-1\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_dbus_1=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libdbus-1\\.$LIBEXT" | sed -e "s/^.*\\[\\(libdbus-1\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_dbus_1:+false} :
+then :
+  ac_cv_lib_soname_dbus_1=`$LDD conftest$ac_exeext | grep "libdbus-1\\.$LIBEXT" | sed -e "s/^.*\(libdbus-1\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_dbus_1= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_dbus_1:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+       DBUS_CFLAGS=""
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_dbus_1" >&5
+printf "%s\n" "$ac_cv_lib_soname_dbus_1" >&6; }
+
+printf "%s\n" "#define SONAME_LIBDBUS_1 \"$ac_cv_lib_soname_dbus_1\"" >>confdefs.h
+
+        ;;
+esac
+fi
+else case e in #(
+  e) DBUS_CFLAGS="" ;;
+esac
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+case $host_os in
+  darwin*) ;;
+  *) if test "x$ac_cv_lib_soname_dbus_1" = "x"
+then :
+  case "x$with_dbus" in
+  x)   as_fn_append wine_notices "|libdbus ${notice_platform}development files not found, no dynamic device support." ;;
+  xno) ;;
+  *)   as_fn_error $? "libdbus ${notice_platform}development files not found, no dynamic device support.
+This is an error since --with-dbus was requested." "$LINENO" 5 ;;
+esac
+
+fi ;;
+esac
+
+if test "x$with_gnutls" != "xno"
+then
+    rm -f conftest.err
+if ${GNUTLS_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  GNUTLS_CFLAGS=`$PKG_CONFIG --cflags gnutls 2>conftest.err`
+fi
+fi
+
+if ${GNUTLS_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  GNUTLS_LIBS=`$PKG_CONFIG --libs gnutls 2>/dev/null`
+fi
+fi
+
+GNUTLS_LIBS=${GNUTLS_LIBS:-"-lgnutls"}
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gnutls cflags: $GNUTLS_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gnutls libs: $GNUTLS_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: gnutls errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $GNUTLS_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "gnutls/gnutls.h" "ac_cv_header_gnutls_gnutls_h" "$ac_includes_default"
+if test "x$ac_cv_header_gnutls_gnutls_h" = xyes
+then :
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <gnutls/gnutls.h>
+#include <gnutls/crypto.h>
+int
+main (void)
+{
+static typeof(gnutls_mac_get_key_size) *func; if (func) return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lgnutls" >&5
+printf %s "checking for -lgnutls... " >&6; }
+if test ${ac_cv_lib_soname_gnutls+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lgnutls $GNUTLS_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char gnutls_global_init (void);
+int
+main (void)
+{
+return gnutls_global_init ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_gnutls=`$ac_cv_path_LDD conftest.exe | grep "gnutls" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_gnutls=`$OTOOL -L conftest$ac_exeext | grep "libgnutls\\(-deb0\\)\\{0,1\\}\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libgnutls\\(-deb0\\)\\{0,1\\}\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_gnutls=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libgnutls\\(-deb0\\)\\{0,1\\}\\.$LIBEXT" | sed -e "s/^.*\\[\\(libgnutls\\(-deb0\\)\\{0,1\\}\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_gnutls:+false} :
+then :
+  ac_cv_lib_soname_gnutls=`$LDD conftest$ac_exeext | grep "libgnutls\\(-deb0\\)\\{0,1\\}\\.$LIBEXT" | sed -e "s/^.*\(libgnutls\\(-deb0\\)\\{0,1\\}\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_gnutls= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_gnutls:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+       GNUTLS_CFLAGS=""
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_gnutls" >&5
+printf "%s\n" "$ac_cv_lib_soname_gnutls" >&6; }
+
+printf "%s\n" "#define SONAME_LIBGNUTLS \"$ac_cv_lib_soname_gnutls\"" >>confdefs.h
+
+        ;;
+esac
+fi
+                 ac_wine_check_funcs_save_LIBS="$LIBS"
+LIBS="$LIBS $GNUTLS_LIBS"
+
+  for ac_func in gnutls_cipher_init
+do :
+  ac_fn_c_check_func "$LINENO" "gnutls_cipher_init" "ac_cv_func_gnutls_cipher_init"
+if test "x$ac_cv_func_gnutls_cipher_init" = xyes
+then :
+  printf "%s\n" "#define HAVE_GNUTLS_CIPHER_INIT 1" >>confdefs.h
+
+else case e in #(
+  e) as_fn_append wine_notices "|libgnutls ${notice_platform}development files too old, bcrypt encryption won't be supported." ;;
+esac
+fi
+
+done
+LIBS="$ac_wine_check_funcs_save_LIBS"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+else case e in #(
+  e) GNUTLS_CFLAGS="" ;;
+esac
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+if test "x$ac_cv_lib_soname_gnutls" = "x"
+then :
+  case "x$with_gnutls" in
+  x)   as_fn_append wine_warnings "|libgnutls ${notice_platform}development files not found, no schannel support." ;;
+  xno) ;;
+  *)   as_fn_error $? "libgnutls ${notice_platform}development files not found, no schannel support.
+This is an error since --with-gnutls was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+if test "x$with_sane" != "xno"
+then
+    rm -f conftest.err
+if ${SANE_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  SANE_CFLAGS=`$PKG_CONFIG --cflags sane-backends 2>conftest.err`
+fi
+fi
+test "$cross_compiling" = yes || SANE_CFLAGS=${SANE_CFLAGS:-`${SANE_CONFIG:-sane-config} --cflags 2>/dev/null`}
+if ${SANE_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  SANE_LIBS=`$PKG_CONFIG --libs sane-backends 2>/dev/null`
+fi
+fi
+test "$cross_compiling" = yes || SANE_LIBS=${SANE_LIBS:-`${SANE_CONFIG:-sane-config} --ldflags 2>/dev/null`}
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: sane-backends cflags: $SANE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: sane-backends libs: $SANE_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: sane-backends errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $SANE_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "sane/sane.h" "ac_cv_header_sane_sane_h" "$ac_includes_default"
+if test "x$ac_cv_header_sane_sane_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for sane_init in -lsane" >&5
+printf %s "checking for sane_init in -lsane... " >&6; }
+if test ${ac_cv_lib_sane_sane_init+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsane $SANE_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char sane_init (void);
+int
+main (void)
+{
+return sane_init ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_sane_sane_init=yes
+else case e in #(
+  e) ac_cv_lib_sane_sane_init=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_sane_sane_init" >&5
+printf "%s\n" "$ac_cv_lib_sane_sane_init" >&6; }
+if test "x$ac_cv_lib_sane_sane_init" = xyes
+then :
+  :
+fi
+
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+if test "$ac_cv_lib_sane_sane_init" != "yes"
+then :
+  case "x$with_sane" in
+  x)   as_fn_append wine_notices "|libsane ${notice_platform}development files not found, scanners won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libsane ${notice_platform}development files not found, scanners won't be supported.
+This is an error since --with-sane was requested." "$LINENO" 5 ;;
+esac
+enable_sane_ds=${enable_sane_ds:-no}
+fi
+
+if test "x$with_usb" != "xno"
+then
+    rm -f conftest.err
+if ${USB_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  USB_CFLAGS=`$PKG_CONFIG --cflags libusb-1.0 2>conftest.err`
+fi
+fi
+
+if ${USB_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  USB_LIBS=`$PKG_CONFIG --libs libusb-1.0 2>/dev/null`
+fi
+fi
+
+USB_LIBS=${USB_LIBS:-"-lusb-1.0"}
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libusb-1.0 cflags: $USB_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libusb-1.0 libs: $USB_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: libusb-1.0 errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $USB_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "libusb.h" "ac_cv_header_libusb_h" "$ac_includes_default"
+if test "x$ac_cv_header_libusb_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for libusb_interrupt_event_handler in -lusb-1.0" >&5
+printf %s "checking for libusb_interrupt_event_handler in -lusb-1.0... " >&6; }
+if test ${ac_cv_lib_usb_1_0_libusb_interrupt_event_handler+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lusb-1.0 $USB_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char libusb_interrupt_event_handler (void);
+int
+main (void)
+{
+return libusb_interrupt_event_handler ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_usb_1_0_libusb_interrupt_event_handler=yes
+else case e in #(
+  e) ac_cv_lib_usb_1_0_libusb_interrupt_event_handler=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_usb_1_0_libusb_interrupt_event_handler" >&5
+printf "%s\n" "$ac_cv_lib_usb_1_0_libusb_interrupt_event_handler" >&6; }
+if test "x$ac_cv_lib_usb_1_0_libusb_interrupt_event_handler" = xyes
+then :
+  :
+else case e in #(
+  e) USB_LIBS="" ;;
+esac
+fi
+
+else case e in #(
+  e) USB_LIBS="" ;;
+esac
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+if test "$ac_cv_lib_usb_1_0_libusb_interrupt_event_handler" != "yes"
+then :
+  case "x$with_usb" in
+  x)   as_fn_append wine_notices "|libusb-1.0 ${notice_platform}development files not found (or too old), USB devices won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libusb-1.0 ${notice_platform}development files not found (or too old), USB devices won't be supported.
+This is an error since --with-usb was requested." "$LINENO" 5 ;;
+esac
+enable_wineusb_sys=${enable_wineusb_sys:-no}
+fi
+
+if test "x$with_v4l2" != "xno"
+then
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lv4l2" >&5
+printf %s "checking for -lv4l2... " >&6; }
+if test ${ac_cv_lib_soname_v4l2+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lv4l2  $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char v4l2_open (void);
+int
+main (void)
+{
+return v4l2_open ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_v4l2=`$ac_cv_path_LDD conftest.exe | grep "v4l2" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_v4l2=`$OTOOL -L conftest$ac_exeext | grep "libv4l2\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libv4l2\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_v4l2=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libv4l2\\.$LIBEXT" | sed -e "s/^.*\\[\\(libv4l2\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_v4l2:+false} :
+then :
+  ac_cv_lib_soname_v4l2=`$LDD conftest$ac_exeext | grep "libv4l2\\.$LIBEXT" | sed -e "s/^.*\(libv4l2\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_v4l2= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_v4l2:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_v4l2" >&5
+printf "%s\n" "$ac_cv_lib_soname_v4l2" >&6; }
+
+printf "%s\n" "#define SONAME_LIBV4L2 \"$ac_cv_lib_soname_v4l2\"" >>confdefs.h
+
+        ;;
+esac
+fi
+fi
+if test "x$ac_cv_lib_soname_v4l2" = "x"
+then :
+  case "x$with_v4l2" in
+  x)   as_fn_append wine_notices "|libv4l2 ${notice_platform}development files not found." ;;
+  xno) ;;
+  *)   as_fn_error $? "libv4l2 ${notice_platform}development files not found.
+This is an error since --with-v4l2 was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+if test "x$with_gphoto" != "xno"
+then
+    rm -f conftest.err
+if ${GPHOTO2_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  GPHOTO2_CFLAGS=`$PKG_CONFIG --cflags libgphoto2 2>conftest.err`
+fi
+fi
+test "$cross_compiling" = yes || GPHOTO2_CFLAGS=${GPHOTO2_CFLAGS:-`${GPHOTO2_CONFIG:-gphoto2-config} --cflags 2>/dev/null`}
+if ${GPHOTO2_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  GPHOTO2_LIBS=`$PKG_CONFIG --libs libgphoto2 2>/dev/null`
+fi
+fi
+test "$cross_compiling" = yes || GPHOTO2_LIBS=${GPHOTO2_LIBS:-`${GPHOTO2_CONFIG:-gphoto2-config} --libs 2>/dev/null`}
+GPHOTO2_LIBS=${GPHOTO2_LIBS:-"-lgphoto2"}
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libgphoto2 cflags: $GPHOTO2_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libgphoto2 libs: $GPHOTO2_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: libgphoto2 errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $GPHOTO2_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "gphoto2-camera.h" "ac_cv_header_gphoto2_camera_h" "$ac_includes_default"
+if test "x$ac_cv_header_gphoto2_camera_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for gp_camera_new in -lgphoto2" >&5
+printf %s "checking for gp_camera_new in -lgphoto2... " >&6; }
+if test ${ac_cv_lib_gphoto2_gp_camera_new+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgphoto2 $GPHOTO2_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char gp_camera_new (void);
+int
+main (void)
+{
+return gp_camera_new ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_gphoto2_gp_camera_new=yes
+else case e in #(
+  e) ac_cv_lib_gphoto2_gp_camera_new=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gphoto2_gp_camera_new" >&5
+printf "%s\n" "$ac_cv_lib_gphoto2_gp_camera_new" >&6; }
+if test "x$ac_cv_lib_gphoto2_gp_camera_new" = xyes
+then :
+  :
+fi
+
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    rm -f conftest.err
+if ${GPHOTO2_PORT_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  GPHOTO2_PORT_CFLAGS=`$PKG_CONFIG --cflags libgphoto2_port 2>conftest.err`
+fi
+fi
+test "$cross_compiling" = yes || GPHOTO2_PORT_CFLAGS=${GPHOTO2_PORT_CFLAGS:-`${GPHOTO2_PORT_CONFIG:-gphoto2-port-config} --cflags 2>/dev/null`}
+if ${GPHOTO2_PORT_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  GPHOTO2_PORT_LIBS=`$PKG_CONFIG --libs libgphoto2_port 2>/dev/null`
+fi
+fi
+test "$cross_compiling" = yes || GPHOTO2_PORT_LIBS=${GPHOTO2_PORT_LIBS:-`${GPHOTO2_PORT_CONFIG:-gphoto2-port-config} --libs 2>/dev/null`}
+GPHOTO2_PORT_LIBS=${GPHOTO2_PORT_LIBS:-"-lgphoto2_port"}
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libgphoto2_port cflags: $GPHOTO2_PORT_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libgphoto2_port libs: $GPHOTO2_PORT_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: libgphoto2_port errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $GPHOTO2_PORT_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "gphoto2-port.h" "ac_cv_header_gphoto2_port_h" "$ac_includes_default"
+if test "x$ac_cv_header_gphoto2_port_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for gp_port_info_list_new in -lgphoto2_port" >&5
+printf %s "checking for gp_port_info_list_new in -lgphoto2_port... " >&6; }
+if test ${ac_cv_lib_gphoto2_port_gp_port_info_list_new+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgphoto2_port $GPHOTO2_PORT_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char gp_port_info_list_new (void);
+int
+main (void)
+{
+return gp_port_info_list_new ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_gphoto2_port_gp_port_info_list_new=yes
+else case e in #(
+  e) ac_cv_lib_gphoto2_port_gp_port_info_list_new=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gphoto2_port_gp_port_info_list_new" >&5
+printf "%s\n" "$ac_cv_lib_gphoto2_port_gp_port_info_list_new" >&6; }
+if test "x$ac_cv_lib_gphoto2_port_gp_port_info_list_new" = xyes
+then :
+
+printf "%s\n" "#define HAVE_GPHOTO2_PORT 1" >>confdefs.h
+
+else case e in #(
+  e) GPHOTO2_PORT_LIBS=""; GPHOTO2_PORT_CFLAGS="" ;;
+esac
+fi
+
+else case e in #(
+  e) GPHOTO2_PORT_LIBS=""; GPHOTO2_PORT_CFLAGS="" ;;
+esac
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+if test "$ac_cv_lib_gphoto2_gp_camera_new" != "yes"
+then :
+  case "x$with_gphoto" in
+  x)   as_fn_append wine_notices "|libgphoto2 ${notice_platform}development files not found, digital cameras won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libgphoto2 ${notice_platform}development files not found, digital cameras won't be supported.
+This is an error since --with-gphoto was requested." "$LINENO" 5 ;;
+esac
+enable_gphoto2_ds=${enable_gphoto2_ds:-no}
+fi
+if test "$ac_cv_lib_gphoto2_port_gp_port_info_list_new" != "yes"
+then :
+  case "x$with_gphoto" in
+  x)   as_fn_append wine_notices "|libgphoto2_port ${notice_platform}development files not found, digital cameras won't be auto-detected." ;;
+  xno) ;;
+  *)   as_fn_error $? "libgphoto2_port ${notice_platform}development files not found, digital cameras won't be auto-detected.
+This is an error since --with-gphoto was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+
+if test "$ac_cv_header_resolv_h" = "yes"
+then
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for resolver library" >&5
+printf %s "checking for resolver library... " >&6; }
+if test ${ac_cv_have_resolv+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_save_LIBS="$LIBS"
+       for lib in '' -lresolv
+       do
+         LIBS="$lib $ac_save_LIBS"
+         cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#include <resolv.h>
+int
+main (void)
+{
+if (!(_res.options & RES_INIT)) res_init(); res_query("foo",ns_c_in,0,0,0); ns_initparse(0,0,0)
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_have_resolv=${lib:-"none required"}
+else case e in #(
+  e) ac_cv_have_resolv="not found" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+         test "x$ac_cv_have_resolv" = "xnot found" || break
+       done
+       LIBS="$ac_save_LIBS" ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have_resolv" >&5
+printf "%s\n" "$ac_cv_have_resolv" >&6; }
+
+    case "$ac_cv_have_resolv" in
+      "not found") ;;
+      "none required")
+
+printf "%s\n" "#define HAVE_RESOLV 1" >>confdefs.h
+ ;;
+      *)
+        printf "%s\n" "#define HAVE_RESOLV 1" >>confdefs.h
+
+        RESOLV_LIBS=$ac_cv_have_resolv
+ ;;
+    esac
+
+    if test "x$ac_cv_have_resolv" != "xnot found"
+    then
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for res_getservers" >&5
+printf %s "checking for res_getservers... " >&6; }
+if test ${ac_cv_have_res_getservers+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_save_LIBS="$LIBS"
+                        LIBS="$RESOLV_LIBS $LIBS"
+                        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <resolv.h>
+int
+main (void)
+{
+res_getservers(NULL, NULL, 0);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_have_res_getservers=yes
+else case e in #(
+  e) ac_cv_have_res_getservers=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+	                 LIBS="$ac_save_LIBS" ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have_res_getservers" >&5
+printf "%s\n" "$ac_cv_have_res_getservers" >&6; }
+        if test "$ac_cv_have_res_getservers" = "yes"
+        then
+
+printf "%s\n" "#define HAVE_RES_GETSERVERS 1" >>confdefs.h
+
+        fi
+    fi
+fi
+
+if test "x$with_freetype" != "xno"
+then
+    rm -f conftest.err
+if ${FREETYPE_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  FREETYPE_CFLAGS=`$PKG_CONFIG --cflags freetype2 2>conftest.err`
+fi
+fi
+test "$cross_compiling" = yes || FREETYPE_CFLAGS=${FREETYPE_CFLAGS:-`(${FREETYPE_CONFIG:-freetype-config} --cflags || ${FREETYPE2_CONFIG:-freetype2-config} --cflags) 2>/dev/null`}
+if ${FREETYPE_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  FREETYPE_LIBS=`$PKG_CONFIG --libs freetype2 2>/dev/null`
+fi
+fi
+test "$cross_compiling" = yes || FREETYPE_LIBS=${FREETYPE_LIBS:-`(${FREETYPE_CONFIG:-freetype-config} --libs || ${FREETYPE2_CONFIG:-freetype2-config} --libs) 2>/dev/null`}
+FREETYPE_LIBS=${FREETYPE_LIBS:-"-lfreetype"}
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: freetype2 cflags: $FREETYPE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: freetype2 libs: $FREETYPE_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: freetype2 errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $FREETYPE_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "ft2build.h" "ac_cv_header_ft2build_h" "$ac_includes_default"
+if test "x$ac_cv_header_ft2build_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_FT2BUILD_H 1" >>confdefs.h
+
+fi
+
+        if test "$ac_cv_header_ft2build_h" = "yes"
+        then
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lfreetype" >&5
+printf %s "checking for -lfreetype... " >&6; }
+if test ${ac_cv_lib_soname_freetype+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lfreetype $FREETYPE_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char FT_Init_FreeType (void);
+int
+main (void)
+{
+return FT_Init_FreeType ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_freetype=`$ac_cv_path_LDD conftest.exe | grep "freetype" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_freetype=`$OTOOL -L conftest$ac_exeext | grep "libfreetype\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libfreetype\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_freetype=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libfreetype\\.$LIBEXT" | sed -e "s/^.*\\[\\(libfreetype\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_freetype:+false} :
+then :
+  ac_cv_lib_soname_freetype=`$LDD conftest$ac_exeext | grep "libfreetype\\.$LIBEXT" | sed -e "s/^.*\(libfreetype\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_freetype= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_freetype:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+       FREETYPE_LIBS=""
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_freetype" >&5
+printf "%s\n" "$ac_cv_lib_soname_freetype" >&6; }
+
+printf "%s\n" "#define SONAME_LIBFREETYPE \"$ac_cv_lib_soname_freetype\"" >>confdefs.h
+
+
+printf "%s\n" "#define HAVE_FREETYPE 1" >>confdefs.h
+
+                 ac_fn_c_check_type "$LINENO" "FT_TrueTypeEngineType" "ac_cv_type_FT_TrueTypeEngineType" "#include <ft2build.h>
+#include FT_MODULE_H
+"
+if test "x$ac_cv_type_FT_TrueTypeEngineType" = xyes
+then :
+
+printf "%s\n" "#define HAVE_FT_TRUETYPEENGINETYPE 1" >>confdefs.h
+
+
+fi
+ ;;
+esac
+fi
+        else
+            FREETYPE_CFLAGS=""
+            FREETYPE_LIBS=""
+        fi
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+if test "x$ac_cv_lib_soname_freetype" = x
+then :
+  case "x$with_freetype" in
+  xno) ;;
+  *)   as_fn_error $? "FreeType ${notice_platform}development files not found. Fonts will not be built.
+Use the --without-freetype option if you really want this." "$LINENO" 5 ;;
+esac
+enable_fonts=${enable_fonts:-no}
+fi
+
+ac_wine_check_funcs_save_LIBS="$LIBS"
+LIBS="$LIBS $PTHREAD_LIBS"
+ac_fn_c_check_func "$LINENO" "pthread_getthreadid_np" "ac_cv_func_pthread_getthreadid_np"
+if test "x$ac_cv_func_pthread_getthreadid_np" = xyes
+then :
+  printf "%s\n" "#define HAVE_PTHREAD_GETTHREADID_NP 1" >>confdefs.h
+
+fi
+
+LIBS="$ac_wine_check_funcs_save_LIBS"
+
+if test "x$enable_tools" != xno -a "x$with_gettextpo" = xyes
+then
+    if test "$ac_cv_header_gettext_po_h" = "yes"
+    then
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for po_message_msgctxt in -lgettextpo" >&5
+printf %s "checking for po_message_msgctxt in -lgettextpo... " >&6; }
+if test ${ac_cv_lib_gettextpo_po_message_msgctxt+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgettextpo  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char po_message_msgctxt (void);
+int
+main (void)
+{
+return po_message_msgctxt ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_gettextpo_po_message_msgctxt=yes
+else case e in #(
+  e) ac_cv_lib_gettextpo_po_message_msgctxt=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gettextpo_po_message_msgctxt" >&5
+printf "%s\n" "$ac_cv_lib_gettextpo_po_message_msgctxt" >&6; }
+if test "x$ac_cv_lib_gettextpo_po_message_msgctxt" = xyes
+then :
+
+printf "%s\n" "#define HAVE_LIBGETTEXTPO 1" >>confdefs.h
+
+                      GETTEXTPO_LIBS="-lgettextpo"
+
+fi
+
+    fi
+    if test "x$GETTEXTPO_LIBS" = "x"
+then :
+  case "x$with_gettextpo" in
+  x)   as_fn_append wine_notices "|GetText ${notice_platform}development files not found (or too old), po files can't be rebuilt." ;;
+  xno) ;;
+  *)   as_fn_error $? "GetText ${notice_platform}development files not found (or too old), po files can't be rebuilt.
+This is an error since --with-gettextpo was requested." "$LINENO" 5 ;;
+esac
+
+fi
+    if test "$srcdir" != .
+then :
+  case "x$with_gettextpo" in
+  x)   as_fn_append wine_notices "|Rebuilding po files is not supported for out of tree builds." ;;
+  xno) ;;
+  *)   as_fn_error $? "Rebuilding po files is not supported for out of tree builds.
+This is an error since --with-gettextpo was requested." "$LINENO" 5 ;;
+esac
+
+fi
+fi
+
+if test "x$with_pulse" != "xno";
+then
+    rm -f conftest.err
+if ${PULSE_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  PULSE_CFLAGS=`$PKG_CONFIG --cflags libpulse 2>conftest.err`
+fi
+fi
+
+if ${PULSE_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  PULSE_LIBS=`$PKG_CONFIG --libs libpulse 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libpulse cflags: $PULSE_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libpulse libs: $PULSE_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: libpulse errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $PULSE_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "pulse/pulseaudio.h" "ac_cv_header_pulse_pulseaudio_h" "$ac_includes_default"
+if test "x$ac_cv_header_pulse_pulseaudio_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for pa_stream_is_corked in -lpulse" >&5
+printf %s "checking for pa_stream_is_corked in -lpulse... " >&6; }
+if test ${ac_cv_lib_pulse_pa_stream_is_corked+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpulse $PULSE_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char pa_stream_is_corked (void);
+int
+main (void)
+{
+return pa_stream_is_corked ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_pulse_pa_stream_is_corked=yes
+else case e in #(
+  e) ac_cv_lib_pulse_pa_stream_is_corked=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pulse_pa_stream_is_corked" >&5
+printf "%s\n" "$ac_cv_lib_pulse_pa_stream_is_corked" >&6; }
+if test "x$ac_cv_lib_pulse_pa_stream_is_corked" = xyes
+then :
+  :
+else case e in #(
+  e) PULSE_LIBS="" ;;
+esac
+fi
+
+else case e in #(
+  e) PULSE_LIBS="" ;;
+esac
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+if test -z "$PULSE_LIBS"
+then :
+  case "x$with_pulse" in
+  x)   as_fn_append wine_notices "|libpulse ${notice_platform}development files not found or too old, Pulse won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libpulse ${notice_platform}development files not found or too old, Pulse won't be supported.
+This is an error since --with-pulse was requested." "$LINENO" 5 ;;
+esac
+enable_winepulse_drv=${enable_winepulse_drv:-no}
+fi
+
+if test "x$with_ffmpeg" != "xno";
+then
+    rm -f conftest.err
+if ${FFMPEG_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  FFMPEG_CFLAGS=`$PKG_CONFIG --cflags libavutil libavformat libavcodec 2>conftest.err`
+fi
+fi
+
+if ${FFMPEG_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  FFMPEG_LIBS=`$PKG_CONFIG --libs libavutil libavformat libavcodec 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libavutil libavformat libavcodec cflags: $FFMPEG_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libavutil libavformat libavcodec libs: $FFMPEG_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: libavutil libavformat libavcodec errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $FFMPEG_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "libavutil/avutil.h" "ac_cv_header_libavutil_avutil_h" "$ac_includes_default"
+if test "x$ac_cv_header_libavutil_avutil_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LIBAVUTIL_AVUTIL_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "libavformat/avformat.h" "ac_cv_header_libavformat_avformat_h" "$ac_includes_default"
+if test "x$ac_cv_header_libavformat_avformat_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LIBAVFORMAT_AVFORMAT_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "libavcodec/avcodec.h" "ac_cv_header_libavcodec_avcodec_h" "$ac_includes_default"
+if test "x$ac_cv_header_libavcodec_avcodec_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LIBAVCODEC_AVCODEC_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "libavcodec/bsf.h" "ac_cv_header_libavcodec_bsf_h" "$ac_includes_default"
+if test "x$ac_cv_header_libavcodec_bsf_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LIBAVCODEC_BSF_H 1" >>confdefs.h
+
+fi
+
+         if test "$ac_cv_header_libavutil_avutil_h" = "yes" -a "$ac_cv_header_libavformat_avformat_h" = "yes" -a "$ac_cv_header_libavcodec_avcodec_h" = "yes"
+         then
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for av_log_set_callback in -lavutil" >&5
+printf %s "checking for av_log_set_callback in -lavutil... " >&6; }
+if test ${ac_cv_lib_avutil_av_log_set_callback+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lavutil $FFMPEG_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char av_log_set_callback (void);
+int
+main (void)
+{
+return av_log_set_callback ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_avutil_av_log_set_callback=yes
+else case e in #(
+  e) ac_cv_lib_avutil_av_log_set_callback=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_avutil_av_log_set_callback" >&5
+printf "%s\n" "$ac_cv_lib_avutil_av_log_set_callback" >&6; }
+if test "x$ac_cv_lib_avutil_av_log_set_callback" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for av_find_input_format in -lavformat" >&5
+printf %s "checking for av_find_input_format in -lavformat... " >&6; }
+if test ${ac_cv_lib_avformat_av_find_input_format+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lavformat $FFMPEG_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char av_find_input_format (void);
+int
+main (void)
+{
+return av_find_input_format ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_avformat_av_find_input_format=yes
+else case e in #(
+  e) ac_cv_lib_avformat_av_find_input_format=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_avformat_av_find_input_format" >&5
+printf "%s\n" "$ac_cv_lib_avformat_av_find_input_format" >&6; }
+if test "x$ac_cv_lib_avformat_av_find_input_format" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for avcodec_get_name in -lavcodec" >&5
+printf %s "checking for avcodec_get_name in -lavcodec... " >&6; }
+if test ${ac_cv_lib_avcodec_avcodec_get_name+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lavcodec $FFMPEG_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char avcodec_get_name (void);
+int
+main (void)
+{
+return avcodec_get_name ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_avcodec_avcodec_get_name=yes
+else case e in #(
+  e) ac_cv_lib_avcodec_avcodec_get_name=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_avcodec_avcodec_get_name" >&5
+printf "%s\n" "$ac_cv_lib_avcodec_avcodec_get_name" >&6; }
+if test "x$ac_cv_lib_avcodec_avcodec_get_name" = xyes
+then :
+
+printf "%s\n" "#define HAVE_FFMPEG 1" >>confdefs.h
+
+else case e in #(
+  e) FFMPEG_LIBS="" ;;
+esac
+fi
+
+else case e in #(
+  e) FFMPEG_LIBS="" ;;
+esac
+fi
+
+else case e in #(
+  e) FFMPEG_LIBS="" ;;
+esac
+fi
+
+         else
+            FFMPEG_LIBS=""
+         fi
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+if test "x$FFMPEG_LIBS" = x
+then :
+  case "x$with_ffmpeg" in
+  x)   as_fn_append wine_notices "|FFmpeg ${notice_platform}development files not found." ;;
+  xno) ;;
+  *)   as_fn_error $? "FFmpeg ${notice_platform}development files not found.
+This is an error since --with-ffmpeg was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+if test "x$with_gstreamer" != "xno"
+then
+    rm -f conftest.err
+if ${GSTREAMER_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  GSTREAMER_CFLAGS=`$PKG_CONFIG --cflags gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 gstreamer-tag-1.0 2>conftest.err`
+fi
+fi
+
+if ${GSTREAMER_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  GSTREAMER_LIBS=`$PKG_CONFIG --libs gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 gstreamer-tag-1.0 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 gstreamer-tag-1.0 cflags: $GSTREAMER_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 gstreamer-tag-1.0 libs: $GSTREAMER_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: gstreamer-1.0 gstreamer-video-1.0 gstreamer-audio-1.0 gstreamer-tag-1.0 errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $GSTREAMER_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "gst/gst.h" "ac_cv_header_gst_gst_h" "$ac_includes_default"
+if test "x$ac_cv_header_gst_gst_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether gint64 defined by gst/gst.h is indeed 64-bit" >&5
+printf %s "checking whether gint64 defined by gst/gst.h is indeed 64-bit... " >&6; }
+              cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <gst/gst.h>
+int
+main (void)
+{
+static int a[sizeof(gint64) > 4 ? 1 : -1]; if (a[0]) return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+printf "%s\n" "yes" >&6; }
+                 { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for gst_pad_new in -lgstreamer-1.0" >&5
+printf %s "checking for gst_pad_new in -lgstreamer-1.0... " >&6; }
+if test ${ac_cv_lib_gstreamer_1_0_gst_pad_new+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgstreamer-1.0 $GSTREAMER_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char gst_pad_new (void);
+int
+main (void)
+{
+return gst_pad_new ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_gstreamer_1_0_gst_pad_new=yes
+else case e in #(
+  e) ac_cv_lib_gstreamer_1_0_gst_pad_new=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gstreamer_1_0_gst_pad_new" >&5
+printf "%s\n" "$ac_cv_lib_gstreamer_1_0_gst_pad_new" >&6; }
+if test "x$ac_cv_lib_gstreamer_1_0_gst_pad_new" = xyes
+then :
+  :
+fi
+
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: no" >&5
+printf "%s\n" "no" >&6; }
+                 ac_glib2_broken=yes
+                 enable_winegstreamer=${enable_winegstreamer:-no}
+                 as_fn_append wine_notices "|glib-2.0 pkgconfig configuration is for the wrong architecture, winegstreamer won't be built." ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+if test "x$ac_glib2_broken" != xyes -a "x$ac_cv_lib_gstreamer_1_0_gst_pad_new" != xyes
+then :
+  case "x$with_gstreamer" in
+  x)   as_fn_append wine_notices "|gstreamer-1.0 base plugins ${notice_platform}development files not found, GStreamer won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "gstreamer-1.0 base plugins ${notice_platform}development files not found, GStreamer won't be supported.
+This is an error since --with-gstreamer was requested." "$LINENO" 5 ;;
+esac
+enable_winegstreamer=${enable_winegstreamer:-no}
+fi
+
+ALSA_LIBS=""
+
+if test "x$with_alsa" != "xno"
+then
+    rm -f conftest.err
+if ${ALSA_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  ALSA_CFLAGS=`$PKG_CONFIG --cflags alsa 2>conftest.err`
+fi
+fi
+
+if ${ALSA_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  ALSA_LIBS=`$PKG_CONFIG --libs alsa 2>/dev/null`
+fi
+fi
+
+ALSA_LIBS=${ALSA_LIBS:-"-lasound"}
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: alsa cflags: $ALSA_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: alsa libs: $ALSA_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: alsa errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $ALSA_CFLAGS"
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for snd_pcm_hw_params_get_access_mask in -lasound" >&5
+printf %s "checking for snd_pcm_hw_params_get_access_mask in -lasound... " >&6; }
+if test ${ac_cv_lib_asound_snd_pcm_hw_params_get_access_mask+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lasound  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char snd_pcm_hw_params_get_access_mask (void);
+int
+main (void)
+{
+return snd_pcm_hw_params_get_access_mask ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_asound_snd_pcm_hw_params_get_access_mask=yes
+else case e in #(
+  e) ac_cv_lib_asound_snd_pcm_hw_params_get_access_mask=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_asound_snd_pcm_hw_params_get_access_mask" >&5
+printf "%s\n" "$ac_cv_lib_asound_snd_pcm_hw_params_get_access_mask" >&6; }
+if test "x$ac_cv_lib_asound_snd_pcm_hw_params_get_access_mask" = xyes
+then :
+  :
+else case e in #(
+  e) ALSA_LIBS="" ;;
+esac
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+if test -z "$ALSA_LIBS"
+then :
+  case "x$with_alsa" in
+  x)   as_fn_append wine_notices "|libasound ${notice_platform}development files not found, Alsa won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libasound ${notice_platform}development files not found, Alsa won't be supported.
+This is an error since --with-alsa was requested." "$LINENO" 5 ;;
+esac
+enable_winealsa_drv=${enable_winealsa_drv:-no}
+fi
+
+if test "x$with_oss" != xno
+then
+    ac_save_CPPFLAGS="$CPPFLAGS"
+    if test -f /etc/oss.conf
+    then
+        . /etc/oss.conf
+    fi
+    ac_oss_incl="-I${OSSLIBDIR:-/usr/lib/oss}/include"
+    CPPFLAGS="$CPPFLAGS $ac_oss_incl"
+    ac_fn_c_check_header_compile "$LINENO" "sys/soundcard.h" "ac_cv_header_sys_soundcard_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_soundcard_h" = xyes
+then :
+  ac_fn_c_check_member "$LINENO" "oss_sysinfo" "numaudioengines" "ac_cv_member_oss_sysinfo_numaudioengines" "#include <sys/soundcard.h>
+"
+if test "x$ac_cv_member_oss_sysinfo_numaudioengines" = xyes
+then :
+
+printf "%s\n" "#define HAVE_OSS_SYSINFO_NUMAUDIOENGINES 1" >>confdefs.h
+
+OSS4_CFLAGS="$ac_oss_incl"
+
+             { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for _oss_ioctl in -lossaudio" >&5
+printf %s "checking for _oss_ioctl in -lossaudio... " >&6; }
+if test ${ac_cv_lib_ossaudio__oss_ioctl+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lossaudio  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char _oss_ioctl (void);
+int
+main (void)
+{
+return _oss_ioctl ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_ossaudio__oss_ioctl=yes
+else case e in #(
+  e) ac_cv_lib_ossaudio__oss_ioctl=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ossaudio__oss_ioctl" >&5
+printf "%s\n" "$ac_cv_lib_ossaudio__oss_ioctl" >&6; }
+if test "x$ac_cv_lib_ossaudio__oss_ioctl" = xyes
+then :
+  OSS4_LIBS="-lossaudio"
+
+fi
+
+fi
+
+fi
+
+    CPPFLAGS="$ac_save_CPPFLAGS"
+fi
+if test "x$ac_cv_member_oss_sysinfo_numaudioengines" != xyes
+then :
+  case "x$with_oss" in
+  x)   as_fn_append wine_notices "|OSS sound system found but too old (OSSv4 needed), OSS won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "OSS sound system found but too old (OSSv4 needed), OSS won't be supported.
+This is an error since --with-oss was requested." "$LINENO" 5 ;;
+esac
+enable_wineoss_drv=${enable_wineoss_drv:-no}
+fi
+
+if test "x$with_udev" != "xno"
+then
+    rm -f conftest.err
+if ${UDEV_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  UDEV_CFLAGS=`$PKG_CONFIG --cflags libudev 2>conftest.err`
+fi
+fi
+
+if ${UDEV_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  UDEV_LIBS=`$PKG_CONFIG --libs libudev 2>/dev/null`
+fi
+fi
+
+UDEV_LIBS=${UDEV_LIBS:-"-ludev"}
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libudev cflags: $UDEV_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libudev libs: $UDEV_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: libudev errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $UDEV_CFLAGS"
+       for ac_header in libudev.h
+do :
+  ac_fn_c_check_header_compile "$LINENO" "libudev.h" "ac_cv_header_libudev_h" "$ac_includes_default"
+if test "x$ac_cv_header_libudev_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LIBUDEV_H 1" >>confdefs.h
+ { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for udev_new in -ludev" >&5
+printf %s "checking for udev_new in -ludev... " >&6; }
+if test ${ac_cv_lib_udev_udev_new+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-ludev $UDEV_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char udev_new (void);
+int
+main (void)
+{
+return udev_new ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_udev_udev_new=yes
+else case e in #(
+  e) ac_cv_lib_udev_udev_new=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_udev_udev_new" >&5
+printf "%s\n" "$ac_cv_lib_udev_udev_new" >&6; }
+if test "x$ac_cv_lib_udev_udev_new" = xyes
+then :
+
+printf "%s\n" "#define HAVE_UDEV 1" >>confdefs.h
+
+else case e in #(
+  e) UDEV_LIBS="" ;;
+esac
+fi
+
+else case e in #(
+  e) UDEV_LIBS="" ;;
+esac
+fi
+
+done
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+if test "x$UDEV_LIBS" = "x"
+then :
+  case "x$with_udev" in
+  x)   as_fn_append wine_notices "|libudev ${notice_platform}development files not found, plug and play won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libudev ${notice_platform}development files not found, plug and play won't be supported.
+This is an error since --with-udev was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+if test $HOST_ARCH = x86_64
+then
+  if test "x$with_unwind" != xno
+  then
+    rm -f conftest.err
+if ${UNWIND_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  UNWIND_CFLAGS=`$PKG_CONFIG --cflags libunwind 2>conftest.err`
+fi
+fi
+
+if ${UNWIND_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  UNWIND_LIBS=`$PKG_CONFIG --libs libunwind 2>/dev/null`
+fi
+fi
+
+UNWIND_LIBS=${UNWIND_LIBS:-"-lunwind"}
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libunwind cflags: $UNWIND_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: libunwind libs: $UNWIND_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: libunwind errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $UNWIND_CFLAGS"
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for unw_step" >&5
+printf %s "checking for unw_step... " >&6; }
+if test ${wine_cv_have_unw_step+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+int
+main (void)
+{
+unw_cursor_t cursor; unw_step( &cursor );
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  wine_cv_have_unw_step="yes"
+else case e in #(
+  e) wine_cv_have_unw_step="no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_have_unw_step" >&5
+printf "%s\n" "$wine_cv_have_unw_step" >&6; }
+        if test "$wine_cv_have_unw_step" = no -a -n "$UNWIND_LIBS"
+        then
+            save_libs=$LIBS
+                        UNWIND_LIBS="-static-libgcc $UNWIND_LIBS"
+            LIBS="$UNWIND_LIBS $LIBS"
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for unw_step in libunwind" >&5
+printf %s "checking for unw_step in libunwind... " >&6; }
+if test ${wine_cv_have_libunwind_unw_step+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#define UNW_LOCAL_ONLY
+#include <libunwind.h>
+int
+main (void)
+{
+unw_cursor_t cursor; unw_step( &cursor );
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  wine_cv_have_libunwind_unw_step="yes"
+else case e in #(
+  e) wine_cv_have_libunwind_unw_step="no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_have_libunwind_unw_step" >&5
+printf "%s\n" "$wine_cv_have_libunwind_unw_step" >&6; }
+            LIBS=$save_libs
+        fi
+        test "$wine_cv_have_libunwind_unw_step" = yes || UNWIND_LIBS=""
+        if test "x$wine_cv_have_unw_step$wine_cv_have_libunwind_unw_step" != xnono
+        then
+
+printf "%s\n" "#define HAVE_LIBUNWIND 1" >>confdefs.h
+
+        fi
+CPPFLAGS=$ac_save_CPPFLAGS
+
+  fi
+  case $host in
+  *-darwin*)
+    if test "x$wine_cv_have_unw_step$wine_cv_have_libunwind_unw_step" = xnono
+then :
+  case "x$with_unwind" in
+  x)   as_fn_append wine_notices "|libunwind ${notice_platform}development files not found, stack unwinding won't work." ;;
+  xno) ;;
+  *)   as_fn_error $? "libunwind ${notice_platform}development files not found, stack unwinding won't work.
+This is an error since --with-unwind was requested." "$LINENO" 5 ;;
+esac
+
+fi ;;
+  esac
+fi
+
+if test "x$with_sdl" != "xno"
+then
+    rm -f conftest.err
+if ${SDL2_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  SDL2_CFLAGS=`$PKG_CONFIG --cflags sdl2 2>conftest.err`
+fi
+fi
+
+if ${SDL2_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  SDL2_LIBS=`$PKG_CONFIG --libs sdl2 2>/dev/null`
+fi
+fi
+
+SDL2_LIBS=${SDL2_LIBS:-"-lSDL2"}
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: sdl2 cflags: $SDL2_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: sdl2 libs: $SDL2_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: sdl2 errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $SDL2_CFLAGS"
+       for ac_header in SDL.h
+do :
+  ac_fn_c_check_header_compile "$LINENO" "SDL.h" "ac_cv_header_SDL_h" "$ac_includes_default"
+if test "x$ac_cv_header_SDL_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_SDL_H 1" >>confdefs.h
+ { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lSDL2" >&5
+printf %s "checking for -lSDL2... " >&6; }
+if test ${ac_cv_lib_soname_SDL2+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lSDL2 $SDL2_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char SDL_Init (void);
+int
+main (void)
+{
+return SDL_Init ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_SDL2=`$ac_cv_path_LDD conftest.exe | grep "SDL2" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_SDL2=`$OTOOL -L conftest$ac_exeext | grep "libSDL2-2.0*\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libSDL2-2.0*\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_SDL2=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libSDL2-2.0*\\.$LIBEXT" | sed -e "s/^.*\\[\\(libSDL2-2.0*\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_SDL2:+false} :
+then :
+  ac_cv_lib_soname_SDL2=`$LDD conftest$ac_exeext | grep "libSDL2-2.0*\\.$LIBEXT" | sed -e "s/^.*\(libSDL2-2.0*\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_SDL2= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_SDL2:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_SDL2" >&5
+printf "%s\n" "$ac_cv_lib_soname_SDL2" >&6; }
+
+printf "%s\n" "#define SONAME_LIBSDL2 \"$ac_cv_lib_soname_SDL2\"" >>confdefs.h
+
+        ;;
+esac
+fi
+fi
+
+done
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+if test "x$ac_cv_lib_soname_SDL2" = "x"
+then :
+  case "x$with_sdl" in
+  x)   as_fn_append wine_notices "|libSDL2 ${notice_platform}development files not found, SDL2 won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libSDL2 ${notice_platform}development files not found, SDL2 won't be supported.
+This is an error since --with-sdl was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+if test "x$with_capi" != "xno"
+then
+    rm -f conftest.err
+if ${CAPI20_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  CAPI20_CFLAGS=`$PKG_CONFIG --cflags capi20 2>conftest.err`
+fi
+fi
+
+if ${CAPI20_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  CAPI20_LIBS=`$PKG_CONFIG --libs capi20 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: capi20 cflags: $CAPI20_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: capi20 libs: $CAPI20_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: capi20 errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $CAPI20_CFLAGS"
+    ac_fn_c_check_header_compile "$LINENO" "capi20.h" "ac_cv_header_capi20_h" "#define __user
+"
+if test "x$ac_cv_header_capi20_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_CAPI20_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "linux/capi.h" "ac_cv_header_linux_capi_h" "#define __user
+"
+if test "x$ac_cv_header_linux_capi_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_LINUX_CAPI_H 1" >>confdefs.h
+
+fi
+
+    if test "$ac_cv_header_capi20_h" = "yes" -a "$ac_cv_header_linux_capi_h" = "yes"
+    then
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for capi20_register in -lcapi20" >&5
+printf %s "checking for capi20_register in -lcapi20... " >&6; }
+if test ${ac_cv_lib_capi20_capi20_register+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lcapi20 $CAPI20_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char capi20_register (void);
+int
+main (void)
+{
+return capi20_register ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_capi20_capi20_register=yes
+else case e in #(
+  e) ac_cv_lib_capi20_capi20_register=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_capi20_capi20_register" >&5
+printf "%s\n" "$ac_cv_lib_capi20_capi20_register" >&6; }
+if test "x$ac_cv_lib_capi20_capi20_register" = xyes
+then :
+  :
+else case e in #(
+  e) CAPI20_LIBS="" ;;
+esac
+fi
+
+    fi
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+if test "x$ac_cv_lib_capi20_capi20_register" != xyes
+then :
+  case "x$with_capi" in
+  x)   as_fn_append wine_notices "|libcapi20 ${notice_platform}development files not found, ISDN won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libcapi20 ${notice_platform}development files not found, ISDN won't be supported.
+This is an error since --with-capi was requested." "$LINENO" 5 ;;
+esac
+enable_capi2032=${enable_capi2032:-no}
+fi
+
+if test "x$with_cups" != "xno"
+then
+    rm -f conftest.err
+if ${CUPS_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  CUPS_CFLAGS=`$PKG_CONFIG --cflags cups 2>conftest.err`
+fi
+fi
+test "$cross_compiling" = yes || CUPS_CFLAGS=${CUPS_CFLAGS:-`${CUPS_CONFIG:-cups-config} --cflags 2>/dev/null`}
+if ${CUPS_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  CUPS_LIBS=`$PKG_CONFIG --libs cups 2>/dev/null`
+fi
+fi
+test "$cross_compiling" = yes || CUPS_LIBS=${CUPS_LIBS:-`${CUPS_CONFIG:-cups-config} --libs 2>/dev/null`}
+CUPS_LIBS=${CUPS_LIBS:-"-lcups"}
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: cups cflags: $CUPS_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: cups libs: $CUPS_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: cups errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $CUPS_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "cups/cups.h" "ac_cv_header_cups_cups_h" "$ac_includes_default"
+if test "x$ac_cv_header_cups_cups_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_CUPS_CUPS_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "cups/ppd.h" "ac_cv_header_cups_ppd_h" "$ac_includes_default"
+if test "x$ac_cv_header_cups_ppd_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_CUPS_PPD_H 1" >>confdefs.h
+
+fi
+
+                        if test "$ac_cv_header_cups_cups_h" = "yes"
+                        then
+                            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lcups" >&5
+printf %s "checking for -lcups... " >&6; }
+if test ${ac_cv_lib_soname_cups+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lcups $CUPS_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char cupsGetDefault (void);
+int
+main (void)
+{
+return cupsGetDefault ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_cups=`$ac_cv_path_LDD conftest.exe | grep "cups" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_cups=`$OTOOL -L conftest$ac_exeext | grep "libcups\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libcups\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_cups=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libcups\\.$LIBEXT" | sed -e "s/^.*\\[\\(libcups\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_cups:+false} :
+then :
+  ac_cv_lib_soname_cups=`$LDD conftest$ac_exeext | grep "libcups\\.$LIBEXT" | sed -e "s/^.*\(libcups\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_cups= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_cups:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+       CUPS_LIBS=""
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_cups" >&5
+printf "%s\n" "$ac_cv_lib_soname_cups" >&6; }
+
+printf "%s\n" "#define SONAME_LIBCUPS \"$ac_cv_lib_soname_cups\"" >>confdefs.h
+
+        ;;
+esac
+fi
+                        else
+                            CUPS_CFLAGS=""
+                            CUPS_LIBS=""
+                        fi
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+if test "x$ac_cv_lib_soname_cups" = "x"
+then :
+  case "x$with_cups" in
+  x)   as_fn_append wine_notices "|libcups ${notice_platform}development files not found, CUPS won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libcups ${notice_platform}development files not found, CUPS won't be supported.
+This is an error since --with-cups was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+if test "x$with_fontconfig" != "xno"
+then
+    rm -f conftest.err
+if ${FONTCONFIG_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  FONTCONFIG_CFLAGS=`$PKG_CONFIG --cflags fontconfig 2>conftest.err`
+fi
+fi
+test "$cross_compiling" = yes || FONTCONFIG_CFLAGS=${FONTCONFIG_CFLAGS:-$X_CFLAGS}
+if ${FONTCONFIG_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  FONTCONFIG_LIBS=`$PKG_CONFIG --libs fontconfig 2>/dev/null`
+fi
+fi
+test "$cross_compiling" = yes || FONTCONFIG_LIBS=${FONTCONFIG_LIBS:-$X_LIBS}
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: fontconfig cflags: $FONTCONFIG_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: fontconfig libs: $FONTCONFIG_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: fontconfig errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $FONTCONFIG_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "fontconfig/fontconfig.h" "ac_cv_header_fontconfig_fontconfig_h" "$ac_includes_default"
+if test "x$ac_cv_header_fontconfig_fontconfig_h" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lfontconfig" >&5
+printf %s "checking for -lfontconfig... " >&6; }
+if test ${ac_cv_lib_soname_fontconfig+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lfontconfig $FONTCONFIG_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char FcInit (void);
+int
+main (void)
+{
+return FcInit ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_fontconfig=`$ac_cv_path_LDD conftest.exe | grep "fontconfig" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_fontconfig=`$OTOOL -L conftest$ac_exeext | grep "libfontconfig\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libfontconfig\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_fontconfig=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libfontconfig\\.$LIBEXT" | sed -e "s/^.*\\[\\(libfontconfig\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_fontconfig:+false} :
+then :
+  ac_cv_lib_soname_fontconfig=`$LDD conftest$ac_exeext | grep "libfontconfig\\.$LIBEXT" | sed -e "s/^.*\(libfontconfig\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_fontconfig= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_fontconfig:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+       FONTCONFIG_CFLAGS=""
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_fontconfig" >&5
+printf "%s\n" "$ac_cv_lib_soname_fontconfig" >&6; }
+
+printf "%s\n" "#define SONAME_LIBFONTCONFIG \"$ac_cv_lib_soname_fontconfig\"" >>confdefs.h
+
+        ;;
+esac
+fi
+else case e in #(
+  e) FONTCONFIG_CFLAGS="" ;;
+esac
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+if test "x$ac_cv_lib_soname_fontconfig" = "x"
+then :
+  case "x$with_fontconfig" in
+  x)   as_fn_append wine_notices "|fontconfig ${notice_platform}development files not found, fontconfig won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "fontconfig ${notice_platform}development files not found, fontconfig won't be supported.
+This is an error since --with-fontconfig was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+if test "x$with_krb5" != "xno"
+then
+    rm -f conftest.err
+if ${KRB5_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  KRB5_CFLAGS=`$PKG_CONFIG --cflags krb5 2>conftest.err`
+fi
+fi
+test "$cross_compiling" = yes || KRB5_CFLAGS=${KRB5_CFLAGS:-`${KRB5_CONFIG:-krb5-config} --cflags 2>/dev/null`}
+if ${KRB5_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  KRB5_LIBS=`$PKG_CONFIG --libs krb5 2>/dev/null`
+fi
+fi
+test "$cross_compiling" = yes || KRB5_LIBS=${KRB5_LIBS:-`${KRB5_CONFIG:-krb5-config} --libs 2>/dev/null`}
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: krb5 cflags: $KRB5_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: krb5 libs: $KRB5_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: krb5 errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $KRB5_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "krb5/krb5.h" "ac_cv_header_krb5_krb5_h" "$ac_includes_default"
+if test "x$ac_cv_header_krb5_krb5_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_KRB5_KRB5_H 1" >>confdefs.h
+
+fi
+
+         if test "$ac_cv_header_krb5_krb5_h" = "yes"
+         then
+             { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lkrb5" >&5
+printf %s "checking for -lkrb5... " >&6; }
+if test ${ac_cv_lib_soname_krb5+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lkrb5 $KRB5_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char krb5_is_config_principal (void);
+int
+main (void)
+{
+return krb5_is_config_principal ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_krb5=`$ac_cv_path_LDD conftest.exe | grep "krb5" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_krb5=`$OTOOL -L conftest$ac_exeext | grep "libkrb5\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libkrb5\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_krb5=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libkrb5\\.$LIBEXT" | sed -e "s/^.*\\[\\(libkrb5\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_krb5:+false} :
+then :
+  ac_cv_lib_soname_krb5=`$LDD conftest$ac_exeext | grep "libkrb5\\.$LIBEXT" | sed -e "s/^.*\(libkrb5\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_krb5= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_krb5:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+       KRB5_CFLAGS=""
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_krb5" >&5
+printf "%s\n" "$ac_cv_lib_soname_krb5" >&6; }
+
+printf "%s\n" "#define SONAME_LIBKRB5 \"$ac_cv_lib_soname_krb5\"" >>confdefs.h
+
+        ;;
+esac
+fi
+         else
+             KRB5_CFLAGS=""
+         fi
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+if test "x$ac_cv_lib_soname_krb5" = "x"
+then :
+  case "x$with_krb5" in
+  x)   as_fn_append wine_notices "|libkrb5 ${notice_platform}development files not found (or too old), Kerberos won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libkrb5 ${notice_platform}development files not found (or too old), Kerberos won't be supported.
+This is an error since --with-krb5 was requested." "$LINENO" 5 ;;
+esac
+
+fi
+test "x$ac_cv_lib_soname_krb5" != "x" || with_gssapi=${with_gssapi:-no}
+
+if test "x$with_gssapi" != "xno"
+then
+    rm -f conftest.err
+if ${GSSAPI_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  GSSAPI_CFLAGS=`$PKG_CONFIG --cflags krb5-gssapi 2>conftest.err`
+fi
+fi
+test "$cross_compiling" = yes || GSSAPI_CFLAGS=${GSSAPI_CFLAGS:-`${KRB5_CONFIG:-krb5-config} --cflags gssapi 2>/dev/null`}
+if ${GSSAPI_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  GSSAPI_LIBS=`$PKG_CONFIG --libs krb5-gssapi 2>/dev/null`
+fi
+fi
+test "$cross_compiling" = yes || GSSAPI_LIBS=${GSSAPI_LIBS:-`${KRB5_CONFIG:-krb5-config} --libs gssapi 2>/dev/null`}
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: krb5-gssapi cflags: $GSSAPI_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: krb5-gssapi libs: $GSSAPI_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: krb5-gssapi errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $GSSAPI_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "gssapi/gssapi.h" "ac_cv_header_gssapi_gssapi_h" "$ac_includes_default"
+if test "x$ac_cv_header_gssapi_gssapi_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_GSSAPI_GSSAPI_H 1" >>confdefs.h
+
+fi
+ac_fn_c_check_header_compile "$LINENO" "gssapi/gssapi_ext.h" "ac_cv_header_gssapi_gssapi_ext_h" "$ac_includes_default"
+if test "x$ac_cv_header_gssapi_gssapi_ext_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_GSSAPI_GSSAPI_EXT_H 1" >>confdefs.h
+
+fi
+
+        if test "$ac_cv_header_gssapi_gssapi_h" = "yes" -a "$ac_cv_header_gssapi_gssapi_ext_h" = "yes"
+        then
+            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lgssapi_krb5" >&5
+printf %s "checking for -lgssapi_krb5... " >&6; }
+if test ${ac_cv_lib_soname_gssapi_krb5+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lgssapi_krb5 $GSSAPI_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char gss_init_sec_context (void);
+int
+main (void)
+{
+return gss_init_sec_context ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_gssapi_krb5=`$ac_cv_path_LDD conftest.exe | grep "gssapi_krb5" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_gssapi_krb5=`$OTOOL -L conftest$ac_exeext | grep "libgssapi_krb5\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libgssapi_krb5\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_gssapi_krb5=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libgssapi_krb5\\.$LIBEXT" | sed -e "s/^.*\\[\\(libgssapi_krb5\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_gssapi_krb5:+false} :
+then :
+  ac_cv_lib_soname_gssapi_krb5=`$LDD conftest$ac_exeext | grep "libgssapi_krb5\\.$LIBEXT" | sed -e "s/^.*\(libgssapi_krb5\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_gssapi_krb5= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_gssapi_krb5:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+       GSSAPI_CFLAGS=""
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_gssapi_krb5" >&5
+printf "%s\n" "$ac_cv_lib_soname_gssapi_krb5" >&6; }
+
+printf "%s\n" "#define SONAME_LIBGSSAPI_KRB5 \"$ac_cv_lib_soname_gssapi_krb5\"" >>confdefs.h
+
+        ;;
+esac
+fi
+        else
+            GSSAPI_CFLAGS=""
+        fi
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+if test "x$ac_cv_lib_soname_gssapi_krb5" = "x"
+then :
+  case "x$with_gssapi" in
+  x)   as_fn_append wine_notices "|libgssapi_krb5 ${notice_platform}development files not found (or too old), no Kerberos SSP support." ;;
+  xno) ;;
+  *)   as_fn_error $? "libgssapi_krb5 ${notice_platform}development files not found (or too old), no Kerberos SSP support.
+This is an error since --with-gssapi was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+if test "$ac_cv_header_libprocstat_h" = "yes"
+then
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for procstat_open_sysctl in -lprocstat" >&5
+printf %s "checking for procstat_open_sysctl in -lprocstat... " >&6; }
+if test ${ac_cv_lib_procstat_procstat_open_sysctl+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_lib_save_LIBS=$LIBS
+LIBS="-lprocstat  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char procstat_open_sysctl (void);
+int
+main (void)
+{
+return procstat_open_sysctl ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_procstat_procstat_open_sysctl=yes
+else case e in #(
+  e) ac_cv_lib_procstat_procstat_open_sysctl=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_procstat_procstat_open_sysctl" >&5
+printf "%s\n" "$ac_cv_lib_procstat_procstat_open_sysctl" >&6; }
+if test "x$ac_cv_lib_procstat_procstat_open_sysctl" = xyes
+then :
+
+printf "%s\n" "#define HAVE_LIBPROCSTAT 1" >>confdefs.h
+
+                  PROCSTAT_LIBS="-lprocstat"
+
+fi
+
+fi
+
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lodbc" >&5
+printf %s "checking for -lodbc... " >&6; }
+if test ${ac_cv_lib_soname_odbc+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lodbc  $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char SQLConnect (void);
+int
+main (void)
+{
+return SQLConnect ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_odbc=`$ac_cv_path_LDD conftest.exe | grep "odbc" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_odbc=`$OTOOL -L conftest$ac_exeext | grep "libodbc\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libodbc\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_odbc=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libodbc\\.$LIBEXT" | sed -e "s/^.*\\[\\(libodbc\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_odbc:+false} :
+then :
+  ac_cv_lib_soname_odbc=`$LDD conftest$ac_exeext | grep "libodbc\\.$LIBEXT" | sed -e "s/^.*\(libodbc\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_odbc= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_odbc:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+       printf "%s\n" "#define SONAME_LIBODBC \"libodbc.$LIBEXT\"" >>confdefs.h
+
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_odbc" >&5
+printf "%s\n" "$ac_cv_lib_soname_odbc" >&6; }
+
+printf "%s\n" "#define SONAME_LIBODBC \"$ac_cv_lib_soname_odbc\"" >>confdefs.h
+
+        ;;
+esac
+fi
+
+if test "x$with_netapi" != "xno"
+then
+    rm -f conftest.err
+if ${NETAPI_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  NETAPI_CFLAGS=`$PKG_CONFIG --cflags netapi 2>conftest.err`
+fi
+fi
+
+if ${NETAPI_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  NETAPI_LIBS=`$PKG_CONFIG --libs netapi 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: netapi cflags: $NETAPI_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: netapi libs: $NETAPI_LIBS" >&5
+if test -s conftest.err; then
+     printf %s "$as_me:${as_lineno-$LINENO}: netapi errors: " >&5
+     cat conftest.err >&5
+fi
+rm -f conftest.err
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $NETAPI_CFLAGS"
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lnetapi" >&5
+printf %s "checking for -lnetapi... " >&6; }
+if test ${ac_cv_lib_soname_netapi+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lnetapi $NETAPI_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char libnetapi_init (void);
+int
+main (void)
+{
+return libnetapi_init ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_netapi=`$ac_cv_path_LDD conftest.exe | grep "netapi" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_netapi=`$OTOOL -L conftest$ac_exeext | grep "libnetapi\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libnetapi\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_netapi=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libnetapi\\.$LIBEXT" | sed -e "s/^.*\\[\\(libnetapi\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_netapi:+false} :
+then :
+  ac_cv_lib_soname_netapi=`$LDD conftest$ac_exeext | grep "libnetapi\\.$LIBEXT" | sed -e "s/^.*\(libnetapi\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_netapi= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_netapi:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+       printf "%s\n" "#define SONAME_LIBNETAPI \"libnetapi.$LIBEXT\"" >>confdefs.h
+
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_netapi" >&5
+printf "%s\n" "$ac_cv_lib_soname_netapi" >&6; }
+
+printf "%s\n" "#define SONAME_LIBNETAPI \"$ac_cv_lib_soname_netapi\"" >>confdefs.h
+
+        ;;
+esac
+fi
+CPPFLAGS=$ac_save_CPPFLAGS
+
+fi
+if test "x$ac_cv_lib_soname_netapi" = "x"
+then :
+  case "x$with_netapi" in
+  x)   as_fn_append wine_notices "|libnetapi not found, Samba NetAPI won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libnetapi not found, Samba NetAPI won't be supported.
+This is an error since --with-netapi was requested." "$LINENO" 5 ;;
+esac
+enable_netapi=${enable_netapi:-no}
+fi
+
+
+if test "x$enable_winealsa_drv$enable_winecoreaudio_drv$enable_winepulse_drv$enable_wineoss_drv$enable_wineandroid_drv" = xnonononono -a \
+        "x$with_alsa$with_coreaudio$with_oss$with_pulse" != xnononono
+then
+    as_fn_append wine_warnings "|No sound system was found. Windows applications will be silent."
+fi
+
+if test "x$with_vulkan" != "xno"
+then
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lvulkan" >&5
+printf %s "checking for -lvulkan... " >&6; }
+if test ${ac_cv_lib_soname_vulkan+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lvulkan  $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char vkGetInstanceProcAddr (void);
+int
+main (void)
+{
+return vkGetInstanceProcAddr ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_vulkan=`$ac_cv_path_LDD conftest.exe | grep "vulkan" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_vulkan=`$OTOOL -L conftest$ac_exeext | grep "libvulkan\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libvulkan\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_vulkan=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libvulkan\\.$LIBEXT" | sed -e "s/^.*\\[\\(libvulkan\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_vulkan:+false} :
+then :
+  ac_cv_lib_soname_vulkan=`$LDD conftest$ac_exeext | grep "libvulkan\\.$LIBEXT" | sed -e "s/^.*\(libvulkan\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_vulkan= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_vulkan:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_vulkan" >&5
+printf "%s\n" "$ac_cv_lib_soname_vulkan" >&6; }
+
+printf "%s\n" "#define SONAME_LIBVULKAN \"$ac_cv_lib_soname_vulkan\"" >>confdefs.h
+
+        ;;
+esac
+fi
+    if test "x$ac_cv_lib_soname_vulkan" = "x"
+    then
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for -lMoltenVK" >&5
+printf %s "checking for -lMoltenVK... " >&6; }
+if test ${ac_cv_lib_soname_MoltenVK+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_check_soname_save_LIBS=$LIBS
+LIBS="-lMoltenVK  $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char vkGetInstanceProcAddr (void);
+int
+main (void)
+{
+return vkGetInstanceProcAddr ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_MoltenVK=`$ac_cv_path_LDD conftest.exe | grep "MoltenVK" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_MoltenVK=`$OTOOL -L conftest$ac_exeext | grep "libMoltenVK\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libMoltenVK\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_MoltenVK=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libMoltenVK\\.$LIBEXT" | sed -e "s/^.*\\[\\(libMoltenVK\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_MoltenVK:+false} :
+then :
+  ac_cv_lib_soname_MoltenVK=`$LDD conftest$ac_exeext | grep "libMoltenVK\\.$LIBEXT" | sed -e "s/^.*\(libMoltenVK\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+else case e in #(
+  e) ac_cv_lib_soname_MoltenVK= ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS ;;
+esac
+fi
+if ${ac_cv_lib_soname_MoltenVK:+false} :
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+printf "%s\n" "not found" >&6; }
+
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_MoltenVK" >&5
+printf "%s\n" "$ac_cv_lib_soname_MoltenVK" >&6; }
+
+printf "%s\n" "#define SONAME_LIBMOLTENVK \"$ac_cv_lib_soname_MoltenVK\"" >>confdefs.h
+
+       printf "%s\n" "#define SONAME_LIBVULKAN \"$ac_cv_lib_soname_MoltenVK\"" >>confdefs.h
+ ;;
+esac
+fi
+    fi
+fi
+if test "x$ac_cv_lib_soname_vulkan" = "x" -a "x$ac_cv_lib_soname_MoltenVK" = "x"
+then :
+  case "x$with_vulkan" in
+  x)   as_fn_append wine_notices "|libvulkan and libMoltenVK ${notice_platform}development files not found, Vulkan won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libvulkan and libMoltenVK ${notice_platform}development files not found, Vulkan won't be supported.
+This is an error since --with-vulkan was requested." "$LINENO" 5 ;;
+esac
+
+fi
+
+
+if test "x${GCC}" = "xyes"
+then
+  EXTRACFLAGS="$EXTRACFLAGS -Wall -pipe"
+
+      saved_CFLAGS=$CFLAGS
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Werror=unknown-warning-option" >&5
+printf %s "checking whether the compiler supports -Werror=unknown-warning-option... " >&6; }
+if test ${ac_cv_cflags__Werror_unknown_warning_option+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Werror=unknown-warning-option"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Werror_unknown_warning_option=yes
+else case e in #(
+  e) ac_cv_cflags__Werror_unknown_warning_option=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Werror_unknown_warning_option" >&5
+printf "%s\n" "$ac_cv_cflags__Werror_unknown_warning_option" >&6; }
+if test "x$ac_cv_cflags__Werror_unknown_warning_option" = xyes
+then :
+  CFLAGS="$CFLAGS -Werror=unknown-warning-option"
+fi
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Werror=unused-command-line-argument" >&5
+printf %s "checking whether the compiler supports -Werror=unused-command-line-argument... " >&6; }
+if test ${ac_cv_cflags__Werror_unused_command_line_argument+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Werror=unused-command-line-argument"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Werror_unused_command_line_argument=yes
+else case e in #(
+  e) ac_cv_cflags__Werror_unused_command_line_argument=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Werror_unused_command_line_argument" >&5
+printf "%s\n" "$ac_cv_cflags__Werror_unused_command_line_argument" >&6; }
+if test "x$ac_cv_cflags__Werror_unused_command_line_argument" = xyes
+then :
+  CFLAGS="$CFLAGS -Werror=unused-command-line-argument"
+fi
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Werror=ignored-optimization-argument" >&5
+printf %s "checking whether the compiler supports -Werror=ignored-optimization-argument... " >&6; }
+if test ${ac_cv_cflags__Werror_ignored_optimization_argument+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Werror=ignored-optimization-argument"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Werror_ignored_optimization_argument=yes
+else case e in #(
+  e) ac_cv_cflags__Werror_ignored_optimization_argument=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Werror_ignored_optimization_argument" >&5
+printf "%s\n" "$ac_cv_cflags__Werror_ignored_optimization_argument" >&6; }
+if test "x$ac_cv_cflags__Werror_ignored_optimization_argument" = xyes
+then :
+  CFLAGS="$CFLAGS -Werror=ignored-optimization-argument"
+fi
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fcf-protection=none" >&5
+printf %s "checking whether the compiler supports -fcf-protection=none... " >&6; }
+if test ${ac_cv_cflags__fcf_protection_none+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -fcf-protection=none"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__fcf_protection_none=yes
+else case e in #(
+  e) ac_cv_cflags__fcf_protection_none=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fcf_protection_none" >&5
+printf "%s\n" "$ac_cv_cflags__fcf_protection_none" >&6; }
+if test "x$ac_cv_cflags__fcf_protection_none" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -fcf-protection=none"
+fi
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fvisibility=hidden" >&5
+printf %s "checking whether the compiler supports -fvisibility=hidden... " >&6; }
+if test ${ac_cv_cflags__fvisibility_hidden+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -fvisibility=hidden"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__fvisibility_hidden=yes
+else case e in #(
+  e) ac_cv_cflags__fvisibility_hidden=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fvisibility_hidden" >&5
+printf "%s\n" "$ac_cv_cflags__fvisibility_hidden" >&6; }
+if test "x$ac_cv_cflags__fvisibility_hidden" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -fvisibility=hidden"
+fi
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fno-stack-protector" >&5
+printf %s "checking whether the compiler supports -fno-stack-protector... " >&6; }
+if test ${ac_cv_cflags__fno_stack_protector+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -fno-stack-protector"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__fno_stack_protector=yes
+else case e in #(
+  e) ac_cv_cflags__fno_stack_protector=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fno_stack_protector" >&5
+printf "%s\n" "$ac_cv_cflags__fno_stack_protector" >&6; }
+if test "x$ac_cv_cflags__fno_stack_protector" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -fno-stack-protector"
+fi
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fno-strict-aliasing" >&5
+printf %s "checking whether the compiler supports -fno-strict-aliasing... " >&6; }
+if test ${ac_cv_cflags__fno_strict_aliasing+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -fno-strict-aliasing"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__fno_strict_aliasing=yes
+else case e in #(
+  e) ac_cv_cflags__fno_strict_aliasing=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fno_strict_aliasing" >&5
+printf "%s\n" "$ac_cv_cflags__fno_strict_aliasing" >&6; }
+if test "x$ac_cv_cflags__fno_strict_aliasing" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -fno-strict-aliasing"
+fi
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wdeclaration-after-statement" >&5
+printf %s "checking whether the compiler supports -Wdeclaration-after-statement... " >&6; }
+if test ${ac_cv_cflags__Wdeclaration_after_statement+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wdeclaration-after-statement"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Wdeclaration_after_statement=yes
+else case e in #(
+  e) ac_cv_cflags__Wdeclaration_after_statement=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wdeclaration_after_statement" >&5
+printf "%s\n" "$ac_cv_cflags__Wdeclaration_after_statement" >&6; }
+if test "x$ac_cv_cflags__Wdeclaration_after_statement" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -Wdeclaration-after-statement"
+fi
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wempty-body" >&5
+printf %s "checking whether the compiler supports -Wempty-body... " >&6; }
+if test ${ac_cv_cflags__Wempty_body+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wempty-body"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Wempty_body=yes
+else case e in #(
+  e) ac_cv_cflags__Wempty_body=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wempty_body" >&5
+printf "%s\n" "$ac_cv_cflags__Wempty_body" >&6; }
+if test "x$ac_cv_cflags__Wempty_body" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -Wempty-body"
+fi
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wignored-qualifiers" >&5
+printf %s "checking whether the compiler supports -Wignored-qualifiers... " >&6; }
+if test ${ac_cv_cflags__Wignored_qualifiers+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wignored-qualifiers"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Wignored_qualifiers=yes
+else case e in #(
+  e) ac_cv_cflags__Wignored_qualifiers=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wignored_qualifiers" >&5
+printf "%s\n" "$ac_cv_cflags__Wignored_qualifiers" >&6; }
+if test "x$ac_cv_cflags__Wignored_qualifiers" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -Wignored-qualifiers"
+fi
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Winit-self" >&5
+printf %s "checking whether the compiler supports -Winit-self... " >&6; }
+if test ${ac_cv_cflags__Winit_self+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Winit-self"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Winit_self=yes
+else case e in #(
+  e) ac_cv_cflags__Winit_self=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Winit_self" >&5
+printf "%s\n" "$ac_cv_cflags__Winit_self" >&6; }
+if test "x$ac_cv_cflags__Winit_self" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -Winit-self"
+fi
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wlogical-op" >&5
+printf %s "checking whether the compiler supports -Wlogical-op... " >&6; }
+if test ${ac_cv_cflags__Wlogical_op+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wlogical-op"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Wlogical_op=yes
+else case e in #(
+  e) ac_cv_cflags__Wlogical_op=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wlogical_op" >&5
+printf "%s\n" "$ac_cv_cflags__Wlogical_op" >&6; }
+if test "x$ac_cv_cflags__Wlogical_op" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -Wlogical-op"
+fi
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wpacked-not-aligned" >&5
+printf %s "checking whether the compiler supports -Wpacked-not-aligned... " >&6; }
+if test ${ac_cv_cflags__Wpacked_not_aligned+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wpacked-not-aligned"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Wpacked_not_aligned=yes
+else case e in #(
+  e) ac_cv_cflags__Wpacked_not_aligned=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wpacked_not_aligned" >&5
+printf "%s\n" "$ac_cv_cflags__Wpacked_not_aligned" >&6; }
+if test "x$ac_cv_cflags__Wpacked_not_aligned" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -Wno-packed-not-aligned"
+fi
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wpointer-arith" >&5
+printf %s "checking whether the compiler supports -Wpointer-arith... " >&6; }
+if test ${ac_cv_cflags__Wpointer_arith+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wpointer-arith"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Wpointer_arith=yes
+else case e in #(
+  e) ac_cv_cflags__Wpointer_arith=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wpointer_arith" >&5
+printf "%s\n" "$ac_cv_cflags__Wpointer_arith" >&6; }
+if test "x$ac_cv_cflags__Wpointer_arith" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -Wpointer-arith"
+fi
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wshift-overflow=2" >&5
+printf %s "checking whether the compiler supports -Wshift-overflow=2... " >&6; }
+if test ${ac_cv_cflags__Wshift_overflow_2+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wshift-overflow=2"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Wshift_overflow_2=yes
+else case e in #(
+  e) ac_cv_cflags__Wshift_overflow_2=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wshift_overflow_2" >&5
+printf "%s\n" "$ac_cv_cflags__Wshift_overflow_2" >&6; }
+if test "x$ac_cv_cflags__Wshift_overflow_2" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -Wshift-overflow=2"
+fi
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wstrict-prototypes" >&5
+printf %s "checking whether the compiler supports -Wstrict-prototypes... " >&6; }
+if test ${ac_cv_cflags__Wstrict_prototypes+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wstrict-prototypes"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Wstrict_prototypes=yes
+else case e in #(
+  e) ac_cv_cflags__Wstrict_prototypes=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wstrict_prototypes" >&5
+printf "%s\n" "$ac_cv_cflags__Wstrict_prototypes" >&6; }
+if test "x$ac_cv_cflags__Wstrict_prototypes" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -Wstrict-prototypes"
+fi
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wtype-limits" >&5
+printf %s "checking whether the compiler supports -Wtype-limits... " >&6; }
+if test ${ac_cv_cflags__Wtype_limits+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wtype-limits"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Wtype_limits=yes
+else case e in #(
+  e) ac_cv_cflags__Wtype_limits=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wtype_limits" >&5
+printf "%s\n" "$ac_cv_cflags__Wtype_limits" >&6; }
+if test "x$ac_cv_cflags__Wtype_limits" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -Wtype-limits"
+fi
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wunused-but-set-parameter" >&5
+printf %s "checking whether the compiler supports -Wunused-but-set-parameter... " >&6; }
+if test ${ac_cv_cflags__Wunused_but_set_parameter+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wunused-but-set-parameter"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Wunused_but_set_parameter=yes
+else case e in #(
+  e) ac_cv_cflags__Wunused_but_set_parameter=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wunused_but_set_parameter" >&5
+printf "%s\n" "$ac_cv_cflags__Wunused_but_set_parameter" >&6; }
+if test "x$ac_cv_cflags__Wunused_but_set_parameter" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -Wunused-but-set-parameter"
+fi
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wvla" >&5
+printf %s "checking whether the compiler supports -Wvla... " >&6; }
+if test ${ac_cv_cflags__Wvla+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wvla"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Wvla=yes
+else case e in #(
+  e) ac_cv_cflags__Wvla=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wvla" >&5
+printf "%s\n" "$ac_cv_cflags__Wvla" >&6; }
+if test "x$ac_cv_cflags__Wvla" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -Wvla"
+fi
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wwrite-strings" >&5
+printf %s "checking whether the compiler supports -Wwrite-strings... " >&6; }
+if test ${ac_cv_cflags__Wwrite_strings+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wwrite-strings"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Wwrite_strings=yes
+else case e in #(
+  e) ac_cv_cflags__Wwrite_strings=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wwrite_strings" >&5
+printf "%s\n" "$ac_cv_cflags__Wwrite_strings" >&6; }
+if test "x$ac_cv_cflags__Wwrite_strings" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -Wwrite-strings"
+fi
+
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -flarge-source-files -Wmisleading-indentation" >&5
+printf %s "checking whether the compiler supports -flarge-source-files -Wmisleading-indentation... " >&6; }
+if test ${ac_cv_cflags__flarge_source_files__Wmisleading_indentation+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -flarge-source-files -Wmisleading-indentation"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__flarge_source_files__Wmisleading_indentation=yes
+else case e in #(
+  e) ac_cv_cflags__flarge_source_files__Wmisleading_indentation=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__flarge_source_files__Wmisleading_indentation" >&5
+printf "%s\n" "$ac_cv_cflags__flarge_source_files__Wmisleading_indentation" >&6; }
+if test "x$ac_cv_cflags__flarge_source_files__Wmisleading_indentation" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -Wno-misleading-indentation"
+fi
+
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for flags needed for 64-bit compare-and-swap support" >&5
+printf %s "checking for flags needed for 64-bit compare-and-swap support... " >&6; }
+if test ${wine_cv_64bit_compare_swap+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifndef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8
+#error no
+#endif
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  wine_cv_64bit_compare_swap="none needed"
+else case e in #(
+  e) case $HOST_ARCH in
+            i386) wine_cv_64bit_compare_swap="-march=i586" ;;
+            arm)  wine_cv_64bit_compare_swap="-march=armv7-a" ;;
+            *)    wine_cv_64bit_compare_swap="unknown" ;;
+           esac
+           if test "x$wine_cv_64bit_compare_swap" != xunknown
+           then
+                              CFLAGS="$CFLAGS $wine_cv_64bit_compare_swap"
+               cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifndef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8
+#error no
+#endif
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+
+else case e in #(
+  e) wine_cv_64bit_compare_swap="unknown" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+               CFLAGS=$saved_CFLAGS
+           fi ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_64bit_compare_swap" >&5
+printf "%s\n" "$wine_cv_64bit_compare_swap" >&6; }
+  case "$wine_cv_64bit_compare_swap" in
+      unknown) as_fn_error $? "64-bit compare-and-swap is not supported on this platform" "$LINENO" 5 ;;
+      "none needed") ;;
+      *) EXTRACFLAGS="$EXTRACFLAGS $wine_cv_64bit_compare_swap" ;;
+  esac
+
+    ac_debug_format_seen=""
+  for ac_flag in $CFLAGS; do
+    case $ac_flag in
+      -gdwarf*)    ac_debug_format_seen=yes ;;
+      -g)          ac_debug_format_seen=${ac_debug_format_seen:-default} ;;
+    esac
+  done
+  if test "x$ac_debug_format_seen" = xdefault
+  then
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -gdwarf-4" >&5
+printf %s "checking whether the compiler supports -gdwarf-4... " >&6; }
+if test ${ac_cv_cflags__gdwarf_4+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -gdwarf-4"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__gdwarf_4=yes
+else case e in #(
+  e) ac_cv_cflags__gdwarf_4=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__gdwarf_4" >&5
+printf "%s\n" "$ac_cv_cflags__gdwarf_4" >&6; }
+if test "x$ac_cv_cflags__gdwarf_4" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -gdwarf-4"
+fi
+  fi
+
+    MSVCRTFLAGS=""
+
+  case $host_os in
+    mingw32*)         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,-delayload,autoconftest.dll" >&5
+printf %s "checking whether the compiler supports -Wl,-delayload,autoconftest.dll... " >&6; }
+if test ${ac_cv_cflags__Wl__delayload_autoconftest_dll+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wl,-delayload,autoconftest.dll"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Wl__delayload_autoconftest_dll=yes
+else case e in #(
+  e) ac_cv_cflags__Wl__delayload_autoconftest_dll=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl__delayload_autoconftest_dll" >&5
+printf "%s\n" "$ac_cv_cflags__Wl__delayload_autoconftest_dll" >&6; }
+if test "x$ac_cv_cflags__Wl__delayload_autoconftest_dll" = xyes
+then :
+  DELAYLOADFLAG="-Wl,-delayload,"
+
+fi ;;
+    *) MSVCRTFLAGS="-D_WIN32"
+       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fno-builtin" >&5
+printf %s "checking whether the compiler supports -fno-builtin... " >&6; }
+if test ${ac_cv_cflags__fno_builtin+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -fno-builtin"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__fno_builtin=yes
+else case e in #(
+  e) ac_cv_cflags__fno_builtin=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fno_builtin" >&5
+printf "%s\n" "$ac_cv_cflags__fno_builtin" >&6; }
+if test "x$ac_cv_cflags__fno_builtin" = xyes
+then :
+  MSVCRTFLAGS="$MSVCRTFLAGS -fno-builtin"
+fi
+       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fshort-wchar" >&5
+printf %s "checking whether the compiler supports -fshort-wchar... " >&6; }
+if test ${ac_cv_cflags__fshort_wchar+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -fshort-wchar"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__fshort_wchar=yes
+else case e in #(
+  e) ac_cv_cflags__fshort_wchar=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fshort_wchar" >&5
+printf "%s\n" "$ac_cv_cflags__fshort_wchar" >&6; }
+if test "x$ac_cv_cflags__fshort_wchar" = xyes
+then :
+  MSVCRTFLAGS="$MSVCRTFLAGS -fshort-wchar"
+fi
+       { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wno-format" >&5
+printf %s "checking whether the compiler supports -Wno-format... " >&6; }
+if test ${ac_cv_cflags__Wno_format+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wno-format"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Wno_format=yes
+else case e in #(
+  e) ac_cv_cflags__Wno_format=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wno_format" >&5
+printf "%s\n" "$ac_cv_cflags__Wno_format" >&6; }
+if test "x$ac_cv_cflags__Wno_format" = xyes
+then :
+  MSVCRTFLAGS="$MSVCRTFLAGS -Wno-format"
+fi ;;
+  esac
+
+  case $HOST_ARCH in
+        i386) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -fno-omit-frame-pointer" >&5
+printf %s "checking whether the compiler supports -fno-omit-frame-pointer... " >&6; }
+if test ${ac_cv_cflags__fno_omit_frame_pointer+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -fno-omit-frame-pointer"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__fno_omit_frame_pointer=yes
+else case e in #(
+  e) ac_cv_cflags__fno_omit_frame_pointer=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__fno_omit_frame_pointer" >&5
+printf "%s\n" "$ac_cv_cflags__fno_omit_frame_pointer" >&6; }
+if test "x$ac_cv_cflags__fno_omit_frame_pointer" = xyes
+then :
+  MSVCRTFLAGS="$MSVCRTFLAGS -fno-omit-frame-pointer"
+fi ;;
+    x86_64)
+      case $host_os in
+                cygwin*|mingw32*) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wno-format" >&5
+printf %s "checking whether the compiler supports -Wno-format... " >&6; }
+if test ${ac_cv_cflags__Wno_format+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wno-format"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Wno_format=yes
+else case e in #(
+  e) ac_cv_cflags__Wno_format=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wno_format" >&5
+printf "%s\n" "$ac_cv_cflags__Wno_format" >&6; }
+if test "x$ac_cv_cflags__Wno_format" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -Wno-format"
+fi ;;
+                *) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for working -mabi=ms" >&5
+printf %s "checking for working -mabi=ms... " >&6; }
+if test ${ac_cv_mabi_ms+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) CFLAGS="$CFLAGS -mabi=ms"
+                cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdarg.h>
+void a(int b, ...) { __builtin_ms_va_list list; __builtin_ms_va_start(list,b); }
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_mabi_ms=yes
+else case e in #(
+  e) ac_cv_mabi_ms=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext
+                CFLAGS=$saved_CFLAGS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_mabi_ms" >&5
+printf "%s\n" "$ac_cv_mabi_ms" >&6; }
+           if test "x$ac_cv_mabi_ms" = xyes
+then :
+  MSVCRTFLAGS="$MSVCRTFLAGS -mabi=ms"
+else case e in #(
+  e) test -n "$PE_ARCHS" || as_fn_error $? "The compiler doesn't support -mabi=ms. Use gcc instead of clang, or install mingw-w64." "$LINENO" 5
+                      DLLEXT="" ;;
+esac
+fi ;;
+      esac ;;
+    arm)
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wincompatible-function-pointer-types" >&5
+printf %s "checking whether the compiler supports -Wincompatible-function-pointer-types... " >&6; }
+if test ${ac_cv_cflags__Wincompatible_function_pointer_types+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wincompatible-function-pointer-types"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Wincompatible_function_pointer_types=yes
+else case e in #(
+  e) ac_cv_cflags__Wincompatible_function_pointer_types=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wincompatible_function_pointer_types" >&5
+printf "%s\n" "$ac_cv_cflags__Wincompatible_function_pointer_types" >&6; }
+if test "x$ac_cv_cflags__Wincompatible_function_pointer_types" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -Wno-error=incompatible-function-pointer-types"
+fi ;;
+  esac
+
+  CFLAGS=$saved_CFLAGS
+
+    if test "x$enable_werror" = "xyes"
+  then
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Werror" >&5
+printf %s "checking whether the compiler supports -Werror... " >&6; }
+if test ${ac_cv_cflags__Werror+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Werror"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Werror=yes
+else case e in #(
+  e) ac_cv_cflags__Werror=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Werror" >&5
+printf "%s\n" "$ac_cv_cflags__Werror" >&6; }
+if test "x$ac_cv_cflags__Werror" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -Werror"
+fi
+  fi
+
+  if test "x$enable_build_id" = xyes
+then :
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether the compiler supports -Wl,--build-id" >&5
+printf %s "checking whether the compiler supports -Wl,--build-id... " >&6; }
+if test ${ac_cv_cflags__Wl___build_id+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_wine_try_cflags_saved=$CFLAGS
+CFLAGS="$CFLAGS -Wl,--build-id"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int main(int argc, char **argv) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_cflags__Wl___build_id=yes
+else case e in #(
+  e) ac_cv_cflags__Wl___build_id=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+CFLAGS=$ac_wine_try_cflags_saved ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cflags__Wl___build_id" >&5
+printf "%s\n" "$ac_cv_cflags__Wl___build_id" >&6; }
+if test "x$ac_cv_cflags__Wl___build_id" = xyes
+then :
+  LDFLAGS="$LDFLAGS -Wl,--build-id"
+fi
+fi
+fi
+
+
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for the need to disable Fortify" >&5
+printf %s "checking for the need to disable Fortify... " >&6; }
+if test ${ac_cv_c_fortify_enabled+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <string.h>
+int
+main (void)
+{
+#if (defined(__USE_FORTIFY_LEVEL) && __USE_FORTIFY_LEVEL > 0) || (defined(_FORTIFY_SOURCE) && _FORTIFY_SOURCE > 0)
+#error Fortify enabled
+#endif
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_c_fortify_enabled=no
+else case e in #(
+  e) ac_cv_c_fortify_enabled=yes ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_fortify_enabled" >&5
+printf "%s\n" "$ac_cv_c_fortify_enabled" >&6; }
+if test "$ac_cv_c_fortify_enabled" = yes
+then
+    CFLAGS="$CFLAGS -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=0"
+fi
+
+
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether CFI directives are supported in assembly code" >&5
+printf %s "checking whether CFI directives are supported in assembly code... " >&6; }
+if test ${ac_cv_c_cfi_support+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+asm(".text\nac_test:\t.cfi_startproc\n\t.long 0\n\t.cfi_endproc");
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_c_cfi_support="yes"
+else case e in #(
+  e) ac_cv_c_cfi_support="no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_cfi_support" >&5
+printf "%s\n" "$ac_cv_c_cfi_support" >&6; }
+if test "$ac_cv_c_cfi_support" = "yes"
+then
+   DLLFLAGS="$DLLFLAGS -fasynchronous-unwind-tables"
+   LDDLLFLAGS="$LDDLLFLAGS -fasynchronous-unwind-tables"
+   UNIXDLLFLAGS="$UNIXDLLFLAGS -fasynchronous-unwind-tables"
+elif test $HOST_ARCH = x86_64
+then
+   as_fn_append wine_warnings "|building 64-bit Wine without support for CFI directives; exception handling will not work properly."
+fi
+
+
+WINELOADER_PROGRAMS="wine"
+
+
+case $host_os in
+  linux*)
+    if test $HOST_ARCH != unknown
+    then
+      wine_use_preloader=yes
+    fi
+    ;;
+esac
+
+if test "$wine_use_preloader" = "yes"
+then
+  WINELOADER_PROGRAMS="$WINELOADER_PROGRAMS wine-preloader"
+
+printf "%s\n" "#define HAVE_WINE_PRELOADER 1" >>confdefs.h
+
+fi
+
+
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for library containing dlopen" >&5
+printf %s "checking for library containing dlopen... " >&6; }
+if test ${ac_cv_search_dlopen+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_func_search_save_LIBS=$LIBS
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen (void);
+int
+main (void)
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+for ac_lib in '' dl
+do
+  if test -z "$ac_lib"; then
+    ac_res="none required"
+  else
+    ac_res=-l$ac_lib
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+  fi
+  if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_search_dlopen=$ac_res
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext
+  if test ${ac_cv_search_dlopen+y}
+then :
+  break
+fi
+done
+if test ${ac_cv_search_dlopen+y}
+then :
+
+else case e in #(
+  e) ac_cv_search_dlopen=no ;;
+esac
+fi
+rm conftest.$ac_ext
+LIBS=$ac_func_search_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_dlopen" >&5
+printf "%s\n" "$ac_cv_search_dlopen" >&6; }
+ac_res=$ac_cv_search_dlopen
+if test "$ac_res" != no
+then :
+  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
+
+fi
+
+
+ac_save_CFLAGS="$CFLAGS"
+CFLAGS="$CFLAGS $BUILTINFLAG"
+ac_fn_c_check_func "$LINENO" "dladdr1" "ac_cv_func_dladdr1"
+if test "x$ac_cv_func_dladdr1" = xyes
+then :
+  printf "%s\n" "#define HAVE_DLADDR1 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "dlinfo" "ac_cv_func_dlinfo"
+if test "x$ac_cv_func_dlinfo" = xyes
+then :
+  printf "%s\n" "#define HAVE_DLINFO 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "epoll_create" "ac_cv_func_epoll_create"
+if test "x$ac_cv_func_epoll_create" = xyes
+then :
+  printf "%s\n" "#define HAVE_EPOLL_CREATE 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "epoll_pwait2" "ac_cv_func_epoll_pwait2"
+if test "x$ac_cv_func_epoll_pwait2" = xyes
+then :
+  printf "%s\n" "#define HAVE_EPOLL_PWAIT2 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "fstatfs" "ac_cv_func_fstatfs"
+if test "x$ac_cv_func_fstatfs" = xyes
+then :
+  printf "%s\n" "#define HAVE_FSTATFS 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "futimens" "ac_cv_func_futimens"
+if test "x$ac_cv_func_futimens" = xyes
+then :
+  printf "%s\n" "#define HAVE_FUTIMENS 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "futimes" "ac_cv_func_futimes"
+if test "x$ac_cv_func_futimes" = xyes
+then :
+  printf "%s\n" "#define HAVE_FUTIMES 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "futimesat" "ac_cv_func_futimesat"
+if test "x$ac_cv_func_futimesat" = xyes
+then :
+  printf "%s\n" "#define HAVE_FUTIMESAT 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "getaddrinfo" "ac_cv_func_getaddrinfo"
+if test "x$ac_cv_func_getaddrinfo" = xyes
+then :
+  printf "%s\n" "#define HAVE_GETADDRINFO 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "getattrlist" "ac_cv_func_getattrlist"
+if test "x$ac_cv_func_getattrlist" = xyes
+then :
+  printf "%s\n" "#define HAVE_GETATTRLIST 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "getauxval" "ac_cv_func_getauxval"
+if test "x$ac_cv_func_getauxval" = xyes
+then :
+  printf "%s\n" "#define HAVE_GETAUXVAL 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "getifaddrs" "ac_cv_func_getifaddrs"
+if test "x$ac_cv_func_getifaddrs" = xyes
+then :
+  printf "%s\n" "#define HAVE_GETIFADDRS 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "getrandom" "ac_cv_func_getrandom"
+if test "x$ac_cv_func_getrandom" = xyes
+then :
+  printf "%s\n" "#define HAVE_GETRANDOM 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "kqueue" "ac_cv_func_kqueue"
+if test "x$ac_cv_func_kqueue" = xyes
+then :
+  printf "%s\n" "#define HAVE_KQUEUE 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "pipe2" "ac_cv_func_pipe2"
+if test "x$ac_cv_func_pipe2" = xyes
+then :
+  printf "%s\n" "#define HAVE_PIPE2 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "port_create" "ac_cv_func_port_create"
+if test "x$ac_cv_func_port_create" = xyes
+then :
+  printf "%s\n" "#define HAVE_PORT_CREATE 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "posix_fadvise" "ac_cv_func_posix_fadvise"
+if test "x$ac_cv_func_posix_fadvise" = xyes
+then :
+  printf "%s\n" "#define HAVE_POSIX_FADVISE 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "posix_fallocate" "ac_cv_func_posix_fallocate"
+if test "x$ac_cv_func_posix_fallocate" = xyes
+then :
+  printf "%s\n" "#define HAVE_POSIX_FALLOCATE 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "prctl" "ac_cv_func_prctl"
+if test "x$ac_cv_func_prctl" = xyes
+then :
+  printf "%s\n" "#define HAVE_PRCTL 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "sched_getcpu" "ac_cv_func_sched_getcpu"
+if test "x$ac_cv_func_sched_getcpu" = xyes
+then :
+  printf "%s\n" "#define HAVE_SCHED_GETCPU 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "sched_yield" "ac_cv_func_sched_yield"
+if test "x$ac_cv_func_sched_yield" = xyes
+then :
+  printf "%s\n" "#define HAVE_SCHED_YIELD 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "setproctitle" "ac_cv_func_setproctitle"
+if test "x$ac_cv_func_setproctitle" = xyes
+then :
+  printf "%s\n" "#define HAVE_SETPROCTITLE 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "setprogname" "ac_cv_func_setprogname"
+if test "x$ac_cv_func_setprogname" = xyes
+then :
+  printf "%s\n" "#define HAVE_SETPROGNAME 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "sigprocmask" "ac_cv_func_sigprocmask"
+if test "x$ac_cv_func_sigprocmask" = xyes
+then :
+  printf "%s\n" "#define HAVE_SIGPROCMASK 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "sysinfo" "ac_cv_func_sysinfo"
+if test "x$ac_cv_func_sysinfo" = xyes
+then :
+  printf "%s\n" "#define HAVE_SYSINFO 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "tcdrain" "ac_cv_func_tcdrain"
+if test "x$ac_cv_func_tcdrain" = xyes
+then :
+  printf "%s\n" "#define HAVE_TCDRAIN 1" >>confdefs.h
+
+fi
+ac_fn_c_check_func "$LINENO" "thr_kill2" "ac_cv_func_thr_kill2"
+if test "x$ac_cv_func_thr_kill2" = xyes
+then :
+  printf "%s\n" "#define HAVE_THR_KILL2 1" >>confdefs.h
+
+fi
+
+CFLAGS="$ac_save_CFLAGS"
+
+ac_save_LIBS=$LIBS
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for library containing clock_gettime" >&5
+printf %s "checking for library containing clock_gettime... " >&6; }
+if test ${ac_cv_search_clock_gettime+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) ac_func_search_save_LIBS=$LIBS
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.
+   The 'extern "C"' is for builds by C++ compilers;
+   although this is not generally supported in C code supporting it here
+   has little cost and some practical benefit (sr 110532).  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char clock_gettime (void);
+int
+main (void)
+{
+return clock_gettime ();
+  ;
+  return 0;
+}
+_ACEOF
+for ac_lib in '' rt
+do
+  if test -z "$ac_lib"; then
+    ac_res="none required"
+  else
+    ac_res=-l$ac_lib
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+  fi
+  if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_search_clock_gettime=$ac_res
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext
+  if test ${ac_cv_search_clock_gettime+y}
+then :
+  break
+fi
+done
+if test ${ac_cv_search_clock_gettime+y}
+then :
+
+else case e in #(
+  e) ac_cv_search_clock_gettime=no ;;
+esac
+fi
+rm conftest.$ac_ext
+LIBS=$ac_func_search_save_LIBS ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_clock_gettime" >&5
+printf "%s\n" "$ac_cv_search_clock_gettime" >&6; }
+ac_res=$ac_cv_search_clock_gettime
+if test "$ac_res" != no
+then :
+  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
+
+printf "%s\n" "#define HAVE_CLOCK_GETTIME 1" >>confdefs.h
+
+                test "$ac_res" = "none required" || RT_LIBS="$ac_res"
+
+fi
+
+LIBS=$ac_save_LIBS
+
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for sched_setaffinity" >&5
+printf %s "checking for sched_setaffinity... " >&6; }
+if test ${wine_cv_have_sched_setaffinity+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sched.h>
+int
+main (void)
+{
+sched_setaffinity(0, 0, 0);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  wine_cv_have_sched_setaffinity=yes
+else case e in #(
+  e) wine_cv_have_sched_setaffinity=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_have_sched_setaffinity" >&5
+printf "%s\n" "$wine_cv_have_sched_setaffinity" >&6; }
+if test "$wine_cv_have_sched_setaffinity" = "yes"
+then
+
+printf "%s\n" "#define HAVE_SCHED_SETAFFINITY 1" >>confdefs.h
+
+fi
+
+
+ac_fn_c_check_type "$LINENO" "request_sense" "ac_cv_type_request_sense" "#include <linux/cdrom.h>
+"
+if test "x$ac_cv_type_request_sense" = xyes
+then :
+
+printf "%s\n" "#define HAVE_REQUEST_SENSE 1" >>confdefs.h
+
+
+fi
+
+
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether we can use re-entrant gethostbyname_r Linux style" >&5
+printf %s "checking whether we can use re-entrant gethostbyname_r Linux style... " >&6; }
+if test ${wine_cv_linux_gethostbyname_r_6+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <netdb.h>
+int
+main (void)
+{
+
+    char *name=0;
+    struct hostent he;
+    struct hostent *result;
+    char *buf=0;
+    int bufsize=0;
+    int errnr;
+    char *addr=0;
+    int addrlen=0;
+    int addrtype=0;
+    gethostbyname_r(name,&he,buf,bufsize,&result,&errnr);
+    gethostbyaddr_r(addr, addrlen, addrtype,&he,buf,bufsize,&result,&errnr);
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  wine_cv_linux_gethostbyname_r_6=yes
+else case e in #(
+  e) wine_cv_linux_gethostbyname_r_6=no
+	 ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+    ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $wine_cv_linux_gethostbyname_r_6" >&5
+printf "%s\n" "$wine_cv_linux_gethostbyname_r_6" >&6; }
+   if test "$wine_cv_linux_gethostbyname_r_6" = "yes"
+   then
+
+printf "%s\n" "#define HAVE_LINUX_GETHOSTBYNAME_R_6 1" >>confdefs.h
+
+   fi
+
+ac_fn_c_check_member "$LINENO" "struct sockaddr_un" "sun_len" "ac_cv_member_struct_sockaddr_un_sun_len" "#include <sys/types.h>
+#include <sys/socket.h>
+#ifdef HAVE_SYS_UN_H
+# include <sys/un.h>
+#endif
+"
+if test "x$ac_cv_member_struct_sockaddr_un_sun_len" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_SOCKADDR_UN_SUN_LEN 1" >>confdefs.h
+
+
+fi
+
+
+ac_fn_c_check_member "$LINENO" "scsireq_t" "cmd" "ac_cv_member_scsireq_t_cmd" "#include <sys/types.h>
+#ifdef HAVE_SCSI_SG_H
+#include <scsi/sg.h>
+#endif
+"
+if test "x$ac_cv_member_scsireq_t_cmd" = xyes
+then :
+
+printf "%s\n" "#define HAVE_SCSIREQ_T_CMD 1" >>confdefs.h
+
+
+fi
+ac_fn_c_check_member "$LINENO" "sg_io_hdr_t" "interface_id" "ac_cv_member_sg_io_hdr_t_interface_id" "#include <sys/types.h>
+#ifdef HAVE_SCSI_SG_H
+#include <scsi/sg.h>
+#endif
+"
+if test "x$ac_cv_member_sg_io_hdr_t_interface_id" = xyes
+then :
+
+printf "%s\n" "#define HAVE_SG_IO_HDR_T_INTERFACE_ID 1" >>confdefs.h
+
+
+fi
+
+
+ac_fn_c_check_member "$LINENO" "siginfo_t" "si_fd" "ac_cv_member_siginfo_t_si_fd" "#include <signal.h>
+"
+if test "x$ac_cv_member_siginfo_t_si_fd" = xyes
+then :
+
+printf "%s\n" "#define HAVE_SIGINFO_T_SI_FD 1" >>confdefs.h
+
+
+fi
+
+
+ac_fn_c_check_member "$LINENO" "struct mtget" "mt_blksiz" "ac_cv_member_struct_mtget_mt_blksiz" "#include <sys/types.h>
+#ifdef HAVE_SYS_MTIO_H
+#include <sys/mtio.h>
+#endif
+"
+if test "x$ac_cv_member_struct_mtget_mt_blksiz" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_MTGET_MT_BLKSIZ 1" >>confdefs.h
+
+
+fi
+ac_fn_c_check_member "$LINENO" "struct mtget" "mt_gstat" "ac_cv_member_struct_mtget_mt_gstat" "#include <sys/types.h>
+#ifdef HAVE_SYS_MTIO_H
+#include <sys/mtio.h>
+#endif
+"
+if test "x$ac_cv_member_struct_mtget_mt_gstat" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_MTGET_MT_GSTAT 1" >>confdefs.h
+
+
+fi
+ac_fn_c_check_member "$LINENO" "struct mtget" "mt_blkno" "ac_cv_member_struct_mtget_mt_blkno" "#include <sys/types.h>
+#ifdef HAVE_SYS_MTIO_H
+#include <sys/mtio.h>
+#endif
+"
+if test "x$ac_cv_member_struct_mtget_mt_blkno" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_MTGET_MT_BLKNO 1" >>confdefs.h
+
+
+fi
+
+
+ac_fn_c_check_member "$LINENO" "struct stat" "st_mtim" "ac_cv_member_struct_stat_st_mtim" "$ac_includes_default"
+if test "x$ac_cv_member_struct_stat_st_mtim" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_STAT_ST_MTIM 1" >>confdefs.h
+
+
+fi
+ac_fn_c_check_member "$LINENO" "struct stat" "st_mtimespec" "ac_cv_member_struct_stat_st_mtimespec" "$ac_includes_default"
+if test "x$ac_cv_member_struct_stat_st_mtimespec" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_STAT_ST_MTIMESPEC 1" >>confdefs.h
+
+
+fi
+ac_fn_c_check_member "$LINENO" "struct stat" "st_ctim" "ac_cv_member_struct_stat_st_ctim" "$ac_includes_default"
+if test "x$ac_cv_member_struct_stat_st_ctim" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_STAT_ST_CTIM 1" >>confdefs.h
+
+
+fi
+ac_fn_c_check_member "$LINENO" "struct stat" "st_ctimespec" "ac_cv_member_struct_stat_st_ctimespec" "$ac_includes_default"
+if test "x$ac_cv_member_struct_stat_st_ctimespec" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_STAT_ST_CTIMESPEC 1" >>confdefs.h
+
+
+fi
+ac_fn_c_check_member "$LINENO" "struct stat" "st_atim" "ac_cv_member_struct_stat_st_atim" "$ac_includes_default"
+if test "x$ac_cv_member_struct_stat_st_atim" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_STAT_ST_ATIM 1" >>confdefs.h
+
+
+fi
+ac_fn_c_check_member "$LINENO" "struct stat" "st_atimespec" "ac_cv_member_struct_stat_st_atimespec" "$ac_includes_default"
+if test "x$ac_cv_member_struct_stat_st_atimespec" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_STAT_ST_ATIMESPEC 1" >>confdefs.h
+
+
+fi
+ac_fn_c_check_member "$LINENO" "struct stat" "st_birthtime" "ac_cv_member_struct_stat_st_birthtime" "$ac_includes_default"
+if test "x$ac_cv_member_struct_stat_st_birthtime" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_STAT_ST_BIRTHTIME 1" >>confdefs.h
+
+
+fi
+ac_fn_c_check_member "$LINENO" "struct stat" "st_birthtim" "ac_cv_member_struct_stat_st_birthtim" "$ac_includes_default"
+if test "x$ac_cv_member_struct_stat_st_birthtim" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_STAT_ST_BIRTHTIM 1" >>confdefs.h
+
+
+fi
+ac_fn_c_check_member "$LINENO" "struct stat" "st_birthtimespec" "ac_cv_member_struct_stat_st_birthtimespec" "$ac_includes_default"
+if test "x$ac_cv_member_struct_stat_st_birthtimespec" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC 1" >>confdefs.h
+
+
+fi
+ac_fn_c_check_member "$LINENO" "struct stat" "__st_birthtime" "ac_cv_member_struct_stat___st_birthtime" "$ac_includes_default"
+if test "x$ac_cv_member_struct_stat___st_birthtime" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_STAT___ST_BIRTHTIME 1" >>confdefs.h
+
+
+fi
+ac_fn_c_check_member "$LINENO" "struct stat" "__st_birthtim" "ac_cv_member_struct_stat___st_birthtim" "$ac_includes_default"
+if test "x$ac_cv_member_struct_stat___st_birthtim" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_STAT___ST_BIRTHTIM 1" >>confdefs.h
+
+
+fi
+
+
+ac_fn_c_check_member "$LINENO" "struct sockaddr_in6" "sin6_scope_id" "ac_cv_member_struct_sockaddr_in6_sin6_scope_id" "#include <sys/types.h>
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+"
+if test "x$ac_cv_member_struct_sockaddr_in6_sin6_scope_id" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID 1" >>confdefs.h
+
+
+fi
+
+
+ac_fn_c_check_member "$LINENO" "struct __res_state" "_u._ext.nscount6" "ac_cv_member_struct___res_state__u__ext_nscount6" "#ifdef HAVE_RESOLV_H
+#include <resolv.h>
+#endif
+"
+if test "x$ac_cv_member_struct___res_state__u__ext_nscount6" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT___RES_STATE__U__EXT_NSCOUNT6 1" >>confdefs.h
+
+
+fi
+
+
+ac_fn_c_check_member "$LINENO" "struct in6_pktinfo" "ipi6_addr" "ac_cv_member_struct_in6_pktinfo_ipi6_addr" "#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+"
+if test "x$ac_cv_member_struct_in6_pktinfo_ipi6_addr" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_IN6_PKTINFO_IPI6_ADDR 1" >>confdefs.h
+
+
+fi
+
+
+ac_fn_c_check_member "$LINENO" "struct ipstat" "ips_total" "ac_cv_member_struct_ipstat_ips_total" "#include <sys/types.h>
+#ifdef HAVE_SYS_SOCKETVAR_H
+#include <sys/socketvar.h>
+#endif
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#ifdef HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+"
+if test "x$ac_cv_member_struct_ipstat_ips_total" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_IPSTAT_IPS_TOTAL 1" >>confdefs.h
+
+
+fi
+
+
+ac_fn_c_check_member "$LINENO" "struct ip_stats" "ips_total" "ac_cv_member_struct_ip_stats_ips_total" "#ifdef HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+"
+if test "x$ac_cv_member_struct_ip_stats_ips_total" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_IP_STATS_IPS_TOTAL 1" >>confdefs.h
+
+
+fi
+
+
+ac_fn_c_check_member "$LINENO" "struct ip6stat" "ip6s_total" "ac_cv_member_struct_ip6stat_ip6s_total" "#include <sys/types.h>
+#ifdef HAVE_SYS_SOCKETVAR_H
+#include <sys/socketvar.h>
+#endif
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#ifdef HAVE_NETINET6_IP6_VAR_H
+#include <netinet6/ip6_var.h>
+#endif
+"
+if test "x$ac_cv_member_struct_ip6stat_ip6s_total" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_IP6STAT_IP6S_TOTAL 1" >>confdefs.h
+
+
+fi
+
+
+ac_fn_c_check_member "$LINENO" "struct icmpstat" "icps_error" "ac_cv_member_struct_icmpstat_icps_error" "#include <sys/types.h>
+#ifdef HAVE_SYS_SOCKETVAR_H
+#include <sys/socketvar.h>
+#endif
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#ifdef HAVE_NETINET_IP_H
+#include <netinet/ip.h>
+#endif
+#ifdef HAVE_NETINET_IP_ICMP_H
+#include <netinet/ip_icmp.h>
+#endif
+#ifdef HAVE_NETINET_ICMP_VAR_H
+#include <netinet/icmp_var.h>
+#endif
+"
+if test "x$ac_cv_member_struct_icmpstat_icps_error" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_ICMPSTAT_ICPS_ERROR 1" >>confdefs.h
+
+
+fi
+
+
+ac_fn_c_check_member "$LINENO" "struct icmp6stat" "icp6s_error" "ac_cv_member_struct_icmp6stat_icp6s_error" "#include <sys/types.h>
+#ifdef HAVE_SYS_SOCKETVAR_H
+#include <sys/socketvar.h>
+#endif
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#ifdef HAVE_NETINET_ICMP6_H
+#include <netinet/icmp6.h>
+#endif
+"
+if test "x$ac_cv_member_struct_icmp6stat_icp6s_error" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_ICMP6STAT_ICP6S_ERROR 1" >>confdefs.h
+
+
+fi
+
+
+ac_fn_c_check_member "$LINENO" "struct tcpstat" "tcps_connattempt" "ac_cv_member_struct_tcpstat_tcps_connattempt" "#include <sys/types.h>
+#ifdef HAVE_SYS_SOCKETVAR_H
+#include <sys/socketvar.h>
+#endif
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#ifdef HAVE_NETINET_TCP_H
+#include <netinet/tcp.h>
+#endif
+#ifdef HAVE_NETINET_TCP_VAR_H
+#include <netinet/tcp_var.h>
+#endif
+"
+if test "x$ac_cv_member_struct_tcpstat_tcps_connattempt" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_TCPSTAT_TCPS_CONNATTEMPT 1" >>confdefs.h
+
+
+fi
+
+
+ac_fn_c_check_member "$LINENO" "struct tcp_stats" "tcps_connattempt" "ac_cv_member_struct_tcp_stats_tcps_connattempt" "#ifdef HAVE_NETINET_TCP_VAR_H
+#include <netinet/tcp_var.h>
+#endif
+"
+if test "x$ac_cv_member_struct_tcp_stats_tcps_connattempt" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_TCP_STATS_TCPS_CONNATTEMPT 1" >>confdefs.h
+
+
+fi
+
+
+ac_fn_c_check_member "$LINENO" "struct udpstat" "udps_ipackets" "ac_cv_member_struct_udpstat_udps_ipackets" "#include <sys/types.h>
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#ifdef HAVE_NETINET_IP_VAR_H
+#include <netinet/ip_var.h>
+#endif
+#ifdef HAVE_NETINET_UDP_H
+#include <netinet/udp.h>
+#endif
+#ifdef HAVE_NETINET_UDP_VAR_H
+#include <netinet/udp_var.h>
+#endif
+"
+if test "x$ac_cv_member_struct_udpstat_udps_ipackets" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_UDPSTAT_UDPS_IPACKETS 1" >>confdefs.h
+
+
+fi
+
+
+ac_fn_c_check_member "$LINENO" "struct ifreq" "ifr_hwaddr" "ac_cv_member_struct_ifreq_ifr_hwaddr" "#include <sys/types.h>
+#ifdef HAVE_NET_IF_H
+# include <net/if.h>
+#endif
+"
+if test "x$ac_cv_member_struct_ifreq_ifr_hwaddr" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_IFREQ_IFR_HWADDR 1" >>confdefs.h
+
+
+fi
+
+
+ac_fn_c_check_member "$LINENO" "struct sysinfo" "totalram" "ac_cv_member_struct_sysinfo_totalram" "#ifdef HAVE_SYS_SYSINFO_H
+# include <sys/sysinfo.h>
+#endif
+"
+if test "x$ac_cv_member_struct_sysinfo_totalram" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_SYSINFO_TOTALRAM 1" >>confdefs.h
+
+
+fi
+ac_fn_c_check_member "$LINENO" "struct sysinfo" "mem_unit" "ac_cv_member_struct_sysinfo_mem_unit" "#ifdef HAVE_SYS_SYSINFO_H
+# include <sys/sysinfo.h>
+#endif
+"
+if test "x$ac_cv_member_struct_sysinfo_mem_unit" = xyes
+then :
+
+printf "%s\n" "#define HAVE_STRUCT_SYSINFO_MEM_UNIT 1" >>confdefs.h
+
+
+fi
+
+
+LIBS="$ac_save_LIBS"
+
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for __builtin_popcount" >&5
+printf %s "checking for __builtin_popcount... " >&6; }
+if test ${ac_cv_have___builtin_popcount+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main (void)
+{
+return __builtin_popcount(1)
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_have___builtin_popcount="yes"
+else case e in #(
+  e) ac_cv_have___builtin_popcount="no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have___builtin_popcount" >&5
+printf "%s\n" "$ac_cv_have___builtin_popcount" >&6; }
+if test "$ac_cv_have___builtin_popcount" = "yes"
+then
+
+printf "%s\n" "#define HAVE___BUILTIN_POPCOUNT 1" >>confdefs.h
+
+fi
+
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for __clear_cache" >&5
+printf %s "checking for __clear_cache... " >&6; }
+if test ${ac_cv_have___clear_cache+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main (void)
+{
+__clear_cache((void*)0, (void*)0); return 0;
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_have___clear_cache="yes"
+else case e in #(
+  e) ac_cv_have___clear_cache="no" ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have___clear_cache" >&5
+printf "%s\n" "$ac_cv_have___clear_cache" >&6; }
+if test "$ac_cv_have___clear_cache" = "yes"
+then
+
+printf "%s\n" "#define HAVE___CLEAR_CACHE 1" >>confdefs.h
+
+fi
+
+
+case $host_cpu in
+  *i[3456789]86*) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether we need to define __i386__" >&5
+printf %s "checking whether we need to define __i386__... " >&6; }
+if test ${ac_cv_cpp_def___i386__+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __i386__
+#error no
+#endif
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_cpp_def___i386__=yes
+else case e in #(
+  e) ac_cv_cpp_def___i386__=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cpp_def___i386__" >&5
+printf "%s\n" "$ac_cv_cpp_def___i386__" >&6; }
+if test "x$ac_cv_cpp_def___i386__" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -D__i386__"
+fi ;;
+  *x86_64*)         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether we need to define __x86_64__" >&5
+printf %s "checking whether we need to define __x86_64__... " >&6; }
+if test ${ac_cv_cpp_def___x86_64__+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __x86_64__
+#error no
+#endif
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_cpp_def___x86_64__=yes
+else case e in #(
+  e) ac_cv_cpp_def___x86_64__=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cpp_def___x86_64__" >&5
+printf "%s\n" "$ac_cv_cpp_def___x86_64__" >&6; }
+if test "x$ac_cv_cpp_def___x86_64__" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -D__x86_64__"
+fi ;;
+  *powerpc64*)      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether we need to define __powerpc64__" >&5
+printf %s "checking whether we need to define __powerpc64__... " >&6; }
+if test ${ac_cv_cpp_def___powerpc64__+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __powerpc64__
+#error no
+#endif
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_cpp_def___powerpc64__=yes
+else case e in #(
+  e) ac_cv_cpp_def___powerpc64__=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cpp_def___powerpc64__" >&5
+printf "%s\n" "$ac_cv_cpp_def___powerpc64__" >&6; }
+if test "x$ac_cv_cpp_def___powerpc64__" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -D__powerpc64__"
+fi ;;
+  *aarch64*)        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether we need to define __aarch64__" >&5
+printf %s "checking whether we need to define __aarch64__... " >&6; }
+if test ${ac_cv_cpp_def___aarch64__+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __aarch64__
+#error no
+#endif
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_cpp_def___aarch64__=yes
+else case e in #(
+  e) ac_cv_cpp_def___aarch64__=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cpp_def___aarch64__" >&5
+printf "%s\n" "$ac_cv_cpp_def___aarch64__" >&6; }
+if test "x$ac_cv_cpp_def___aarch64__" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -D__aarch64__"
+fi ;;
+  *arm*)            { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking whether we need to define __arm__" >&5
+printf %s "checking whether we need to define __arm__... " >&6; }
+if test ${ac_cv_cpp_def___arm__+y}
+then :
+  printf %s "(cached) " >&6
+else case e in #(
+  e) cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __arm__
+#error no
+#endif
+int
+main (void)
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"
+then :
+  ac_cv_cpp_def___arm__=yes
+else case e in #(
+  e) ac_cv_cpp_def___arm__=no ;;
+esac
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext ;;
+esac
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cpp_def___arm__" >&5
+printf "%s\n" "$ac_cv_cpp_def___arm__" >&6; }
+if test "x$ac_cv_cpp_def___arm__" = xyes
+then :
+  EXTRACFLAGS="$EXTRACFLAGS -D__arm__"
+fi ;;
+esac
+
+
+enable_vcruntime140_1=${enable_vcruntime140_1:-x86_64,arm64ec}
+
+if test -n "$PE_ARCHS"
+then
+    enable_wow64=${enable_wow64:-aarch64,x86_64}
+    enable_wow64win=${enable_wow64win:-aarch64,x86_64}
+    enable_wow64cpu=${enable_wow64cpu:-x86_64}
+    enable_xtajit64=${enable_xtajit64:-arm64ec}
+else
+    enable_wow64=${enable_wow64:-no}
+    enable_wow64win=${enable_wow64win:-no}
+    enable_wow64cpu=${enable_wow64cpu:-no}
+    enable_xtajit64=${enable_xtajit64:-no}
+    enable_compiler_rt=${enable_compiler_rt:-no}
+fi
+
+enable_conhost=${enable_conhost:-$HOST_ARCH}
+enable_plugplay=${enable_plugplay:-$HOST_ARCH}
+enable_rpcss=${enable_rpcss:-$HOST_ARCH}
+enable_services=${enable_services:-$HOST_ARCH}
+enable_spoolsv=${enable_spoolsv:-$HOST_ARCH}
+enable_termsv=${enable_termsv:-$HOST_ARCH}
+enable_wineboot=${enable_wineboot:-$HOST_ARCH}
+enable_winemenubuilder=${enable_winemenubuilder:-$HOST_ARCH}
+enable_wuauserv=${enable_wuauserv:-$HOST_ARCH}
+
+enable_cmd=${enable_cmd:-yes}
+enable_dllhost=${enable_dllhost:-yes}
+enable_dpnsvr=${enable_dpnsvr:-i386,x86_64,arm64ec}
+enable_dxdiag=${enable_dxdiag:-yes}
+enable_msiexec=${enable_msiexec:-yes}
+enable_netsh=${enable_netsh:-yes}
+enable_regsvr32=${enable_regsvr32:-yes}
+enable_rundll32=${enable_rundll32:-yes}
+
+enable_win16=${enable_win16:-i386}
+enable_w32skrnl=${enable_w32skrnl:-$enable_win16}
+enable_wow32=${enable_wow32:-$enable_win16}
+enable_winevdm=${enable_winevdm:-$enable_win16}
+
+enable_winetest=${enable_winetest:-$enable_tests}
+
+
+
+
+
+ac_config_commands="$ac_config_commands include/stamp-h"
+
+printf %s "creating Makefile rules..." >&6
+
+makedep_flags=" -C"
+test "x$enable_silent_rules" = xyes && makedep_flags="$makedep_flags -S"
+
+wine_srcdir=
+test "$srcdir" = . || wine_srcdir="$srcdir/"
+
+wine_fn_config_makefile dlls/acledit enable_acledit
+wine_fn_config_makefile dlls/aclui enable_aclui
+wine_fn_config_makefile dlls/activeds.tlb enable_activeds_tlb
+wine_fn_config_makefile dlls/activeds enable_activeds
+wine_fn_config_makefile dlls/activeds/tests enable_tests
+wine_fn_config_makefile dlls/actxprxy enable_actxprxy
+wine_fn_config_makefile dlls/adsldp enable_adsldp
+wine_fn_config_makefile dlls/adsldp/tests enable_tests
+wine_fn_config_makefile dlls/adsldpc enable_adsldpc
+wine_fn_config_makefile dlls/advapi32 enable_advapi32
+wine_fn_config_makefile dlls/advapi32/tests enable_tests
+wine_fn_config_makefile dlls/advpack enable_advpack
+wine_fn_config_makefile dlls/advpack/tests enable_tests
+wine_fn_config_makefile dlls/amsi enable_amsi
+wine_fn_config_makefile dlls/amstream enable_amstream
+wine_fn_config_makefile dlls/amstream/tests enable_tests
+wine_fn_config_makefile dlls/apisetschema enable_apisetschema
+wine_fn_config_makefile dlls/apphelp enable_apphelp
+wine_fn_config_makefile dlls/apphelp/tests enable_tests
+wine_fn_config_makefile dlls/appwiz.cpl enable_appwiz_cpl
+wine_fn_config_makefile dlls/appxdeploymentclient enable_appxdeploymentclient
+wine_fn_config_makefile dlls/atl enable_atl
+wine_fn_config_makefile dlls/atl/tests enable_tests
+wine_fn_config_makefile dlls/atl100 enable_atl100
+wine_fn_config_makefile dlls/atl100/tests enable_tests
+wine_fn_config_makefile dlls/atl110 enable_atl110
+wine_fn_config_makefile dlls/atl110/tests enable_tests
+wine_fn_config_makefile dlls/atl80 enable_atl80
+wine_fn_config_makefile dlls/atl80/tests enable_tests
+wine_fn_config_makefile dlls/atl90 enable_atl90
+wine_fn_config_makefile dlls/atlthunk enable_atlthunk
+wine_fn_config_makefile dlls/atlthunk/tests enable_tests
+wine_fn_config_makefile dlls/atmlib enable_atmlib
+wine_fn_config_makefile dlls/authz enable_authz
+wine_fn_config_makefile dlls/avicap32 enable_avicap32
+wine_fn_config_makefile dlls/avifil32 enable_avifil32
+wine_fn_config_makefile dlls/avifil32/tests enable_tests
+wine_fn_config_makefile dlls/avifile.dll16 enable_win16
+wine_fn_config_makefile dlls/avrt enable_avrt
+wine_fn_config_makefile dlls/bcp47langs enable_bcp47langs
+wine_fn_config_makefile dlls/bcp47langs/tests enable_tests
+wine_fn_config_makefile dlls/bcrypt enable_bcrypt
+wine_fn_config_makefile dlls/bcrypt/tests enable_tests
+wine_fn_config_makefile dlls/bcryptprimitives enable_bcryptprimitives
+wine_fn_config_makefile dlls/bluetoothapis enable_bluetoothapis
+wine_fn_config_makefile dlls/bluetoothapis/tests enable_tests
+wine_fn_config_makefile dlls/browseui enable_browseui
+wine_fn_config_makefile dlls/browseui/tests enable_tests
+wine_fn_config_makefile dlls/bthprops.cpl enable_bthprops_cpl
+wine_fn_config_makefile dlls/cabinet enable_cabinet
+wine_fn_config_makefile dlls/cabinet/tests enable_tests
+wine_fn_config_makefile dlls/capi2032 enable_capi2032
+wine_fn_config_makefile dlls/cards enable_cards
+wine_fn_config_makefile dlls/cdosys enable_cdosys
+wine_fn_config_makefile dlls/cfgmgr32 enable_cfgmgr32
+wine_fn_config_makefile dlls/cfgmgr32/tests enable_tests
+wine_fn_config_makefile dlls/clusapi enable_clusapi
+wine_fn_config_makefile dlls/cng.sys enable_cng_sys
+wine_fn_config_makefile dlls/colorcnv enable_colorcnv
+wine_fn_config_makefile dlls/combase enable_combase
+wine_fn_config_makefile dlls/combase/tests enable_tests
+wine_fn_config_makefile dlls/comcat enable_comcat
+wine_fn_config_makefile dlls/comcat/tests enable_tests
+wine_fn_config_makefile dlls/comctl32 enable_comctl32
+wine_fn_config_makefile dlls/comctl32/tests enable_tests
+wine_fn_config_makefile dlls/comdlg32 enable_comdlg32
+wine_fn_config_makefile dlls/comdlg32/tests enable_tests
+wine_fn_config_makefile dlls/coml2 enable_coml2
+wine_fn_config_makefile dlls/comm.drv16 enable_win16
+wine_fn_config_makefile dlls/commdlg.dll16 enable_win16
+wine_fn_config_makefile dlls/compobj.dll16 enable_win16
+wine_fn_config_makefile dlls/compstui enable_compstui
+wine_fn_config_makefile dlls/compstui/tests enable_tests
+wine_fn_config_makefile dlls/comsvcs enable_comsvcs
+wine_fn_config_makefile dlls/comsvcs/tests enable_tests
+wine_fn_config_makefile dlls/concrt140 enable_concrt140
+wine_fn_config_makefile dlls/concrt140/tests enable_tests
+wine_fn_config_makefile dlls/connect enable_connect
+wine_fn_config_makefile dlls/coremessaging enable_coremessaging
+wine_fn_config_makefile dlls/coremessaging/tests enable_tests
+wine_fn_config_makefile dlls/credui enable_credui
+wine_fn_config_makefile dlls/credui/tests enable_tests
+wine_fn_config_makefile dlls/crtdll enable_crtdll
+wine_fn_config_makefile dlls/crypt32 enable_crypt32
+wine_fn_config_makefile dlls/crypt32/tests enable_tests
+wine_fn_config_makefile dlls/cryptbase enable_cryptbase
+wine_fn_config_makefile dlls/cryptdlg enable_cryptdlg
+wine_fn_config_makefile dlls/cryptdll enable_cryptdll
+wine_fn_config_makefile dlls/cryptext enable_cryptext
+wine_fn_config_makefile dlls/cryptext/tests enable_tests
+wine_fn_config_makefile dlls/cryptnet enable_cryptnet
+wine_fn_config_makefile dlls/cryptnet/tests enable_tests
+wine_fn_config_makefile dlls/cryptowinrt enable_cryptowinrt
+wine_fn_config_makefile dlls/cryptowinrt/tests enable_tests
+wine_fn_config_makefile dlls/cryptsp enable_cryptsp
+wine_fn_config_makefile dlls/cryptui enable_cryptui
+wine_fn_config_makefile dlls/cryptui/tests enable_tests
+wine_fn_config_makefile dlls/cryptxml enable_cryptxml
+wine_fn_config_makefile dlls/cryptxml/tests enable_tests
+wine_fn_config_makefile dlls/ctapi32 enable_ctapi32
+wine_fn_config_makefile dlls/ctl3d.dll16 enable_win16
+wine_fn_config_makefile dlls/ctl3d32 enable_ctl3d32
+wine_fn_config_makefile dlls/ctl3dv2.dll16 enable_win16
+wine_fn_config_makefile dlls/d2d1 enable_d2d1
+wine_fn_config_makefile dlls/d2d1/tests enable_tests
+wine_fn_config_makefile dlls/d3d10 enable_d3d10
+wine_fn_config_makefile dlls/d3d10/tests enable_tests
+wine_fn_config_makefile dlls/d3d10_1 enable_d3d10_1
+wine_fn_config_makefile dlls/d3d10_1/tests enable_tests
+wine_fn_config_makefile dlls/d3d10core enable_d3d10core
+wine_fn_config_makefile dlls/d3d10core/tests enable_tests
+wine_fn_config_makefile dlls/d3d11 enable_d3d11
+wine_fn_config_makefile dlls/d3d11/tests enable_tests
+wine_fn_config_makefile dlls/d3d12 enable_d3d12
+wine_fn_config_makefile dlls/d3d12/tests enable_tests
+wine_fn_config_makefile dlls/d3d12core enable_d3d12core
+wine_fn_config_makefile dlls/d3d8 enable_d3d8
+wine_fn_config_makefile dlls/d3d8/tests enable_tests
+wine_fn_config_makefile dlls/d3d8thk enable_d3d8thk
+wine_fn_config_makefile dlls/d3d9 enable_d3d9
+wine_fn_config_makefile dlls/d3d9/tests enable_tests
+wine_fn_config_makefile dlls/d3dcompiler_33 enable_d3dcompiler_33
+wine_fn_config_makefile dlls/d3dcompiler_34 enable_d3dcompiler_34
+wine_fn_config_makefile dlls/d3dcompiler_35 enable_d3dcompiler_35
+wine_fn_config_makefile dlls/d3dcompiler_36 enable_d3dcompiler_36
+wine_fn_config_makefile dlls/d3dcompiler_37 enable_d3dcompiler_37
+wine_fn_config_makefile dlls/d3dcompiler_38 enable_d3dcompiler_38
+wine_fn_config_makefile dlls/d3dcompiler_39 enable_d3dcompiler_39
+wine_fn_config_makefile dlls/d3dcompiler_40 enable_d3dcompiler_40
+wine_fn_config_makefile dlls/d3dcompiler_41 enable_d3dcompiler_41
+wine_fn_config_makefile dlls/d3dcompiler_42 enable_d3dcompiler_42
+wine_fn_config_makefile dlls/d3dcompiler_42/tests enable_tests
+wine_fn_config_makefile dlls/d3dcompiler_43 enable_d3dcompiler_43
+wine_fn_config_makefile dlls/d3dcompiler_43/tests enable_tests
+wine_fn_config_makefile dlls/d3dcompiler_46 enable_d3dcompiler_46
+wine_fn_config_makefile dlls/d3dcompiler_46/tests enable_tests
+wine_fn_config_makefile dlls/d3dcompiler_47 enable_d3dcompiler_47
+wine_fn_config_makefile dlls/d3dcompiler_47/tests enable_tests
+wine_fn_config_makefile dlls/d3dim enable_d3dim
+wine_fn_config_makefile dlls/d3dim700 enable_d3dim700
+wine_fn_config_makefile dlls/d3drm enable_d3drm
+wine_fn_config_makefile dlls/d3drm/tests enable_tests
+wine_fn_config_makefile dlls/d3dx10_33 enable_d3dx10_33
+wine_fn_config_makefile dlls/d3dx10_33/tests enable_tests
+wine_fn_config_makefile dlls/d3dx10_34 enable_d3dx10_34
+wine_fn_config_makefile dlls/d3dx10_34/tests enable_tests
+wine_fn_config_makefile dlls/d3dx10_35 enable_d3dx10_35
+wine_fn_config_makefile dlls/d3dx10_35/tests enable_tests
+wine_fn_config_makefile dlls/d3dx10_36 enable_d3dx10_36
+wine_fn_config_makefile dlls/d3dx10_36/tests enable_tests
+wine_fn_config_makefile dlls/d3dx10_37 enable_d3dx10_37
+wine_fn_config_makefile dlls/d3dx10_37/tests enable_tests
+wine_fn_config_makefile dlls/d3dx10_38 enable_d3dx10_38
+wine_fn_config_makefile dlls/d3dx10_38/tests enable_tests
+wine_fn_config_makefile dlls/d3dx10_39 enable_d3dx10_39
+wine_fn_config_makefile dlls/d3dx10_39/tests enable_tests
+wine_fn_config_makefile dlls/d3dx10_40 enable_d3dx10_40
+wine_fn_config_makefile dlls/d3dx10_40/tests enable_tests
+wine_fn_config_makefile dlls/d3dx10_41 enable_d3dx10_41
+wine_fn_config_makefile dlls/d3dx10_41/tests enable_tests
+wine_fn_config_makefile dlls/d3dx10_42 enable_d3dx10_42
+wine_fn_config_makefile dlls/d3dx10_42/tests enable_tests
+wine_fn_config_makefile dlls/d3dx10_43 enable_d3dx10_43
+wine_fn_config_makefile dlls/d3dx10_43/tests enable_tests
+wine_fn_config_makefile dlls/d3dx11_42 enable_d3dx11_42
+wine_fn_config_makefile dlls/d3dx11_42/tests enable_tests
+wine_fn_config_makefile dlls/d3dx11_43 enable_d3dx11_43
+wine_fn_config_makefile dlls/d3dx11_43/tests enable_tests
+wine_fn_config_makefile dlls/d3dx9_24 enable_d3dx9_24
+wine_fn_config_makefile dlls/d3dx9_25 enable_d3dx9_25
+wine_fn_config_makefile dlls/d3dx9_26 enable_d3dx9_26
+wine_fn_config_makefile dlls/d3dx9_27 enable_d3dx9_27
+wine_fn_config_makefile dlls/d3dx9_28 enable_d3dx9_28
+wine_fn_config_makefile dlls/d3dx9_29 enable_d3dx9_29
+wine_fn_config_makefile dlls/d3dx9_30 enable_d3dx9_30
+wine_fn_config_makefile dlls/d3dx9_31 enable_d3dx9_31
+wine_fn_config_makefile dlls/d3dx9_32 enable_d3dx9_32
+wine_fn_config_makefile dlls/d3dx9_33 enable_d3dx9_33
+wine_fn_config_makefile dlls/d3dx9_34 enable_d3dx9_34
+wine_fn_config_makefile dlls/d3dx9_35 enable_d3dx9_35
+wine_fn_config_makefile dlls/d3dx9_35/tests enable_tests
+wine_fn_config_makefile dlls/d3dx9_36 enable_d3dx9_36
+wine_fn_config_makefile dlls/d3dx9_36/tests enable_tests
+wine_fn_config_makefile dlls/d3dx9_37 enable_d3dx9_37
+wine_fn_config_makefile dlls/d3dx9_38 enable_d3dx9_38
+wine_fn_config_makefile dlls/d3dx9_39 enable_d3dx9_39
+wine_fn_config_makefile dlls/d3dx9_40 enable_d3dx9_40
+wine_fn_config_makefile dlls/d3dx9_41 enable_d3dx9_41
+wine_fn_config_makefile dlls/d3dx9_42 enable_d3dx9_42
+wine_fn_config_makefile dlls/d3dx9_42/tests enable_tests
+wine_fn_config_makefile dlls/d3dx9_43 enable_d3dx9_43
+wine_fn_config_makefile dlls/d3dx9_43/tests enable_tests
+wine_fn_config_makefile dlls/d3dxof enable_d3dxof
+wine_fn_config_makefile dlls/d3dxof/tests enable_tests
+wine_fn_config_makefile dlls/dataexchange enable_dataexchange
+wine_fn_config_makefile dlls/dataexchange/tests enable_tests
+wine_fn_config_makefile dlls/davclnt enable_davclnt
+wine_fn_config_makefile dlls/dbgeng enable_dbgeng
+wine_fn_config_makefile dlls/dbgeng/tests enable_tests
+wine_fn_config_makefile dlls/dbghelp enable_dbghelp
+wine_fn_config_makefile dlls/dbghelp/tests enable_tests
+wine_fn_config_makefile dlls/dciman32 enable_dciman32
+wine_fn_config_makefile dlls/dcomp enable_dcomp
+wine_fn_config_makefile dlls/ddeml.dll16 enable_win16
+wine_fn_config_makefile dlls/ddraw enable_ddraw
+wine_fn_config_makefile dlls/ddraw/tests enable_tests
+wine_fn_config_makefile dlls/ddrawex enable_ddrawex
+wine_fn_config_makefile dlls/ddrawex/tests enable_tests
+wine_fn_config_makefile dlls/desk.cpl enable_desk_cpl
+wine_fn_config_makefile dlls/devenum enable_devenum
+wine_fn_config_makefile dlls/devenum/tests enable_tests
+wine_fn_config_makefile dlls/dhcpcsvc enable_dhcpcsvc
+wine_fn_config_makefile dlls/dhcpcsvc/tests enable_tests
+wine_fn_config_makefile dlls/dhcpcsvc6 enable_dhcpcsvc6
+wine_fn_config_makefile dlls/dhtmled.ocx enable_dhtmled_ocx
+wine_fn_config_makefile dlls/diasymreader enable_diasymreader
+wine_fn_config_makefile dlls/difxapi enable_difxapi
+wine_fn_config_makefile dlls/dinput enable_dinput
+wine_fn_config_makefile dlls/dinput/tests enable_tests
+wine_fn_config_makefile dlls/dinput8 enable_dinput8
+wine_fn_config_makefile dlls/directmanipulation enable_directmanipulation
+wine_fn_config_makefile dlls/directmanipulation/tests enable_tests
+wine_fn_config_makefile dlls/dispdib.dll16 enable_win16
+wine_fn_config_makefile dlls/dispex enable_dispex
+wine_fn_config_makefile dlls/dispex/tests enable_tests
+wine_fn_config_makefile dlls/display.drv16 enable_win16
+wine_fn_config_makefile dlls/dmband enable_dmband
+wine_fn_config_makefile dlls/dmband/tests enable_tests
+wine_fn_config_makefile dlls/dmcompos enable_dmcompos
+wine_fn_config_makefile dlls/dmcompos/tests enable_tests
+wine_fn_config_makefile dlls/dmime enable_dmime
+wine_fn_config_makefile dlls/dmime/tests enable_tests
+wine_fn_config_makefile dlls/dmloader enable_dmloader
+wine_fn_config_makefile dlls/dmloader/tests enable_tests
+wine_fn_config_makefile dlls/dmscript enable_dmscript
+wine_fn_config_makefile dlls/dmscript/tests enable_tests
+wine_fn_config_makefile dlls/dmstyle enable_dmstyle
+wine_fn_config_makefile dlls/dmstyle/tests enable_tests
+wine_fn_config_makefile dlls/dmsynth enable_dmsynth
+wine_fn_config_makefile dlls/dmsynth/tests enable_tests
+wine_fn_config_makefile dlls/dmusic enable_dmusic
+wine_fn_config_makefile dlls/dmusic/tests enable_tests
+wine_fn_config_makefile dlls/dmusic32 enable_dmusic32
+wine_fn_config_makefile dlls/dnsapi enable_dnsapi
+wine_fn_config_makefile dlls/dnsapi/tests enable_tests
+wine_fn_config_makefile dlls/dplay enable_dplay
+wine_fn_config_makefile dlls/dplayx enable_dplayx
+wine_fn_config_makefile dlls/dplayx/tests enable_tests
+wine_fn_config_makefile dlls/dpnaddr enable_dpnaddr
+wine_fn_config_makefile dlls/dpnet enable_dpnet
+wine_fn_config_makefile dlls/dpnet/tests enable_tests
+wine_fn_config_makefile dlls/dpnhpast enable_dpnhpast
+wine_fn_config_makefile dlls/dpnhupnp enable_dpnhupnp
+wine_fn_config_makefile dlls/dpnlobby enable_dpnlobby
+wine_fn_config_makefile dlls/dpvoice enable_dpvoice
+wine_fn_config_makefile dlls/dpvoice/tests enable_tests
+wine_fn_config_makefile dlls/dpwsockx enable_dpwsockx
+wine_fn_config_makefile dlls/drmclien enable_drmclien
+wine_fn_config_makefile dlls/dsdmo enable_dsdmo
+wine_fn_config_makefile dlls/dsdmo/tests enable_tests
+wine_fn_config_makefile dlls/dsound enable_dsound
+wine_fn_config_makefile dlls/dsound/tests enable_tests
+wine_fn_config_makefile dlls/dsquery enable_dsquery
+wine_fn_config_makefile dlls/dssenh enable_dssenh
+wine_fn_config_makefile dlls/dssenh/tests enable_tests
+wine_fn_config_makefile dlls/dsuiext enable_dsuiext
+wine_fn_config_makefile dlls/dswave enable_dswave
+wine_fn_config_makefile dlls/dswave/tests enable_tests
+wine_fn_config_makefile dlls/dwmapi enable_dwmapi
+wine_fn_config_makefile dlls/dwmapi/tests enable_tests
+wine_fn_config_makefile dlls/dwrite enable_dwrite
+wine_fn_config_makefile dlls/dwrite/tests enable_tests
+wine_fn_config_makefile dlls/dx8vb enable_dx8vb
+wine_fn_config_makefile dlls/dxcore enable_dxcore
+wine_fn_config_makefile dlls/dxcore/tests enable_tests
+wine_fn_config_makefile dlls/dxdiagn enable_dxdiagn
+wine_fn_config_makefile dlls/dxdiagn/tests enable_tests
+wine_fn_config_makefile dlls/dxgi enable_dxgi
+wine_fn_config_makefile dlls/dxgi/tests enable_tests
+wine_fn_config_makefile dlls/dxtrans enable_dxtrans
+wine_fn_config_makefile dlls/dxva2 enable_dxva2
+wine_fn_config_makefile dlls/dxva2/tests enable_tests
+wine_fn_config_makefile dlls/esent enable_esent
+wine_fn_config_makefile dlls/evr enable_evr
+wine_fn_config_makefile dlls/evr/tests enable_tests
+wine_fn_config_makefile dlls/explorerframe enable_explorerframe
+wine_fn_config_makefile dlls/explorerframe/tests enable_tests
+wine_fn_config_makefile dlls/faultrep enable_faultrep
+wine_fn_config_makefile dlls/faultrep/tests enable_tests
+wine_fn_config_makefile dlls/feclient enable_feclient
+wine_fn_config_makefile dlls/fltlib enable_fltlib
+wine_fn_config_makefile dlls/fltmgr.sys enable_fltmgr_sys
+wine_fn_config_makefile dlls/fntcache enable_fntcache
+wine_fn_config_makefile dlls/fontsub enable_fontsub
+wine_fn_config_makefile dlls/fusion enable_fusion
+wine_fn_config_makefile dlls/fusion/tests enable_tests
+wine_fn_config_makefile dlls/fwpuclnt enable_fwpuclnt
+wine_fn_config_makefile dlls/gameinput enable_gameinput
+wine_fn_config_makefile dlls/gameux enable_gameux
+wine_fn_config_makefile dlls/gameux/tests enable_tests
+wine_fn_config_makefile dlls/gamingtcui enable_gamingtcui
+wine_fn_config_makefile dlls/gdi.exe16 enable_win16
+wine_fn_config_makefile dlls/gdi32 enable_gdi32
+wine_fn_config_makefile dlls/gdi32/tests enable_tests
+wine_fn_config_makefile dlls/gdiplus enable_gdiplus
+wine_fn_config_makefile dlls/gdiplus/tests enable_tests
+wine_fn_config_makefile dlls/geolocation enable_geolocation
+wine_fn_config_makefile dlls/geolocation/tests enable_tests
+wine_fn_config_makefile dlls/glu32 enable_glu32
+wine_fn_config_makefile dlls/glu32/tests enable_tests
+wine_fn_config_makefile dlls/gphoto2.ds enable_gphoto2_ds
+wine_fn_config_makefile dlls/gpkcsp enable_gpkcsp
+wine_fn_config_makefile dlls/graphicscapture enable_graphicscapture
+wine_fn_config_makefile dlls/graphicscapture/tests enable_tests
+wine_fn_config_makefile dlls/hal enable_hal
+wine_fn_config_makefile dlls/hhctrl.ocx enable_hhctrl_ocx
+wine_fn_config_makefile dlls/hid enable_hid
+wine_fn_config_makefile dlls/hid/tests enable_tests
+wine_fn_config_makefile dlls/hidclass.sys enable_hidclass_sys
+wine_fn_config_makefile dlls/hidparse.sys enable_hidparse_sys
+wine_fn_config_makefile dlls/hlink enable_hlink
+wine_fn_config_makefile dlls/hlink/tests enable_tests
+wine_fn_config_makefile dlls/hnetcfg enable_hnetcfg
+wine_fn_config_makefile dlls/hnetcfg/tests enable_tests
+wine_fn_config_makefile dlls/hrtfapo enable_hrtfapo
+wine_fn_config_makefile dlls/http.sys enable_http_sys
+wine_fn_config_makefile dlls/httpapi enable_httpapi
+wine_fn_config_makefile dlls/httpapi/tests enable_tests
+wine_fn_config_makefile dlls/hvsimanagementapi enable_hvsimanagementapi
+wine_fn_config_makefile dlls/hvsimanagementapi/tests enable_tests
+wine_fn_config_makefile dlls/ia2comproxy enable_ia2comproxy
+wine_fn_config_makefile dlls/iccvid enable_iccvid
+wine_fn_config_makefile dlls/icmp enable_icmp
+wine_fn_config_makefile dlls/icmui enable_icmui
+wine_fn_config_makefile dlls/icmui/tests enable_tests
+wine_fn_config_makefile dlls/ieframe enable_ieframe
+wine_fn_config_makefile dlls/ieframe/tests enable_tests
+wine_fn_config_makefile dlls/ieproxy enable_ieproxy
+wine_fn_config_makefile dlls/iertutil enable_iertutil
+wine_fn_config_makefile dlls/iertutil/tests enable_tests
+wine_fn_config_makefile dlls/ifsmgr.vxd enable_win16
+wine_fn_config_makefile dlls/imaadp32.acm enable_imaadp32_acm
+wine_fn_config_makefile dlls/imagehlp enable_imagehlp
+wine_fn_config_makefile dlls/imagehlp/tests enable_tests
+wine_fn_config_makefile dlls/imm.dll16 enable_win16
+wine_fn_config_makefile dlls/imm32 enable_imm32
+wine_fn_config_makefile dlls/imm32/tests enable_tests
+wine_fn_config_makefile dlls/inetcomm enable_inetcomm
+wine_fn_config_makefile dlls/inetcomm/tests enable_tests
+wine_fn_config_makefile dlls/inetcpl.cpl enable_inetcpl_cpl
+wine_fn_config_makefile dlls/inetmib1 enable_inetmib1
+wine_fn_config_makefile dlls/inetmib1/tests enable_tests
+wine_fn_config_makefile dlls/infosoft enable_infosoft
+wine_fn_config_makefile dlls/infosoft/tests enable_tests
+wine_fn_config_makefile dlls/initpki enable_initpki
+wine_fn_config_makefile dlls/inkobj enable_inkobj
+wine_fn_config_makefile dlls/inseng enable_inseng
+wine_fn_config_makefile dlls/iphlpapi enable_iphlpapi
+wine_fn_config_makefile dlls/iphlpapi/tests enable_tests
+wine_fn_config_makefile dlls/iprop enable_iprop
+wine_fn_config_makefile dlls/ir50_32 enable_ir50_32
+wine_fn_config_makefile dlls/ir50_32/tests enable_tests
+wine_fn_config_makefile dlls/irprops.cpl enable_irprops_cpl
+wine_fn_config_makefile dlls/itircl enable_itircl
+wine_fn_config_makefile dlls/itss enable_itss
+wine_fn_config_makefile dlls/itss/tests enable_tests
+wine_fn_config_makefile dlls/joy.cpl enable_joy_cpl
+wine_fn_config_makefile dlls/jscript enable_jscript
+wine_fn_config_makefile dlls/jscript/tests enable_tests
+wine_fn_config_makefile dlls/jsproxy enable_jsproxy
+wine_fn_config_makefile dlls/jsproxy/tests enable_tests
+wine_fn_config_makefile dlls/kerberos enable_kerberos
+wine_fn_config_makefile dlls/kernel32 enable_kernel32
+wine_fn_config_makefile dlls/kernel32/tests enable_tests
+wine_fn_config_makefile dlls/kernelbase enable_kernelbase
+wine_fn_config_makefile dlls/kernelbase/tests enable_tests
+wine_fn_config_makefile dlls/keyboard.drv16 enable_win16
+wine_fn_config_makefile dlls/krnl386.exe16 enable_win16
+wine_fn_config_makefile dlls/ksecdd.sys enable_ksecdd_sys
+wine_fn_config_makefile dlls/ksproxy.ax enable_ksproxy_ax
+wine_fn_config_makefile dlls/ksuser enable_ksuser
+wine_fn_config_makefile dlls/ktmw32 enable_ktmw32
+wine_fn_config_makefile dlls/l3codeca.acm enable_l3codeca_acm
+wine_fn_config_makefile dlls/l3codecx.ax enable_l3codecx_ax
+wine_fn_config_makefile dlls/light.msstyles enable_light_msstyles
+wine_fn_config_makefile dlls/loadperf enable_loadperf
+wine_fn_config_makefile dlls/localspl enable_localspl
+wine_fn_config_makefile dlls/localspl/tests enable_tests
+wine_fn_config_makefile dlls/localui enable_localui
+wine_fn_config_makefile dlls/localui/tests enable_tests
+wine_fn_config_makefile dlls/lz32 enable_lz32
+wine_fn_config_makefile dlls/lz32/tests enable_tests
+wine_fn_config_makefile dlls/lzexpand.dll16 enable_win16
+wine_fn_config_makefile dlls/magnification enable_magnification
+wine_fn_config_makefile dlls/mapi32 enable_mapi32
+wine_fn_config_makefile dlls/mapi32/tests enable_tests
+wine_fn_config_makefile dlls/mapistub enable_mapistub
+wine_fn_config_makefile dlls/mciavi32 enable_mciavi32
+wine_fn_config_makefile dlls/mcicda enable_mcicda
+wine_fn_config_makefile dlls/mciqtz32 enable_mciqtz32
+wine_fn_config_makefile dlls/mciseq enable_mciseq
+wine_fn_config_makefile dlls/mciwave enable_mciwave
+wine_fn_config_makefile dlls/mf enable_mf
+wine_fn_config_makefile dlls/mf/tests enable_tests
+wine_fn_config_makefile dlls/mf3216 enable_mf3216
+wine_fn_config_makefile dlls/mfasfsrcsnk enable_mfasfsrcsnk
+wine_fn_config_makefile dlls/mferror enable_mferror
+wine_fn_config_makefile dlls/mfh264enc enable_mfh264enc
+wine_fn_config_makefile dlls/mfmediaengine enable_mfmediaengine
+wine_fn_config_makefile dlls/mfmediaengine/tests enable_tests
+wine_fn_config_makefile dlls/mfmp4srcsnk enable_mfmp4srcsnk
+wine_fn_config_makefile dlls/mfplat enable_mfplat
+wine_fn_config_makefile dlls/mfplat/tests enable_tests
+wine_fn_config_makefile dlls/mfplay enable_mfplay
+wine_fn_config_makefile dlls/mfplay/tests enable_tests
+wine_fn_config_makefile dlls/mfreadwrite enable_mfreadwrite
+wine_fn_config_makefile dlls/mfreadwrite/tests enable_tests
+wine_fn_config_makefile dlls/mfsrcsnk enable_mfsrcsnk
+wine_fn_config_makefile dlls/mfsrcsnk/tests enable_tests
+wine_fn_config_makefile dlls/mgmtapi enable_mgmtapi
+wine_fn_config_makefile dlls/midimap enable_midimap
+wine_fn_config_makefile dlls/mlang enable_mlang
+wine_fn_config_makefile dlls/mlang/tests enable_tests
+wine_fn_config_makefile dlls/mmcndmgr enable_mmcndmgr
+wine_fn_config_makefile dlls/mmcndmgr/tests enable_tests
+wine_fn_config_makefile dlls/mmdevapi enable_mmdevapi
+wine_fn_config_makefile dlls/mmdevapi/tests enable_tests
+wine_fn_config_makefile dlls/mmdevldr.vxd enable_win16
+wine_fn_config_makefile dlls/mmsystem.dll16 enable_win16
+wine_fn_config_makefile dlls/monodebg.vxd enable_win16
+wine_fn_config_makefile dlls/mouhid.sys enable_mouhid_sys
+wine_fn_config_makefile dlls/mountmgr.sys enable_mountmgr_sys
+wine_fn_config_makefile dlls/mouse.drv16 enable_win16
+wine_fn_config_makefile dlls/mp3dmod enable_mp3dmod
+wine_fn_config_makefile dlls/mp3dmod/tests enable_tests
+wine_fn_config_makefile dlls/mpr enable_mpr
+wine_fn_config_makefile dlls/mpr/tests enable_tests
+wine_fn_config_makefile dlls/mprapi enable_mprapi
+wine_fn_config_makefile dlls/msacm.dll16 enable_win16
+wine_fn_config_makefile dlls/msacm32.drv enable_msacm32_drv
+wine_fn_config_makefile dlls/msacm32 enable_msacm32
+wine_fn_config_makefile dlls/msacm32/tests enable_tests
+wine_fn_config_makefile dlls/msado15 enable_msado15
+wine_fn_config_makefile dlls/msado15/tests enable_tests
+wine_fn_config_makefile dlls/msadp32.acm enable_msadp32_acm
+wine_fn_config_makefile dlls/msasn1 enable_msasn1
+wine_fn_config_makefile dlls/msasn1/tests enable_tests
+wine_fn_config_makefile dlls/msauddecmft enable_msauddecmft
+wine_fn_config_makefile dlls/mscat32 enable_mscat32
+wine_fn_config_makefile dlls/mscms enable_mscms
+wine_fn_config_makefile dlls/mscms/tests enable_tests
+wine_fn_config_makefile dlls/mscoree enable_mscoree
+wine_fn_config_makefile dlls/mscoree/tests enable_tests
+wine_fn_config_makefile dlls/mscorwks enable_mscorwks
+wine_fn_config_makefile dlls/msctf enable_msctf
+wine_fn_config_makefile dlls/msctf/tests enable_tests
+wine_fn_config_makefile dlls/msctfmonitor enable_msctfmonitor
+wine_fn_config_makefile dlls/msctfp enable_msctfp
+wine_fn_config_makefile dlls/msdaps enable_msdaps
+wine_fn_config_makefile dlls/msdasql enable_msdasql
+wine_fn_config_makefile dlls/msdasql/tests enable_tests
+wine_fn_config_makefile dlls/msdelta enable_msdelta
+wine_fn_config_makefile dlls/msdmo enable_msdmo
+wine_fn_config_makefile dlls/msdmo/tests enable_tests
+wine_fn_config_makefile dlls/msdrm enable_msdrm
+wine_fn_config_makefile dlls/msftedit enable_msftedit
+wine_fn_config_makefile dlls/msftedit/tests enable_tests
+wine_fn_config_makefile dlls/msg711.acm enable_msg711_acm
+wine_fn_config_makefile dlls/msgsm32.acm enable_msgsm32_acm
+wine_fn_config_makefile dlls/mshtml.tlb enable_mshtml_tlb
+wine_fn_config_makefile dlls/mshtml enable_mshtml
+wine_fn_config_makefile dlls/mshtml/tests enable_tests
+wine_fn_config_makefile dlls/msi enable_msi
+wine_fn_config_makefile dlls/msi/tests enable_tests
+wine_fn_config_makefile dlls/msident enable_msident
+wine_fn_config_makefile dlls/msimg32 enable_msimg32
+wine_fn_config_makefile dlls/msimsg enable_msimsg
+wine_fn_config_makefile dlls/msimtf enable_msimtf
+wine_fn_config_makefile dlls/msisip enable_msisip
+wine_fn_config_makefile dlls/msisys.ocx enable_msisys_ocx
+wine_fn_config_makefile dlls/msls31 enable_msls31
+wine_fn_config_makefile dlls/msmpeg2vdec enable_msmpeg2vdec
+wine_fn_config_makefile dlls/msnet32 enable_msnet32
+wine_fn_config_makefile dlls/mspatcha enable_mspatcha
+wine_fn_config_makefile dlls/mspatcha/tests enable_tests
+wine_fn_config_makefile dlls/msports enable_msports
+wine_fn_config_makefile dlls/msrle32 enable_msrle32
+wine_fn_config_makefile dlls/msrle32/tests enable_tests
+wine_fn_config_makefile dlls/msscript.ocx enable_msscript_ocx
+wine_fn_config_makefile dlls/msscript.ocx/tests enable_tests
+wine_fn_config_makefile dlls/mssign32 enable_mssign32
+wine_fn_config_makefile dlls/mssip32 enable_mssip32
+wine_fn_config_makefile dlls/mstask enable_mstask
+wine_fn_config_makefile dlls/mstask/tests enable_tests
+wine_fn_config_makefile dlls/msttsengine enable_msttsengine
+wine_fn_config_makefile dlls/msv1_0 enable_msv1_0
+wine_fn_config_makefile dlls/msvcirt enable_msvcirt
+wine_fn_config_makefile dlls/msvcirt/tests enable_tests
+wine_fn_config_makefile dlls/msvcm80 enable_msvcm80
+wine_fn_config_makefile dlls/msvcm90 enable_msvcm90
+wine_fn_config_makefile dlls/msvcp100 enable_msvcp100
+wine_fn_config_makefile dlls/msvcp100/tests enable_tests
+wine_fn_config_makefile dlls/msvcp110 enable_msvcp110
+wine_fn_config_makefile dlls/msvcp110/tests enable_tests
+wine_fn_config_makefile dlls/msvcp120 enable_msvcp120
+wine_fn_config_makefile dlls/msvcp120/tests enable_tests
+wine_fn_config_makefile dlls/msvcp120_app enable_msvcp120_app
+wine_fn_config_makefile dlls/msvcp140 enable_msvcp140
+wine_fn_config_makefile dlls/msvcp140/tests enable_tests
+wine_fn_config_makefile dlls/msvcp140_1 enable_msvcp140_1
+wine_fn_config_makefile dlls/msvcp140_1/tests enable_tests
+wine_fn_config_makefile dlls/msvcp140_2 enable_msvcp140_2
+wine_fn_config_makefile dlls/msvcp140_2/tests enable_tests
+wine_fn_config_makefile dlls/msvcp140_atomic_wait enable_msvcp140_atomic_wait
+wine_fn_config_makefile dlls/msvcp140_atomic_wait/tests enable_tests
+wine_fn_config_makefile dlls/msvcp140_codecvt_ids enable_msvcp140_codecvt_ids
+wine_fn_config_makefile dlls/msvcp60 enable_msvcp60
+wine_fn_config_makefile dlls/msvcp60/tests enable_tests
+wine_fn_config_makefile dlls/msvcp70 enable_msvcp70
+wine_fn_config_makefile dlls/msvcp71 enable_msvcp71
+wine_fn_config_makefile dlls/msvcp80 enable_msvcp80
+wine_fn_config_makefile dlls/msvcp90 enable_msvcp90
+wine_fn_config_makefile dlls/msvcp90/tests enable_tests
+wine_fn_config_makefile dlls/msvcp_win enable_msvcp_win
+wine_fn_config_makefile dlls/msvcr100 enable_msvcr100
+wine_fn_config_makefile dlls/msvcr100/tests enable_tests
+wine_fn_config_makefile dlls/msvcr110 enable_msvcr110
+wine_fn_config_makefile dlls/msvcr110/tests enable_tests
+wine_fn_config_makefile dlls/msvcr120 enable_msvcr120
+wine_fn_config_makefile dlls/msvcr120/tests enable_tests
+wine_fn_config_makefile dlls/msvcr120_app enable_msvcr120_app
+wine_fn_config_makefile dlls/msvcr70 enable_msvcr70
+wine_fn_config_makefile dlls/msvcr70/tests enable_tests
+wine_fn_config_makefile dlls/msvcr71 enable_msvcr71
+wine_fn_config_makefile dlls/msvcr71/tests enable_tests
+wine_fn_config_makefile dlls/msvcr80 enable_msvcr80
+wine_fn_config_makefile dlls/msvcr80/tests enable_tests
+wine_fn_config_makefile dlls/msvcr90 enable_msvcr90
+wine_fn_config_makefile dlls/msvcr90/tests enable_tests
+wine_fn_config_makefile dlls/msvcrt enable_msvcrt
+wine_fn_config_makefile dlls/msvcrt/tests enable_tests
+wine_fn_config_makefile dlls/msvcrt20 enable_msvcrt20
+wine_fn_config_makefile dlls/msvcrt40 enable_msvcrt40
+wine_fn_config_makefile dlls/msvcrtd enable_msvcrtd
+wine_fn_config_makefile dlls/msvcrtd/tests enable_tests
+wine_fn_config_makefile dlls/msvfw32 enable_msvfw32
+wine_fn_config_makefile dlls/msvfw32/tests enable_tests
+wine_fn_config_makefile dlls/msvidc32 enable_msvidc32
+wine_fn_config_makefile dlls/msvideo.dll16 enable_win16
+wine_fn_config_makefile dlls/msvproc enable_msvproc
+wine_fn_config_makefile dlls/mswsock enable_mswsock
+wine_fn_config_makefile dlls/msxml enable_msxml
+wine_fn_config_makefile dlls/msxml2 enable_msxml2
+wine_fn_config_makefile dlls/msxml3 enable_msxml3
+wine_fn_config_makefile dlls/msxml3/tests enable_tests
+wine_fn_config_makefile dlls/msxml4 enable_msxml4
+wine_fn_config_makefile dlls/msxml4/tests enable_tests
+wine_fn_config_makefile dlls/msxml6 enable_msxml6
+wine_fn_config_makefile dlls/msxml6/tests enable_tests
+wine_fn_config_makefile dlls/mtxdm enable_mtxdm
+wine_fn_config_makefile dlls/ncrypt enable_ncrypt
+wine_fn_config_makefile dlls/ncrypt/tests enable_tests
+wine_fn_config_makefile dlls/nddeapi enable_nddeapi
+wine_fn_config_makefile dlls/ndis.sys enable_ndis_sys
+wine_fn_config_makefile dlls/ndis.sys/tests enable_tests
+wine_fn_config_makefile dlls/netapi32 enable_netapi32
+wine_fn_config_makefile dlls/netapi32/tests enable_tests
+wine_fn_config_makefile dlls/netcfgx enable_netcfgx
+wine_fn_config_makefile dlls/netcfgx/tests enable_tests
+wine_fn_config_makefile dlls/netio.sys enable_netio_sys
+wine_fn_config_makefile dlls/netprofm enable_netprofm
+wine_fn_config_makefile dlls/netprofm/tests enable_tests
+wine_fn_config_makefile dlls/netutils enable_netutils
+wine_fn_config_makefile dlls/newdev enable_newdev
+wine_fn_config_makefile dlls/ninput enable_ninput
+wine_fn_config_makefile dlls/ninput/tests enable_tests
+wine_fn_config_makefile dlls/normaliz enable_normaliz
+wine_fn_config_makefile dlls/npmshtml enable_npmshtml
+wine_fn_config_makefile dlls/npptools enable_npptools
+wine_fn_config_makefile dlls/nsi enable_nsi
+wine_fn_config_makefile dlls/nsi/tests enable_tests
+wine_fn_config_makefile dlls/nsiproxy.sys enable_nsiproxy_sys
+wine_fn_config_makefile dlls/ntdll enable_ntdll
+wine_fn_config_makefile dlls/ntdll/tests enable_tests
+wine_fn_config_makefile dlls/ntdsapi enable_ntdsapi
+wine_fn_config_makefile dlls/ntdsapi/tests enable_tests
+wine_fn_config_makefile dlls/ntoskrnl.exe enable_ntoskrnl_exe
+wine_fn_config_makefile dlls/ntoskrnl.exe/tests enable_tests
+wine_fn_config_makefile dlls/ntprint enable_ntprint
+wine_fn_config_makefile dlls/ntprint/tests enable_tests
+wine_fn_config_makefile dlls/objsel enable_objsel
+wine_fn_config_makefile dlls/odbc32 enable_odbc32
+wine_fn_config_makefile dlls/odbc32/tests enable_tests
+wine_fn_config_makefile dlls/odbcbcp enable_odbcbcp
+wine_fn_config_makefile dlls/odbccp32 enable_odbccp32
+wine_fn_config_makefile dlls/odbccp32/tests enable_tests
+wine_fn_config_makefile dlls/odbccu32 enable_odbccu32
+wine_fn_config_makefile dlls/ole2.dll16 enable_win16
+wine_fn_config_makefile dlls/ole2conv.dll16 enable_win16
+wine_fn_config_makefile dlls/ole2disp.dll16 enable_win16
+wine_fn_config_makefile dlls/ole2nls.dll16 enable_win16
+wine_fn_config_makefile dlls/ole2prox.dll16 enable_win16
+wine_fn_config_makefile dlls/ole2thk.dll16 enable_win16
+wine_fn_config_makefile dlls/ole32 enable_ole32
+wine_fn_config_makefile dlls/ole32/tests enable_tests
+wine_fn_config_makefile dlls/oleacc enable_oleacc
+wine_fn_config_makefile dlls/oleacc/tests enable_tests
+wine_fn_config_makefile dlls/oleaut32 enable_oleaut32
+wine_fn_config_makefile dlls/oleaut32/tests enable_tests
+wine_fn_config_makefile dlls/olecli.dll16 enable_win16
+wine_fn_config_makefile dlls/olecli32 enable_olecli32
+wine_fn_config_makefile dlls/oledb32 enable_oledb32
+wine_fn_config_makefile dlls/oledb32/tests enable_tests
+wine_fn_config_makefile dlls/oledlg enable_oledlg
+wine_fn_config_makefile dlls/oledlg/tests enable_tests
+wine_fn_config_makefile dlls/olepro32 enable_olepro32
+wine_fn_config_makefile dlls/olesvr.dll16 enable_win16
+wine_fn_config_makefile dlls/olesvr32 enable_olesvr32
+wine_fn_config_makefile dlls/olethk32 enable_olethk32
+wine_fn_config_makefile dlls/opcservices enable_opcservices
+wine_fn_config_makefile dlls/opcservices/tests enable_tests
+wine_fn_config_makefile dlls/opencl enable_opencl
+wine_fn_config_makefile dlls/opengl32 enable_opengl32
+wine_fn_config_makefile dlls/opengl32/tests enable_tests
+wine_fn_config_makefile dlls/packager enable_packager
+wine_fn_config_makefile dlls/packager/tests enable_tests
+wine_fn_config_makefile dlls/pdh enable_pdh
+wine_fn_config_makefile dlls/pdh/tests enable_tests
+wine_fn_config_makefile dlls/photometadatahandler enable_photometadatahandler
+wine_fn_config_makefile dlls/pidgen enable_pidgen
+wine_fn_config_makefile dlls/powrprof enable_powrprof
+wine_fn_config_makefile dlls/printui enable_printui
+wine_fn_config_makefile dlls/prntvpt enable_prntvpt
+wine_fn_config_makefile dlls/prntvpt/tests enable_tests
+wine_fn_config_makefile dlls/profapi enable_profapi
+wine_fn_config_makefile dlls/propsys enable_propsys
+wine_fn_config_makefile dlls/propsys/tests enable_tests
+wine_fn_config_makefile dlls/psapi enable_psapi
+wine_fn_config_makefile dlls/psapi/tests enable_tests
+wine_fn_config_makefile dlls/pstorec enable_pstorec
+wine_fn_config_makefile dlls/pstorec/tests enable_tests
+wine_fn_config_makefile dlls/pwrshplugin enable_pwrshplugin
+wine_fn_config_makefile dlls/qasf enable_qasf
+wine_fn_config_makefile dlls/qasf/tests enable_tests
+wine_fn_config_makefile dlls/qcap enable_qcap
+wine_fn_config_makefile dlls/qcap/tests enable_tests
+wine_fn_config_makefile dlls/qdvd enable_qdvd
+wine_fn_config_makefile dlls/qdvd/tests enable_tests
+wine_fn_config_makefile dlls/qedit enable_qedit
+wine_fn_config_makefile dlls/qedit/tests enable_tests
+wine_fn_config_makefile dlls/qmgr enable_qmgr
+wine_fn_config_makefile dlls/qmgr/tests enable_tests
+wine_fn_config_makefile dlls/qmgrprxy enable_qmgrprxy
+wine_fn_config_makefile dlls/quartz enable_quartz
+wine_fn_config_makefile dlls/quartz/tests enable_tests
+wine_fn_config_makefile dlls/query enable_query
+wine_fn_config_makefile dlls/qwave enable_qwave
+wine_fn_config_makefile dlls/qwave/tests enable_tests
+wine_fn_config_makefile dlls/rasapi16.dll16 enable_win16
+wine_fn_config_makefile dlls/rasapi32 enable_rasapi32
+wine_fn_config_makefile dlls/rasapi32/tests enable_tests
+wine_fn_config_makefile dlls/rasdlg enable_rasdlg
+wine_fn_config_makefile dlls/regapi enable_regapi
+wine_fn_config_makefile dlls/resampledmo enable_resampledmo
+wine_fn_config_makefile dlls/resutils enable_resutils
+wine_fn_config_makefile dlls/riched20 enable_riched20
+wine_fn_config_makefile dlls/riched20/tests enable_tests
+wine_fn_config_makefile dlls/riched32 enable_riched32
+wine_fn_config_makefile dlls/riched32/tests enable_tests
+wine_fn_config_makefile dlls/rometadata enable_rometadata
+wine_fn_config_makefile dlls/rometadata/tests enable_tests
+wine_fn_config_makefile dlls/rpcrt4 enable_rpcrt4
+wine_fn_config_makefile dlls/rpcrt4/tests enable_tests
+wine_fn_config_makefile dlls/rsabase enable_rsabase
+wine_fn_config_makefile dlls/rsaenh enable_rsaenh
+wine_fn_config_makefile dlls/rsaenh/tests enable_tests
+wine_fn_config_makefile dlls/rstrtmgr enable_rstrtmgr
+wine_fn_config_makefile dlls/rtutils enable_rtutils
+wine_fn_config_makefile dlls/rtworkq enable_rtworkq
+wine_fn_config_makefile dlls/rtworkq/tests enable_tests
+wine_fn_config_makefile dlls/samlib enable_samlib
+wine_fn_config_makefile dlls/sane.ds enable_sane_ds
+wine_fn_config_makefile dlls/sapi enable_sapi
+wine_fn_config_makefile dlls/sapi/tests enable_tests
+wine_fn_config_makefile dlls/sas enable_sas
+wine_fn_config_makefile dlls/scarddlg enable_scarddlg
+wine_fn_config_makefile dlls/scardsvr enable_scardsvr
+wine_fn_config_makefile dlls/sccbase enable_sccbase
+wine_fn_config_makefile dlls/schannel enable_schannel
+wine_fn_config_makefile dlls/schannel/tests enable_tests
+wine_fn_config_makefile dlls/schedsvc enable_schedsvc
+wine_fn_config_makefile dlls/schedsvc/tests enable_tests
+wine_fn_config_makefile dlls/scrobj enable_scrobj
+wine_fn_config_makefile dlls/scrobj/tests enable_tests
+wine_fn_config_makefile dlls/scrrun enable_scrrun
+wine_fn_config_makefile dlls/scrrun/tests enable_tests
+wine_fn_config_makefile dlls/scsiport.sys enable_scsiport_sys
+wine_fn_config_makefile dlls/sechost enable_sechost
+wine_fn_config_makefile dlls/secur32 enable_secur32
+wine_fn_config_makefile dlls/secur32/tests enable_tests
+wine_fn_config_makefile dlls/security enable_security
+wine_fn_config_makefile dlls/sensapi enable_sensapi
+wine_fn_config_makefile dlls/serialui enable_serialui
+wine_fn_config_makefile dlls/serialui/tests enable_tests
+wine_fn_config_makefile dlls/setupapi enable_setupapi
+wine_fn_config_makefile dlls/setupapi/tests enable_tests
+wine_fn_config_makefile dlls/setupx.dll16 enable_win16
+wine_fn_config_makefile dlls/sfc enable_sfc
+wine_fn_config_makefile dlls/sfc_os enable_sfc_os
+wine_fn_config_makefile dlls/shcore enable_shcore
+wine_fn_config_makefile dlls/shcore/tests enable_tests
+wine_fn_config_makefile dlls/shdoclc enable_shdoclc
+wine_fn_config_makefile dlls/shdocvw enable_shdocvw
+wine_fn_config_makefile dlls/shdocvw/tests enable_tests
+wine_fn_config_makefile dlls/shell.dll16 enable_win16
+wine_fn_config_makefile dlls/shell32 enable_shell32
+wine_fn_config_makefile dlls/shell32/tests enable_tests
+wine_fn_config_makefile dlls/shfolder enable_shfolder
+wine_fn_config_makefile dlls/shlwapi enable_shlwapi
+wine_fn_config_makefile dlls/shlwapi/tests enable_tests
+wine_fn_config_makefile dlls/slbcsp enable_slbcsp
+wine_fn_config_makefile dlls/slc enable_slc
+wine_fn_config_makefile dlls/slc/tests enable_tests
+wine_fn_config_makefile dlls/snmpapi enable_snmpapi
+wine_fn_config_makefile dlls/snmpapi/tests enable_tests
+wine_fn_config_makefile dlls/softpub enable_softpub
+wine_fn_config_makefile dlls/sound.drv16 enable_win16
+wine_fn_config_makefile dlls/spoolss enable_spoolss
+wine_fn_config_makefile dlls/spoolss/tests enable_tests
+wine_fn_config_makefile dlls/sppc enable_sppc
+wine_fn_config_makefile dlls/srclient enable_srclient
+wine_fn_config_makefile dlls/srvcli enable_srvcli
+wine_fn_config_makefile dlls/srvsvc enable_srvsvc
+wine_fn_config_makefile dlls/sspicli enable_sspicli
+wine_fn_config_makefile dlls/stdole2.tlb enable_stdole2_tlb
+wine_fn_config_makefile dlls/stdole32.tlb enable_stdole32_tlb
+wine_fn_config_makefile dlls/sti enable_sti
+wine_fn_config_makefile dlls/sti/tests enable_tests
+wine_fn_config_makefile dlls/storage.dll16 enable_win16
+wine_fn_config_makefile dlls/stress.dll16 enable_win16
+wine_fn_config_makefile dlls/strmdll enable_strmdll
+wine_fn_config_makefile dlls/svrapi enable_svrapi
+wine_fn_config_makefile dlls/sxs enable_sxs
+wine_fn_config_makefile dlls/sxs/tests enable_tests
+wine_fn_config_makefile dlls/system.drv16 enable_win16
+wine_fn_config_makefile dlls/t2embed enable_t2embed
+wine_fn_config_makefile dlls/t2embed/tests enable_tests
+wine_fn_config_makefile dlls/tapi32 enable_tapi32
+wine_fn_config_makefile dlls/tapi32/tests enable_tests
+wine_fn_config_makefile dlls/taskschd enable_taskschd
+wine_fn_config_makefile dlls/taskschd/tests enable_tests
+wine_fn_config_makefile dlls/tbs enable_tbs
+wine_fn_config_makefile dlls/tdh enable_tdh
+wine_fn_config_makefile dlls/tdi.sys enable_tdi_sys
+wine_fn_config_makefile dlls/threadpoolwinrt enable_threadpoolwinrt
+wine_fn_config_makefile dlls/threadpoolwinrt/tests enable_tests
+wine_fn_config_makefile dlls/toolhelp.dll16 enable_win16
+wine_fn_config_makefile dlls/traffic enable_traffic
+wine_fn_config_makefile dlls/twain.dll16 enable_win16
+wine_fn_config_makefile dlls/twain_32 enable_twain_32
+wine_fn_config_makefile dlls/twain_32/tests enable_tests
+wine_fn_config_makefile dlls/twinapi.appcore enable_twinapi_appcore
+wine_fn_config_makefile dlls/twinapi.appcore/tests enable_tests
+wine_fn_config_makefile dlls/typelib.dll16 enable_win16
+wine_fn_config_makefile dlls/tzres enable_tzres
+wine_fn_config_makefile dlls/ucrtbase enable_ucrtbase
+wine_fn_config_makefile dlls/ucrtbase/tests enable_tests
+wine_fn_config_makefile dlls/uianimation enable_uianimation
+wine_fn_config_makefile dlls/uianimation/tests enable_tests
+wine_fn_config_makefile dlls/uiautomationcore enable_uiautomationcore
+wine_fn_config_makefile dlls/uiautomationcore/tests enable_tests
+wine_fn_config_makefile dlls/uiribbon enable_uiribbon
+wine_fn_config_makefile dlls/unicows enable_unicows
+wine_fn_config_makefile dlls/updspapi enable_updspapi
+wine_fn_config_makefile dlls/url enable_url
+wine_fn_config_makefile dlls/urlmon enable_urlmon
+wine_fn_config_makefile dlls/urlmon/tests enable_tests
+wine_fn_config_makefile dlls/usbd.sys enable_usbd_sys
+wine_fn_config_makefile dlls/user.exe16 enable_win16
+wine_fn_config_makefile dlls/user32 enable_user32
+wine_fn_config_makefile dlls/user32/tests enable_tests
+wine_fn_config_makefile dlls/userenv enable_userenv
+wine_fn_config_makefile dlls/userenv/tests enable_tests
+wine_fn_config_makefile dlls/usp10 enable_usp10
+wine_fn_config_makefile dlls/usp10/tests enable_tests
+wine_fn_config_makefile dlls/utildll enable_utildll
+wine_fn_config_makefile dlls/uxtheme enable_uxtheme
+wine_fn_config_makefile dlls/uxtheme/tests enable_tests
+wine_fn_config_makefile dlls/vbscript enable_vbscript
+wine_fn_config_makefile dlls/vbscript/tests enable_tests
+wine_fn_config_makefile dlls/vccorlib140 enable_vccorlib140
+wine_fn_config_makefile dlls/vccorlib140/tests enable_tests
+wine_fn_config_makefile dlls/vcomp enable_vcomp
+wine_fn_config_makefile dlls/vcomp/tests enable_tests
+wine_fn_config_makefile dlls/vcomp100 enable_vcomp100
+wine_fn_config_makefile dlls/vcomp110 enable_vcomp110
+wine_fn_config_makefile dlls/vcomp110/tests enable_tests
+wine_fn_config_makefile dlls/vcomp120 enable_vcomp120
+wine_fn_config_makefile dlls/vcomp140 enable_vcomp140
+wine_fn_config_makefile dlls/vcomp90 enable_vcomp90
+wine_fn_config_makefile dlls/vcruntime140 enable_vcruntime140
+wine_fn_config_makefile dlls/vcruntime140_1 enable_vcruntime140_1
+wine_fn_config_makefile dlls/vdhcp.vxd enable_win16
+wine_fn_config_makefile dlls/vdmdbg enable_vdmdbg
+wine_fn_config_makefile dlls/ver.dll16 enable_win16
+wine_fn_config_makefile dlls/version enable_version
+wine_fn_config_makefile dlls/version/tests enable_tests
+wine_fn_config_makefile dlls/vga enable_vga
+wine_fn_config_makefile dlls/virtdisk enable_virtdisk
+wine_fn_config_makefile dlls/virtdisk/tests enable_tests
+wine_fn_config_makefile dlls/vmm.vxd enable_win16
+wine_fn_config_makefile dlls/vnbt.vxd enable_win16
+wine_fn_config_makefile dlls/vnetbios.vxd enable_win16
+wine_fn_config_makefile dlls/vssapi enable_vssapi
+wine_fn_config_makefile dlls/vtdapi.vxd enable_win16
+wine_fn_config_makefile dlls/vulkan-1 enable_vulkan_1
+wine_fn_config_makefile dlls/vulkan-1/tests enable_tests
+wine_fn_config_makefile dlls/vwin32.vxd enable_win16
+wine_fn_config_makefile dlls/w32skrnl enable_w32skrnl
+wine_fn_config_makefile dlls/w32sys.dll16 enable_win16
+wine_fn_config_makefile dlls/wbemdisp enable_wbemdisp
+wine_fn_config_makefile dlls/wbemdisp/tests enable_tests
+wine_fn_config_makefile dlls/wbemprox enable_wbemprox
+wine_fn_config_makefile dlls/wbemprox/tests enable_tests
+wine_fn_config_makefile dlls/wdscore enable_wdscore
+wine_fn_config_makefile dlls/webservices enable_webservices
+wine_fn_config_makefile dlls/webservices/tests enable_tests
+wine_fn_config_makefile dlls/websocket enable_websocket
+wine_fn_config_makefile dlls/wer enable_wer
+wine_fn_config_makefile dlls/wer/tests enable_tests
+wine_fn_config_makefile dlls/wevtapi enable_wevtapi
+wine_fn_config_makefile dlls/wevtapi/tests enable_tests
+wine_fn_config_makefile dlls/wevtsvc enable_wevtsvc
+wine_fn_config_makefile dlls/wiaservc enable_wiaservc
+wine_fn_config_makefile dlls/wiaservc/tests enable_tests
+wine_fn_config_makefile dlls/wimgapi enable_wimgapi
+wine_fn_config_makefile dlls/win32s16.dll16 enable_win16
+wine_fn_config_makefile dlls/win32u enable_win32u
+wine_fn_config_makefile dlls/win32u/tests enable_tests
+wine_fn_config_makefile dlls/win87em.dll16 enable_win16
+wine_fn_config_makefile dlls/winaspi.dll16 enable_win16
+wine_fn_config_makefile dlls/winbio enable_winbio
+wine_fn_config_makefile dlls/windebug.dll16 enable_win16
+wine_fn_config_makefile dlls/windows.applicationmodel enable_windows_applicationmodel
+wine_fn_config_makefile dlls/windows.applicationmodel/tests enable_tests
+wine_fn_config_makefile dlls/windows.devices.bluetooth enable_windows_devices_bluetooth
+wine_fn_config_makefile dlls/windows.devices.bluetooth/tests enable_tests
+wine_fn_config_makefile dlls/windows.devices.enumeration enable_windows_devices_enumeration
+wine_fn_config_makefile dlls/windows.devices.enumeration/tests enable_tests
+wine_fn_config_makefile dlls/windows.devices.usb enable_windows_devices_usb
+wine_fn_config_makefile dlls/windows.devices.usb/tests enable_tests
+wine_fn_config_makefile dlls/windows.gaming.input enable_windows_gaming_input
+wine_fn_config_makefile dlls/windows.gaming.input/tests enable_tests
+wine_fn_config_makefile dlls/windows.gaming.ui.gamebar enable_windows_gaming_ui_gamebar
+wine_fn_config_makefile dlls/windows.gaming.ui.gamebar/tests enable_tests
+wine_fn_config_makefile dlls/windows.globalization enable_windows_globalization
+wine_fn_config_makefile dlls/windows.globalization/tests enable_tests
+wine_fn_config_makefile dlls/windows.media.devices enable_windows_media_devices
+wine_fn_config_makefile dlls/windows.media.devices/tests enable_tests
+wine_fn_config_makefile dlls/windows.media.mediacontrol enable_windows_media_mediacontrol
+wine_fn_config_makefile dlls/windows.media.mediacontrol/tests enable_tests
+wine_fn_config_makefile dlls/windows.media.playback.backgroundmediaplayer enable_windows_media_playback_backgroundmediaplayer
+wine_fn_config_makefile dlls/windows.media.playback.backgroundmediaplayer/tests enable_tests
+wine_fn_config_makefile dlls/windows.media.playback.mediaplayer enable_windows_media_playback_mediaplayer
+wine_fn_config_makefile dlls/windows.media.playback.mediaplayer/tests enable_tests
+wine_fn_config_makefile dlls/windows.media.speech enable_windows_media_speech
+wine_fn_config_makefile dlls/windows.media.speech/tests enable_tests
+wine_fn_config_makefile dlls/windows.media enable_windows_media
+wine_fn_config_makefile dlls/windows.media/tests enable_tests
+wine_fn_config_makefile dlls/windows.networking.connectivity enable_windows_networking_connectivity
+wine_fn_config_makefile dlls/windows.networking.connectivity/tests enable_tests
+wine_fn_config_makefile dlls/windows.networking.hostname enable_windows_networking_hostname
+wine_fn_config_makefile dlls/windows.networking.hostname/tests enable_tests
+wine_fn_config_makefile dlls/windows.networking enable_windows_networking
+wine_fn_config_makefile dlls/windows.perception.stub enable_windows_perception_stub
+wine_fn_config_makefile dlls/windows.perception.stub/tests enable_tests
+wine_fn_config_makefile dlls/windows.security.authentication.onlineid enable_windows_security_authentication_onlineid
+wine_fn_config_makefile dlls/windows.security.authentication.onlineid/tests enable_tests
+wine_fn_config_makefile dlls/windows.security.credentials.ui.userconsentverifier enable_windows_security_credentials_ui_userconsentverifier
+wine_fn_config_makefile dlls/windows.security.credentials.ui.userconsentverifier/tests enable_tests
+wine_fn_config_makefile dlls/windows.storage.applicationdata enable_windows_storage_applicationdata
+wine_fn_config_makefile dlls/windows.storage.applicationdata/tests enable_tests
+wine_fn_config_makefile dlls/windows.storage enable_windows_storage
+wine_fn_config_makefile dlls/windows.storage/tests enable_tests
+wine_fn_config_makefile dlls/windows.system.profile.systemid enable_windows_system_profile_systemid
+wine_fn_config_makefile dlls/windows.system.profile.systemid/tests enable_tests
+wine_fn_config_makefile dlls/windows.system.profile.systemmanufacturers enable_windows_system_profile_systemmanufacturers
+wine_fn_config_makefile dlls/windows.system.profile.systemmanufacturers/tests enable_tests
+wine_fn_config_makefile dlls/windows.ui.xaml enable_windows_ui_xaml
+wine_fn_config_makefile dlls/windows.ui.xaml/tests enable_tests
+wine_fn_config_makefile dlls/windows.ui enable_windows_ui
+wine_fn_config_makefile dlls/windows.ui/tests enable_tests
+wine_fn_config_makefile dlls/windows.web enable_windows_web
+wine_fn_config_makefile dlls/windows.web/tests enable_tests
+wine_fn_config_makefile dlls/windowscodecs enable_windowscodecs
+wine_fn_config_makefile dlls/windowscodecs/tests enable_tests
+wine_fn_config_makefile dlls/windowscodecsext enable_windowscodecsext
+wine_fn_config_makefile dlls/windowscodecsext/tests enable_tests
+wine_fn_config_makefile dlls/winealsa.drv enable_winealsa_drv
+wine_fn_config_makefile dlls/wineandroid.drv enable_wineandroid_drv
+wine_fn_config_makefile dlls/winebth.sys enable_winebth_sys
+wine_fn_config_makefile dlls/winebus.sys enable_winebus_sys
+wine_fn_config_makefile dlls/winecoreaudio.drv enable_winecoreaudio_drv
+wine_fn_config_makefile dlls/winecrt0 enable_winecrt0
+wine_fn_config_makefile dlls/wined3d enable_wined3d
+wine_fn_config_makefile dlls/winedmo enable_winedmo
+wine_fn_config_makefile dlls/winegstreamer enable_winegstreamer
+wine_fn_config_makefile dlls/winehid.sys enable_winehid_sys
+wine_fn_config_makefile dlls/winemac.drv enable_winemac_drv
+wine_fn_config_makefile dlls/winemapi enable_winemapi
+wine_fn_config_makefile dlls/wineoss.drv enable_wineoss_drv
+wine_fn_config_makefile dlls/wineps.drv enable_wineps_drv
+wine_fn_config_makefile dlls/wineps16.drv16 enable_win16
+wine_fn_config_makefile dlls/winepulse.drv enable_winepulse_drv
+wine_fn_config_makefile dlls/wineusb.sys enable_wineusb_sys
+wine_fn_config_makefile dlls/winevulkan enable_winevulkan
+wine_fn_config_makefile dlls/winewayland.drv enable_winewayland_drv
+wine_fn_config_makefile dlls/winex11.drv enable_winex11_drv
+wine_fn_config_makefile dlls/winexinput.sys enable_winexinput_sys
+wine_fn_config_makefile dlls/wing.dll16 enable_win16
+wine_fn_config_makefile dlls/wing32 enable_wing32
+wine_fn_config_makefile dlls/wing32/tests enable_tests
+wine_fn_config_makefile dlls/winhttp enable_winhttp
+wine_fn_config_makefile dlls/winhttp/tests enable_tests
+wine_fn_config_makefile dlls/wininet enable_wininet
+wine_fn_config_makefile dlls/wininet/tests enable_tests
+wine_fn_config_makefile dlls/winmm enable_winmm
+wine_fn_config_makefile dlls/winmm/tests enable_tests
+wine_fn_config_makefile dlls/winnls.dll16 enable_win16
+wine_fn_config_makefile dlls/winnls32 enable_winnls32
+wine_fn_config_makefile dlls/winprint enable_winprint
+wine_fn_config_makefile dlls/winscard enable_winscard
+wine_fn_config_makefile dlls/winscard/tests enable_tests
+wine_fn_config_makefile dlls/winsock.dll16 enable_win16
+wine_fn_config_makefile dlls/winspool.drv enable_winspool_drv
+wine_fn_config_makefile dlls/winspool.drv/tests enable_tests
+wine_fn_config_makefile dlls/winsta enable_winsta
+wine_fn_config_makefile dlls/wintab.dll16 enable_win16
+wine_fn_config_makefile dlls/wintab32 enable_wintab32
+wine_fn_config_makefile dlls/wintab32/tests enable_tests
+wine_fn_config_makefile dlls/wintrust enable_wintrust
+wine_fn_config_makefile dlls/wintrust/tests enable_tests
+wine_fn_config_makefile dlls/wintypes enable_wintypes
+wine_fn_config_makefile dlls/wintypes/tests enable_tests
+wine_fn_config_makefile dlls/winusb enable_winusb
+wine_fn_config_makefile dlls/wlanapi enable_wlanapi
+wine_fn_config_makefile dlls/wlanapi/tests enable_tests
+wine_fn_config_makefile dlls/wlanui enable_wlanui
+wine_fn_config_makefile dlls/wldap32 enable_wldap32
+wine_fn_config_makefile dlls/wldap32/tests enable_tests
+wine_fn_config_makefile dlls/wldp enable_wldp
+wine_fn_config_makefile dlls/wldp/tests enable_tests
+wine_fn_config_makefile dlls/wmadmod enable_wmadmod
+wine_fn_config_makefile dlls/wmasf enable_wmasf
+wine_fn_config_makefile dlls/wmi enable_wmi
+wine_fn_config_makefile dlls/wmilib.sys enable_wmilib_sys
+wine_fn_config_makefile dlls/wmiutils enable_wmiutils
+wine_fn_config_makefile dlls/wmiutils/tests enable_tests
+wine_fn_config_makefile dlls/wmp enable_wmp
+wine_fn_config_makefile dlls/wmp/tests enable_tests
+wine_fn_config_makefile dlls/wmphoto enable_wmphoto
+wine_fn_config_makefile dlls/wmvcore enable_wmvcore
+wine_fn_config_makefile dlls/wmvcore/tests enable_tests
+wine_fn_config_makefile dlls/wmvdecod enable_wmvdecod
+wine_fn_config_makefile dlls/wnaspi32 enable_wnaspi32
+wine_fn_config_makefile dlls/wofutil enable_wofutil
+wine_fn_config_makefile dlls/wow32 enable_wow32
+wine_fn_config_makefile dlls/wow64 enable_wow64
+wine_fn_config_makefile dlls/wow64cpu enable_wow64cpu
+wine_fn_config_makefile dlls/wow64win enable_wow64win
+wine_fn_config_makefile dlls/wpc enable_wpc
+wine_fn_config_makefile dlls/wpc/tests enable_tests
+wine_fn_config_makefile dlls/wpcap enable_wpcap
+wine_fn_config_makefile dlls/wpcap/tests enable_tests
+wine_fn_config_makefile dlls/ws2_32 enable_ws2_32
+wine_fn_config_makefile dlls/ws2_32/tests enable_tests
+wine_fn_config_makefile dlls/wsdapi enable_wsdapi
+wine_fn_config_makefile dlls/wsdapi/tests enable_tests
+wine_fn_config_makefile dlls/wshom.ocx enable_wshom_ocx
+wine_fn_config_makefile dlls/wshom.ocx/tests enable_tests
+wine_fn_config_makefile dlls/wsnmp32 enable_wsnmp32
+wine_fn_config_makefile dlls/wsnmp32/tests enable_tests
+wine_fn_config_makefile dlls/wsock32 enable_wsock32
+wine_fn_config_makefile dlls/wtsapi32 enable_wtsapi32
+wine_fn_config_makefile dlls/wtsapi32/tests enable_tests
+wine_fn_config_makefile dlls/wuapi enable_wuapi
+wine_fn_config_makefile dlls/wuaueng enable_wuaueng
+wine_fn_config_makefile dlls/x3daudio1_0 enable_x3daudio1_0
+wine_fn_config_makefile dlls/x3daudio1_1 enable_x3daudio1_1
+wine_fn_config_makefile dlls/x3daudio1_2 enable_x3daudio1_2
+wine_fn_config_makefile dlls/x3daudio1_3 enable_x3daudio1_3
+wine_fn_config_makefile dlls/x3daudio1_4 enable_x3daudio1_4
+wine_fn_config_makefile dlls/x3daudio1_5 enable_x3daudio1_5
+wine_fn_config_makefile dlls/x3daudio1_6 enable_x3daudio1_6
+wine_fn_config_makefile dlls/x3daudio1_7 enable_x3daudio1_7
+wine_fn_config_makefile dlls/xactengine2_0 enable_xactengine2_0
+wine_fn_config_makefile dlls/xactengine2_4 enable_xactengine2_4
+wine_fn_config_makefile dlls/xactengine2_7 enable_xactengine2_7
+wine_fn_config_makefile dlls/xactengine2_9 enable_xactengine2_9
+wine_fn_config_makefile dlls/xactengine3_0 enable_xactengine3_0
+wine_fn_config_makefile dlls/xactengine3_1 enable_xactengine3_1
+wine_fn_config_makefile dlls/xactengine3_2 enable_xactengine3_2
+wine_fn_config_makefile dlls/xactengine3_3 enable_xactengine3_3
+wine_fn_config_makefile dlls/xactengine3_4 enable_xactengine3_4
+wine_fn_config_makefile dlls/xactengine3_5 enable_xactengine3_5
+wine_fn_config_makefile dlls/xactengine3_6 enable_xactengine3_6
+wine_fn_config_makefile dlls/xactengine3_7 enable_xactengine3_7
+wine_fn_config_makefile dlls/xactengine3_7/tests enable_tests
+wine_fn_config_makefile dlls/xapofx1_1 enable_xapofx1_1
+wine_fn_config_makefile dlls/xapofx1_2 enable_xapofx1_2
+wine_fn_config_makefile dlls/xapofx1_3 enable_xapofx1_3
+wine_fn_config_makefile dlls/xapofx1_4 enable_xapofx1_4
+wine_fn_config_makefile dlls/xapofx1_5 enable_xapofx1_5
+wine_fn_config_makefile dlls/xaudio2_0 enable_xaudio2_0
+wine_fn_config_makefile dlls/xaudio2_1 enable_xaudio2_1
+wine_fn_config_makefile dlls/xaudio2_2 enable_xaudio2_2
+wine_fn_config_makefile dlls/xaudio2_3 enable_xaudio2_3
+wine_fn_config_makefile dlls/xaudio2_4 enable_xaudio2_4
+wine_fn_config_makefile dlls/xaudio2_5 enable_xaudio2_5
+wine_fn_config_makefile dlls/xaudio2_6 enable_xaudio2_6
+wine_fn_config_makefile dlls/xaudio2_7 enable_xaudio2_7
+wine_fn_config_makefile dlls/xaudio2_7/tests enable_tests
+wine_fn_config_makefile dlls/xaudio2_8 enable_xaudio2_8
+wine_fn_config_makefile dlls/xaudio2_8/tests enable_tests
+wine_fn_config_makefile dlls/xaudio2_9 enable_xaudio2_9
+wine_fn_config_makefile dlls/xinput1_1 enable_xinput1_1
+wine_fn_config_makefile dlls/xinput1_2 enable_xinput1_2
+wine_fn_config_makefile dlls/xinput1_3 enable_xinput1_3
+wine_fn_config_makefile dlls/xinput1_3/tests enable_tests
+wine_fn_config_makefile dlls/xinput1_4 enable_xinput1_4
+wine_fn_config_makefile dlls/xinput9_1_0 enable_xinput9_1_0
+wine_fn_config_makefile dlls/xinputuap enable_xinputuap
+wine_fn_config_makefile dlls/xmllite enable_xmllite
+wine_fn_config_makefile dlls/xmllite/tests enable_tests
+wine_fn_config_makefile dlls/xolehlp enable_xolehlp
+wine_fn_config_makefile dlls/xpsprint enable_xpsprint
+wine_fn_config_makefile dlls/xpssvcs enable_xpssvcs
+wine_fn_config_makefile dlls/xtajit64 enable_xtajit64
+wine_fn_config_makefile fonts enable_fonts
+wine_fn_config_makefile include enable_include
+wine_fn_config_makefile libs/adsiid enable_adsiid
+wine_fn_config_makefile libs/capstone enable_capstone
+wine_fn_config_makefile libs/compiler-rt enable_compiler_rt
+wine_fn_config_makefile libs/dmoguids enable_dmoguids
+wine_fn_config_makefile libs/dxerr8 enable_dxerr8
+wine_fn_config_makefile libs/dxerr9 enable_dxerr9
+wine_fn_config_makefile libs/dxguid enable_dxguid
+wine_fn_config_makefile libs/faudio enable_faudio
+wine_fn_config_makefile libs/fluidsynth enable_fluidsynth
+wine_fn_config_makefile libs/gsm enable_gsm
+wine_fn_config_makefile libs/jpeg enable_jpeg
+wine_fn_config_makefile libs/jxr enable_jxr
+wine_fn_config_makefile libs/lcms2 enable_lcms2
+wine_fn_config_makefile libs/ldap enable_ldap
+wine_fn_config_makefile libs/mfuuid enable_mfuuid
+wine_fn_config_makefile libs/mpg123 enable_mpg123
+wine_fn_config_makefile libs/musl enable_musl
+wine_fn_config_makefile libs/png enable_png
+wine_fn_config_makefile libs/strmbase enable_strmbase
+wine_fn_config_makefile libs/strmiids enable_strmiids
+wine_fn_config_makefile libs/tiff enable_tiff
+wine_fn_config_makefile libs/tomcrypt enable_tomcrypt
+wine_fn_config_makefile libs/uuid enable_uuid
+wine_fn_config_makefile libs/vkd3d enable_vkd3d
+wine_fn_config_makefile libs/wbemuuid enable_wbemuuid
+wine_fn_config_makefile libs/wmcodecdspuuid enable_wmcodecdspuuid
+wine_fn_config_makefile libs/xml2 enable_xml2
+wine_fn_config_makefile libs/xslt enable_xslt
+wine_fn_config_makefile libs/zlib enable_zlib
+wine_fn_config_makefile loader enable_loader
+wine_fn_config_makefile nls enable_nls
+wine_fn_config_makefile po enable_po
+wine_fn_config_makefile programs/arp enable_arp
+wine_fn_config_makefile programs/aspnet_regiis enable_aspnet_regiis
+wine_fn_config_makefile programs/attrib enable_attrib
+wine_fn_config_makefile programs/cabarc enable_cabarc
+wine_fn_config_makefile programs/cacls enable_cacls
+wine_fn_config_makefile programs/certutil enable_certutil
+wine_fn_config_makefile programs/chcp.com enable_chcp_com
+wine_fn_config_makefile programs/clock enable_clock
+wine_fn_config_makefile programs/cmd enable_cmd
+wine_fn_config_makefile programs/cmd/tests enable_tests
+wine_fn_config_makefile programs/conhost enable_conhost
+wine_fn_config_makefile programs/conhost/tests enable_tests
+wine_fn_config_makefile programs/control enable_control
+wine_fn_config_makefile programs/cscript enable_cscript
+wine_fn_config_makefile programs/dism enable_dism
+wine_fn_config_makefile programs/dllhost enable_dllhost
+wine_fn_config_makefile programs/dplaysvr enable_dplaysvr
+wine_fn_config_makefile programs/dpnsvr enable_dpnsvr
+wine_fn_config_makefile programs/dpvsetup enable_dpvsetup
+wine_fn_config_makefile programs/dxdiag enable_dxdiag
+wine_fn_config_makefile programs/eject enable_eject
+wine_fn_config_makefile programs/expand enable_expand
+wine_fn_config_makefile programs/explorer enable_explorer
+wine_fn_config_makefile programs/explorer/tests enable_tests
+wine_fn_config_makefile programs/extrac32 enable_extrac32
+wine_fn_config_makefile programs/fc enable_fc
+wine_fn_config_makefile programs/fc/tests enable_tests
+wine_fn_config_makefile programs/find enable_find
+wine_fn_config_makefile programs/find/tests enable_tests
+wine_fn_config_makefile programs/findstr enable_findstr
+wine_fn_config_makefile programs/findstr/tests enable_tests
+wine_fn_config_makefile programs/fsutil enable_fsutil
+wine_fn_config_makefile programs/fsutil/tests enable_tests
+wine_fn_config_makefile programs/hh enable_hh
+wine_fn_config_makefile programs/hostname enable_hostname
+wine_fn_config_makefile programs/icacls enable_icacls
+wine_fn_config_makefile programs/icinfo enable_icinfo
+wine_fn_config_makefile programs/iexplore enable_iexplore
+wine_fn_config_makefile programs/ipconfig enable_ipconfig
+wine_fn_config_makefile programs/klist enable_klist
+wine_fn_config_makefile programs/lodctr enable_lodctr
+wine_fn_config_makefile programs/makecab enable_makecab
+wine_fn_config_makefile programs/mofcomp enable_mofcomp
+wine_fn_config_makefile programs/mshta enable_mshta
+wine_fn_config_makefile programs/msidb enable_msidb
+wine_fn_config_makefile programs/msiexec enable_msiexec
+wine_fn_config_makefile programs/msinfo32 enable_msinfo32
+wine_fn_config_makefile programs/net enable_net
+wine_fn_config_makefile programs/net/tests enable_tests
+wine_fn_config_makefile programs/netsh enable_netsh
+wine_fn_config_makefile programs/netstat enable_netstat
+wine_fn_config_makefile programs/ngen enable_ngen
+wine_fn_config_makefile programs/notepad enable_notepad
+wine_fn_config_makefile programs/oleview enable_oleview
+wine_fn_config_makefile programs/ping enable_ping
+wine_fn_config_makefile programs/plugplay enable_plugplay
+wine_fn_config_makefile programs/pnputil enable_pnputil
+wine_fn_config_makefile programs/powershell enable_powershell
+wine_fn_config_makefile programs/presentationfontcache enable_presentationfontcache
+wine_fn_config_makefile programs/progman enable_progman
+wine_fn_config_makefile programs/reg enable_reg
+wine_fn_config_makefile programs/reg/tests enable_tests
+wine_fn_config_makefile programs/regasm enable_regasm
+wine_fn_config_makefile programs/regedit enable_regedit
+wine_fn_config_makefile programs/regedit/tests enable_tests
+wine_fn_config_makefile programs/regini enable_regini
+wine_fn_config_makefile programs/regsvcs enable_regsvcs
+wine_fn_config_makefile programs/regsvr32 enable_regsvr32
+wine_fn_config_makefile programs/robocopy enable_robocopy
+wine_fn_config_makefile programs/rpcss enable_rpcss
+wine_fn_config_makefile programs/runas enable_runas
+wine_fn_config_makefile programs/rundll.exe16 enable_win16
+wine_fn_config_makefile programs/rundll32 enable_rundll32
+wine_fn_config_makefile programs/sc enable_sc
+wine_fn_config_makefile programs/sc/tests enable_tests
+wine_fn_config_makefile programs/schtasks enable_schtasks
+wine_fn_config_makefile programs/schtasks/tests enable_tests
+wine_fn_config_makefile programs/sdbinst enable_sdbinst
+wine_fn_config_makefile programs/secedit enable_secedit
+wine_fn_config_makefile programs/servicemodelreg enable_servicemodelreg
+wine_fn_config_makefile programs/services enable_services
+wine_fn_config_makefile programs/services/tests enable_tests
+wine_fn_config_makefile programs/setx enable_setx
+wine_fn_config_makefile programs/shutdown enable_shutdown
+wine_fn_config_makefile programs/sort enable_sort
+wine_fn_config_makefile programs/spoolsv enable_spoolsv
+wine_fn_config_makefile programs/start enable_start
+wine_fn_config_makefile programs/subst enable_subst
+wine_fn_config_makefile programs/svchost enable_svchost
+wine_fn_config_makefile programs/systeminfo enable_systeminfo
+wine_fn_config_makefile programs/taskkill enable_taskkill
+wine_fn_config_makefile programs/tasklist enable_tasklist
+wine_fn_config_makefile programs/tasklist/tests enable_tests
+wine_fn_config_makefile programs/taskmgr enable_taskmgr
+wine_fn_config_makefile programs/termsv enable_termsv
+wine_fn_config_makefile programs/timeout enable_timeout
+wine_fn_config_makefile programs/timeout/tests enable_tests
+wine_fn_config_makefile programs/uninstaller enable_uninstaller
+wine_fn_config_makefile programs/unlodctr enable_unlodctr
+wine_fn_config_makefile programs/view enable_view
+wine_fn_config_makefile programs/wevtutil enable_wevtutil
+wine_fn_config_makefile programs/where enable_where
+wine_fn_config_makefile programs/whoami enable_whoami
+wine_fn_config_makefile programs/wineboot enable_wineboot
+wine_fn_config_makefile programs/winebrowser enable_winebrowser
+wine_fn_config_makefile programs/winecfg enable_winecfg
+wine_fn_config_makefile programs/wineconsole enable_wineconsole
+wine_fn_config_makefile programs/winedbg enable_winedbg
+wine_fn_config_makefile programs/winedevice enable_winedevice
+wine_fn_config_makefile programs/winefile enable_winefile
+wine_fn_config_makefile programs/winemenubuilder enable_winemenubuilder
+wine_fn_config_makefile programs/winemine enable_winemine
+wine_fn_config_makefile programs/winemsibuilder enable_winemsibuilder
+wine_fn_config_makefile programs/winepath enable_winepath
+wine_fn_config_makefile programs/winetest enable_winetest
+wine_fn_config_makefile programs/winevdm enable_winevdm
+wine_fn_config_makefile programs/winhelp.exe16 enable_win16
+wine_fn_config_makefile programs/winhlp32 enable_winhlp32
+wine_fn_config_makefile programs/winmgmt enable_winmgmt
+wine_fn_config_makefile programs/winoldap.mod16 enable_win16
+wine_fn_config_makefile programs/winver enable_winver
+wine_fn_config_makefile programs/wmic enable_wmic
+wine_fn_config_makefile programs/wmplayer enable_wmplayer
+wine_fn_config_makefile programs/wordpad enable_wordpad
+wine_fn_config_makefile programs/write enable_write
+wine_fn_config_makefile programs/wscript enable_wscript
+wine_fn_config_makefile programs/wscript/tests enable_tests
+wine_fn_config_makefile programs/wuauserv enable_wuauserv
+wine_fn_config_makefile programs/wusa enable_wusa
+wine_fn_config_makefile programs/xcopy enable_xcopy
+wine_fn_config_makefile programs/xcopy/tests enable_tests
+wine_fn_config_makefile server enable_server
+test "x$enable_tools" = xno || wine_fn_config_makefile tools enable_tools
+test "x$enable_tools" = xno || wine_fn_config_makefile tools/sfnt2fon enable_sfnt2fon
+test "x$enable_tools" = xno || wine_fn_config_makefile tools/widl enable_widl
+test "x$enable_tools" = xno || wine_fn_config_makefile tools/wine enable_wine
+test "x$enable_tools" = xno || wine_fn_config_makefile tools/winebuild enable_winebuild
+test "x$enable_tools" = xno || wine_fn_config_makefile tools/winedump enable_winedump
+test "x$enable_tools" = xno || wine_fn_config_makefile tools/winegcc enable_winegcc
+test "x$enable_tools" = xno || wine_fn_config_makefile tools/winemaker enable_winemaker
+test "x$enable_tools" = xno || wine_fn_config_makefile tools/wmc enable_wmc
+test "x$enable_tools" = xno || wine_fn_config_makefile tools/wrc enable_wrc
+
+
+as_fn_append CONFIGURE_TARGETS " TAGS"
+as_fn_append CONFIGURE_TARGETS " tags"
+as_fn_append CONFIGURE_TARGETS " config.log"
+
+if test "x$enable_tools" != xno
+then
+    ac_config_commands="$ac_config_commands tools/makedep"
+
+fi
+
+ac_config_commands="$ac_config_commands Makefile"
+
+
+
+SHELL=/bin/sh
+
+
+
+if test "x$enable_maintainer_mode" = xyes
+then
+    as_fn_append wine_rules "
+configure: configure.ac aclocal.m4
+	autoconf --warnings=all
+include/config.h.in: include/stamp-h.in
+include/stamp-h.in: configure.ac aclocal.m4
+	autoheader --warnings=all
+	@echo timestamp > \$@"
+fi
+
+
+if test -z "$with_wine64"
+then
+    TOP_INSTALL_DEV="$TOP_INSTALL_DEV include"
+    TOP_INSTALL_LIB="$TOP_INSTALL_LIB \
+fonts \
+loader/wine.inf \
+nls \
+programs/msidb/msidb \
+programs/msiexec/msiexec \
+programs/notepad/notepad \
+programs/regedit/regedit \
+programs/regsvr32/regsvr32 \
+programs/wineboot/wineboot \
+programs/winecfg/winecfg \
+programs/wineconsole/wineconsole \
+programs/winedbg/winedbg \
+programs/winefile/winefile \
+programs/winemine/winemine \
+programs/winepath/winepath \
+server/wineserver"
+
+    case $host_os in
+      cygwin*|mingw32*|darwin*|linux-android*) ;;
+      *) TOP_INSTALL_LIB="$TOP_INSTALL_LIB loader/wine.desktop" ;;
+    esac
+fi
+
+
+as_fn_append wine_rules "
+dlls/ntdll/unix/version.c: dummy
+	@version=\`(GIT_DIR=${wine_srcdir}.git git describe HEAD 2>/dev/null || echo \"wine-\$(PACKAGE_VERSION)\") | sed -n -e '\$\$s/\(.*\)/const char wine_build[] = \"\\1\";/p'\` && (echo \$\$version | cmp -s - \$@) || echo \$\$version >\$@ || (rm -f \$@ && exit 1)
+programs/winetest/build.rc: dummy
+	@build=\"STRINGTABLE { 1 \\\"\`GIT_DIR=${wine_srcdir}.git git rev-parse HEAD 2>/dev/null\`\\\" }\" && (echo \$\$build | cmp -s - \$@) || echo \$\$build >\$@ || (rm -f \$@ && exit 1)
+dlls/wineandroid.drv/wine-debug.apk: dlls/wineandroid.drv/build.gradle ${wine_srcdir}dlls/wineandroid.drv/AndroidManifest.xml ${wine_srcdir}dlls/wineandroid.drv/WineActivity.java ${wine_srcdir}dlls/wineandroid.drv/wine.svg
+	cd dlls/wineandroid.drv && gradle -q -Psrcdir=$srcdir assembleDebug
+	mv dlls/wineandroid.drv/build/outputs/apk/wine-debug.apk \$@"
+
+
+TAGSFLAGS="--langmap='c:+.idl.l.rh,make:(Make*.in)'"
+
+as_fn_append wine_rules "
+TAGS etags:
+	rm -f TAGS
+	(test -d .git && git ls-files || find -L $srcdir -name '*.[ch]' -print) | xargs etags -a \$(TAGSFLAGS)
+tags ctags:
+	rm -f tags
+	(test -d .git && git ls-files || find -L $srcdir -name '*.[ch]' -print) | xargs ctags -a \$(TAGSFLAGS)
+dummy:
+.PHONY: dummy"
+
+printf "%s\n" " done" >&6
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# 'ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* 'ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, we kill variables containing newlines.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+(
+  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+printf "%s\n" "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) { eval $ac_var=; unset $ac_var;} ;;
+      esac ;;
+    esac
+  done
+
+  (set) 2>&1 |
+    case $as_nl`(ac_space=' '; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      # 'set' does not quote correctly, so add quotes: double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \.
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;; #(
+    *)
+      # 'set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+) |
+  sed '
+     /^ac_cv_env_/b end
+     t clear
+     :clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test ${\1+y} || &/
+     t end
+     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     :end' >>confcache
+if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
+  if test -w "$cache_file"; then
+    if test "x$cache_file" != "x/dev/null"; then
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
+printf "%s\n" "$as_me: updating cache $cache_file" >&6;}
+      if test ! -f "$cache_file" || test -h "$cache_file"; then
+	cat confcache >"$cache_file"
+      else
+        case $cache_file in #(
+        */* | ?:*)
+	  mv -f confcache "$cache_file"$$ &&
+	  mv -f "$cache_file"$$ "$cache_file" ;; #(
+        *)
+	  mv -f confcache "$cache_file" ;;
+	esac
+      fi
+    fi
+  else
+    { printf "%s\n" "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
+printf "%s\n" "$as_me: not updating unwritable cache $cache_file" >&6;}
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+DEFS=-DHAVE_CONFIG_H
+
+ac_libobjs=
+ac_ltlibobjs=
+U=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
+  ac_i=`printf "%s\n" "$ac_i" | sed "$ac_script"`
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  as_fn_append ac_ltlibobjs " \${LIBOBJDIR}$ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+# Check whether --enable-year2038 was given.
+if test ${enable_year2038+y}
+then :
+  enableval=$enable_year2038;
+fi
+
+
+: "${CONFIG_STATUS=./config.status}"
+ac_write_fail=0
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
+printf "%s\n" "$as_me: creating $CONFIG_STATUS" >&6;}
+as_write_fail=0
+cat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+
+SHELL=\${CONFIG_SHELL-$SHELL}
+export SHELL
+_ASEOF
+cat >>$CONFIG_STATUS <<\_ASEOF || as_write_fail=1
+## -------------------- ##
+## M4sh Initialization. ##
+## -------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test ${ZSH_VERSION+y} && (emulate sh) >/dev/null 2>&1
+then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else case e in #(
+  e) case `(set -o) 2>/dev/null` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac ;;
+esac
+fi
+
+
+
+# Reset variables that may have inherited troublesome values from
+# the environment.
+
+# IFS needs to be set, to space, tab, and newline, in precisely that order.
+# (If _AS_PATH_WALK were called with IFS unset, it would have the
+# side effect of setting IFS to empty, thus disabling word splitting.)
+# Quoting is to prevent editors from complaining about space-tab.
+as_nl='
+'
+export as_nl
+IFS=" ""	$as_nl"
+
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# Ensure predictable behavior from utilities with locale-dependent output.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# We cannot yet rely on "unset" to work, but we need these variables
+# to be unset--not just set to an empty or harmless value--now, to
+# avoid bugs in old shells (e.g. pre-3.0 UWIN ksh).  This construct
+# also avoids known problems related to "unset" and subshell syntax
+# in other old shells (e.g. bash 2.01 and pdksh 5.2.14).
+for as_var in BASH_ENV ENV MAIL MAILPATH CDPATH
+do eval test \${$as_var+y} \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+
+# Ensure that fds 0, 1, and 2 are open.
+if (exec 3>&0) 2>/dev/null; then :; else exec 0</dev/null; fi
+if (exec 3>&1) 2>/dev/null; then :; else exec 1>/dev/null; fi
+if (exec 3>&2)            ; then :; else exec 2>/dev/null; fi
+
+# The user is always right.
+if ${PATH_SEPARATOR+false} :; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
+
+
+# Find who we are.  Look in the path if we contain no directory separator.
+as_myself=
+case $0 in #((
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  case $as_dir in #(((
+    '') as_dir=./ ;;
+    */) ;;
+    *) as_dir=$as_dir/ ;;
+  esac
+    test -r "$as_dir$0" && as_myself=$as_dir$0 && break
+  done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as 'sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  printf "%s\n" "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  exit 1
+fi
+
+
+
+# as_fn_error STATUS ERROR [LINENO LOG_FD]
+# ----------------------------------------
+# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
+# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
+# script with STATUS, using 1 if that was 0.
+as_fn_error ()
+{
+  as_status=$1; test $as_status -eq 0 && as_status=1
+  if test "$4"; then
+    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    printf "%s\n" "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
+  fi
+  printf "%s\n" "$as_me: error: $2" >&2
+  as_fn_exit $as_status
+} # as_fn_error
+
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+
+# as_fn_unset VAR
+# ---------------
+# Portably unset VAR.
+as_fn_unset ()
+{
+  { eval $1=; unset $1;}
+}
+as_unset=as_fn_unset
+
+# as_fn_append VAR VALUE
+# ----------------------
+# Append the text in VALUE to the end of the definition contained in VAR. Take
+# advantage of any shell optimizations that allow amortized linear growth over
+# repeated appends, instead of the typical quadratic growth present in naive
+# implementations.
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null
+then :
+  eval 'as_fn_append ()
+  {
+    eval $1+=\$2
+  }'
+else case e in #(
+  e) as_fn_append ()
+  {
+    eval $1=\$$1\$2
+  } ;;
+esac
+fi # as_fn_append
+
+# as_fn_arith ARG...
+# ------------------
+# Perform arithmetic evaluation on the ARGs, and store the result in the
+# global $as_val. Take advantage of shells that can avoid forks. The arguments
+# must be portable across $(()) and expr.
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null
+then :
+  eval 'as_fn_arith ()
+  {
+    as_val=$(( $* ))
+  }'
+else case e in #(
+  e) as_fn_arith ()
+  {
+    as_val=`expr "$@" || test $? -eq 1`
+  } ;;
+esac
+fi # as_fn_arith
+
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+printf "%s\n" X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+
+# Determine whether it's possible to make 'echo' print without a newline.
+# These variables are no longer used directly by Autoconf, but are AC_SUBSTed
+# for compatibility with existing Makefiles.
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in #(((((
+-n*)
+  case `echo 'xy\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  xy)  ECHO_C='\c';;
+  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
+       ECHO_T='	';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+# For backward compatibility with old third-party macros, we provide
+# the shell variables $as_echo and $as_echo_n.  New code should use
+# AS_ECHO(["message"]) and AS_ECHO_N(["message"]), respectively.
+as_echo='printf %s\n'
+as_echo_n='printf %s'
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
+fi
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both 'ln -s file dir' and 'ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; 'ln -s' creates a wrapper executable.
+    # In both cases, we have to default to 'cp -pR'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -pR'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -pR'
+  fi
+else
+  as_ln_s='cp -pR'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+
+# as_fn_mkdir_p
+# -------------
+# Create "$as_dir" as a directory, including parents if necessary.
+as_fn_mkdir_p ()
+{
+
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || eval $as_mkdir_p || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`printf "%s\n" "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+printf "%s\n" X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
+
+
+} # as_fn_mkdir_p
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p='mkdir -p "$as_dir"'
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+
+# as_fn_executable_p FILE
+# -----------------------
+# Test if FILE is an executable regular file.
+as_fn_executable_p ()
+{
+  test -f "$1" && test -x "$1"
+} # as_fn_executable_p
+as_test_x='test -x'
+as_executable_p=as_fn_executable_p
+
+# Sed expression to map a string onto a valid CPP name.
+as_sed_cpp="y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g"
+as_tr_cpp="eval sed '$as_sed_cpp'" # deprecated
+
+# Sed expression to map a string onto a valid variable name.
+as_sed_sh="y%*+%pp%;s%[^_$as_cr_alnum]%_%g"
+as_tr_sh="eval sed '$as_sed_sh'" # deprecated
+
+
+exec 6>&1
+## ----------------------------------- ##
+## Main body of $CONFIG_STATUS script. ##
+## ----------------------------------- ##
+_ASEOF
+test $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# Save the log message, to keep $0 and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.
+ac_log="
+This file was extended by Wine $as_me 10.16, which was
+generated by GNU Autoconf 2.72.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+on `(hostname || uname -n) 2>/dev/null | sed 1q`
+"
+
+_ACEOF
+
+
+case $ac_config_headers in *"
+"*) set x $ac_config_headers; shift; ac_config_headers=$*;;
+esac
+
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+# Files that config.status was made for.
+config_headers="$ac_config_headers"
+config_commands="$ac_config_commands"
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+ac_cs_usage="\
+'$as_me' instantiates files and other configuration actions
+from templates according to the current configuration.  Unless the files
+and actions are specified as TAGs, all are instantiated by default.
+
+Usage: $0 [OPTION]... [TAG]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number and configuration settings, then exit
+      --config     print configuration, then exit
+  -q, --quiet, --silent
+                   do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+      --header=FILE[:TEMPLATE]
+                   instantiate the configuration header FILE
+
+Configuration headers:
+$config_headers
+
+Configuration commands:
+$config_commands
+
+Report bugs to <wine-devel@winehq.org>.
+Wine home page: <https://www.winehq.org>."
+
+_ACEOF
+ac_cs_config=`printf "%s\n" "$ac_configure_args" | sed "$ac_safe_unquote"`
+ac_cs_config_escaped=`printf "%s\n" "$ac_cs_config" | sed "s/^ //; s/'/'\\\\\\\\''/g"`
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_cs_config='$ac_cs_config_escaped'
+ac_cs_version="\\
+Wine config.status 10.16
+configured by $0, generated by GNU Autoconf 2.72,
+  with options \\"\$ac_cs_config\\"
+
+Copyright (C) 2023 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+
+ac_pwd='$ac_pwd'
+srcdir='$srcdir'
+test -n "\$AWK" || AWK=awk
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# The default lists apply if the user does not specify any file.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=?*)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  --*=)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=
+    ac_shift=:
+    ;;
+  *)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
+    printf "%s\n" "$ac_cs_version"; exit ;;
+  --config | --confi | --conf | --con | --co | --c )
+    printf "%s\n" "$ac_cs_config"; exit ;;
+  --debug | --debu | --deb | --de | --d | -d )
+    debug=: ;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    case $ac_optarg in
+    *\'*) ac_optarg=`printf "%s\n" "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    as_fn_append CONFIG_HEADERS " '$ac_optarg'"
+    ac_need_defaults=false;;
+  --he | --h)
+    # Conflict between --help and --header
+    as_fn_error $? "ambiguous option: '$1'
+Try '$0 --help' for more information.";;
+  --help | --hel | -h )
+    printf "%s\n" "$ac_cs_usage"; exit ;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) as_fn_error $? "unrecognized option: '$1'
+Try '$0 --help' for more information." ;;
+
+  *) as_fn_append ac_config_targets " $1"
+     ac_need_defaults=false ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+if \$ac_cs_recheck; then
+  set X $SHELL '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+  shift
+  \printf "%s\n" "running CONFIG_SHELL=$SHELL \$*" >&6
+  CONFIG_SHELL='$SHELL'
+  export CONFIG_SHELL
+  exec "\$@"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+  printf "%s\n" "$ac_log"
+} >&5
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+#
+# INIT-COMMANDS
+#
+wine_fn_output_makedep ()
+{
+    as_dir=tools; as_fn_mkdir_p
+    $CC -c -I${wine_srcdir}tools -Iinclude -I${wine_srcdir}include -D__WINESRC__ -DWINE_UNIX_LIB $EXTRACFLAGS $CPPFLAGS $CFLAGS -o tools/makedep.o ${wine_srcdir}tools/makedep.c
+    $CC -o tools/makedep$ac_exeext tools/makedep.o $LDFLAGS
+}
+wine_fn_output_makefile ()
+{
+    cat <<\_WINE_EOF >\$tmp/makefile && "$wine_makedep"$makedep_flags -i\$tmp/makefile && return
+# This Makefile understands the following targets:
+#
+# all (default):   build wine
+# clean:           remove all intermediate files
+# distclean:       also remove all files created by configure
+# test:            run tests
+# testclean:       clean test results to force running all tests again
+# install-lib:     install libraries needed to run applications
+# install-dev:     install development environment
+# install:         install everything
+# uninstall:       uninstall everything
+# ctags:           create a tags file for vim and others.
+# etags:           create a TAGS file for Emacs.
+
+SHELL = $SHELL
+PATH_SEPARATOR = $PATH_SEPARATOR
+PACKAGE_NAME = $PACKAGE_NAME
+PACKAGE_TARNAME = $PACKAGE_TARNAME
+PACKAGE_VERSION = $PACKAGE_VERSION
+PACKAGE_STRING = $PACKAGE_STRING
+PACKAGE_BUGREPORT = $PACKAGE_BUGREPORT
+PACKAGE_URL = $PACKAGE_URL
+exec_prefix = $exec_prefix
+prefix = $prefix
+program_transform_name = $program_transform_name
+bindir = $bindir
+sbindir = $sbindir
+libexecdir = $libexecdir
+datarootdir = $datarootdir
+datadir = $datadir
+sysconfdir = $sysconfdir
+sharedstatedir = $sharedstatedir
+localstatedir = $localstatedir
+runstatedir = $runstatedir
+includedir = $includedir
+oldincludedir = $oldincludedir
+docdir = $docdir
+infodir = $infodir
+htmldir = $htmldir
+dvidir = $dvidir
+pdfdir = $pdfdir
+psdir = $psdir
+libdir = $libdir
+localedir = $localedir
+mandir = $mandir
+DEFS = $DEFS
+ECHO_C = $ECHO_C
+ECHO_N = $ECHO_N
+ECHO_T = $ECHO_T
+LIBS = $LIBS
+build_alias = $build_alias
+host_alias = $host_alias
+target_alias = $target_alias
+system_dllpath = $system_dllpath
+build = $build
+build_cpu = $build_cpu
+build_vendor = $build_vendor
+build_os = $build_os
+host = $host
+host_cpu = $host_cpu
+host_vendor = $host_vendor
+host_os = $host_os
+srcdir = $srcdir
+SARIF_CONVERTER = $SARIF_CONVERTER
+CC = $CC
+CFLAGS = $CFLAGS
+LDFLAGS = $LDFLAGS
+CPPFLAGS = $CPPFLAGS
+ac_ct_CC = $ac_ct_CC
+EXEEXT = $EXEEXT
+OBJEXT = $OBJEXT
+CXX = $CXX
+CXXFLAGS = $CXXFLAGS
+ac_ct_CXX = $ac_ct_CXX
+CPPBIN = $CPPBIN
+LD = $LD
+TARGETFLAGS = $TARGETFLAGS
+toolsext = $toolsext
+HOST_ARCH = $HOST_ARCH
+aarch64_CC = $aarch64_CC
+aarch64_CFLAGS = $aarch64_CFLAGS
+aarch64_EXTRACFLAGS = $aarch64_EXTRACFLAGS
+aarch64_LDFLAGS = $aarch64_LDFLAGS
+aarch64_DEBUG = $aarch64_DEBUG
+aarch64_TARGET = $aarch64_TARGET
+aarch64_STRIP = $aarch64_STRIP
+aarch64_DELAYLOADFLAG = $aarch64_DELAYLOADFLAG
+aarch64_DISABLED_SUBDIRS = $aarch64_DISABLED_SUBDIRS
+arm_CC = $arm_CC
+arm_CFLAGS = $arm_CFLAGS
+arm_EXTRACFLAGS = $arm_EXTRACFLAGS
+arm_LDFLAGS = $arm_LDFLAGS
+arm_DEBUG = $arm_DEBUG
+arm_TARGET = $arm_TARGET
+arm_STRIP = $arm_STRIP
+arm_DELAYLOADFLAG = $arm_DELAYLOADFLAG
+arm_DISABLED_SUBDIRS = $arm_DISABLED_SUBDIRS
+arm64ec_CC = $arm64ec_CC
+arm64ec_CFLAGS = $arm64ec_CFLAGS
+arm64ec_EXTRACFLAGS = $arm64ec_EXTRACFLAGS
+arm64ec_LDFLAGS = $arm64ec_LDFLAGS
+arm64ec_DEBUG = $arm64ec_DEBUG
+arm64ec_TARGET = $arm64ec_TARGET
+arm64ec_STRIP = $arm64ec_STRIP
+arm64ec_DELAYLOADFLAG = $arm64ec_DELAYLOADFLAG
+arm64ec_DISABLED_SUBDIRS = $arm64ec_DISABLED_SUBDIRS
+i386_CC = $i386_CC
+i386_CFLAGS = $i386_CFLAGS
+i386_EXTRACFLAGS = $i386_EXTRACFLAGS
+i386_LDFLAGS = $i386_LDFLAGS
+i386_DEBUG = $i386_DEBUG
+i386_TARGET = $i386_TARGET
+i386_STRIP = $i386_STRIP
+i386_DELAYLOADFLAG = $i386_DELAYLOADFLAG
+i386_DISABLED_SUBDIRS = $i386_DISABLED_SUBDIRS
+x86_64_CC = $x86_64_CC
+x86_64_CFLAGS = $x86_64_CFLAGS
+x86_64_EXTRACFLAGS = $x86_64_EXTRACFLAGS
+x86_64_LDFLAGS = $x86_64_LDFLAGS
+x86_64_DEBUG = $x86_64_DEBUG
+x86_64_TARGET = $x86_64_TARGET
+x86_64_STRIP = $x86_64_STRIP
+x86_64_DELAYLOADFLAG = $x86_64_DELAYLOADFLAG
+x86_64_DISABLED_SUBDIRS = $x86_64_DISABLED_SUBDIRS
+toolsdir = $toolsdir
+wine64dir = $wine64dir
+RUNTESTFLAGS = $RUNTESTFLAGS
+SED_CMD = $SED_CMD
+FLEX = $FLEX
+BISON = $BISON
+STRIP = $STRIP
+LN_S = $LN_S
+PKG_CONFIG = $PKG_CONFIG
+FONTFORGE = $FONTFORGE
+RSVG = $RSVG
+CONVERT = $CONVERT
+ICOTOOL = $ICOTOOL
+MSGFMT = $MSGFMT
+PE_ARCHS = $PE_ARCHS
+DLLEXT = $DLLEXT
+I386_LIBS = $I386_LIBS
+OPENGL_LIBS = $OPENGL_LIBS
+DLLFLAGS = $DLLFLAGS
+LDDLLFLAGS = $LDDLLFLAGS
+LDEXECFLAGS = $LDEXECFLAGS
+EXTRACFLAGS = $EXTRACFLAGS
+UNIXDLLFLAGS = $UNIXDLLFLAGS
+UNIXLDFLAGS = $UNIXLDFLAGS
+TOP_INSTALL_LIB = $TOP_INSTALL_LIB
+TOP_INSTALL_DEV = $TOP_INSTALL_DEV
+WINELOADER_LDFLAGS = $WINELOADER_LDFLAGS
+WINEPRELOADER_LDFLAGS = $WINEPRELOADER_LDFLAGS
+LDD = $LDD
+OTOOL = $OTOOL
+READELF = $READELF
+SUBDIRS = $SUBDIRS
+DISABLED_SUBDIRS = $DISABLED_SUBDIRS
+CONFIGURE_TARGETS = $CONFIGURE_TARGETS
+CORETEXT_LIBS = $CORETEXT_LIBS
+COREFOUNDATION_LIBS = $COREFOUNDATION_LIBS
+DISKARBITRATION_LIBS = $DISKARBITRATION_LIBS
+IOKIT_LIBS = $IOKIT_LIBS
+APPLICATIONSERVICES_LIBS = $APPLICATIONSERVICES_LIBS
+CORESERVICES_LIBS = $CORESERVICES_LIBS
+APPKIT_LIBS = $APPKIT_LIBS
+SECURITY_LIBS = $SECURITY_LIBS
+SYSTEMCONFIGURATION_LIBS = $SYSTEMCONFIGURATION_LIBS
+COREAUDIO_LIBS = $COREAUDIO_LIBS
+OPENCL_LIBS = $OPENCL_LIBS
+OBJC = $OBJC
+OBJCFLAGS = $OBJCFLAGS
+ac_ct_OBJC = $ac_ct_OBJC
+WINELOADER_DEPENDS = $WINELOADER_DEPENDS
+MINGW_PKG_CONFIG = $MINGW_PKG_CONFIG
+CAPSTONE_PE_CFLAGS = $CAPSTONE_PE_CFLAGS
+CAPSTONE_PE_LIBS = $CAPSTONE_PE_LIBS
+COMPILER_RT_PE_CFLAGS = $COMPILER_RT_PE_CFLAGS
+COMPILER_RT_PE_LIBS = $COMPILER_RT_PE_LIBS
+FAUDIO_PE_CFLAGS = $FAUDIO_PE_CFLAGS
+FAUDIO_PE_LIBS = $FAUDIO_PE_LIBS
+FLUIDSYNTH_PE_CFLAGS = $FLUIDSYNTH_PE_CFLAGS
+FLUIDSYNTH_PE_LIBS = $FLUIDSYNTH_PE_LIBS
+GSM_PE_CFLAGS = $GSM_PE_CFLAGS
+GSM_PE_LIBS = $GSM_PE_LIBS
+JPEG_PE_CFLAGS = $JPEG_PE_CFLAGS
+JPEG_PE_LIBS = $JPEG_PE_LIBS
+JXR_PE_CFLAGS = $JXR_PE_CFLAGS
+JXR_PE_LIBS = $JXR_PE_LIBS
+LCMS2_PE_CFLAGS = $LCMS2_PE_CFLAGS
+LCMS2_PE_LIBS = $LCMS2_PE_LIBS
+LDAP_PE_CFLAGS = $LDAP_PE_CFLAGS
+LDAP_PE_LIBS = $LDAP_PE_LIBS
+MPG123_PE_CFLAGS = $MPG123_PE_CFLAGS
+MPG123_PE_LIBS = $MPG123_PE_LIBS
+MUSL_PE_CFLAGS = $MUSL_PE_CFLAGS
+MUSL_PE_LIBS = $MUSL_PE_LIBS
+PNG_PE_CFLAGS = $PNG_PE_CFLAGS
+PNG_PE_LIBS = $PNG_PE_LIBS
+TIFF_PE_CFLAGS = $TIFF_PE_CFLAGS
+TIFF_PE_LIBS = $TIFF_PE_LIBS
+TOMCRYPT_PE_CFLAGS = $TOMCRYPT_PE_CFLAGS
+TOMCRYPT_PE_LIBS = $TOMCRYPT_PE_LIBS
+VKD3D_PE_CFLAGS = $VKD3D_PE_CFLAGS
+VKD3D_PE_LIBS = $VKD3D_PE_LIBS
+XML2_PE_CFLAGS = $XML2_PE_CFLAGS
+XML2_PE_LIBS = $XML2_PE_LIBS
+XSLT_PE_CFLAGS = $XSLT_PE_CFLAGS
+XSLT_PE_LIBS = $XSLT_PE_LIBS
+ZLIB_PE_CFLAGS = $ZLIB_PE_CFLAGS
+ZLIB_PE_LIBS = $ZLIB_PE_LIBS
+PTHREAD_LIBS = $PTHREAD_LIBS
+EGL_CFLAGS = $EGL_CFLAGS
+EGL_LIBS = $EGL_LIBS
+XMKMF = $XMKMF
+CPP = $CPP
+X_CFLAGS = $X_CFLAGS
+X_LIBS = $X_LIBS
+WAYLAND_CLIENT_CFLAGS = $WAYLAND_CLIENT_CFLAGS
+WAYLAND_CLIENT_LIBS = $WAYLAND_CLIENT_LIBS
+WAYLAND_SCANNER = $WAYLAND_SCANNER
+XKBCOMMON_CFLAGS = $XKBCOMMON_CFLAGS
+XKBCOMMON_LIBS = $XKBCOMMON_LIBS
+XKBREGISTRY_CFLAGS = $XKBREGISTRY_CFLAGS
+XKBREGISTRY_LIBS = $XKBREGISTRY_LIBS
+WAYLAND_EGL_CFLAGS = $WAYLAND_EGL_CFLAGS
+WAYLAND_EGL_LIBS = $WAYLAND_EGL_LIBS
+PCAP_LIBS = $PCAP_LIBS
+PCSCLITE_LIBS = $PCSCLITE_LIBS
+INOTIFY_CFLAGS = $INOTIFY_CFLAGS
+INOTIFY_LIBS = $INOTIFY_LIBS
+DBUS_CFLAGS = $DBUS_CFLAGS
+DBUS_LIBS = $DBUS_LIBS
+GNUTLS_CFLAGS = $GNUTLS_CFLAGS
+GNUTLS_LIBS = $GNUTLS_LIBS
+SANE_CFLAGS = $SANE_CFLAGS
+SANE_LIBS = $SANE_LIBS
+USB_CFLAGS = $USB_CFLAGS
+USB_LIBS = $USB_LIBS
+GPHOTO2_CFLAGS = $GPHOTO2_CFLAGS
+GPHOTO2_LIBS = $GPHOTO2_LIBS
+GPHOTO2_PORT_CFLAGS = $GPHOTO2_PORT_CFLAGS
+GPHOTO2_PORT_LIBS = $GPHOTO2_PORT_LIBS
+RESOLV_LIBS = $RESOLV_LIBS
+FREETYPE_CFLAGS = $FREETYPE_CFLAGS
+FREETYPE_LIBS = $FREETYPE_LIBS
+GETTEXTPO_LIBS = $GETTEXTPO_LIBS
+PULSE_CFLAGS = $PULSE_CFLAGS
+PULSE_LIBS = $PULSE_LIBS
+FFMPEG_CFLAGS = $FFMPEG_CFLAGS
+FFMPEG_LIBS = $FFMPEG_LIBS
+GSTREAMER_CFLAGS = $GSTREAMER_CFLAGS
+GSTREAMER_LIBS = $GSTREAMER_LIBS
+ALSA_LIBS = $ALSA_LIBS
+ALSA_CFLAGS = $ALSA_CFLAGS
+OSS4_CFLAGS = $OSS4_CFLAGS
+OSS4_LIBS = $OSS4_LIBS
+UDEV_CFLAGS = $UDEV_CFLAGS
+UDEV_LIBS = $UDEV_LIBS
+UNWIND_CFLAGS = $UNWIND_CFLAGS
+UNWIND_LIBS = $UNWIND_LIBS
+SDL2_CFLAGS = $SDL2_CFLAGS
+SDL2_LIBS = $SDL2_LIBS
+CAPI20_CFLAGS = $CAPI20_CFLAGS
+CAPI20_LIBS = $CAPI20_LIBS
+CUPS_CFLAGS = $CUPS_CFLAGS
+CUPS_LIBS = $CUPS_LIBS
+FONTCONFIG_CFLAGS = $FONTCONFIG_CFLAGS
+FONTCONFIG_LIBS = $FONTCONFIG_LIBS
+KRB5_CFLAGS = $KRB5_CFLAGS
+KRB5_LIBS = $KRB5_LIBS
+GSSAPI_CFLAGS = $GSSAPI_CFLAGS
+GSSAPI_LIBS = $GSSAPI_LIBS
+PROCSTAT_LIBS = $PROCSTAT_LIBS
+NETAPI_CFLAGS = $NETAPI_CFLAGS
+NETAPI_LIBS = $NETAPI_LIBS
+MSVCRTFLAGS = $MSVCRTFLAGS
+DELAYLOADFLAG = $DELAYLOADFLAG
+WINELOADER_PROGRAMS = $WINELOADER_PROGRAMS
+RT_LIBS = $RT_LIBS
+TAGSFLAGS = $TAGSFLAGS
+LIBOBJS = $LIBOBJS
+LTLIBOBJS = $LTLIBOBJS
+$SET_MAKE
+$wine_rules
+_WINE_EOF
+    as_fn_error $? "could not create Makefile" "$LINENO" 5
+}
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+
+# Handling of arguments.
+for ac_config_target in $ac_config_targets
+do
+  case $ac_config_target in
+    "include/config.h") CONFIG_HEADERS="$CONFIG_HEADERS include/config.h" ;;
+    "include/stamp-h") CONFIG_COMMANDS="$CONFIG_COMMANDS include/stamp-h" ;;
+    "tools/makedep") CONFIG_COMMANDS="$CONFIG_COMMANDS tools/makedep" ;;
+    "Makefile") CONFIG_COMMANDS="$CONFIG_COMMANDS Makefile" ;;
+
+  *) as_fn_error $? "invalid argument: '$ac_config_target'" "$LINENO" 5;;
+  esac
+done
+
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test ${CONFIG_HEADERS+y} || CONFIG_HEADERS=$config_headers
+  test ${CONFIG_COMMANDS+y} || CONFIG_COMMANDS=$config_commands
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason against having it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Hook for its removal unless debugging.
+# Note that there is a small window in which the directory will not be cleaned:
+# after its creation but before its name has been assigned to '$tmp'.
+$debug ||
+{
+  tmp= ac_tmp=
+  trap 'exit_status=$?
+  : "${ac_tmp:=$tmp}"
+  { test ! -d "$ac_tmp" || rm -fr "$ac_tmp"; } && exit $exit_status
+' 0
+  trap 'as_fn_exit 1' 1 2 13 15
+}
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
+  test -d "$tmp"
+}  ||
+{
+  tmp=./conf$$-$RANDOM
+  (umask 077 && mkdir "$tmp")
+} || as_fn_error $? "cannot create a temporary directory in ." "$LINENO" 5
+ac_tmp=$tmp
+
+# Set up the scripts for CONFIG_HEADERS section.
+# No need to generate them if there are no CONFIG_HEADERS.
+# This happens for instance with './config.status Makefile'.
+if test -n "$CONFIG_HEADERS"; then
+cat >"$ac_tmp/defines.awk" <<\_ACAWK ||
+BEGIN {
+_ACEOF
+
+# Transform confdefs.h into an awk script 'defines.awk', embedded as
+# here-document in config.status, that substitutes the proper values into
+# config.h.in to produce config.h.
+
+# Create a delimiter string that does not exist in confdefs.h, to ease
+# handling of long lines.
+ac_delim='%!_!# '
+for ac_last_try in false false :; do
+  ac_tt=`sed -n "/$ac_delim/p" confdefs.h`
+  if test -z "$ac_tt"; then
+    break
+  elif $ac_last_try; then
+    as_fn_error $? "could not make $CONFIG_HEADERS" "$LINENO" 5
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+
+# For the awk script, D is an array of macro values keyed by name,
+# likewise P contains macro parameters if any.  Preserve backslash
+# newline sequences.
+
+ac_word_re=[_$as_cr_Letters][_$as_cr_alnum]*
+sed -n '
+s/.\{148\}/&'"$ac_delim"'/g
+t rset
+:rset
+s/^[	 ]*#[	 ]*define[	 ][	 ]*/ /
+t def
+d
+:def
+s/\\$//
+t bsnl
+s/["\\]/\\&/g
+s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
+D["\1"]=" \3"/p
+s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2"/p
+d
+:bsnl
+s/["\\]/\\&/g
+s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
+D["\1"]=" \3\\\\\\n"\\/p
+t cont
+s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2\\\\\\n"\\/p
+t cont
+d
+:cont
+n
+s/.\{148\}/&'"$ac_delim"'/g
+t clear
+:clear
+s/\\$//
+t bsnlc
+s/["\\]/\\&/g; s/^/"/; s/$/"/p
+d
+:bsnlc
+s/["\\]/\\&/g; s/^/"/; s/$/\\\\\\n"\\/p
+b cont
+' <confdefs.h | sed '
+s/'"$ac_delim"'/"\\\
+"/g' >>$CONFIG_STATUS || ac_write_fail=1
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+  for (key in D) D_is_set[key] = 1
+  FS = ""
+}
+/^[\t ]*#[\t ]*(define|undef)[\t ]+$ac_word_re([\t (]|\$)/ {
+  line = \$ 0
+  split(line, arg, " ")
+  if (arg[1] == "#") {
+    defundef = arg[2]
+    mac1 = arg[3]
+  } else {
+    defundef = substr(arg[1], 2)
+    mac1 = arg[2]
+  }
+  split(mac1, mac2, "(") #)
+  macro = mac2[1]
+  prefix = substr(line, 1, index(line, defundef) - 1)
+  if (D_is_set[macro]) {
+    # Preserve the white space surrounding the "#".
+    print prefix "define", macro P[macro] D[macro]
+    next
+  } else {
+    # Replace #undef with comments.  This is necessary, for example,
+    # in the case of _POSIX_SOURCE, which is predefined and required
+    # on some systems where configure will not decide to define it.
+    if (defundef == "undef") {
+      print "/*", prefix defundef, macro, "*/"
+      next
+    }
+  }
+}
+{ print }
+_ACAWK
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+  as_fn_error $? "could not setup config headers machinery" "$LINENO" 5
+fi # test -n "$CONFIG_HEADERS"
+
+
+eval set X "    :H $CONFIG_HEADERS    :C $CONFIG_COMMANDS"
+shift
+for ac_tag
+do
+  case $ac_tag in
+  :[FHLC]) ac_mode=$ac_tag; continue;;
+  esac
+  case $ac_mode$ac_tag in
+  :[FHL]*:*);;
+  :L* | :C*:*) as_fn_error $? "invalid tag '$ac_tag'" "$LINENO" 5;;
+  :[FH]-) ac_tag=-:-;;
+  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
+  esac
+  ac_save_IFS=$IFS
+  IFS=:
+  set x $ac_tag
+  IFS=$ac_save_IFS
+  shift
+  ac_file=$1
+  shift
+
+  case $ac_mode in
+  :L) ac_source=$1;;
+  :[FH])
+    ac_file_inputs=
+    for ac_f
+    do
+      case $ac_f in
+      -) ac_f="$ac_tmp/stdin";;
+      *) # Look for the file first in the build tree, then in the source tree
+	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
+	 # because $ac_f cannot contain ':'.
+	 test -f "$ac_f" ||
+	   case $ac_f in
+	   [\\/$]*) false;;
+	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
+	   esac ||
+	   as_fn_error 1 "cannot find input file: '$ac_f'" "$LINENO" 5;;
+      esac
+      case $ac_f in *\'*) ac_f=`printf "%s\n" "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
+      as_fn_append ac_file_inputs " '$ac_f'"
+    done
+
+    # Let's still pretend it is 'configure' which instantiates (i.e., don't
+    # use $as_me), people would be surprised to read:
+    #    /* config.h.  Generated by config.status.  */
+    configure_input='Generated from '`
+	  printf "%s\n" "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
+	`' by configure.'
+    if test x"$ac_file" != x-; then
+      configure_input="$ac_file.  $configure_input"
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
+printf "%s\n" "$as_me: creating $ac_file" >&6;}
+    fi
+    # Neutralize special characters interpreted by sed in replacement strings.
+    case $configure_input in #(
+    *\&* | *\|* | *\\* )
+       ac_sed_conf_input=`printf "%s\n" "$configure_input" |
+       sed 's/[\\\\&|]/\\\\&/g'`;; #(
+    *) ac_sed_conf_input=$configure_input;;
+    esac
+
+    case $ac_tag in
+    *:-:* | *:-) cat >"$ac_tmp/stdin" \
+      || as_fn_error $? "could not create $ac_file" "$LINENO" 5 ;;
+    esac
+    ;;
+  esac
+
+  ac_dir=`$as_dirname -- "$ac_file" ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
+printf "%s\n" X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  as_dir="$ac_dir"; as_fn_mkdir_p
+  ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`printf "%s\n" "$ac_dir" | sed 's|^\.[\\/]||'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`printf "%s\n" "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+
+  case $ac_mode in
+
+  :H)
+  #
+  # CONFIG_HEADER
+  #
+  if test x"$ac_file" != x-; then
+    {
+      printf "%s\n" "/* $configure_input  */" >&1 \
+      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs"
+    } >"$ac_tmp/config.h" \
+      || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+    if diff "$ac_file" "$ac_tmp/config.h" >/dev/null 2>&1; then
+      { printf "%s\n" "$as_me:${as_lineno-$LINENO}: $ac_file is unchanged" >&5
+printf "%s\n" "$as_me: $ac_file is unchanged" >&6;}
+    else
+      rm -f "$ac_file"
+      mv "$ac_tmp/config.h" "$ac_file" \
+	|| as_fn_error $? "could not create $ac_file" "$LINENO" 5
+    fi
+  else
+    printf "%s\n" "/* $configure_input  */" >&1 \
+      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs" \
+      || as_fn_error $? "could not create -" "$LINENO" 5
+  fi
+ ;;
+
+  :C)  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: executing $ac_file commands" >&5
+printf "%s\n" "$as_me: executing $ac_file commands" >&6;}
+ ;;
+  esac
+
+
+  case $ac_file$ac_mode in
+    "include/stamp-h":C) echo timestamp > include/stamp-h ;;
+    "tools/makedep":C) wine_fn_output_makedep || as_fn_exit $? ;;
+    "Makefile":C) wine_fn_output_makefile Makefile ;;
+
+  esac
+done # for ac_tag
+
+
+as_fn_exit 0
+_ACEOF
+ac_clean_files=$ac_clean_files_save
+
+test $ac_write_fail = 0 ||
+  as_fn_error $? "write failure creating $CONFIG_STATUS" "$LINENO" 5
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || as_fn_exit 1
+fi
+if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
+  { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
+printf "%s\n" "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
+fi
+
+
+if test "$no_create" = "yes"
+then
+  exit 0
+fi
+
+ac_save_IFS="$IFS"
+if test "x$wine_notices" != x; then
+    echo >&6
+    IFS="|"
+    for msg in $wine_notices; do
+        IFS="$ac_save_IFS"
+        if ${msg:+false} :
+then :
+
+else case e in #(
+  e) { printf "%s\n" "$as_me:${as_lineno-$LINENO}: $msg" >&5
+printf "%s\n" "$as_me: $msg" >&6;} ;;
+esac
+fi
+    done
+fi
+IFS="|"
+for msg in $wine_warnings; do
+    IFS="$ac_save_IFS"
+    if ${msg:+false} :
+then :
+
+else case e in #(
+  e) echo >&2
+        { printf "%s\n" "$as_me:${as_lineno-$LINENO}: WARNING: $msg" >&5
+printf "%s\n" "$as_me: WARNING: $msg" >&2;} ;;
+esac
+fi
+done
+IFS="$ac_save_IFS"
+
+printf "%s\n" "
+$as_me: Finished.  Do '${MAKE-make}' to compile Wine.
+" >&6
+
+
diff -ruN --show-c-function dlls/kernel32/tests/sync.c dlls/kernel32/tests/sync.c
--- dlls/kernel32/tests/sync.c	2025-10-10 10:17:47.234746574 -0700
+++ dlls/kernel32/tests/sync.c	2025-10-10 10:22:17.168366670 -0700
@@ -60,6 +60,7 @@ static DWORD (WINAPI *pQueueUserAPC2)(PA
 
 static NTSTATUS (WINAPI *pNtAllocateVirtualMemory)(HANDLE, PVOID *, ULONG_PTR, SIZE_T *, ULONG, ULONG);
 static NTSTATUS (WINAPI *pNtFreeVirtualMemory)(HANDLE, PVOID *, SIZE_T *, ULONG);
+static NTSTATUS (WINAPI *pNtQuerySystemTime)(LARGE_INTEGER *);
 static NTSTATUS (WINAPI *pNtWaitForSingleObject)(HANDLE, BOOLEAN, const LARGE_INTEGER *);
 static NTSTATUS (WINAPI *pNtWaitForMultipleObjects)(ULONG,const HANDLE*,BOOLEAN,BOOLEAN,const LARGE_INTEGER*);
 static PSLIST_ENTRY (__fastcall *pRtlInterlockedPushListSList)(PSLIST_HEADER list, PSLIST_ENTRY first,
@@ -292,7 +293,8 @@ static void test_mutex(void)
     SetLastError(0xdeadbeef);
     hOpened = OpenMutexA(GENERIC_READ | GENERIC_WRITE, FALSE, "WineTestMutex");
     ok(hOpened != NULL, "OpenMutex failed with error %ld\n", GetLastError());
-    wait_ret = WaitForSingleObject(hOpened, INFINITE);
+    wait_ret = WaitForSingleObject(hOpened, 0);
+todo_wine_if(getenv("WINEESYNC"))   /* XFAIL: validation is not implemented */
     ok(wait_ret == WAIT_FAILED, "WaitForSingleObject succeeded\n");
     CloseHandle(hOpened);
 
@@ -323,6 +325,7 @@ static void test_mutex(void)
 
     SetLastError(0xdeadbeef);
     ret = ReleaseMutex(hCreated);
+todo_wine_if(getenv("WINEESYNC"))   /* XFAIL: due to the above */
     ok(!ret && (GetLastError() == ERROR_NOT_OWNER),
         "ReleaseMutex should have failed with ERROR_NOT_OWNER instead of %ld\n", GetLastError());
 
@@ -572,12 +575,13 @@ static void test_slist(void)
 
 static void test_event(void)
 {
-    HANDLE handle, handle2;
+    HANDLE handle, handle2, handles[2];
     SECURITY_ATTRIBUTES sa;
     SECURITY_DESCRIPTOR sd;
     ACL acl;
     DWORD ret;
     BOOL val;
+    int i;
 
     /* no sd */
     handle = CreateEventA(NULL, FALSE, FALSE, __FILE__ ": Test Event");
@@ -681,11 +685,130 @@ static void test_event(void)
     ok( ret, "QueryMemoryResourceNotification failed err %lu\n", GetLastError() );
     ok( val == FALSE || val == TRUE, "wrong value %u\n", val );
     CloseHandle( handle );
+
+    handle = CreateEventA( NULL, TRUE, FALSE, NULL );
+    ok(!!handle, "got error %lu\n", GetLastError());
+
+    ret = WaitForSingleObject( handle, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    ret = SetEvent( handle );
+    ok(ret, "got error %lu\n", GetLastError());
+
+    ret = SetEvent( handle );
+    ok(ret, "got error %lu\n", GetLastError());
+
+    for (i = 0; i < 100; i++)
+    {
+        ret = WaitForSingleObject( handle, 0 );
+        ok(ret == 0, "got %lu\n", ret);
+    }
+
+    ret = ResetEvent( handle );
+    ok(ret, "got error %lu\n", GetLastError());
+
+    ret = ResetEvent( handle );
+    ok(ret, "got error %lu\n", GetLastError());
+
+    ret = WaitForSingleObject( handle, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    handle2 = CreateEventA( NULL, FALSE, TRUE, NULL );
+    ok(!!handle2, "got error %lu\n", GetLastError());
+
+    ret = WaitForSingleObject( handle2, 0 );
+    ok(ret == 0, "got %lu\n", ret);
+
+    ret = WaitForSingleObject( handle2, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    ret = SetEvent( handle2 );
+    ok(ret, "got error %lu\n", GetLastError());
+
+    ret = SetEvent( handle2 );
+    ok(ret, "got error %lu\n", GetLastError());
+
+    ret = ResetEvent( handle2 );
+    ok(ret, "got error %lu\n", GetLastError());
+
+    ret = ResetEvent( handle2 );
+    ok(ret, "got error %lu\n", GetLastError());
+
+    ret = WaitForSingleObject( handle2, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    handles[0] = handle;
+    handles[1] = handle2;
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    SetEvent( handle );
+    SetEvent( handle2 );
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 0, "got %lu\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 0, "got %lu\n", ret);
+
+    ret = WaitForSingleObject( handle2, 0 );
+    ok(ret == 0, "got %lu\n", ret);
+
+    ResetEvent( handle );
+    SetEvent( handle2 );
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 1, "got %lu\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    SetEvent( handle );
+    SetEvent( handle2 );
+
+    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
+    ok(ret == 0, "got %lu\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    SetEvent( handle2 );
+    ResetEvent( handle );
+
+    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    ret = WaitForSingleObject( handle2, 0 );
+    ok(ret == 0, "got %lu\n", ret);
+
+    handles[0] = handle2;
+    handles[1] = handle;
+    SetEvent( handle );
+    SetEvent( handle2 );
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 0, "got %lu\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 1, "got %lu\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 1, "got %lu\n", ret);
+
+    ret = CloseHandle( handle );
+    ok(ret, "got error %lu\n", GetLastError());
+
+    ret = CloseHandle( handle2 );
+    ok(ret, "got error %lu\n", GetLastError());
 }
 
 static void test_semaphore(void)
 {
-    HANDLE handle, handle2;
+    HANDLE handle, handle2, handles[2];
+    DWORD ret;
+    LONG prev;
+    int i;
 
     /* test case sensitivity */
 
@@ -727,6 +850,99 @@ static void test_semaphore(void)
     ok( GetLastError() == ERROR_INVALID_PARAMETER, "wrong error %lu\n", GetLastError());
 
     CloseHandle( handle );
+
+    handle = CreateSemaphoreA( NULL, 0, 5, NULL );
+    ok(!!handle, "CreateSemaphore failed: %lu\n", GetLastError());
+
+    ret = WaitForSingleObject( handle, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    ret = ReleaseSemaphore( handle, 1, &prev );
+    ok(ret, "got error %lu\n", GetLastError());
+    ok(prev == 0, "got prev %ld\n", prev);
+
+    ret = ReleaseSemaphore( handle, 1, &prev );
+    ok(ret, "got error %lu\n", GetLastError());
+    ok(prev == 1, "got prev %ld\n", prev);
+
+    ret = ReleaseSemaphore( handle, 5, &prev );
+    ok(!ret, "got %ld\n", ret);
+    ok(GetLastError() == ERROR_TOO_MANY_POSTS, "got error %lu\n", GetLastError());
+    ok(prev == 1, "got prev %ld\n", prev);
+
+    ret = ReleaseSemaphore( handle, 2, &prev );
+    ok(ret, "got error %lu\n", GetLastError());
+    ok(prev == 2, "got prev %ld\n", prev);
+
+    ret = ReleaseSemaphore( handle, 1, &prev );
+    ok(ret, "got error %lu\n", GetLastError());
+    ok(prev == 4, "got prev %ld\n", prev);
+
+    for (i = 0; i < 5; i++)
+    {
+        ret = WaitForSingleObject( handle, 0 );
+        ok(ret == 0, "got %lu\n", ret);
+    }
+
+    ret = WaitForSingleObject( handle, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    handle2 = CreateSemaphoreA( NULL, 3, 5, NULL );
+    ok(!!handle2, "CreateSemaphore failed: %lu\n", GetLastError());
+
+    ret = ReleaseSemaphore( handle2, 1, &prev );
+    ok(ret, "got error %lu\n", GetLastError());
+    ok(prev == 3, "got prev %ld\n", prev);
+
+    for (i = 0; i < 4; i++)
+    {
+        ret = WaitForSingleObject( handle2, 0 );
+        ok(ret == 0, "got %lu\n", ret);
+    }
+
+    ret = WaitForSingleObject( handle2, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    handles[0] = handle;
+    handles[1] = handle2;
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    ReleaseSemaphore( handle, 1, NULL );
+    ReleaseSemaphore( handle2, 1, NULL );
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 0, "got %lu\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 1, "got %lu\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    ReleaseSemaphore( handle, 1, NULL );
+    ReleaseSemaphore( handle2, 1, NULL );
+
+    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
+    ok(ret == 0, "got %lu\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    ReleaseSemaphore( handle, 1, NULL );
+
+    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    ret = WaitForSingleObject( handle, 0 );
+    ok(ret == 0, "got %lu\n", ret);
+
+    ret = CloseHandle( handle );
+    ok(ret, "got error %lu\n", ret);
+
+    ret = CloseHandle( handle2 );
+    ok(ret, "got error %lu\n", ret);
 }
 
 static void test_waitable_timer(void)
@@ -1281,11 +1497,15 @@ static HANDLE modify_handle(HANDLE handl
     return ULongToHandle(tmp);
 }
 
+#define TIMEOUT_INFINITE (((LONGLONG)0x7fffffff) << 32 | 0xffffffff)
+
 static void test_WaitForSingleObject(void)
 {
     HANDLE signaled, nonsignaled, invalid;
+    LARGE_INTEGER ntnow, ntthen;
     LARGE_INTEGER timeout;
     NTSTATUS status;
+    DWORD now, then;
     DWORD ret;
 
     signaled = CreateEventW(NULL, TRUE, TRUE, NULL);
@@ -1370,6 +1590,68 @@ static void test_WaitForSingleObject(voi
     status = pNtWaitForSingleObject(GetCurrentThread(), FALSE, &timeout);
     ok(status == STATUS_TIMEOUT, "expected STATUS_TIMEOUT, got %08lx\n", status);
 
+    ret = WaitForSingleObject( signaled, 0 );
+    ok(ret == 0, "got %lu\n", ret);
+
+    ret = WaitForSingleObject( nonsignaled, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    /* test that a timed wait actually does wait */
+    now = GetTickCount();
+    ret = WaitForSingleObject( nonsignaled, 100 );
+    then = GetTickCount();
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+    ok(abs((then - now) - 100) < 5, "got %lu ms\n", then - now);
+
+    now = GetTickCount();
+    ret = WaitForSingleObject( signaled, 100 );
+    then = GetTickCount();
+    ok(ret == 0, "got %lu\n", ret);
+    ok(abs(then - now) < 5, "got %lu ms\n", then - now);
+
+    ret = WaitForSingleObject( signaled, INFINITE );
+    ok(ret == 0, "got %lu\n", ret);
+
+    /* test NT timeouts */
+    pNtQuerySystemTime( &ntnow );
+    timeout.QuadPart = ntnow.QuadPart + 100 * 10000;
+    status = pNtWaitForSingleObject( nonsignaled, FALSE, &timeout );
+    pNtQuerySystemTime( &ntthen );
+    ok(status == STATUS_TIMEOUT, "got %#lx\n", status);
+    ok(abs(((ntthen.QuadPart - ntnow.QuadPart) / 10000) - 100) < 5, "got %s ns\n",
+        wine_dbgstr_longlong((ntthen.QuadPart - ntnow.QuadPart) * 100));
+
+    pNtQuerySystemTime( &ntnow );
+    timeout.QuadPart = -100 * 10000;
+    status = pNtWaitForSingleObject( nonsignaled, FALSE, &timeout );
+    pNtQuerySystemTime( &ntthen );
+    ok(status == STATUS_TIMEOUT, "got %#lx\n", status);
+    ok(abs(((ntthen.QuadPart - ntnow.QuadPart) / 10000) - 100) < 5, "got %s ns\n",
+        wine_dbgstr_longlong((ntthen.QuadPart - ntnow.QuadPart) * 100));
+
+    status = pNtWaitForSingleObject( signaled, FALSE, NULL );
+    ok(status == 0, "got %#lx\n", status);
+
+    timeout.QuadPart = TIMEOUT_INFINITE;
+    status = pNtWaitForSingleObject( signaled, FALSE, &timeout );
+    ok(status == 0, "got %#lx\n", status);
+
+    pNtQuerySystemTime( &ntnow );
+    timeout.QuadPart = ntnow.QuadPart;
+    status = pNtWaitForSingleObject( nonsignaled, FALSE, &timeout );
+    pNtQuerySystemTime( &ntthen );
+    ok(status == STATUS_TIMEOUT, "got %#lx\n", status);
+    ok(abs((ntthen.QuadPart - ntnow.QuadPart) / 10000) < 5, "got %s ns\n",
+        wine_dbgstr_longlong((ntthen.QuadPart - ntnow.QuadPart) * 100));
+
+    pNtQuerySystemTime( &ntnow );
+    timeout.QuadPart = ntnow.QuadPart - 100 * 10000;
+    status = pNtWaitForSingleObject( nonsignaled, FALSE, &timeout );
+    pNtQuerySystemTime( &ntthen );
+    ok(status == STATUS_TIMEOUT, "got %#lx\n", status);
+    ok(abs((ntthen.QuadPart - ntnow.QuadPart) / 10000) < 5, "got %s ns\n",
+        wine_dbgstr_longlong((ntthen.QuadPart - ntnow.QuadPart) * 100));
+
     CloseHandle(signaled);
     CloseHandle(nonsignaled);
 }
@@ -2992,6 +3274,84 @@ static void test_QueueUserAPC(void)
     }
 }
 
+static int zigzag_state, zigzag_count[2], zigzag_stop;
+
+static DWORD CALLBACK zigzag_event0(void *arg)
+{
+    HANDLE *events = arg;
+
+    while (!zigzag_stop)
+    {
+        WaitForSingleObject(events[0], INFINITE);
+        ResetEvent(events[0]);
+        ok(zigzag_state == 0, "got wrong state %d\n", zigzag_state);
+        zigzag_state++;
+        SetEvent(events[1]);
+        zigzag_count[0]++;
+    }
+    trace("thread 0 got done\n");
+    return 0;
+}
+
+static DWORD CALLBACK zigzag_event1(void *arg)
+{
+    HANDLE *events = arg;
+
+    while (!zigzag_stop)
+    {
+        WaitForSingleObject(events[1], INFINITE);
+        ResetEvent(events[1]);
+        ok(zigzag_state == 1, "got wrong state %d\n", zigzag_state);
+        zigzag_state--;
+        SetEvent(events[0]);
+        zigzag_count[1]++;
+    }
+    trace("thread 1 got done\n");
+    return 0;
+}
+
+static void test_zigzag_event(void)
+{
+    /* The basic idea is to test SetEvent/Wait back and forth between two
+     * threads. Each thread clears their own event, sets some common data,
+     * signals the other's, then waits on their own. We make sure the common
+     * data is always in the right state. We also print performance data. */
+
+    HANDLE threads[2], events[2];
+    BOOL ret;
+
+    events[0] = CreateEventA(NULL, FALSE, FALSE, NULL);
+    events[1] = CreateEventA(NULL, FALSE, FALSE, NULL);
+
+    threads[0] = CreateThread(NULL, 0, zigzag_event0, events, 0, NULL);
+    threads[1] = CreateThread(NULL, 0, zigzag_event1, events, 0, NULL);
+
+    zigzag_state = 0;
+    zigzag_count[0] = zigzag_count[1] = 0;
+    zigzag_stop = 0;
+
+    trace("starting zigzag test (events)\n");
+    SetEvent(events[0]);
+    Sleep(2000);
+    zigzag_stop = 1;
+    ret = WaitForMultipleObjects(2, threads, FALSE, INFINITE);
+    trace("%d\n", ret);
+    ok(ret == 0 || ret == 1, "wait failed: %u\n", ret);
+
+    ok(zigzag_count[0] == zigzag_count[1] || zigzag_count[0] == zigzag_count[1] + 1,
+        "count did not match: %d != %d\n", zigzag_count[0], zigzag_count[1]);
+
+    /* signal the other thread to finish, if it didn't already
+     * (in theory they both would at the same time, but there's a slight race on teardown if we get
+     * thread 1 SetEvent -> thread 0 ResetEvent -> thread 0 Wait -> thread 1 exits */
+    zigzag_state = 1-ret;
+    SetEvent(events[1-ret]);
+    ret = WaitForSingleObject(threads[1-ret], 1000);
+    ok(!ret, "wait failed: %u\n", ret);
+
+    trace("count: %d\n", zigzag_count[0]);
+}
+
 START_TEST(sync)
 {
     char **argv;
@@ -3019,6 +3379,7 @@ START_TEST(sync)
     pQueueUserAPC2 = (void *)GetProcAddress(hdll, "QueueUserAPC2");
     pNtAllocateVirtualMemory = (void *)GetProcAddress(hntdll, "NtAllocateVirtualMemory");
     pNtFreeVirtualMemory = (void *)GetProcAddress(hntdll, "NtFreeVirtualMemory");
+    pNtQuerySystemTime = (void *)GetProcAddress(hntdll, "NtQuerySystemTime");
     pNtWaitForSingleObject = (void *)GetProcAddress(hntdll, "NtWaitForSingleObject");
     pNtWaitForMultipleObjects = (void *)GetProcAddress(hntdll, "NtWaitForMultipleObjects");
     pRtlInterlockedPushListSList = (void *)GetProcAddress(hntdll, "RtlInterlockedPushListSList");
@@ -3063,5 +3424,6 @@ START_TEST(sync)
     test_srwlock_example();
     test_alertable_wait();
     test_apc_deadlock();
+    test_zigzag_event();
     test_crit_section();
 }
diff -ruN --show-c-function dlls/kernel32/tests/sync.c.orig dlls/kernel32/tests/sync.c.orig
--- dlls/kernel32/tests/sync.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ dlls/kernel32/tests/sync.c.orig	2025-10-10 10:22:12.146264450 -0700
@@ -0,0 +1,3067 @@
+/*
+ * Synchronization tests
+ *
+ * Copyright 2005 Mike McCormack for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include <windef.h>
+#include <winbase.h>
+#include <winternl.h>
+#include <setjmp.h>
+
+#include "wine/test.h"
+
+#undef __fastcall
+#define __fastcall __stdcall
+
+static HANDLE (WINAPI *pCreateMemoryResourceNotification)(MEMORY_RESOURCE_NOTIFICATION_TYPE);
+static BOOL   (WINAPI *pQueryMemoryResourceNotification)(HANDLE, PBOOL);
+static VOID   (WINAPI *pInitOnceInitialize)(PINIT_ONCE);
+static BOOL   (WINAPI *pInitOnceExecuteOnce)(PINIT_ONCE,PINIT_ONCE_FN,PVOID,LPVOID*);
+static BOOL   (WINAPI *pInitOnceBeginInitialize)(PINIT_ONCE,DWORD,BOOL*,LPVOID*);
+static BOOL   (WINAPI *pInitOnceComplete)(PINIT_ONCE,DWORD,LPVOID);
+
+static BOOL   (WINAPI *pInitializeCriticalSectionEx)(CRITICAL_SECTION*,DWORD,DWORD);
+static VOID   (WINAPI *pInitializeConditionVariable)(PCONDITION_VARIABLE);
+static BOOL   (WINAPI *pSleepConditionVariableCS)(PCONDITION_VARIABLE,PCRITICAL_SECTION,DWORD);
+static BOOL   (WINAPI *pSleepConditionVariableSRW)(PCONDITION_VARIABLE,PSRWLOCK,DWORD,ULONG);
+static VOID   (WINAPI *pWakeAllConditionVariable)(PCONDITION_VARIABLE);
+static VOID   (WINAPI *pWakeConditionVariable)(PCONDITION_VARIABLE);
+
+static VOID   (WINAPI *pInitializeSRWLock)(PSRWLOCK);
+static VOID   (WINAPI *pAcquireSRWLockExclusive)(PSRWLOCK);
+static VOID   (WINAPI *pAcquireSRWLockShared)(PSRWLOCK);
+static VOID   (WINAPI *pReleaseSRWLockExclusive)(PSRWLOCK);
+static VOID   (WINAPI *pReleaseSRWLockShared)(PSRWLOCK);
+static BOOLEAN (WINAPI *pTryAcquireSRWLockExclusive)(PSRWLOCK);
+static BOOLEAN (WINAPI *pTryAcquireSRWLockShared)(PSRWLOCK);
+
+static DWORD (WINAPI *pQueueUserAPC2)(PAPCFUNC,HANDLE,ULONG_PTR,QUEUE_USER_APC_FLAGS);
+
+static NTSTATUS (WINAPI *pNtAllocateVirtualMemory)(HANDLE, PVOID *, ULONG_PTR, SIZE_T *, ULONG, ULONG);
+static NTSTATUS (WINAPI *pNtFreeVirtualMemory)(HANDLE, PVOID *, SIZE_T *, ULONG);
+static NTSTATUS (WINAPI *pNtWaitForSingleObject)(HANDLE, BOOLEAN, const LARGE_INTEGER *);
+static NTSTATUS (WINAPI *pNtWaitForMultipleObjects)(ULONG,const HANDLE*,BOOLEAN,BOOLEAN,const LARGE_INTEGER*);
+static PSLIST_ENTRY (__fastcall *pRtlInterlockedPushListSList)(PSLIST_HEADER list, PSLIST_ENTRY first,
+                                                               PSLIST_ENTRY last, ULONG count);
+static PSLIST_ENTRY (WINAPI *pRtlInterlockedPushListSListEx)(PSLIST_HEADER list, PSLIST_ENTRY first,
+                                                             PSLIST_ENTRY last, ULONG count);
+static NTSTATUS (WINAPI *pNtQueueApcThread)(HANDLE,PNTAPCFUNC,ULONG_PTR,ULONG_PTR,ULONG_PTR);
+static NTSTATUS (WINAPI *pNtTestAlert)(void);
+
+#ifdef __i386__
+
+#pragma pack(push,1)
+struct fastcall_thunk
+{
+    BYTE pop_edx;   /* popl %edx            (ret addr) */
+    BYTE pop_eax;   /* popl %eax            (func) */
+    BYTE pop_ecx;   /* popl %ecx            (param 1) */
+    BYTE xchg[3];   /* xchgl (%esp),%edx    (param 2) */
+    WORD jmp_eax;   /* jmp  *%eax */
+};
+#pragma pack(pop)
+
+static void * (WINAPI *call_fastcall_func4)(void *func, const void *a, const void *b, const void *c, const void *d);
+
+static void init_fastcall_thunk(void)
+{
+    struct fastcall_thunk *thunk = VirtualAlloc(NULL, sizeof(*thunk), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
+    thunk->pop_edx = 0x5a;      /* popl  %edx */
+    thunk->pop_eax = 0x58;      /* popl  %eax */
+    thunk->pop_ecx = 0x59;      /* popl  %ecx */
+    thunk->xchg[0] = 0x87;      /* xchgl (%esp),%edx */
+    thunk->xchg[1] = 0x14;
+    thunk->xchg[2] = 0x24;
+    thunk->jmp_eax = 0xe0ff;    /* jmp *%eax */
+    call_fastcall_func4 = (void *)thunk;
+}
+
+#define call_func4(func, a, b, c, d) call_fastcall_func4(func, (const void *)(a), \
+        (const void *)(b), (const void *)(c), (const void *)(d))
+
+#else  /* __i386__ */
+
+#define init_fastcall_thunk() do { } while(0)
+#define call_func4(func, a, b, c, d) func(a, b, c, d)
+
+#endif /* __i386__ */
+
+static void test_signalandwait(void)
+{
+    DWORD r;
+    HANDLE event[2], semaphore[2], file;
+    int i;
+
+    /* invalid parameters */
+    r = SignalObjectAndWait(NULL, NULL, 0, 0);
+    ok( r == WAIT_FAILED, "should fail\n");
+
+    event[0] = CreateEventW(NULL, 0, 0, NULL);
+    event[1] = CreateEventW(NULL, 1, 1, NULL);
+
+    ok( event[0] && event[1], "failed to create event flags\n");
+
+    r = SignalObjectAndWait(event[0], NULL, 0, FALSE);
+    ok( r == WAIT_FAILED, "should fail\n");
+
+    r = SignalObjectAndWait(NULL, event[0], 0, FALSE);
+    ok( r == WAIT_FAILED, "should fail\n");
+
+
+    /* valid parameters */
+    r = SignalObjectAndWait(event[0], event[1], 0, FALSE);
+    ok( r == WAIT_OBJECT_0, "should succeed\n");
+
+    /* event[0] is now signalled - we repeat this test multiple times
+     * to ensure that the wineserver handles this situation properly. */
+    for (i = 0; i < 10000; i++)
+    {
+        r = SignalObjectAndWait(event[0], event[0], 0, FALSE);
+        ok(r == WAIT_OBJECT_0, "should succeed\n");
+    }
+
+    /* event[0] is not signalled */
+    r = WaitForSingleObject(event[0], 0);
+    ok( r == WAIT_TIMEOUT, "event was signalled\n");
+
+    r = SignalObjectAndWait(event[0], event[0], 0, FALSE);
+    ok( r == WAIT_OBJECT_0, "should succeed\n");
+
+    /* clear event[1] and check for a timeout */
+    ok(ResetEvent(event[1]), "failed to clear event[1]\n");
+    r = SignalObjectAndWait(event[0], event[1], 0, FALSE);
+    ok( r == WAIT_TIMEOUT, "should timeout\n");
+
+    CloseHandle(event[0]);
+    CloseHandle(event[1]);
+
+    /* semaphores */
+    semaphore[0] = CreateSemaphoreW( NULL, 0, 1, NULL );
+    semaphore[1] = CreateSemaphoreW( NULL, 1, 1, NULL );
+    ok( semaphore[0] && semaphore[1], "failed to create semaphore\n");
+
+    r = SignalObjectAndWait(semaphore[0], semaphore[1], 0, FALSE);
+    ok( r == WAIT_OBJECT_0, "should succeed\n");
+
+    r = SignalObjectAndWait(semaphore[0], semaphore[1], 0, FALSE);
+    ok( r == WAIT_FAILED, "should fail\n");
+
+    r = ReleaseSemaphore(semaphore[0],1,NULL);
+    ok( r == FALSE, "should fail\n");
+
+    r = ReleaseSemaphore(semaphore[1],1,NULL);
+    ok( r == TRUE, "should succeed\n");
+
+    CloseHandle(semaphore[0]);
+    CloseHandle(semaphore[1]);
+
+    /* try a registry key */
+    file = CreateFileA("x", GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
+        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE, NULL);
+    r = SignalObjectAndWait(file, file, 0, FALSE);
+    ok( r == WAIT_FAILED, "should fail\n");
+    ok( ERROR_INVALID_HANDLE == GetLastError(), "should return invalid handle error\n");
+    CloseHandle(file);
+}
+
+static void test_temporary_objects(void)
+{
+    HANDLE handle;
+
+    SetLastError(0xdeadbeef);
+    handle = CreateMutexA(NULL, FALSE, "WineTestMutex2");
+    ok(handle != NULL, "CreateMutex failed with error %ld\n", GetLastError());
+    CloseHandle(handle);
+
+    SetLastError(0xdeadbeef);
+    handle = OpenMutexA(READ_CONTROL, FALSE, "WineTestMutex2");
+    ok(!handle, "OpenMutex succeeded\n");
+    ok(GetLastError() == ERROR_FILE_NOT_FOUND, "wrong error %lu\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    handle = CreateSemaphoreA(NULL, 0, 1, "WineTestSemaphore2");
+    ok(handle != NULL, "CreateSemaphore failed with error %ld\n", GetLastError());
+    CloseHandle(handle);
+
+    SetLastError(0xdeadbeef);
+    handle = OpenSemaphoreA(READ_CONTROL, FALSE, "WineTestSemaphore2");
+    ok(!handle, "OpenSemaphore succeeded\n");
+    ok(GetLastError() == ERROR_FILE_NOT_FOUND, "wrong error %lu\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    handle = CreateEventA(NULL, FALSE, FALSE, "WineTestEvent2");
+    ok(handle != NULL, "CreateEvent failed with error %ld\n", GetLastError());
+    CloseHandle(handle);
+
+    SetLastError(0xdeadbeef);
+    handle = OpenEventA(READ_CONTROL, FALSE, "WineTestEvent2");
+    ok(!handle, "OpenEvent succeeded\n");
+    ok(GetLastError() == ERROR_FILE_NOT_FOUND, "wrong error %lu\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    handle = CreateWaitableTimerA(NULL, FALSE, "WineTestWaitableTimer2");
+    ok(handle != NULL, "CreateWaitableTimer failed with error %ld\n", GetLastError());
+    CloseHandle(handle);
+
+    SetLastError(0xdeadbeef);
+    handle = OpenWaitableTimerA(READ_CONTROL, FALSE, "WineTestWaitableTimer2");
+    ok(!handle, "OpenWaitableTimer succeeded\n");
+    ok(GetLastError() == ERROR_FILE_NOT_FOUND, "wrong error %lu\n", GetLastError());
+}
+
+struct test_mutex_thread_params
+{
+    HANDLE mutex;
+    HANDLE start_event;
+    HANDLE stop_event;
+    BOOL owner;
+};
+
+static DWORD WINAPI test_mutex_thread(void *arg)
+{
+    struct test_mutex_thread_params *params = arg;
+    DWORD ret;
+
+    ret = WaitForSingleObject(params->mutex, INFINITE);
+    if (params->owner) ok(!ret, "got %#lx\n", ret);
+    else ok(ret == WAIT_ABANDONED, "got %#lx\n", ret);
+    SetEvent(params->start_event);
+
+    ret = WaitForSingleObject(params->stop_event, INFINITE);
+    ok(!ret, "got %#lx\n", ret);
+    return 0;
+}
+
+static void test_mutex(void)
+{
+    DWORD wait_ret;
+    BOOL ret;
+    HANDLE hCreated, hOpened, owner_thread, waiter_thread;
+    struct test_mutex_thread_params params;
+    int i;
+    DWORD failed = 0;
+
+    SetLastError(0xdeadbeef);
+    hOpened = OpenMutexA(0, FALSE, "WineTestMutex");
+    ok(hOpened == NULL, "OpenMutex succeeded\n");
+    ok(GetLastError() == ERROR_FILE_NOT_FOUND, "wrong error %lu\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    hCreated = CreateMutexA(NULL, FALSE, "WineTestMutex");
+    ok(hCreated != NULL, "CreateMutex failed with error %ld\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    hOpened = OpenMutexA(0, FALSE, "WineTestMutex");
+    ok(hOpened == NULL, "OpenMutex succeeded\n");
+    ok(GetLastError() == ERROR_ACCESS_DENIED, "wrong error %lu\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    hOpened = OpenMutexA(GENERIC_EXECUTE, FALSE, "WineTestMutex");
+    ok(hOpened != NULL, "OpenMutex failed with error %ld\n", GetLastError());
+    wait_ret = WaitForSingleObject(hOpened, INFINITE);
+    ok(wait_ret == WAIT_OBJECT_0, "WaitForSingleObject failed with error %ld\n", GetLastError());
+    CloseHandle(hOpened);
+
+    for(i=0; i < 31; i++)
+    {
+        wait_ret = WaitForSingleObject(hCreated, INFINITE);
+        ok(wait_ret == WAIT_OBJECT_0, "WaitForSingleObject failed with error 0x%08lx\n", wait_ret);
+    }
+
+    SetLastError(0xdeadbeef);
+    hOpened = OpenMutexA(GENERIC_READ | GENERIC_WRITE, FALSE, "WineTestMutex");
+    ok(hOpened != NULL, "OpenMutex failed with error %ld\n", GetLastError());
+    wait_ret = WaitForSingleObject(hOpened, INFINITE);
+    ok(wait_ret == WAIT_FAILED, "WaitForSingleObject succeeded\n");
+    CloseHandle(hOpened);
+
+    for (i = 0; i < 32; i++)
+    {
+        SetLastError(0xdeadbeef);
+        hOpened = OpenMutexA(0x1 << i, FALSE, "WineTestMutex");
+        if(hOpened != NULL)
+        {
+            SetLastError(0xdeadbeef);
+            ret = ReleaseMutex(hOpened);
+            ok(ret, "ReleaseMutex failed with error %ld, access %x\n", GetLastError(), 1 << i);
+            CloseHandle(hOpened);
+        }
+        else
+        {
+            if ((1 << i) == ACCESS_SYSTEM_SECURITY)
+                todo_wine ok(GetLastError() == ERROR_PRIVILEGE_NOT_HELD, "wrong error %lu, access %x\n", GetLastError(), 1 << i);
+            else
+                ok(GetLastError() == ERROR_ACCESS_DENIED, "wrong error %lu, , access %x\n", GetLastError(), 1 << i);
+            ReleaseMutex(hCreated);
+            failed |=0x1 << i;
+        }
+    }
+
+    todo_wine
+    ok( failed == 0x0de0fffe, "open succeeded when it shouldn't: %lx\n", failed);
+
+    SetLastError(0xdeadbeef);
+    ret = ReleaseMutex(hCreated);
+    ok(!ret && (GetLastError() == ERROR_NOT_OWNER),
+        "ReleaseMutex should have failed with ERROR_NOT_OWNER instead of %ld\n", GetLastError());
+
+    /* test case sensitivity */
+
+    SetLastError(0xdeadbeef);
+    hOpened = OpenMutexA(READ_CONTROL, FALSE, "WINETESTMUTEX");
+    ok(!hOpened, "OpenMutex succeeded\n");
+    ok(GetLastError() == ERROR_FILE_NOT_FOUND, "wrong error %lu\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    hOpened = OpenMutexA(READ_CONTROL, FALSE, "winetestmutex");
+    ok(!hOpened, "OpenMutex succeeded\n");
+    ok(GetLastError() == ERROR_FILE_NOT_FOUND, "wrong error %lu\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    hOpened = OpenMutexA(READ_CONTROL, FALSE, NULL);
+    ok(!hOpened, "OpenMutex succeeded\n");
+    ok(GetLastError() == ERROR_INVALID_PARAMETER, "wrong error %lu\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    hOpened = OpenMutexW(READ_CONTROL, FALSE, NULL);
+    ok(!hOpened, "OpenMutex succeeded\n");
+    ok(GetLastError() == ERROR_INVALID_PARAMETER, "wrong error %lu\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    hOpened = CreateMutexA(NULL, FALSE, "WineTestMutex");
+    ok(hOpened != NULL, "CreateMutex failed with error %ld\n", GetLastError());
+    ok(GetLastError() == ERROR_ALREADY_EXISTS, "wrong error %lu\n", GetLastError());
+    CloseHandle(hOpened);
+
+    SetLastError(0xdeadbeef);
+    hOpened = CreateMutexA(NULL, FALSE, "WINETESTMUTEX");
+    ok(hOpened != NULL, "CreateMutex failed with error %ld\n", GetLastError());
+    ok(GetLastError() == 0, "wrong error %lu\n", GetLastError());
+    CloseHandle(hOpened);
+
+    CloseHandle(hCreated);
+
+    params.start_event = CreateEventW(NULL, FALSE, FALSE, NULL);
+    params.stop_event = CreateEventW(NULL, FALSE, FALSE, NULL);
+    params.mutex = CreateMutexA(NULL, FALSE, NULL);
+
+    params.owner = TRUE;
+    owner_thread = CreateThread(NULL, 0, test_mutex_thread, &params, 0, NULL);
+    ok(!!owner_thread, "CreateThread failed, error %lu\n", GetLastError());
+    ret = WaitForSingleObject(params.start_event, 1000);
+    ok(!ret, "got %#x\n", ret);
+
+    params.owner = FALSE;
+    waiter_thread = CreateThread(NULL, 0, test_mutex_thread, &params, 0, NULL);
+    ok(!!waiter_thread, "CreateThread failed, error %lu\n", GetLastError());
+    ret = WaitForSingleObject(params.start_event, 100);
+    ok(ret == WAIT_TIMEOUT, "got %#x\n", ret);
+
+    CloseHandle(params.mutex);
+    ret = WaitForSingleObject(params.start_event, 100);
+    ok(ret == WAIT_TIMEOUT, "got %#x\n", ret);
+
+    TerminateThread(owner_thread, 0);
+    ret = WaitForSingleObject(owner_thread, 1000);
+    ok(!ret, "got %#x\n", ret);
+    ret = WaitForSingleObject(params.start_event, 1000);
+    ok(!ret, "got %#x\n", ret);
+
+    SetEvent(params.stop_event);
+    ret = WaitForSingleObject(waiter_thread, 1000);
+    ok(!ret, "got %#x\n", ret);
+
+    CloseHandle(owner_thread);
+    CloseHandle(waiter_thread);
+
+    CloseHandle(params.start_event);
+    CloseHandle(params.stop_event);
+}
+
+static void test_slist(void)
+{
+    struct item
+    {
+        SLIST_ENTRY entry;
+        int value;
+    } item1, item2, item3, *item;
+    SLIST_HEADER slist_header;
+    SLIST_ENTRY *entry;
+    USHORT size;
+    int i;
+
+    item1.value = 1;
+    item2.value = 2;
+    item3.value = 3;
+
+    memset(&slist_header, 0xff, sizeof(slist_header));
+    InitializeSListHead(&slist_header);
+    size = QueryDepthSList(&slist_header);
+    ok(size == 0, "Expected size == 0, got %u\n", size);
+
+    /* test PushEntry, PopEntry and Flush */
+    entry = InterlockedPushEntrySList(&slist_header, &item1.entry);
+    ok(entry == NULL, "Expected entry == NULL, got %p\n", entry);
+    size = QueryDepthSList(&slist_header);
+    ok(size == 1, "Expected size == 1, got %u\n", size);
+
+    entry = InterlockedPushEntrySList(&slist_header, &item2.entry);
+    ok(entry != NULL, "Expected entry != NULL, got %p\n", entry);
+    item = CONTAINING_RECORD(entry, struct item, entry);
+    ok(item->value == 1, "Expected item->value == 1, got %u\n", item->value);
+    size = QueryDepthSList(&slist_header);
+    ok(size == 2, "Expected size == 2, got %u\n", size);
+
+    entry = InterlockedPushEntrySList(&slist_header, &item3.entry);
+    ok(entry != NULL, "Expected entry != NULL, got %p\n", entry);
+    item = CONTAINING_RECORD(entry, struct item, entry);
+    ok(item->value == 2, "Expected item->value == 2, got %u\n", item->value);
+    size = QueryDepthSList(&slist_header);
+    ok(size == 3, "Expected size == 3, got %u\n", size);
+
+    entry = InterlockedPopEntrySList(&slist_header);
+    ok(entry != NULL, "Expected entry != NULL, got %p\n", entry);
+    item = CONTAINING_RECORD(entry, struct item, entry);
+    ok(item->value == 3, "Expected item->value == 3, got %u\n", item->value);
+    size = QueryDepthSList(&slist_header);
+    ok(size == 2, "Expected size == 2, got %u\n", size);
+
+    entry = InterlockedFlushSList(&slist_header);
+    ok(entry != NULL, "Expected entry != NULL, got %p\n", entry);
+    item = CONTAINING_RECORD(entry, struct item, entry);
+    ok(item->value == 2, "Expected item->value == 2, got %u\n", item->value);
+    item = CONTAINING_RECORD(item->entry.Next, struct item, entry);
+    ok(item->value == 1, "Expected item->value == 1, got %u\n", item->value);
+    size = QueryDepthSList(&slist_header);
+    ok(size == 0, "Expected size == 0, got %u\n", size);
+    entry = InterlockedPopEntrySList(&slist_header);
+    ok(entry == NULL, "Expected entry == NULL, got %p\n", entry);
+
+    /* test RtlInterlockedPushListSList */
+    entry = InterlockedPushEntrySList(&slist_header, &item3.entry);
+    ok(entry == NULL, "Expected entry == NULL, got %p\n", entry);
+    entry = call_func4(pRtlInterlockedPushListSList, &slist_header, &item2.entry, &item1.entry, 42);
+    ok(entry != NULL, "Expected entry != NULL, got %p\n", entry);
+    item = CONTAINING_RECORD(entry, struct item, entry);
+    ok(item->value == 3, "Expected item->value == 3, got %u\n", item->value);
+    size = QueryDepthSList(&slist_header);
+    ok(size == 43, "Expected size == 43, got %u\n", size);
+
+    entry = InterlockedPopEntrySList(&slist_header);
+    ok(entry != NULL, "Expected entry != NULL, got %p\n", entry);
+    item = CONTAINING_RECORD(entry, struct item, entry);
+    ok(item->value == 2, "Expected item->value == 2, got %u\n", item->value);
+    size = QueryDepthSList(&slist_header);
+    ok(size == 42, "Expected size == 42, got %u\n", size);
+
+    entry = InterlockedPopEntrySList(&slist_header);
+    ok(entry != NULL, "Expected entry != NULL, got %p\n", entry);
+    item = CONTAINING_RECORD(entry, struct item, entry);
+    ok(item->value == 1, "Expected item->value == 1, got %u\n", item->value);
+    size = QueryDepthSList(&slist_header);
+    ok(size == 41, "Expected size == 41, got %u\n", size);
+
+    entry = InterlockedPopEntrySList(&slist_header);
+    ok(entry != NULL, "Expected entry != NULL, got %p\n", entry);
+    item = CONTAINING_RECORD(entry, struct item, entry);
+    ok(item->value == 3, "Expected item->value == 3, got %u\n", item->value);
+    size = QueryDepthSList(&slist_header);
+    ok(size == 40, "Expected size == 40, got %u\n", size);
+
+    entry = InterlockedPopEntrySList(&slist_header);
+    ok(entry == NULL, "Expected entry == NULL, got %p\n", entry);
+    size = QueryDepthSList(&slist_header);
+    ok(size == 40, "Expected size == 40, got %u\n", size);
+
+    entry = InterlockedFlushSList(&slist_header);
+    ok(entry == NULL, "Expected entry == NULL, got %p\n", entry);
+    size = QueryDepthSList(&slist_header);
+    ok(size == 40 || broken(size == 0) /* >= Win 8 */, "Expected size == 40, got %u\n", size);
+
+    entry = InterlockedPushEntrySList(&slist_header, &item1.entry);
+    ok(entry == NULL, "Expected entry == NULL, got %p\n", entry);
+    entry = InterlockedFlushSList(&slist_header);
+    ok(entry != NULL, "Expected entry != NULL, got %p\n", entry);
+    item = CONTAINING_RECORD(entry, struct item, entry);
+    ok(item->value == 1, "Expected item->value == 1, got %u\n", item->value);
+    size = QueryDepthSList(&slist_header);
+    ok(size == 0, "Expected size == 0, got %u\n", size);
+
+    /* test RtlInterlockedPushListSListEx */
+    if (pRtlInterlockedPushListSListEx)
+    {
+        entry = InterlockedPushEntrySList(&slist_header, &item3.entry);
+        ok(entry == NULL, "Expected entry == NULL, got %p\n", entry);
+        entry = pRtlInterlockedPushListSListEx(&slist_header, &item2.entry, &item1.entry, 42);
+        ok(entry != NULL, "Expected entry != NULL, got %p\n", entry);
+        item = CONTAINING_RECORD(entry, struct item, entry);
+        ok(item->value == 3, "Expected item->value == 3, got %u\n", item->value);
+        size = QueryDepthSList(&slist_header);
+        ok(size == 43, "Expected size == 43, got %u\n", size);
+
+        entry = InterlockedFlushSList(&slist_header);
+        ok(entry != NULL, "Expected entry != NULL, got %p\n", entry);
+        item = CONTAINING_RECORD(entry, struct item, entry);
+        ok(item->value == 2, "Expected item->value == 2, got %u\n", item->value);
+        item = CONTAINING_RECORD(item->entry.Next, struct item, entry);
+        ok(item->value == 1, "Expected item->value == 1, got %u\n", item->value);
+        item = CONTAINING_RECORD(item->entry.Next, struct item, entry);
+        ok(item->value == 3, "Expected item->value == 3, got %u\n", item->value);
+        size = QueryDepthSList(&slist_header);
+        ok(size == 0, "Expected size == 0, got %u\n", size);
+    }
+    else
+        win_skip("RtlInterlockedPushListSListEx not available, skipping tests\n");
+
+    /* test with a lot of items */
+    for (i = 0; i < 65536; i++)
+    {
+        item = HeapAlloc(GetProcessHeap(), 0, sizeof(*item));
+        item->value = i + 1;
+        entry = InterlockedPushEntrySList(&slist_header, &item->entry);
+        if (i)
+        {
+            ok(entry != NULL, "Expected entry != NULL, got %p\n", entry);
+            item = CONTAINING_RECORD(entry, struct item, entry);
+            ok(item->value == i, "Expected item->value == %u, got %u\n", i, item->value);
+        }
+        else
+        {
+            ok(entry == NULL, "Expected entry == NULL, got %p\n", entry);
+        }
+        size = QueryDepthSList(&slist_header);
+        ok(size == ((i + 1) & 0xffff), "Expected size == %u, got %u\n", (i + 1) & 0xffff, size);
+    }
+
+    entry = InterlockedFlushSList(&slist_header);
+    for (i = 65536; i > 0; i--)
+    {
+        ok(entry != NULL, "Expected entry != NULL, got %p\n", entry);
+        item = CONTAINING_RECORD(entry, struct item, entry);
+        ok(item->value == i, "Expected item->value == %u, got %u\n", i, item->value);
+        entry = item->entry.Next;
+        HeapFree(GetProcessHeap(), 0, item);
+    }
+    ok(entry == NULL, "Expected entry == NULL, got %p\n", entry);
+    size = QueryDepthSList(&slist_header);
+    ok(size == 0, "Expected size == 0, got %u\n", size);
+    entry = InterlockedPopEntrySList(&slist_header);
+    ok(entry == NULL, "Expected entry == NULL, got %p\n", entry);
+}
+
+static void test_event(void)
+{
+    HANDLE handle, handle2;
+    SECURITY_ATTRIBUTES sa;
+    SECURITY_DESCRIPTOR sd;
+    ACL acl;
+    DWORD ret;
+    BOOL val;
+
+    /* no sd */
+    handle = CreateEventA(NULL, FALSE, FALSE, __FILE__ ": Test Event");
+    ok(handle != NULL, "CreateEventW with blank sd failed with error %ld\n", GetLastError());
+    CloseHandle(handle);
+
+    sa.nLength = sizeof(sa);
+    sa.lpSecurityDescriptor = &sd;
+    sa.bInheritHandle = FALSE;
+
+    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
+
+    /* blank sd */
+    handle = CreateEventA(&sa, FALSE, FALSE, __FILE__ ": Test Event");
+    ok(handle != NULL, "CreateEventW with blank sd failed with error %ld\n", GetLastError());
+    CloseHandle(handle);
+
+    /* sd with NULL dacl */
+    SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);
+    handle = CreateEventA(&sa, FALSE, FALSE, __FILE__ ": Test Event");
+    ok(handle != NULL, "CreateEventW with blank sd failed with error %ld\n", GetLastError());
+    CloseHandle(handle);
+
+    /* sd with empty dacl */
+    InitializeAcl(&acl, sizeof(acl), ACL_REVISION);
+    SetSecurityDescriptorDacl(&sd, TRUE, &acl, FALSE);
+    handle = CreateEventA(&sa, FALSE, FALSE, __FILE__ ": Test Event");
+    ok(handle != NULL, "CreateEventW with blank sd failed with error %ld\n", GetLastError());
+    CloseHandle(handle);
+
+    /* test case sensitivity */
+
+    SetLastError(0xdeadbeef);
+    handle = CreateEventA(NULL, FALSE, FALSE, __FILE__ ": Test Event");
+    ok( handle != NULL, "CreateEvent failed with error %lu\n", GetLastError());
+    ok( GetLastError() == 0, "wrong error %lu\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    handle2 = CreateEventA(NULL, FALSE, FALSE, __FILE__ ": Test Event");
+    ok( handle2 != NULL, "CreateEvent failed with error %ld\n", GetLastError());
+    ok( GetLastError() == ERROR_ALREADY_EXISTS, "wrong error %lu\n", GetLastError());
+    CloseHandle( handle2 );
+
+    SetLastError(0xdeadbeef);
+    handle2 = CreateEventA(NULL, FALSE, FALSE, __FILE__ ": TEST EVENT");
+    ok( handle2 != NULL, "CreateEvent failed with error %ld\n", GetLastError());
+    ok( GetLastError() == 0, "wrong error %lu\n", GetLastError());
+    CloseHandle( handle2 );
+
+    SetLastError(0xdeadbeef);
+    handle2 = OpenEventA( EVENT_ALL_ACCESS, FALSE, __FILE__ ": Test Event");
+    ok( handle2 != NULL, "OpenEvent failed with error %ld\n", GetLastError());
+    CloseHandle( handle2 );
+
+    SetLastError(0xdeadbeef);
+    handle2 = OpenEventA( EVENT_ALL_ACCESS, FALSE, __FILE__ ": TEST EVENT");
+    ok( !handle2, "OpenEvent succeeded\n");
+    ok( GetLastError() == ERROR_FILE_NOT_FOUND, "wrong error %lu\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    handle2 = OpenEventA( EVENT_ALL_ACCESS, FALSE, NULL );
+    ok( !handle2, "OpenEvent succeeded\n");
+    ok( GetLastError() == ERROR_INVALID_PARAMETER, "wrong error %lu\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    handle2 = OpenEventW( EVENT_ALL_ACCESS, FALSE, NULL );
+    ok( !handle2, "OpenEvent succeeded\n");
+    ok( GetLastError() == ERROR_INVALID_PARAMETER, "wrong error %lu\n", GetLastError());
+
+    CloseHandle( handle );
+
+    /* resource notifications are events too */
+
+    if (!pCreateMemoryResourceNotification || !pQueryMemoryResourceNotification)
+    {
+        trace( "memory resource notifications not supported\n" );
+        return;
+    }
+    handle = pCreateMemoryResourceNotification( HighMemoryResourceNotification + 1 );
+    ok( !handle, "CreateMemoryResourceNotification succeeded\n" );
+    ok( GetLastError() == ERROR_INVALID_PARAMETER, "wrong error %lu\n", GetLastError() );
+    ret = pQueryMemoryResourceNotification( handle, &val );
+    ok( !ret, "QueryMemoryResourceNotification succeeded\n" );
+    ok( GetLastError() == ERROR_INVALID_PARAMETER, "wrong error %lu\n", GetLastError() );
+
+    handle = pCreateMemoryResourceNotification( LowMemoryResourceNotification );
+    ok( handle != 0, "CreateMemoryResourceNotification failed err %lu\n", GetLastError() );
+    ret = WaitForSingleObject( handle, 10 );
+    ok( ret == WAIT_OBJECT_0 || ret == WAIT_TIMEOUT, "WaitForSingleObject wrong ret %lu\n", ret );
+
+    val = ~0;
+    ret = pQueryMemoryResourceNotification( handle, &val );
+    ok( ret, "QueryMemoryResourceNotification failed err %lu\n", GetLastError() );
+    ok( val == FALSE || val == TRUE, "wrong value %u\n", val );
+    ret = CloseHandle( handle );
+    ok( ret, "CloseHandle failed err %lu\n", GetLastError() );
+
+    handle = CreateEventA(NULL, FALSE, FALSE, __FILE__ ": Test Event");
+    val = ~0;
+    ret = pQueryMemoryResourceNotification( handle, &val );
+    ok( ret, "QueryMemoryResourceNotification failed err %lu\n", GetLastError() );
+    ok( val == FALSE || val == TRUE, "wrong value %u\n", val );
+    CloseHandle( handle );
+}
+
+static void test_semaphore(void)
+{
+    HANDLE handle, handle2;
+
+    /* test case sensitivity */
+
+    SetLastError(0xdeadbeef);
+    handle = CreateSemaphoreA(NULL, 0, 1, __FILE__ ": Test Semaphore");
+    ok(handle != NULL, "CreateSemaphore failed with error %lu\n", GetLastError());
+    ok(GetLastError() == 0, "wrong error %lu\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    handle2 = CreateSemaphoreA(NULL, 0, 1, __FILE__ ": Test Semaphore");
+    ok( handle2 != NULL, "CreateSemaphore failed with error %ld\n", GetLastError());
+    ok( GetLastError() == ERROR_ALREADY_EXISTS, "wrong error %lu\n", GetLastError());
+    CloseHandle( handle2 );
+
+    SetLastError(0xdeadbeef);
+    handle2 = CreateSemaphoreA(NULL, 0, 1, __FILE__ ": TEST SEMAPHORE");
+    ok( handle2 != NULL, "CreateSemaphore failed with error %ld\n", GetLastError());
+    ok( GetLastError() == 0, "wrong error %lu\n", GetLastError());
+    CloseHandle( handle2 );
+
+    SetLastError(0xdeadbeef);
+    handle2 = OpenSemaphoreA( SEMAPHORE_ALL_ACCESS, FALSE, __FILE__ ": Test Semaphore");
+    ok( handle2 != NULL, "OpenSemaphore failed with error %ld\n", GetLastError());
+    CloseHandle( handle2 );
+
+    SetLastError(0xdeadbeef);
+    handle2 = OpenSemaphoreA( SEMAPHORE_ALL_ACCESS, FALSE, __FILE__ ": TEST SEMAPHORE");
+    ok( !handle2, "OpenSemaphore succeeded\n");
+    ok( GetLastError() == ERROR_FILE_NOT_FOUND, "wrong error %lu\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    handle2 = OpenSemaphoreA( SEMAPHORE_ALL_ACCESS, FALSE, NULL );
+    ok( !handle2, "OpenSemaphore succeeded\n");
+    ok( GetLastError() == ERROR_INVALID_PARAMETER, "wrong error %lu\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    handle2 = OpenSemaphoreW( SEMAPHORE_ALL_ACCESS, FALSE, NULL );
+    ok( !handle2, "OpenSemaphore succeeded\n");
+    ok( GetLastError() == ERROR_INVALID_PARAMETER, "wrong error %lu\n", GetLastError());
+
+    CloseHandle( handle );
+}
+
+static void test_waitable_timer(void)
+{
+    HANDLE handle, handle2;
+
+    /* test case sensitivity */
+
+    SetLastError(0xdeadbeef);
+    handle = CreateWaitableTimerA(NULL, FALSE, __FILE__ ": Test WaitableTimer");
+    ok(handle != NULL, "CreateWaitableTimer failed with error %lu\n", GetLastError());
+    ok(GetLastError() == 0, "wrong error %lu\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    handle2 = CreateWaitableTimerA(NULL, FALSE, __FILE__ ": Test WaitableTimer");
+    ok( handle2 != NULL, "CreateWaitableTimer failed with error %ld\n", GetLastError());
+    ok( GetLastError() == ERROR_ALREADY_EXISTS, "wrong error %lu\n", GetLastError());
+    CloseHandle( handle2 );
+
+    SetLastError(0xdeadbeef);
+    handle2 = CreateWaitableTimerA(NULL, FALSE, __FILE__ ": TEST WAITABLETIMER");
+    ok( handle2 != NULL, "CreateWaitableTimer failed with error %ld\n", GetLastError());
+    ok( GetLastError() == 0, "wrong error %lu\n", GetLastError());
+    CloseHandle( handle2 );
+
+    SetLastError(0xdeadbeef);
+    handle2 = OpenWaitableTimerA( TIMER_ALL_ACCESS, FALSE, __FILE__ ": Test WaitableTimer");
+    ok( handle2 != NULL, "OpenWaitableTimer failed with error %ld\n", GetLastError());
+    CloseHandle( handle2 );
+
+    SetLastError(0xdeadbeef);
+    handle2 = OpenWaitableTimerA( TIMER_ALL_ACCESS, FALSE, __FILE__ ": TEST WAITABLETIMER");
+    ok( !handle2, "OpenWaitableTimer succeeded\n");
+    ok( GetLastError() == ERROR_FILE_NOT_FOUND, "wrong error %lu\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    handle2 = OpenWaitableTimerA( TIMER_ALL_ACCESS, FALSE, NULL );
+    ok( !handle2, "OpenWaitableTimer failed with error %ld\n", GetLastError());
+    ok( GetLastError() == ERROR_INVALID_PARAMETER, "wrong error %lu\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    handle2 = OpenWaitableTimerW( TIMER_ALL_ACCESS, FALSE, NULL );
+    ok( !handle2, "OpenWaitableTimer failed with error %ld\n", GetLastError());
+    ok( GetLastError() == ERROR_INVALID_PARAMETER, "wrong error %lu\n", GetLastError());
+
+    CloseHandle( handle );
+}
+
+static HANDLE sem = 0;
+
+static void CALLBACK iocp_callback(DWORD dwErrorCode, DWORD dwNumberOfBytesTransferred, LPOVERLAPPED lpOverlapped)
+{
+    ReleaseSemaphore(sem, 1, NULL);
+}
+
+static BOOL (WINAPI *p_BindIoCompletionCallback)( HANDLE FileHandle, LPOVERLAPPED_COMPLETION_ROUTINE Function, ULONG Flags) = NULL;
+
+static void test_iocp_callback(void)
+{
+    char temp_path[MAX_PATH];
+    char filename[MAX_PATH];
+    DWORD ret;
+    BOOL retb;
+    static const char prefix[] = "pfx";
+    HANDLE hFile;
+    HMODULE hmod = GetModuleHandleA("kernel32.dll");
+    DWORD bytesWritten;
+    const char *buffer = "12345678123456781234567812345678";
+    OVERLAPPED overlapped;
+
+    p_BindIoCompletionCallback = (void*)GetProcAddress(hmod, "BindIoCompletionCallback");
+    if(!p_BindIoCompletionCallback) {
+        win_skip("BindIoCompletionCallback not found in this DLL\n");
+        return;
+    }
+
+    sem = CreateSemaphoreW(NULL, 0, 1, NULL);
+    ok(sem != INVALID_HANDLE_VALUE, "Creating a semaphore failed\n");
+
+    ret = GetTempPathA(MAX_PATH, temp_path);
+    ok(ret != 0, "GetTempPathA error %ld\n", GetLastError());
+    ok(ret < MAX_PATH, "temp path should fit into MAX_PATH\n");
+
+    ret = GetTempFileNameA(temp_path, prefix, 0, filename);
+    ok(ret != 0, "GetTempFileNameA error %ld\n", GetLastError());
+
+    hFile = CreateFileA(filename, GENERIC_READ | GENERIC_WRITE, 0, NULL,
+                        CREATE_ALWAYS, FILE_FLAG_RANDOM_ACCESS, 0);
+    ok(hFile != INVALID_HANDLE_VALUE, "CreateFileA: error %ld\n", GetLastError());
+
+    retb = p_BindIoCompletionCallback(hFile, iocp_callback, 0);
+    ok(retb == FALSE, "BindIoCompletionCallback succeeded on a file that wasn't created with FILE_FLAG_OVERLAPPED\n");
+    ok(GetLastError() == ERROR_INVALID_PARAMETER, "Last error is %ld\n", GetLastError());
+
+    ret = CloseHandle(hFile);
+    ok( ret, "CloseHandle: error %ld\n", GetLastError());
+    ret = DeleteFileA(filename);
+    ok( ret, "DeleteFileA: error %ld\n", GetLastError());
+
+    hFile = CreateFileA(filename, GENERIC_READ | GENERIC_WRITE, 0, NULL,
+                        CREATE_ALWAYS, FILE_FLAG_RANDOM_ACCESS | FILE_FLAG_OVERLAPPED, 0);
+    ok(hFile != INVALID_HANDLE_VALUE, "CreateFileA: error %ld\n", GetLastError());
+
+    retb = p_BindIoCompletionCallback(hFile, iocp_callback, 0);
+    ok(retb == TRUE, "BindIoCompletionCallback failed\n");
+
+    memset(&overlapped, 0, sizeof(overlapped));
+    retb = WriteFile(hFile, buffer, 4, &bytesWritten, &overlapped);
+    ok(retb == TRUE || GetLastError() == ERROR_IO_PENDING, "WriteFile failed, lastError = %ld\n", GetLastError());
+
+    ret = WaitForSingleObject(sem, 5000);
+    ok(ret == WAIT_OBJECT_0, "Wait for the IO completion callback failed\n");
+    CloseHandle(sem);
+
+    retb = p_BindIoCompletionCallback(hFile, iocp_callback, 0);
+    ok(retb == FALSE, "BindIoCompletionCallback succeeded when setting the same callback on the file again\n");
+    ok(GetLastError() == ERROR_INVALID_PARAMETER, "Last error is %ld\n", GetLastError());
+    retb = p_BindIoCompletionCallback(hFile, NULL, 0);
+    ok(retb == FALSE, "BindIoCompletionCallback succeeded when setting the callback to NULL\n");
+    ok(GetLastError() == ERROR_INVALID_PARAMETER, "Last error is %ld\n", GetLastError());
+
+    ret = CloseHandle(hFile);
+    ok( ret, "CloseHandle: error %ld\n", GetLastError());
+    ret = DeleteFileA(filename);
+    ok( ret, "DeleteFileA: error %ld\n", GetLastError());
+
+    /* win2k3 requires the Flags parameter to be zero */
+    SetLastError(0xdeadbeef);
+    hFile = CreateFileA(filename, GENERIC_READ | GENERIC_WRITE, 0, NULL,
+                        CREATE_ALWAYS, FILE_FLAG_RANDOM_ACCESS | FILE_FLAG_OVERLAPPED, 0);
+    ok(hFile != INVALID_HANDLE_VALUE, "CreateFileA: error %ld\n", GetLastError());
+    retb = p_BindIoCompletionCallback(hFile, iocp_callback, 12345);
+    if (!retb)
+        ok(GetLastError() == ERROR_INVALID_PARAMETER,
+           "Expected ERROR_INVALID_PARAMETER, got %ld\n", GetLastError());
+    else
+        ok(retb == TRUE, "BindIoCompletionCallback failed with Flags != 0\n");
+    ret = CloseHandle(hFile);
+    ok( ret, "CloseHandle: error %ld\n", GetLastError());
+    ret = DeleteFileA(filename);
+    ok( ret, "DeleteFileA: error %ld\n", GetLastError());
+
+    retb = p_BindIoCompletionCallback(NULL, iocp_callback, 0);
+    ok(retb == FALSE, "BindIoCompletionCallback succeeded on a NULL file\n");
+    ok(GetLastError() == ERROR_INVALID_HANDLE ||
+       GetLastError() == ERROR_INVALID_PARAMETER, /* vista */
+       "Last error is %ld\n", GetLastError());
+}
+
+static void CALLBACK timer_queue_cb1(PVOID p, BOOLEAN timedOut)
+{
+    int *pn = p;
+    ok(timedOut, "Timer callbacks should always time out\n");
+    ++*pn;
+}
+
+struct timer_queue_data1
+{
+    int num_calls;
+    int max_calls;
+    HANDLE q, t;
+};
+
+static void CALLBACK timer_queue_cb2(PVOID p, BOOLEAN timedOut)
+{
+    struct timer_queue_data1 *d = p;
+    ok(timedOut, "Timer callbacks should always time out\n");
+    if (d->t && ++d->num_calls == d->max_calls)
+    {
+        BOOL ret;
+        SetLastError(0xdeadbeef);
+        /* Note, XP SP2 does *not* do any deadlock checking, so passing
+           INVALID_HANDLE_VALUE here will just hang.  */
+        ret = DeleteTimerQueueTimer(d->q, d->t, NULL);
+        ok(!ret, "DeleteTimerQueueTimer\n");
+        ok(GetLastError() == ERROR_IO_PENDING, "DeleteTimerQueueTimer\n");
+    }
+}
+
+static void CALLBACK timer_queue_cb3(PVOID p, BOOLEAN timedOut)
+{
+    struct timer_queue_data1 *d = p;
+    ok(timedOut, "Timer callbacks should always time out\n");
+    if (d->t && ++d->num_calls == d->max_calls)
+    {
+        /* Basically kill the timer since it won't have time to run
+           again.  */
+        BOOL ret = ChangeTimerQueueTimer(d->q, d->t, 10000, 0);
+        ok(ret, "ChangeTimerQueueTimer\n");
+    }
+}
+
+static void CALLBACK timer_queue_cb4(PVOID p, BOOLEAN timedOut)
+{
+    struct timer_queue_data1 *d = p;
+    ok(timedOut, "Timer callbacks should always time out\n");
+    if (d->t)
+    {
+        /* This tests whether a timer gets flagged for deletion before
+           or after the callback runs.  If we start this timer with a
+           period of zero (run once), then ChangeTimerQueueTimer will
+           fail if the timer is already flagged.  Hence we really run
+           only once.  Otherwise we will run multiple times.  */
+        BOOL ret = ChangeTimerQueueTimer(d->q, d->t, 50, 50);
+        ok(ret, "ChangeTimerQueueTimer\n");
+        ++d->num_calls;
+    }
+}
+
+static void CALLBACK timer_queue_cb5(PVOID p, BOOLEAN timedOut)
+{
+    DWORD_PTR delay = (DWORD_PTR) p;
+    ok(timedOut, "Timer callbacks should always time out\n");
+    if (delay)
+        Sleep(delay);
+}
+
+static void CALLBACK timer_queue_cb6(PVOID p, BOOLEAN timedOut)
+{
+    struct timer_queue_data1 *d = p;
+    ok(timedOut, "Timer callbacks should always time out\n");
+    /* This tests an original implementation bug where a deleted timer may get
+       to run, but it is tricky to set up.  */
+    if (d->q && d->num_calls++ == 0)
+    {
+        /* First run: delete ourselves, then insert and remove a timer
+           that goes in front of us in the sorted timeout list.  Once
+           removed, we will still timeout at the faster timer's due time,
+           but this should be a no-op if we are bug-free.  There should
+           not be a second run.  We can test the value of num_calls later.  */
+        BOOL ret;
+        HANDLE t;
+
+        /* The delete will pend while we are in this callback.  */
+        SetLastError(0xdeadbeef);
+        ret = DeleteTimerQueueTimer(d->q, d->t, NULL);
+        ok(!ret, "DeleteTimerQueueTimer\n");
+        ok(GetLastError() == ERROR_IO_PENDING, "DeleteTimerQueueTimer\n");
+
+        ret = CreateTimerQueueTimer(&t, d->q, timer_queue_cb1, NULL, 100, 0, 0);
+        ok(ret, "CreateTimerQueueTimer\n");
+        ok(t != NULL, "CreateTimerQueueTimer\n");
+
+        ret = DeleteTimerQueueTimer(d->q, t, INVALID_HANDLE_VALUE);
+        ok(ret, "DeleteTimerQueueTimer\n");
+
+        /* Now we stay alive by hanging around in the callback.  */
+        Sleep(500);
+    }
+}
+
+static void test_timer_queue(void)
+{
+    HANDLE q, t0, t1, t2, t3, t4, t5;
+    int n0, n1, n2, n3, n4, n5;
+    struct timer_queue_data1 d1, d2, d3, d4;
+    HANDLE e, et1, et2;
+    BOOL ret, ret0;
+
+    /* Test asynchronous deletion of the queue. */
+    q = CreateTimerQueue();
+    ok(q != NULL, "CreateTimerQueue\n");
+
+    SetLastError(0xdeadbeef);
+    ret = DeleteTimerQueueEx(q, NULL);
+    ok(ret /* vista */ || GetLastError() == ERROR_IO_PENDING,
+       "DeleteTimerQueueEx, GetLastError: expected ERROR_IO_PENDING, got %ld\n",
+       GetLastError());
+
+    /* Test synchronous deletion of the queue and running timers. */
+    q = CreateTimerQueue();
+    ok(q != NULL, "CreateTimerQueue\n");
+
+    /* Not called. */
+    t0 = NULL;
+    n0 = 0;
+    ret = CreateTimerQueueTimer(&t0, q, timer_queue_cb1, &n0, 0, 300, 0);
+    ok(ret, "CreateTimerQueueTimer\n");
+    ok(t0 != NULL, "CreateTimerQueueTimer\n");
+    ret0 = DeleteTimerQueueTimer(q, t0, NULL);
+    ok((!ret0 && GetLastError() == ERROR_IO_PENDING) ||
+       broken(ret0), /* Win 2000 & XP & 2003 */
+       "DeleteTimerQueueTimer ret=%d le=%lu\n", ret0, GetLastError());
+
+    /* Called once.  */
+    t1 = NULL;
+    n1 = 0;
+    ret = CreateTimerQueueTimer(&t1, q, timer_queue_cb1, &n1, 0, 0, 0);
+    ok(ret, "CreateTimerQueueTimer\n");
+    ok(t1 != NULL, "CreateTimerQueueTimer\n");
+
+    /* A slow one.  */
+    t2 = NULL;
+    n2 = 0;
+    ret = CreateTimerQueueTimer(&t2, q, timer_queue_cb1, &n2, 0, 100, 0);
+    ok(ret, "CreateTimerQueueTimer\n");
+    ok(t2 != NULL, "CreateTimerQueueTimer\n");
+
+    /* A fast one.  */
+    t3 = NULL;
+    n3 = 0;
+    ret = CreateTimerQueueTimer(&t3, q, timer_queue_cb1, &n3, 0, 10, 0);
+    ok(ret, "CreateTimerQueueTimer\n");
+    ok(t3 != NULL, "CreateTimerQueueTimer\n");
+
+    /* Start really late (it won't start).  */
+    t4 = NULL;
+    n4 = 0;
+    ret = CreateTimerQueueTimer(&t4, q, timer_queue_cb1, &n4, 10000, 10, 0);
+    ok(ret, "CreateTimerQueueTimer\n");
+    ok(t4 != NULL, "CreateTimerQueueTimer\n");
+
+    /* Start soon, but delay so long it won't run again.  */
+    t5 = NULL;
+    n5 = 0;
+    ret = CreateTimerQueueTimer(&t5, q, timer_queue_cb1, &n5, 0, 10000, 0);
+    ok(ret, "CreateTimerQueueTimer\n");
+    ok(t5 != NULL, "CreateTimerQueueTimer\n");
+
+    /* Give them a chance to do some work.  */
+    Sleep(500);
+
+    /* Test deleting a once-only timer.  */
+    ret = DeleteTimerQueueTimer(q, t1, INVALID_HANDLE_VALUE);
+    ok(ret, "DeleteTimerQueueTimer\n");
+
+    /* A periodic timer.  */
+    ret = DeleteTimerQueueTimer(q, t2, INVALID_HANDLE_VALUE);
+    ok(ret, "DeleteTimerQueueTimer\n");
+
+    ret = DeleteTimerQueueEx(q, INVALID_HANDLE_VALUE);
+    ok(ret, "DeleteTimerQueueEx\n");
+    todo_wine
+    ok(n0 == 1 || broken(ret0 && n0 == 0), "Timer callback 0 expected 1 got %d\n", n0);
+    ok(n1 == 1, "Timer callback 1 expected 1 got %d\n", n1);
+    ok(n2 < n3, "Timer callback 2 & 3 expected %d < %d\n", n2, n3);
+    ok(n4 == 0, "Timer callback 4 expected 0 got %d\n", n4);
+    ok(n5 == 1, "Timer callback 5 expected 1 got %d\n", n5);
+
+    /* Test synchronous deletion of the timer/queue with event trigger. */
+    e = CreateEventW(NULL, TRUE, FALSE, NULL);
+    et1 = CreateEventW(NULL, TRUE, FALSE, NULL);
+    et2 = CreateEventW(NULL, TRUE, FALSE, NULL);
+    if (!e || !et1 || !et2)
+    {
+        skip("Failed to create timer queue descruction event\n");
+        return;
+    }
+
+    q = CreateTimerQueue();
+    ok(q != NULL, "CreateTimerQueue\n");
+
+    /* Run once and finish quickly (should be done when we delete it).  */
+    t1 = NULL;
+    ret = CreateTimerQueueTimer(&t1, q, timer_queue_cb5, NULL, 0, 0, 0);
+    ok(ret, "CreateTimerQueueTimer\n");
+    ok(t1 != NULL, "CreateTimerQueueTimer\n");
+
+    /* Run once and finish slowly (shouldn't be done when we delete it).  */
+    t2 = NULL;
+    ret = CreateTimerQueueTimer(&t2, q, timer_queue_cb5, (PVOID) 1000, 0, 0, 0);
+    ok(ret, "CreateTimerQueueTimer\n");
+    ok(t2 != NULL, "CreateTimerQueueTimer\n");
+
+    /* Run once and finish quickly (should be done when we delete it).  */
+    t3 = NULL;
+    ret = CreateTimerQueueTimer(&t3, q, timer_queue_cb5, NULL, 0, 0, 0);
+    ok(ret, "CreateTimerQueueTimer\n");
+    ok(t3 != NULL, "CreateTimerQueueTimer\n");
+
+    /* Run once and finish slowly (shouldn't be done when we delete it).  */
+    t4 = NULL;
+    ret = CreateTimerQueueTimer(&t4, q, timer_queue_cb5, (PVOID) 1000, 0, 0, 0);
+    ok(ret, "CreateTimerQueueTimer\n");
+    ok(t4 != NULL, "CreateTimerQueueTimer\n");
+
+    /* Give them a chance to start.  */
+    Sleep(400);
+
+    /* DeleteTimerQueueTimer always returns PENDING with a NULL event,
+       even if the timer is finished.  */
+    SetLastError(0xdeadbeef);
+    ret = DeleteTimerQueueTimer(q, t1, NULL);
+    ok(ret /* vista */ || GetLastError() == ERROR_IO_PENDING,
+       "DeleteTimerQueueTimer, GetLastError: expected ERROR_IO_PENDING, got %ld\n",
+       GetLastError());
+
+    SetLastError(0xdeadbeef);
+    ret = DeleteTimerQueueTimer(q, t2, NULL);
+    ok(!ret, "DeleteTimerQueueTimer call was expected to fail\n");
+    ok(GetLastError() == ERROR_IO_PENDING,
+       "DeleteTimerQueueTimer, GetLastError: expected ERROR_IO_PENDING, got %ld\n",
+       GetLastError());
+
+    SetLastError(0xdeadbeef);
+    ret = DeleteTimerQueueTimer(q, t3, et1);
+    ok(ret, "DeleteTimerQueueTimer call was expected to fail\n");
+    ok(GetLastError() == 0xdeadbeef,
+       "DeleteTimerQueueTimer, GetLastError: expected 0xdeadbeef, got %ld\n",
+       GetLastError());
+    ok(WaitForSingleObject(et1, 250) == WAIT_OBJECT_0,
+       "Timer destruction event not triggered\n");
+
+    SetLastError(0xdeadbeef);
+    ret = DeleteTimerQueueTimer(q, t4, et2);
+    ok(!ret, "DeleteTimerQueueTimer call was expected to fail\n");
+    ok(GetLastError() == ERROR_IO_PENDING,
+       "DeleteTimerQueueTimer, GetLastError: expected ERROR_IO_PENDING, got %ld\n",
+       GetLastError());
+    ok(WaitForSingleObject(et2, 1000) == WAIT_OBJECT_0,
+       "Timer destruction event not triggered\n");
+
+    SetLastError(0xdeadbeef);
+    ret = DeleteTimerQueueEx(q, e);
+    ok(ret /* vista */ || GetLastError() == ERROR_IO_PENDING,
+       "DeleteTimerQueueEx, GetLastError: expected ERROR_IO_PENDING, got %ld\n",
+       GetLastError());
+    ok(WaitForSingleObject(e, 250) == WAIT_OBJECT_0,
+       "Queue destruction event not triggered\n");
+    CloseHandle(e);
+
+    /* Test deleting/changing a timer in execution.  */
+    q = CreateTimerQueue();
+    ok(q != NULL, "CreateTimerQueue\n");
+
+    /* Test changing a once-only timer before it fires (this is allowed,
+       whereas after it fires you cannot).  */
+    n1 = 0;
+    ret = CreateTimerQueueTimer(&t1, q, timer_queue_cb1, &n1, 10000, 0, 0);
+    ok(ret, "CreateTimerQueueTimer\n");
+    ok(t1 != NULL, "CreateTimerQueueTimer\n");
+    ret = ChangeTimerQueueTimer(q, t1, 0, 0);
+    ok(ret, "ChangeTimerQueueTimer\n");
+
+    d2.t = t2 = NULL;
+    d2.num_calls = 0;
+    d2.max_calls = 3;
+    d2.q = q;
+    ret = CreateTimerQueueTimer(&t2, q, timer_queue_cb2, &d2, 10, 10, 0);
+    d2.t = t2;
+    ok(ret, "CreateTimerQueueTimer\n");
+    ok(t2 != NULL, "CreateTimerQueueTimer\n");
+
+    d3.t = t3 = NULL;
+    d3.num_calls = 0;
+    d3.max_calls = 4;
+    d3.q = q;
+    ret = CreateTimerQueueTimer(&t3, q, timer_queue_cb3, &d3, 10, 10, 0);
+    d3.t = t3;
+    ok(ret, "CreateTimerQueueTimer\n");
+    ok(t3 != NULL, "CreateTimerQueueTimer\n");
+
+    d4.t = t4 = NULL;
+    d4.num_calls = 0;
+    d4.q = q;
+    ret = CreateTimerQueueTimer(&t4, q, timer_queue_cb4, &d4, 10, 0, 0);
+    d4.t = t4;
+    ok(ret, "CreateTimerQueueTimer\n");
+    ok(t4 != NULL, "CreateTimerQueueTimer\n");
+
+    Sleep(500);
+
+    ret = DeleteTimerQueueEx(q, INVALID_HANDLE_VALUE);
+    ok(ret, "DeleteTimerQueueEx\n");
+    ok(n1 == 1, "ChangeTimerQueueTimer\n");
+    ok(d2.num_calls == d2.max_calls, "DeleteTimerQueueTimer\n");
+    ok(d3.num_calls == d3.max_calls, "ChangeTimerQueueTimer\n");
+    ok(d4.num_calls == 1, "Timer flagged for deletion incorrectly\n");
+
+    /* Test an obscure bug that was in the original implementation.  */
+    q = CreateTimerQueue();
+    ok(q != NULL, "CreateTimerQueue\n");
+
+    /* All the work is done in the callback.  */
+    d1.t = t1 = NULL;
+    d1.num_calls = 0;
+    d1.q = q;
+    ret = CreateTimerQueueTimer(&t1, q, timer_queue_cb6, &d1, 100, 100, WT_EXECUTELONGFUNCTION);
+    d1.t = t1;
+    ok(ret, "CreateTimerQueueTimer\n");
+    ok(t1 != NULL, "CreateTimerQueueTimer\n");
+
+    Sleep(750);
+
+    SetLastError(0xdeadbeef);
+    ret = DeleteTimerQueueEx(q, NULL);
+    ok(ret /* vista */ || GetLastError() == ERROR_IO_PENDING,
+       "DeleteTimerQueueEx, GetLastError: expected ERROR_IO_PENDING, got %ld\n",
+       GetLastError());
+    ok(d1.num_calls == 1, "DeleteTimerQueueTimer\n");
+
+    /* Test functions on the default timer queue.  */
+    t1 = NULL;
+    n1 = 0;
+    ret = CreateTimerQueueTimer(&t1, NULL, timer_queue_cb1, &n1, 1000, 1000, 0);
+    ok(ret, "CreateTimerQueueTimer, default queue\n");
+    ok(t1 != NULL, "CreateTimerQueueTimer, default queue\n");
+
+    ret = ChangeTimerQueueTimer(NULL, t1, 2000, 2000);
+    ok(ret, "ChangeTimerQueueTimer, default queue\n");
+
+    ret = DeleteTimerQueueTimer(NULL, t1, INVALID_HANDLE_VALUE);
+    ok(ret, "DeleteTimerQueueTimer, default queue\n");
+
+    /* Try mixing default and non-default queues.  Apparently this works.  */
+    q = CreateTimerQueue();
+    ok(q != NULL, "CreateTimerQueue\n");
+
+    t1 = NULL;
+    n1 = 0;
+    ret = CreateTimerQueueTimer(&t1, q, timer_queue_cb1, &n1, 1000, 1000, 0);
+    ok(ret, "CreateTimerQueueTimer\n");
+    ok(t1 != NULL, "CreateTimerQueueTimer\n");
+
+    t2 = NULL;
+    n2 = 0;
+    ret = CreateTimerQueueTimer(&t2, NULL, timer_queue_cb1, &n2, 1000, 1000, 0);
+    ok(ret, "CreateTimerQueueTimer\n");
+    ok(t2 != NULL, "CreateTimerQueueTimer\n");
+
+    ret = ChangeTimerQueueTimer(NULL, t1, 2000, 2000);
+    ok(ret, "ChangeTimerQueueTimer\n");
+
+    ret = ChangeTimerQueueTimer(q, t2, 2000, 2000);
+    ok(ret, "ChangeTimerQueueTimer\n");
+
+    ret = DeleteTimerQueueTimer(NULL, t1, INVALID_HANDLE_VALUE);
+    ok(ret, "DeleteTimerQueueTimer\n");
+
+    ret = DeleteTimerQueueTimer(q, t2, INVALID_HANDLE_VALUE);
+    ok(ret, "DeleteTimerQueueTimer\n");
+
+    /* Try to delete the default queue?  In any case: not allowed.  */
+    SetLastError(0xdeadbeef);
+    ret = DeleteTimerQueueEx(NULL, NULL);
+    ok(!ret, "DeleteTimerQueueEx call was expected to fail\n");
+    ok(GetLastError() == ERROR_INVALID_HANDLE,
+       "DeleteTimerQueueEx, GetLastError: expected ERROR_INVALID_HANDLE, got %ld\n",
+       GetLastError());
+
+    SetLastError(0xdeadbeef);
+    ret = DeleteTimerQueueEx(q, NULL);
+    ok(ret /* vista */ || GetLastError() == ERROR_IO_PENDING,
+       "DeleteTimerQueueEx, GetLastError: expected ERROR_IO_PENDING, got %ld\n",
+       GetLastError());
+}
+
+static HANDLE modify_handle(HANDLE handle, DWORD modify)
+{
+    DWORD tmp = HandleToULong(handle);
+    tmp |= modify;
+    return ULongToHandle(tmp);
+}
+
+static void test_WaitForSingleObject(void)
+{
+    HANDLE signaled, nonsignaled, invalid;
+    LARGE_INTEGER timeout;
+    NTSTATUS status;
+    DWORD ret;
+
+    signaled = CreateEventW(NULL, TRUE, TRUE, NULL);
+    nonsignaled = CreateEventW(NULL, TRUE, FALSE, NULL);
+    invalid = (HANDLE) 0xdeadbee0;
+
+    /* invalid handle with different values for lower 2 bits */
+    SetLastError(0xdeadbeef);
+    ret = WaitForSingleObject(invalid, 0);
+    ok(ret == WAIT_FAILED, "expected WAIT_FAILED, got %ld\n", ret);
+    ok(GetLastError() == ERROR_INVALID_HANDLE, "expected ERROR_INVALID_HANDLE, got %ld\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    ret = WaitForSingleObject(modify_handle(invalid, 1), 0);
+    ok(ret == WAIT_FAILED, "expected WAIT_FAILED, got %ld\n", ret);
+    ok(GetLastError() == ERROR_INVALID_HANDLE, "expected ERROR_INVALID_HANDLE, got %ld\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    ret = WaitForSingleObject(modify_handle(invalid, 2), 0);
+    ok(ret == WAIT_FAILED, "expected WAIT_FAILED, got %ld\n", ret);
+    ok(GetLastError() == ERROR_INVALID_HANDLE, "expected ERROR_INVALID_HANDLE, got %ld\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    ret = WaitForSingleObject(modify_handle(invalid, 3), 0);
+    ok(ret == WAIT_FAILED, "expected WAIT_FAILED, got %ld\n", ret);
+    ok(GetLastError() == ERROR_INVALID_HANDLE, "expected ERROR_INVALID_HANDLE, got %ld\n", GetLastError());
+
+    /* valid handle with different values for lower 2 bits */
+    SetLastError(0xdeadbeef);
+    ret = WaitForSingleObject(nonsignaled, 0);
+    ok(ret == WAIT_TIMEOUT, "expected WAIT_TIMEOUT, got %ld\n", ret);
+    ok(GetLastError() == 0xdeadbeef, "expected 0xdeadbeef, got %ld\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    ret = WaitForSingleObject(modify_handle(nonsignaled, 1), 0);
+    ok(ret == WAIT_TIMEOUT, "expected WAIT_TIMEOUT, got %ld\n", ret);
+    ok(GetLastError() == 0xdeadbeef, "expected 0xdeadbeef, got %ld\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    ret = WaitForSingleObject(modify_handle(nonsignaled, 2), 0);
+    ok(ret == WAIT_TIMEOUT, "expected WAIT_TIMEOUT, got %ld\n", ret);
+    ok(GetLastError() == 0xdeadbeef, "expected 0xdeadbeef, got %ld\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    ret = WaitForSingleObject(modify_handle(nonsignaled, 3), 0);
+    ok(ret == WAIT_TIMEOUT, "expected WAIT_TIMEOUT, got %ld\n", ret);
+    ok(GetLastError() == 0xdeadbeef, "expected 0xdeadbeef, got %ld\n", GetLastError());
+
+    /* valid handle with different values for lower 2 bits */
+    SetLastError(0xdeadbeef);
+    ret = WaitForSingleObject(signaled, 0);
+    ok(ret == WAIT_OBJECT_0, "expected WAIT_OBJECT_0, got %ld\n", ret);
+    ok(GetLastError() == 0xdeadbeef, "expected 0xdeadbeef, got %ld\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    ret = WaitForSingleObject(modify_handle(signaled, 1), 0);
+    ok(ret == WAIT_OBJECT_0, "expected WAIT_OBJECT_0, got %ld\n", ret);
+    ok(GetLastError() == 0xdeadbeef, "expected 0xdeadbeef, got %ld\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    ret = WaitForSingleObject(modify_handle(signaled, 2), 0);
+    ok(ret == WAIT_OBJECT_0, "expected WAIT_OBJECT_0, got %ld\n", ret);
+    ok(GetLastError() == 0xdeadbeef, "expected 0xdeadbeef, got %ld\n", GetLastError());
+
+    SetLastError(0xdeadbeef);
+    ret = WaitForSingleObject(modify_handle(signaled, 3), 0);
+    ok(ret == WAIT_OBJECT_0, "expected WAIT_OBJECT_0, got %ld\n", ret);
+    ok(GetLastError() == 0xdeadbeef, "expected 0xdeadbeef, got %ld\n", GetLastError());
+
+    /* pseudo handles are allowed in WaitForSingleObject and NtWaitForSingleObject */
+    ret = WaitForSingleObject(GetCurrentProcess(), 100);
+    ok(ret == WAIT_TIMEOUT, "expected WAIT_TIMEOUT, got %lu\n", ret);
+
+    ret = WaitForSingleObject(GetCurrentThread(), 100);
+    ok(ret == WAIT_TIMEOUT, "expected WAIT_TIMEOUT, got %lu\n", ret);
+
+    timeout.QuadPart = -1000000;
+    status = pNtWaitForSingleObject(GetCurrentProcess(), FALSE, &timeout);
+    ok(status == STATUS_TIMEOUT, "expected STATUS_TIMEOUT, got %08lx\n", status);
+
+    timeout.QuadPart = -1000000;
+    status = pNtWaitForSingleObject(GetCurrentThread(), FALSE, &timeout);
+    ok(status == STATUS_TIMEOUT, "expected STATUS_TIMEOUT, got %08lx\n", status);
+
+    CloseHandle(signaled);
+    CloseHandle(nonsignaled);
+}
+
+static void test_WaitForMultipleObjects(void)
+{
+    LARGE_INTEGER timeout;
+    NTSTATUS status;
+    DWORD r;
+    int i;
+    HANDLE maxevents[MAXIMUM_WAIT_OBJECTS];
+
+    /* create the maximum number of events and make sure
+     * we can wait on that many */
+    for (i=0; i<MAXIMUM_WAIT_OBJECTS; i++)
+    {
+        maxevents[i] = CreateEventW(NULL, i==0, TRUE, NULL);
+        ok( maxevents[i] != 0, "should create enough events\n");
+    }
+
+    /* a manual-reset event remains signaled, an auto-reset event is cleared */
+    r = WaitForMultipleObjects(MAXIMUM_WAIT_OBJECTS, maxevents, FALSE, 0);
+    ok( r == WAIT_OBJECT_0, "should signal lowest handle first, got %ld\n", r);
+    r = WaitForMultipleObjects(MAXIMUM_WAIT_OBJECTS, maxevents, FALSE, 0);
+    ok( r == WAIT_OBJECT_0, "should signal handle #0 first, got %ld\n", r);
+    ok(ResetEvent(maxevents[0]), "ResetEvent\n");
+    for (i=1; i<MAXIMUM_WAIT_OBJECTS; i++)
+    {
+        /* the lowest index is checked first and remaining events are untouched */
+        r = WaitForMultipleObjects(MAXIMUM_WAIT_OBJECTS, maxevents, FALSE, 0);
+        ok( r == WAIT_OBJECT_0+i, "should signal handle #%d first, got %ld\n", i, r);
+    }
+
+    /* run same test with Nt* call */
+    for (i=0; i<MAXIMUM_WAIT_OBJECTS; i++)
+        SetEvent(maxevents[i]);
+
+    /* a manual-reset event remains signaled, an auto-reset event is cleared */
+    status = pNtWaitForMultipleObjects(MAXIMUM_WAIT_OBJECTS, maxevents, TRUE, FALSE, NULL);
+    ok(status == STATUS_WAIT_0, "should signal lowest handle first, got %08lx\n", status);
+    status = pNtWaitForMultipleObjects(MAXIMUM_WAIT_OBJECTS, maxevents, TRUE, FALSE, NULL);
+    ok(status == STATUS_WAIT_0, "should signal handle #0 first, got %08lx\n", status);
+    ok(ResetEvent(maxevents[0]), "ResetEvent\n");
+    for (i=1; i<MAXIMUM_WAIT_OBJECTS; i++)
+    {
+        /* the lowest index is checked first and remaining events are untouched */
+        status = pNtWaitForMultipleObjects(MAXIMUM_WAIT_OBJECTS, maxevents, TRUE, FALSE, NULL);
+        ok(status == STATUS_WAIT_0 + i, "should signal handle #%d first, got %08lx\n", i, status);
+    }
+
+    for (i=0; i<MAXIMUM_WAIT_OBJECTS; i++)
+        if (maxevents[i]) CloseHandle(maxevents[i]);
+
+    /* in contrast to WaitForSingleObject, pseudo handles are not allowed in
+     * WaitForMultipleObjects and NtWaitForMultipleObjects */
+    maxevents[0] = GetCurrentProcess();
+    SetLastError(0xdeadbeef);
+    r = WaitForMultipleObjects(1, maxevents, FALSE, 100);
+    todo_wine ok(r == WAIT_FAILED, "expected WAIT_FAILED, got %lu\n", r);
+    todo_wine ok(GetLastError() == ERROR_INVALID_HANDLE,
+                 "expected ERROR_INVALID_HANDLE, got %lu\n", GetLastError());
+
+    maxevents[0] = GetCurrentThread();
+    SetLastError(0xdeadbeef);
+    r = WaitForMultipleObjects(1, maxevents, FALSE, 100);
+    todo_wine ok(r == WAIT_FAILED, "expected WAIT_FAILED, got %lu\n", r);
+    todo_wine ok(GetLastError() == ERROR_INVALID_HANDLE,
+                 "expected ERROR_INVALID_HANDLE, got %lu\n", GetLastError());
+
+    timeout.QuadPart = -1000000;
+    maxevents[0] = GetCurrentProcess();
+    status = pNtWaitForMultipleObjects(1, maxevents, TRUE, FALSE, &timeout);
+    todo_wine ok(status == STATUS_INVALID_HANDLE, "expected STATUS_INVALID_HANDLE, got %08lx\n", status);
+
+    timeout.QuadPart = -1000000;
+    maxevents[0] = GetCurrentThread();
+    status = pNtWaitForMultipleObjects(1, maxevents, TRUE, FALSE, &timeout);
+    todo_wine ok(status == STATUS_INVALID_HANDLE, "expected STATUS_INVALID_HANDLE, got %08lx\n", status);
+}
+
+static BOOL g_initcallback_ret, g_initcallback_called;
+static void *g_initctxt;
+
+static BOOL CALLBACK initonce_callback(INIT_ONCE *initonce, void *parameter, void **ctxt)
+{
+    g_initcallback_called = TRUE;
+    /* zero bit set means here that initialization is taking place - initialization locked */
+    ok(g_initctxt == *ctxt, "got wrong context value %p, expected %p\n", *ctxt, g_initctxt);
+    ok(initonce->Ptr == (void*)0x1, "got %p\n", initonce->Ptr);
+    ok(parameter == (void*)0xdeadbeef, "got wrong parameter\n");
+    return g_initcallback_ret;
+}
+
+static void test_initonce(void)
+{
+    INIT_ONCE initonce;
+    BOOL ret, pending;
+
+    if (!pInitOnceInitialize || !pInitOnceExecuteOnce)
+    {
+        win_skip("one-time initialization API not supported\n");
+        return;
+    }
+
+    /* blocking initialization with callback */
+    initonce.Ptr = (void*)0xdeadbeef;
+    pInitOnceInitialize(&initonce);
+    ok(initonce.Ptr == NULL, "got %p\n", initonce.Ptr);
+
+    /* initialisation completed successfully */
+    g_initcallback_ret = TRUE;
+    g_initctxt = NULL;
+    ret = pInitOnceExecuteOnce(&initonce, initonce_callback, (void*)0xdeadbeef, &g_initctxt);
+    ok(ret, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(initonce.Ptr == (void*)0x2, "got %p\n", initonce.Ptr);
+    ok(g_initctxt == NULL, "got %p\n", g_initctxt);
+    ok(g_initcallback_called, "got %d\n", g_initcallback_called);
+
+    /* so it's been called already so won't be called again */
+    g_initctxt = NULL;
+    g_initcallback_called = FALSE;
+    ret = pInitOnceExecuteOnce(&initonce, initonce_callback, (void*)0xdeadbeef, &g_initctxt);
+    ok(ret, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(initonce.Ptr == (void*)0x2, "got %p\n", initonce.Ptr);
+    ok(g_initctxt == NULL, "got %p\n", g_initctxt);
+    ok(!g_initcallback_called, "got %d\n", g_initcallback_called);
+
+    pInitOnceInitialize(&initonce);
+    g_initcallback_called = FALSE;
+    /* 2 lower order bits should never be used, you'll get a crash in result */
+    g_initctxt = (void*)0xFFFFFFF0;
+    ret = pInitOnceExecuteOnce(&initonce, initonce_callback, (void*)0xdeadbeef, &g_initctxt);
+    ok(ret, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(initonce.Ptr == (void*)0xFFFFFFF2, "got %p\n", initonce.Ptr);
+    ok(g_initctxt == (void*)0xFFFFFFF0, "got %p\n", g_initctxt);
+    ok(g_initcallback_called, "got %d\n", g_initcallback_called);
+
+    /* callback failed */
+    g_initcallback_ret = FALSE;
+    g_initcallback_called = FALSE;
+    g_initctxt = NULL;
+    pInitOnceInitialize(&initonce);
+    SetLastError( 0xdeadbeef );
+    ret = pInitOnceExecuteOnce(&initonce, initonce_callback, (void*)0xdeadbeef, &g_initctxt);
+    ok(!ret && GetLastError() == 0xdeadbeef, "got wrong ret value %d err %lu\n", ret, GetLastError());
+    ok(initonce.Ptr == NULL, "got %p\n", initonce.Ptr);
+    ok(g_initctxt == NULL, "got %p\n", g_initctxt);
+    ok(g_initcallback_called, "got %d\n", g_initcallback_called);
+
+    /* blocking initialization without a callback */
+    pInitOnceInitialize(&initonce);
+    g_initctxt = NULL;
+    pending = FALSE;
+    ret = pInitOnceBeginInitialize(&initonce, 0, &pending, &g_initctxt);
+    ok(ret, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(pending, "got %d\n", pending);
+    ok(initonce.Ptr == (void*)1, "got %p\n", initonce.Ptr);
+    ok(g_initctxt == NULL, "got %p\n", g_initctxt);
+    /* another attempt to begin initialization with block a single thread */
+
+    g_initctxt = NULL;
+    pending = 0xf;
+    SetLastError( 0xdeadbeef );
+    ret = pInitOnceBeginInitialize(&initonce, INIT_ONCE_CHECK_ONLY, &pending, &g_initctxt);
+    ok(!ret && GetLastError() == ERROR_GEN_FAILURE, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(pending == 0xf, "got %d\n", pending);
+    ok(initonce.Ptr == (void*)1, "got %p\n", initonce.Ptr);
+    ok(g_initctxt == NULL, "got %p\n", g_initctxt);
+
+    g_initctxt = (void*)0xdeadbee0;
+    SetLastError( 0xdeadbeef );
+    ret = pInitOnceComplete(&initonce, INIT_ONCE_INIT_FAILED, g_initctxt);
+    ok(!ret && GetLastError() == ERROR_INVALID_PARAMETER, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(initonce.Ptr == (void*)1, "got %p\n", initonce.Ptr);
+
+    /* once failed already */
+    g_initctxt = (void*)0xdeadbee0;
+    ret = pInitOnceComplete(&initonce, 0, g_initctxt);
+    ok(ret, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(initonce.Ptr == (void*)0xdeadbee2, "got %p\n", initonce.Ptr);
+
+    pInitOnceInitialize(&initonce);
+    SetLastError( 0xdeadbeef );
+    ret = pInitOnceComplete(&initonce, INIT_ONCE_INIT_FAILED, NULL);
+    ok(!ret && GetLastError() == ERROR_GEN_FAILURE, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(initonce.Ptr == NULL, "got %p\n", initonce.Ptr);
+
+    SetLastError( 0xdeadbeef );
+    ret = pInitOnceComplete(&initonce, INIT_ONCE_INIT_FAILED | INIT_ONCE_ASYNC, NULL);
+    ok(!ret && GetLastError() == ERROR_INVALID_PARAMETER, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(initonce.Ptr == NULL, "got %p\n", initonce.Ptr);
+
+    ret = pInitOnceBeginInitialize(&initonce, 0, &pending, &g_initctxt);
+    ok(ret, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(pending, "got %d\n", pending);
+    ok(initonce.Ptr == (void*)1, "got %p\n", initonce.Ptr);
+
+    SetLastError( 0xdeadbeef );
+    ret = pInitOnceBeginInitialize(&initonce, INIT_ONCE_ASYNC, &pending, &g_initctxt);
+    ok(!ret && GetLastError() == ERROR_INVALID_PARAMETER, "wrong ret %d err %lu\n", ret, GetLastError());
+
+    SetLastError( 0xdeadbeef );
+    ret = pInitOnceComplete(&initonce, INIT_ONCE_INIT_FAILED | INIT_ONCE_ASYNC, NULL);
+    ok(!ret && GetLastError() == ERROR_INVALID_PARAMETER, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(initonce.Ptr == (void*)1, "got %p\n", initonce.Ptr);
+
+    SetLastError( 0xdeadbeef );
+    ret = pInitOnceComplete(&initonce, 0, (void *)0xdeadbeef);
+    ok(!ret && GetLastError() == ERROR_INVALID_PARAMETER, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(initonce.Ptr == (void*)1, "got %p\n", initonce.Ptr);
+
+    ret = pInitOnceComplete(&initonce, INIT_ONCE_INIT_FAILED, NULL);
+    ok(ret, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(initonce.Ptr == NULL, "got %p\n", initonce.Ptr);
+
+    pInitOnceInitialize(&initonce);
+    ret = pInitOnceBeginInitialize(&initonce, INIT_ONCE_ASYNC, &pending, &g_initctxt);
+    ok(ret, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(pending, "got %d\n", pending);
+    ok(initonce.Ptr == (void*)3, "got %p\n", initonce.Ptr);
+
+    SetLastError( 0xdeadbeef );
+    ret = pInitOnceBeginInitialize(&initonce, 0, &pending, &g_initctxt);
+    ok(!ret && GetLastError() == ERROR_INVALID_PARAMETER, "wrong ret %d err %lu\n", ret, GetLastError());
+
+    ret = pInitOnceBeginInitialize(&initonce, INIT_ONCE_ASYNC, &pending, &g_initctxt);
+    ok(ret, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(pending, "got %d\n", pending);
+    ok(initonce.Ptr == (void*)3, "got %p\n", initonce.Ptr);
+
+    SetLastError( 0xdeadbeef );
+    ret = pInitOnceComplete(&initonce, INIT_ONCE_INIT_FAILED, NULL);
+    ok(!ret && GetLastError() == ERROR_INVALID_PARAMETER, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(initonce.Ptr == (void*)3, "got %p\n", initonce.Ptr);
+
+    SetLastError( 0xdeadbeef );
+    ret = pInitOnceComplete(&initonce, INIT_ONCE_INIT_FAILED | INIT_ONCE_ASYNC, NULL);
+    ok(!ret && GetLastError() == ERROR_INVALID_PARAMETER, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(initonce.Ptr == (void*)3, "got %p\n", initonce.Ptr);
+
+    SetLastError( 0xdeadbeef );
+    ret = pInitOnceComplete(&initonce, INIT_ONCE_ASYNC, (void *)0xdeadbeef);
+    ok(!ret && GetLastError() == ERROR_INVALID_PARAMETER, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(initonce.Ptr == (void*)3, "got %p\n", initonce.Ptr);
+
+    ret = pInitOnceComplete(&initonce, INIT_ONCE_ASYNC, (void *)0xdeadbee0);
+    ok(ret, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(initonce.Ptr == (void*)0xdeadbee2, "got %p\n", initonce.Ptr);
+
+    SetLastError( 0xdeadbeef );
+    ret = pInitOnceComplete(&initonce, INIT_ONCE_INIT_FAILED | INIT_ONCE_ASYNC, NULL);
+    ok(!ret && GetLastError() == ERROR_INVALID_PARAMETER, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(initonce.Ptr == (void*)0xdeadbee2, "got %p\n", initonce.Ptr);
+
+    pInitOnceInitialize(&initonce);
+    ret = pInitOnceBeginInitialize(&initonce, 0, &pending, &g_initctxt);
+    ok(ret, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(pending, "got %d\n", pending);
+    ok(initonce.Ptr == (void*)1, "got %p\n", initonce.Ptr);
+
+    /* test INIT_ONCE_CHECK_ONLY */
+
+    pInitOnceInitialize(&initonce);
+    SetLastError( 0xdeadbeef );
+    ret = pInitOnceBeginInitialize(&initonce, INIT_ONCE_CHECK_ONLY, &pending, &g_initctxt);
+    ok(!ret && GetLastError() == ERROR_GEN_FAILURE, "wrong ret %d err %lu\n", ret, GetLastError());
+    SetLastError( 0xdeadbeef );
+    ret = pInitOnceBeginInitialize(&initonce, INIT_ONCE_CHECK_ONLY|INIT_ONCE_ASYNC, &pending, &g_initctxt);
+    ok(!ret && GetLastError() == ERROR_INVALID_PARAMETER, "wrong ret %d err %lu\n", ret, GetLastError());
+
+    ret = pInitOnceBeginInitialize(&initonce, 0, &pending, &g_initctxt);
+    ok(ret, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(pending, "got %d\n", pending);
+    ok(initonce.Ptr == (void*)1, "got %p\n", initonce.Ptr);
+
+    SetLastError( 0xdeadbeef );
+    ret = pInitOnceBeginInitialize(&initonce, INIT_ONCE_CHECK_ONLY, &pending, &g_initctxt);
+    ok(!ret && GetLastError() == ERROR_GEN_FAILURE, "wrong ret %d err %lu\n", ret, GetLastError());
+    SetLastError( 0xdeadbeef );
+    ret = pInitOnceBeginInitialize(&initonce, INIT_ONCE_CHECK_ONLY|INIT_ONCE_ASYNC, &pending, &g_initctxt);
+    ok(!ret && GetLastError() == ERROR_INVALID_PARAMETER, "wrong ret %d err %lu\n", ret, GetLastError());
+
+    ret = pInitOnceComplete(&initonce, 0, (void *)0xdeadbee0);
+    ok(ret, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(initonce.Ptr == (void*)0xdeadbee2, "got %p\n", initonce.Ptr);
+
+    ret = pInitOnceBeginInitialize(&initonce, INIT_ONCE_CHECK_ONLY, &pending, &g_initctxt);
+    ok(ret, "got wrong ret value %d err %lu\n", ret, GetLastError());
+    ok(!pending, "got %d\n", pending);
+    ok(initonce.Ptr == (void*)0xdeadbee2, "got %p\n", initonce.Ptr);
+    ok(g_initctxt == (void*)0xdeadbee0, "got %p\n", initonce.Ptr);
+
+    SetLastError( 0xdeadbeef );
+    ret = pInitOnceBeginInitialize(&initonce, INIT_ONCE_CHECK_ONLY|INIT_ONCE_ASYNC, &pending, &g_initctxt);
+    ok(!ret && GetLastError() == ERROR_INVALID_PARAMETER, "wrong ret %d err %lu\n", ret, GetLastError());
+
+    pInitOnceInitialize(&initonce);
+    ret = pInitOnceBeginInitialize(&initonce, INIT_ONCE_ASYNC, &pending, &g_initctxt);
+    ok(ret, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(pending, "got %d\n", pending);
+    ok(initonce.Ptr == (void*)3, "got %p\n", initonce.Ptr);
+
+    SetLastError( 0xdeadbeef );
+    ret = pInitOnceBeginInitialize(&initonce, INIT_ONCE_CHECK_ONLY, &pending, &g_initctxt);
+    ok(!ret && GetLastError() == ERROR_GEN_FAILURE, "wrong ret %d err %lu\n", ret, GetLastError());
+    SetLastError( 0xdeadbeef );
+    ret = pInitOnceBeginInitialize(&initonce, INIT_ONCE_CHECK_ONLY|INIT_ONCE_ASYNC, &pending, &g_initctxt);
+    ok(!ret && GetLastError() == ERROR_INVALID_PARAMETER, "wrong ret %d err %lu\n", ret, GetLastError());
+
+    ret = pInitOnceComplete(&initonce, INIT_ONCE_ASYNC, (void *)0xdeadbee0);
+    ok(ret, "wrong ret %d err %lu\n", ret, GetLastError());
+    ok(initonce.Ptr == (void*)0xdeadbee2, "got %p\n", initonce.Ptr);
+
+    ret = pInitOnceBeginInitialize(&initonce, INIT_ONCE_CHECK_ONLY, &pending, &g_initctxt);
+    ok(ret, "got wrong ret value %d err %lu\n", ret, GetLastError());
+    ok(!pending, "got %d\n", pending);
+    ok(initonce.Ptr == (void*)0xdeadbee2, "got %p\n", initonce.Ptr);
+    ok(g_initctxt == (void*)0xdeadbee0, "got %p\n", initonce.Ptr);
+
+    SetLastError( 0xdeadbeef );
+    ret = pInitOnceBeginInitialize(&initonce, INIT_ONCE_CHECK_ONLY|INIT_ONCE_ASYNC, &pending, &g_initctxt);
+    ok(!ret && GetLastError() == ERROR_INVALID_PARAMETER, "wrong ret %d err %lu\n", ret, GetLastError());
+}
+
+static CONDITION_VARIABLE buffernotempty = CONDITION_VARIABLE_INIT;
+static CONDITION_VARIABLE buffernotfull = CONDITION_VARIABLE_INIT;
+static CRITICAL_SECTION   buffercrit;
+static BOOL condvar_stop = FALSE, condvar_sleeperr = FALSE;
+static LONG bufferlen,totalproduced,totalconsumed;
+static LONG condvar_producer_sleepcnt,condvar_consumer_sleepcnt;
+
+#define BUFFER_SIZE 5
+
+static DWORD WINAPI condvar_producer(LPVOID x) {
+    DWORD sleepinterval = 5;
+
+    while (1) {
+        Sleep(sleepinterval);
+        if (sleepinterval > 1)
+            sleepinterval -= 1;
+
+        EnterCriticalSection(&buffercrit);
+        while ((bufferlen == BUFFER_SIZE) && !condvar_stop) {
+            condvar_producer_sleepcnt++;
+            if (!pSleepConditionVariableCS(&buffernotfull, &buffercrit, sleepinterval)) {
+                if (GetLastError() != ERROR_TIMEOUT)
+                    condvar_sleeperr = TRUE;
+            }
+        }
+        if (condvar_stop) {
+            LeaveCriticalSection(&buffercrit);
+            break;
+        }
+        bufferlen++;
+        totalproduced++;
+        LeaveCriticalSection(&buffercrit);
+        pWakeConditionVariable(&buffernotempty);
+    }
+    return 0;
+}
+
+static DWORD WINAPI condvar_consumer(LPVOID x) {
+    DWORD *cnt = (DWORD*)x;
+    DWORD sleepinterval = 1;
+
+    while (1) {
+        EnterCriticalSection(&buffercrit);
+        while ((bufferlen == 0) && !condvar_stop) {
+            condvar_consumer_sleepcnt++;
+            if (!pSleepConditionVariableCS (&buffernotempty, &buffercrit, sleepinterval)) {
+                if (GetLastError() != ERROR_TIMEOUT)
+                    condvar_sleeperr = TRUE;
+            }
+        }
+        if (condvar_stop && (bufferlen == 0)) {
+            LeaveCriticalSection(&buffercrit);
+            break;
+        }
+        bufferlen--;
+        totalconsumed++;
+        (*cnt)++;
+        LeaveCriticalSection(&buffercrit);
+        pWakeConditionVariable(&buffernotfull);
+        Sleep(sleepinterval);
+        if (sleepinterval < 5) sleepinterval += 1;
+    }
+    return 0;
+}
+
+static void test_condvars_consumer_producer(void)
+{
+    HANDLE hp1,hp2,hp3,hc1,hc2,hc3;
+    DWORD dummy;
+    DWORD cnt1,cnt2,cnt3;
+
+    if (!pInitializeConditionVariable) {
+        /* function is not yet in XP, only in newer Windows */
+        win_skip("no condition variable support.\n");
+        return;
+    }
+
+    /* Implement a producer / consumer scheme with non-full / non-empty triggers */
+
+    /* If we have static initialized condition variables, InitializeConditionVariable
+     * is not strictly necessary.
+     * pInitializeConditionVariable(&buffernotfull);
+     */
+    pInitializeConditionVariable(&buffernotempty);
+    InitializeCriticalSection(&buffercrit);
+
+    /* Larger Test: consumer/producer example */
+
+    bufferlen = totalproduced = totalconsumed = cnt1 = cnt2 = cnt3 = 0;
+
+    hp1 = CreateThread(NULL, 0, condvar_producer, NULL, 0, &dummy);
+    hp2 = CreateThread(NULL, 0, condvar_producer, NULL, 0, &dummy);
+    hp3 = CreateThread(NULL, 0, condvar_producer, NULL, 0, &dummy);
+    hc1 = CreateThread(NULL, 0, condvar_consumer, (PVOID)&cnt1, 0, &dummy);
+    hc2 = CreateThread(NULL, 0, condvar_consumer, (PVOID)&cnt2, 0, &dummy);
+    hc3 = CreateThread(NULL, 0, condvar_consumer, (PVOID)&cnt3, 0, &dummy);
+
+    /* Limit run to 0.5 seconds. */
+    Sleep(500);
+
+    /* tear down start */
+    condvar_stop = TRUE;
+
+    /* final wake up call */
+    pWakeAllConditionVariable (&buffernotfull);
+    pWakeAllConditionVariable (&buffernotempty);
+
+    /* (mostly an implementation detail)
+     * ok(buffernotfull.Ptr == NULL, "buffernotfull.Ptr is %p\n", buffernotfull.Ptr);
+     */
+
+    WaitForSingleObject(hp1, 1000);
+    WaitForSingleObject(hp2, 1000);
+    WaitForSingleObject(hp3, 1000);
+    WaitForSingleObject(hc1, 1000);
+    WaitForSingleObject(hc2, 1000);
+    WaitForSingleObject(hc3, 1000);
+
+    ok(totalconsumed == totalproduced,
+       "consumed %ld != produced %ld\n", totalconsumed, totalproduced);
+    ok (!condvar_sleeperr, "error occurred during SleepConditionVariableCS\n");
+
+    /* Checking cnt1 - cnt2 for non-0 would be not good, the case where
+     * one consumer does not get anything to do is possible. */
+    trace("produced %ld, c1 %ld, c2 %ld, c3 %ld\n", totalproduced, cnt1, cnt2, cnt3);
+    /* The sleeps of the producer or consumer should not go above 100* produced count,
+     * otherwise the implementation does not sleep correctly. But yet again, this is
+     * not hard defined. */
+    trace("producer sleep %ld, consumer sleep %ld\n", condvar_producer_sleepcnt, condvar_consumer_sleepcnt);
+}
+
+/* Sample test for some sequence of events happening, sequenced using "condvar_seq" */
+static DWORD condvar_seq = 0;
+static CONDITION_VARIABLE aligned_cv;
+static CRITICAL_SECTION condvar_crit;
+static SRWLOCK condvar_srwlock;
+
+#pragma pack(push,1)
+static struct
+{
+    char c;
+    CONDITION_VARIABLE cv;
+} unaligned_cv;
+#pragma pack(pop)
+
+/* Sequence of wake/sleep to check boundary conditions:
+ * 0: init
+ * 1: producer emits a WakeConditionVariable without consumer waiting.
+ * 2: consumer sleeps without a wake expecting timeout
+ * 3: producer emits a WakeAllConditionVariable without consumer waiting.
+ * 4: consumer sleeps without a wake expecting timeout
+ * 5: a wake is handed to a SleepConditionVariableCS
+ * 6: a wakeall is handed to a SleepConditionVariableCS
+ * 7: sleep after above should timeout
+ * 8: wake with crit section locked into the sleep timeout
+ *
+ * the following tests will only be executed if InitializeSRWLock is available
+ *
+ *  9: producer (exclusive) wakes up consumer (exclusive)
+ * 10: producer (exclusive) wakes up consumer (shared)
+ * 11: producer (shared) wakes up consumer (exclusive)
+ * 12: producer (shared) wakes up consumer (shared)
+ * 13: end
+ */
+static DWORD WINAPI condvar_base_producer(void *arg)
+{
+    CONDITION_VARIABLE *cv = arg;
+
+    while (condvar_seq < 1) Sleep(1);
+
+    pWakeConditionVariable(cv);
+    condvar_seq = 2;
+
+    while (condvar_seq < 3) Sleep(1);
+    pWakeAllConditionVariable(cv);
+    condvar_seq = 4;
+
+    while (condvar_seq < 5) Sleep(1);
+    EnterCriticalSection (&condvar_crit);
+    pWakeConditionVariable(cv);
+    LeaveCriticalSection (&condvar_crit);
+    while (condvar_seq < 6) Sleep(1);
+    EnterCriticalSection (&condvar_crit);
+    pWakeAllConditionVariable(cv);
+    LeaveCriticalSection (&condvar_crit);
+
+    while (condvar_seq < 8) Sleep(1);
+    EnterCriticalSection (&condvar_crit);
+    pWakeConditionVariable(cv);
+    Sleep(50);
+    LeaveCriticalSection (&condvar_crit);
+
+    /* skip over remaining tests if InitializeSRWLock is not available */
+    if (!pInitializeSRWLock)
+        return 0;
+
+    while (condvar_seq < 9) Sleep(1);
+    pAcquireSRWLockExclusive(&condvar_srwlock);
+    pWakeConditionVariable(cv);
+    pReleaseSRWLockExclusive(&condvar_srwlock);
+
+    while (condvar_seq < 10) Sleep(1);
+    pAcquireSRWLockExclusive(&condvar_srwlock);
+    pWakeConditionVariable(cv);
+    pReleaseSRWLockExclusive(&condvar_srwlock);
+
+    while (condvar_seq < 11) Sleep(1);
+    pAcquireSRWLockShared(&condvar_srwlock);
+    pWakeConditionVariable(cv);
+    pReleaseSRWLockShared(&condvar_srwlock);
+
+    while (condvar_seq < 12) Sleep(1);
+    Sleep(50); /* ensure that consumer waits for cond variable */
+    pAcquireSRWLockShared(&condvar_srwlock);
+    pWakeConditionVariable(cv);
+    pReleaseSRWLockShared(&condvar_srwlock);
+
+    return 0;
+}
+
+static DWORD WINAPI condvar_base_consumer(void *arg)
+{
+    CONDITION_VARIABLE *cv = arg;
+    BOOL ret;
+
+    while (condvar_seq < 2) Sleep(1);
+
+    /* wake was emitted, but we were not sleeping */
+    EnterCriticalSection (&condvar_crit);
+    ret = pSleepConditionVariableCS(cv, &condvar_crit, 10);
+    LeaveCriticalSection (&condvar_crit);
+    ok (!ret, "SleepConditionVariableCS should return FALSE on out of band wake\n");
+    ok (GetLastError() == ERROR_TIMEOUT, "SleepConditionVariableCS should return ERROR_TIMEOUT on out of band wake, not %ld\n", GetLastError());
+
+    condvar_seq = 3;
+    while (condvar_seq < 4) Sleep(1);
+
+    /* wake all was emitted, but we were not sleeping */
+    EnterCriticalSection (&condvar_crit);
+    ret = pSleepConditionVariableCS(cv, &condvar_crit, 10);
+    LeaveCriticalSection (&condvar_crit);
+    ok (!ret, "SleepConditionVariableCS should return FALSE on out of band wake\n");
+    ok (GetLastError() == ERROR_TIMEOUT, "SleepConditionVariableCS should return ERROR_TIMEOUT on out of band wake, not %ld\n", GetLastError());
+
+    EnterCriticalSection (&condvar_crit);
+    condvar_seq = 5;
+    ret = pSleepConditionVariableCS(cv, &condvar_crit, 200);
+    LeaveCriticalSection (&condvar_crit);
+    ok (ret, "SleepConditionVariableCS should return TRUE on good wake\n");
+
+    EnterCriticalSection (&condvar_crit);
+    condvar_seq = 6;
+    ret = pSleepConditionVariableCS(cv, &condvar_crit, 200);
+    LeaveCriticalSection (&condvar_crit);
+    ok (ret, "SleepConditionVariableCS should return TRUE on good wakeall\n");
+    condvar_seq = 7;
+
+    EnterCriticalSection (&condvar_crit);
+    ret = pSleepConditionVariableCS(cv, &condvar_crit, 10);
+    LeaveCriticalSection (&condvar_crit);
+    ok (!ret, "SleepConditionVariableCS should return FALSE on out of band wake\n");
+    ok (GetLastError() == ERROR_TIMEOUT, "SleepConditionVariableCS should return ERROR_TIMEOUT on out of band wake, not %ld\n", GetLastError());
+
+    EnterCriticalSection (&condvar_crit);
+    condvar_seq = 8;
+    ret = pSleepConditionVariableCS(cv, &condvar_crit, 20);
+    LeaveCriticalSection (&condvar_crit);
+    ok (ret, "SleepConditionVariableCS should still return TRUE on crit unlock delay\n");
+
+    /* skip over remaining tests if InitializeSRWLock is not available */
+    if (!pInitializeSRWLock)
+    {
+        win_skip("no srw lock support.\n");
+        condvar_seq = 13; /* end */
+        return 0;
+    }
+
+    pAcquireSRWLockExclusive(&condvar_srwlock);
+    condvar_seq = 9;
+    ret = pSleepConditionVariableSRW(cv, &condvar_srwlock, 200, 0);
+    pReleaseSRWLockExclusive(&condvar_srwlock);
+    ok (ret, "pSleepConditionVariableSRW should return TRUE on good wake\n");
+
+    pAcquireSRWLockShared(&condvar_srwlock);
+    condvar_seq = 10;
+    ret = pSleepConditionVariableSRW(cv, &condvar_srwlock, 200, CONDITION_VARIABLE_LOCKMODE_SHARED);
+    pReleaseSRWLockShared(&condvar_srwlock);
+    ok (ret, "pSleepConditionVariableSRW should return TRUE on good wake\n");
+
+    pAcquireSRWLockExclusive(&condvar_srwlock);
+    condvar_seq = 11;
+    ret = pSleepConditionVariableSRW(cv, &condvar_srwlock, 200, 0);
+    pReleaseSRWLockExclusive(&condvar_srwlock);
+    ok (ret, "pSleepConditionVariableSRW should return TRUE on good wake\n");
+
+    pAcquireSRWLockShared(&condvar_srwlock);
+    condvar_seq = 12;
+    ret = pSleepConditionVariableSRW(cv, &condvar_srwlock, 200, CONDITION_VARIABLE_LOCKMODE_SHARED);
+    pReleaseSRWLockShared(&condvar_srwlock);
+    ok (ret, "pSleepConditionVariableSRW should return TRUE on good wake\n");
+
+    condvar_seq = 13;
+    return 0;
+}
+
+static void test_condvars_base(RTL_CONDITION_VARIABLE *cv)
+{
+    HANDLE hp, hc;
+    DWORD dummy;
+    BOOL ret;
+
+    if (!pInitializeConditionVariable) {
+        /* function is not yet in XP, only in newer Windows */
+        win_skip("no condition variable support.\n");
+        return;
+    }
+
+    InitializeCriticalSection (&condvar_crit);
+
+    if (pInitializeSRWLock)
+        pInitializeSRWLock(&condvar_srwlock);
+
+    EnterCriticalSection (&condvar_crit);
+    ret = pSleepConditionVariableCS(cv, &condvar_crit, 10);
+    LeaveCriticalSection (&condvar_crit);
+
+    ok (!ret, "SleepConditionVariableCS should return FALSE on untriggered condvar\n");
+    ok (GetLastError() == ERROR_TIMEOUT, "SleepConditionVariableCS should return ERROR_TIMEOUT on untriggered condvar, not %ld\n", GetLastError());
+
+    if (pInitializeSRWLock)
+    {
+        pAcquireSRWLockExclusive(&condvar_srwlock);
+        ret = pSleepConditionVariableSRW(cv, &condvar_srwlock, 10, 0);
+        pReleaseSRWLockExclusive(&condvar_srwlock);
+
+        ok(!ret, "SleepConditionVariableSRW should return FALSE on untriggered condvar\n");
+        ok(GetLastError() == ERROR_TIMEOUT, "SleepConditionVariableSRW should return ERROR_TIMEOUT on untriggered condvar, not %ld\n", GetLastError());
+
+        pAcquireSRWLockShared(&condvar_srwlock);
+        ret = pSleepConditionVariableSRW(cv, &condvar_srwlock, 10, CONDITION_VARIABLE_LOCKMODE_SHARED);
+        pReleaseSRWLockShared(&condvar_srwlock);
+
+        ok(!ret, "SleepConditionVariableSRW should return FALSE on untriggered condvar\n");
+        ok(GetLastError() == ERROR_TIMEOUT, "SleepConditionVariableSRW should return ERROR_TIMEOUT on untriggered condvar, not %ld\n", GetLastError());
+    }
+
+    condvar_seq = 0;
+    hp = CreateThread(NULL, 0, condvar_base_producer, cv, 0, &dummy);
+    hc = CreateThread(NULL, 0, condvar_base_consumer, cv, 0, &dummy);
+
+    condvar_seq = 1; /* go */
+
+    while (condvar_seq < 9)
+        Sleep (5);
+    WaitForSingleObject(hp, 100);
+    WaitForSingleObject(hc, 100);
+}
+
+static LONG srwlock_seq = 0;
+static SRWLOCK aligned_srwlock;
+static struct
+{
+    LONG wrong_execution_order;
+    LONG samethread_excl_excl;
+    LONG samethread_excl_shared;
+    LONG samethread_shared_excl;
+    LONG multithread_excl_excl;
+    LONG excl_not_preferred;
+    LONG trylock_excl;
+    LONG trylock_shared;
+} srwlock_base_errors;
+
+#if defined(__i386__) || defined(__x86_64__)
+#pragma pack(push,1)
+struct
+{
+    char c;
+    SRWLOCK lock;
+} unaligned_srwlock;
+#pragma pack(pop)
+#endif
+
+/* Sequence of acquire/release to check boundary conditions:
+ *  0: init
+ *
+ *  1: thread2 acquires an exclusive lock and tries to acquire a second exclusive lock
+ *  2: thread1 expects a deadlock and releases the waiting lock
+ *     thread2 releases the lock again
+ *
+ *  3: thread2 acquires an exclusive lock and tries to acquire a shared lock
+ *  4: thread1 expects a deadlock and releases the waiting lock
+ *     thread2 releases the lock again
+ *
+ *  5: thread2 acquires a shared lock and tries to acquire an exclusive lock
+ *  6: thread1 expects a deadlock and releases the waiting lock
+ *     thread2 releases the lock again
+ *
+ *  7: thread2 acquires and releases two nested shared locks
+ *
+ *  8: thread1 acquires an exclusive lock
+ *  9: thread2 tries to acquire the exclusive lock, too
+ *     thread1 releases the exclusive lock again
+ * 10: thread2 enters the exclusive lock and leaves it immediately again
+ *
+ * 11: thread1 acquires a shared lock
+ * 12: thread2 acquires and releases a shared lock
+ *     thread1 releases the lock again
+ *
+ * 13: thread1 acquires a shared lock
+ * 14: thread2 tries to acquire an exclusive lock
+ * 15: thread3 tries to acquire a shared lock
+ * 16: thread1 releases the shared lock
+ * 17: thread2 wakes up and releases the exclusive lock
+ * 18: thread3 wakes up and releases the shared lock
+ *
+ * the following tests will only be executed if TryAcquireSRWLock* is available
+ *
+ * 19: thread1 calls TryAcquireSRWLockExclusive which should return TRUE
+ *     thread1 checks the result of recursive calls to TryAcquireSRWLock*
+ *     thread1 releases the exclusive lock
+ *
+ *     thread1 calls TryAcquireSRWLockShared which should return TRUE
+ *     thread1 checks the result of recursive calls to TryAcquireSRWLock*
+ *     thread1 releases the shared lock
+ *
+ *     thread1 acquires an exclusive lock
+ * 20: thread2 calls TryAcquireSRWLockShared which should return FALSE
+ *     thread2 calls TryAcquireSRWLockExclusive which should return FALSE
+ * 21: thread1 releases the exclusive lock
+ *
+ *     thread1 acquires an shared lock
+ * 22: thread2 calls TryAcquireSRWLockShared which should return TRUE
+ *     thread2 calls TryAcquireSRWLockExclusive which should return FALSE
+ * 23: thread1 releases the shared lock
+ *
+ *     thread1 acquires a shared lock and tries to acquire an exclusive lock
+ * 24: thread2 calls TryAcquireSRWLockShared which should return FALSE
+ *     thread2 calls TryAcquireSRWLockExclusive which should return FALSE
+ * 25: thread1 releases the exclusive lock
+ *
+ *     thread1 acquires two shared locks
+ * 26: thread2 calls TryAcquireSRWLockShared which should return TRUE
+ *     thread2 calls TryAcquireSRWLockExclusive which should return FALSE
+ * 27: thread1 releases one shared lock
+ * 28: thread2 calls TryAcquireSRWLockShared which should return TRUE
+ *     thread2 calls TryAcquireSRWLockExclusive which should return FALSE
+ * 29: thread1 releases the second shared lock
+ * 30: thread2 calls TryAcquireSRWLockShared which should return TRUE
+ *     thread2 calls TryAcquireSRWLockExclusive which should return TRUE
+ *
+ * 31: end
+ */
+
+static DWORD WINAPI srwlock_base_thread1(void *arg)
+{
+    SRWLOCK *lock = arg;
+
+    /* seq 2 */
+    while (srwlock_seq < 2) Sleep(1);
+    Sleep(100);
+    if (InterlockedIncrement(&srwlock_seq) != 3)
+        InterlockedIncrement(&srwlock_base_errors.samethread_excl_excl);
+    pReleaseSRWLockExclusive(lock);
+
+    /* seq 4 */
+    while (srwlock_seq < 4) Sleep(1);
+    Sleep(100);
+    if (InterlockedIncrement(&srwlock_seq) != 5)
+        InterlockedIncrement(&srwlock_base_errors.samethread_excl_shared);
+    pReleaseSRWLockExclusive(lock);
+
+    /* seq 6 */
+    while (srwlock_seq < 6) Sleep(1);
+    Sleep(100);
+    if (InterlockedIncrement(&srwlock_seq) != 7)
+        InterlockedIncrement(&srwlock_base_errors.samethread_shared_excl);
+    pReleaseSRWLockShared(lock);
+
+    /* seq 8 */
+    while (srwlock_seq < 8) Sleep(1);
+    pAcquireSRWLockExclusive(lock);
+    if (InterlockedIncrement(&srwlock_seq) != 9)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+    Sleep(100);
+    if (InterlockedIncrement(&srwlock_seq) != 10)
+        InterlockedIncrement(&srwlock_base_errors.multithread_excl_excl);
+    pReleaseSRWLockExclusive(lock);
+
+    /* seq 11 */
+    while (srwlock_seq < 11) Sleep(1);
+    pAcquireSRWLockShared(lock);
+    if (InterlockedIncrement(&srwlock_seq) != 12)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+
+    /* seq 13 */
+    while (srwlock_seq < 13) Sleep(1);
+    pReleaseSRWLockShared(lock);
+    pAcquireSRWLockShared(lock);
+    if (InterlockedIncrement(&srwlock_seq) != 14)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+
+    /* seq 16 */
+    while (srwlock_seq < 16) Sleep(1);
+    Sleep(50); /* ensure that both the exclusive and shared access thread are queued */
+    if (InterlockedIncrement(&srwlock_seq) != 17)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+    pReleaseSRWLockShared(lock);
+
+    /* skip over remaining tests if TryAcquireSRWLock* is not available */
+    if (!pTryAcquireSRWLockExclusive)
+        return 0;
+
+    /* seq 19 */
+    while (srwlock_seq < 19) Sleep(1);
+    if (pTryAcquireSRWLockExclusive(lock))
+    {
+        if (pTryAcquireSRWLockShared(lock))
+            InterlockedIncrement(&srwlock_base_errors.trylock_shared);
+        if (pTryAcquireSRWLockExclusive(lock))
+            InterlockedIncrement(&srwlock_base_errors.trylock_excl);
+        pReleaseSRWLockExclusive(lock);
+    }
+    else
+        InterlockedIncrement(&srwlock_base_errors.trylock_excl);
+
+    if (pTryAcquireSRWLockShared(lock))
+    {
+        if (pTryAcquireSRWLockShared(lock))
+            pReleaseSRWLockShared(lock);
+        else
+            InterlockedIncrement(&srwlock_base_errors.trylock_shared);
+        if (pTryAcquireSRWLockExclusive(lock))
+            InterlockedIncrement(&srwlock_base_errors.trylock_excl);
+        pReleaseSRWLockShared(lock);
+    }
+    else
+        InterlockedIncrement(&srwlock_base_errors.trylock_shared);
+
+    pAcquireSRWLockExclusive(lock);
+    if (InterlockedIncrement(&srwlock_seq) != 20)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+
+    /* seq 21 */
+    while (srwlock_seq < 21) Sleep(1);
+    pReleaseSRWLockExclusive(lock);
+    pAcquireSRWLockShared(lock);
+    if (InterlockedIncrement(&srwlock_seq) != 22)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+
+    /* seq 23 */
+    while (srwlock_seq < 23) Sleep(1);
+    pReleaseSRWLockShared(lock);
+    pAcquireSRWLockShared(lock);
+    if (InterlockedIncrement(&srwlock_seq) != 24)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+
+    /* seq 25 */
+    pAcquireSRWLockExclusive(lock);
+    if (srwlock_seq != 25)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+    pReleaseSRWLockExclusive(lock);
+
+    pAcquireSRWLockShared(lock);
+    pAcquireSRWLockShared(lock);
+    if (InterlockedIncrement(&srwlock_seq) != 26)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+
+    /* seq 27 */
+    while (srwlock_seq < 27) Sleep(1);
+    pReleaseSRWLockShared(lock);
+    if (InterlockedIncrement(&srwlock_seq) != 28)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+
+    /* seq 29 */
+    while (srwlock_seq < 29) Sleep(1);
+    pReleaseSRWLockShared(lock);
+    if (InterlockedIncrement(&srwlock_seq) != 30)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+
+    return 0;
+}
+
+static DWORD WINAPI srwlock_base_thread2(void *arg)
+{
+    SRWLOCK *lock = arg;
+
+    /* seq 1 */
+    while (srwlock_seq < 1) Sleep(1);
+    pAcquireSRWLockExclusive(lock);
+    if (InterlockedIncrement(&srwlock_seq) != 2)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+
+    /* seq 3 */
+    pAcquireSRWLockExclusive(lock);
+    if (srwlock_seq != 3)
+        InterlockedIncrement(&srwlock_base_errors.samethread_excl_excl);
+    pReleaseSRWLockExclusive(lock);
+    pAcquireSRWLockExclusive(lock);
+    if (InterlockedIncrement(&srwlock_seq) != 4)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+
+    /* seq 5 */
+    pAcquireSRWLockShared(lock);
+    if (srwlock_seq != 5)
+        InterlockedIncrement(&srwlock_base_errors.samethread_excl_shared);
+    pReleaseSRWLockShared(lock);
+    pAcquireSRWLockShared(lock);
+    if (InterlockedIncrement(&srwlock_seq) != 6)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+
+    /* seq 7 */
+    pAcquireSRWLockExclusive(lock);
+    if (srwlock_seq != 7)
+        InterlockedIncrement(&srwlock_base_errors.samethread_shared_excl);
+    pReleaseSRWLockExclusive(lock);
+    pAcquireSRWLockShared(lock);
+    pAcquireSRWLockShared(lock);
+    pReleaseSRWLockShared(lock);
+    pReleaseSRWLockShared(lock);
+    if (InterlockedIncrement(&srwlock_seq) != 8)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+
+    /* seq 9, 10 */
+    while (srwlock_seq < 9) Sleep(1);
+    pAcquireSRWLockExclusive(lock);
+    if (srwlock_seq != 10)
+        InterlockedIncrement(&srwlock_base_errors.multithread_excl_excl);
+    pReleaseSRWLockExclusive(lock);
+    if (InterlockedIncrement(&srwlock_seq) != 11)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+
+    /* seq 12 */
+    while (srwlock_seq < 12) Sleep(1);
+    pAcquireSRWLockShared(lock);
+    pReleaseSRWLockShared(lock);
+    if (InterlockedIncrement(&srwlock_seq) != 13)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+
+    /* seq 14 */
+    while (srwlock_seq < 14) Sleep(1);
+    if (InterlockedIncrement(&srwlock_seq) != 15)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+
+    /* seq 17 */
+    pAcquireSRWLockExclusive(lock);
+    if (srwlock_seq != 17)
+        InterlockedIncrement(&srwlock_base_errors.excl_not_preferred);
+    if (InterlockedIncrement(&srwlock_seq) != 18)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+    pReleaseSRWLockExclusive(lock);
+
+    /* skip over remaining tests if TryAcquireSRWLock* is not available */
+    if (!pTryAcquireSRWLockExclusive)
+        return 0;
+
+    /* seq 20 */
+    while (srwlock_seq < 20) Sleep(1);
+    if (pTryAcquireSRWLockShared(lock))
+        InterlockedIncrement(&srwlock_base_errors.trylock_shared);
+    if (pTryAcquireSRWLockExclusive(lock))
+        InterlockedIncrement(&srwlock_base_errors.trylock_excl);
+    if (InterlockedIncrement(&srwlock_seq) != 21)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+
+    /* seq 22 */
+    while (srwlock_seq < 22) Sleep(1);
+    if (pTryAcquireSRWLockShared(lock))
+        pReleaseSRWLockShared(lock);
+    else
+        InterlockedIncrement(&srwlock_base_errors.trylock_shared);
+    if (pTryAcquireSRWLockExclusive(lock))
+        InterlockedIncrement(&srwlock_base_errors.trylock_excl);
+    if (InterlockedIncrement(&srwlock_seq) != 23)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+
+    /* seq 24 */
+    while (srwlock_seq < 24) Sleep(1);
+    Sleep(50); /* ensure that exclusive access request is queued */
+    if (pTryAcquireSRWLockShared(lock))
+    {
+        pReleaseSRWLockShared(lock);
+        InterlockedIncrement(&srwlock_base_errors.excl_not_preferred);
+    }
+    if (pTryAcquireSRWLockExclusive(lock))
+        InterlockedIncrement(&srwlock_base_errors.trylock_excl);
+    if (InterlockedIncrement(&srwlock_seq) != 25)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+    pReleaseSRWLockShared(lock);
+
+    /* seq 26 */
+    while (srwlock_seq < 26) Sleep(1);
+    if (pTryAcquireSRWLockShared(lock))
+        pReleaseSRWLockShared(lock);
+    else
+        InterlockedIncrement(&srwlock_base_errors.trylock_shared);
+    if (pTryAcquireSRWLockExclusive(lock))
+        InterlockedIncrement(&srwlock_base_errors.trylock_excl);
+    if (InterlockedIncrement(&srwlock_seq) != 27)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+
+    /* seq 28 */
+    while (srwlock_seq < 28) Sleep(1);
+    if (pTryAcquireSRWLockShared(lock))
+        pReleaseSRWLockShared(lock);
+    else
+        InterlockedIncrement(&srwlock_base_errors.trylock_shared);
+    if (pTryAcquireSRWLockExclusive(lock))
+        InterlockedIncrement(&srwlock_base_errors.trylock_excl);
+    if (InterlockedIncrement(&srwlock_seq) != 29)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+
+    /* seq 30 */
+    while (srwlock_seq < 30) Sleep(1);
+    if (pTryAcquireSRWLockShared(lock))
+        pReleaseSRWLockShared(lock);
+    else
+        InterlockedIncrement(&srwlock_base_errors.trylock_shared);
+    if (pTryAcquireSRWLockExclusive(lock))
+        pReleaseSRWLockExclusive(lock);
+    else
+        InterlockedIncrement(&srwlock_base_errors.trylock_excl);
+    if (InterlockedIncrement(&srwlock_seq) != 31)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+
+    return 0;
+}
+
+static DWORD WINAPI srwlock_base_thread3(void *arg)
+{
+    SRWLOCK *lock = arg;
+
+    /* seq 15 */
+    while (srwlock_seq < 15) Sleep(1);
+    Sleep(50); /* some delay, so that thread2 can try to acquire a second exclusive lock */
+    if (InterlockedIncrement(&srwlock_seq) != 16)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+
+    /* seq 18 */
+    pAcquireSRWLockShared(lock);
+    if (srwlock_seq != 18)
+        InterlockedIncrement(&srwlock_base_errors.excl_not_preferred);
+    pReleaseSRWLockShared(lock);
+    if (InterlockedIncrement(&srwlock_seq) != 19)
+        InterlockedIncrement(&srwlock_base_errors.wrong_execution_order);
+
+    /* skip over remaining tests if TryAcquireSRWLock* is not available */
+    if (!pTryAcquireSRWLockExclusive)
+    {
+        /* function is only in Windows 7 and newer */
+        win_skip("no srw trylock support.\n");
+        srwlock_seq = 31; /* end */
+        return 0;
+    }
+
+    return 0;
+}
+
+static void test_srwlock_base(SRWLOCK *lock)
+{
+    HANDLE h1, h2, h3;
+    DWORD dummy;
+
+    if (!pInitializeSRWLock)
+    {
+        /* function is not yet in XP, only in newer Windows */
+        win_skip("no srw lock support.\n");
+        return;
+    }
+
+    pInitializeSRWLock(lock);
+    memset(&srwlock_base_errors, 0, sizeof(srwlock_base_errors));
+    srwlock_seq = 0;
+
+    h1 = CreateThread(NULL, 0, srwlock_base_thread1, lock, 0, &dummy);
+    h2 = CreateThread(NULL, 0, srwlock_base_thread2, lock, 0, &dummy);
+    h3 = CreateThread(NULL, 0, srwlock_base_thread3, lock, 0, &dummy);
+
+    srwlock_seq = 1; /* go */
+    while (srwlock_seq < 31)
+        Sleep(5);
+
+    WaitForSingleObject(h1, 100);
+    WaitForSingleObject(h2, 100);
+    WaitForSingleObject(h3, 100);
+
+    ok(!srwlock_base_errors.wrong_execution_order,
+            "thread commands were executed in the wrong order (occurred %ld times).\n",
+            srwlock_base_errors.wrong_execution_order);
+
+    ok(!srwlock_base_errors.samethread_excl_excl,
+            "AcquireSRWLockExclusive didn't block when called multiple times from the same thread (occurred %ld times).\n",
+            srwlock_base_errors.samethread_excl_excl);
+
+    ok(!srwlock_base_errors.samethread_excl_shared,
+            "AcquireSRWLockShared didn't block when the same thread holds an exclusive lock (occurred %ld times).\n",
+            srwlock_base_errors.samethread_excl_shared);
+
+    ok(!srwlock_base_errors.samethread_shared_excl,
+            "AcquireSRWLockExclusive didn't block when the same thread holds a shared lock (occurred %ld times).\n",
+            srwlock_base_errors.samethread_shared_excl);
+
+    ok(!srwlock_base_errors.multithread_excl_excl,
+            "AcquireSRWLockExclusive didn't block when a second thread holds the exclusive lock (occurred %ld times).\n",
+            srwlock_base_errors.multithread_excl_excl);
+
+    ok(!srwlock_base_errors.excl_not_preferred,
+            "thread waiting for exclusive access to the SHMLock was not preferred (occurred %ld times).\n",
+            srwlock_base_errors.excl_not_preferred);
+
+    ok(!srwlock_base_errors.trylock_excl,
+            "TryAcquireSRWLockExclusive didn't behave as expected (occurred %ld times).\n",
+            srwlock_base_errors.trylock_excl);
+
+    ok(!srwlock_base_errors.trylock_shared,
+            "TryAcquireSRWLockShared didn't behave as expected (occurred %ld times).\n",
+            srwlock_base_errors.trylock_shared);
+
+}
+
+static SRWLOCK srwlock_example;
+static LONG srwlock_protected_value = 0;
+static LONG srwlock_example_errors = 0, srwlock_inside = 0, srwlock_cnt = 0;
+static BOOL srwlock_stop = FALSE;
+
+static DWORD WINAPI srwlock_example_thread(LPVOID x) {
+    DWORD *cnt = x;
+    LONG old;
+
+    while (!srwlock_stop)
+    {
+
+        /* periodically request exclusive access */
+        if (InterlockedIncrement(&srwlock_cnt) % 13 == 0)
+        {
+            pAcquireSRWLockExclusive(&srwlock_example);
+            if (InterlockedIncrement(&srwlock_inside) != 1)
+                InterlockedIncrement(&srwlock_example_errors);
+
+            InterlockedIncrement(&srwlock_protected_value);
+            Sleep(1);
+
+            if (InterlockedDecrement(&srwlock_inside) != 0)
+                InterlockedIncrement(&srwlock_example_errors);
+            pReleaseSRWLockExclusive(&srwlock_example);
+        }
+
+        /* request shared access */
+        pAcquireSRWLockShared(&srwlock_example);
+        InterlockedIncrement(&srwlock_inside);
+        old = srwlock_protected_value;
+
+        (*cnt)++;
+        Sleep(1);
+
+        if (old != srwlock_protected_value)
+            InterlockedIncrement(&srwlock_example_errors);
+        InterlockedDecrement(&srwlock_inside);
+        pReleaseSRWLockShared(&srwlock_example);
+    }
+
+    return 0;
+}
+
+static void test_srwlock_example(void)
+{
+    HANDLE h1, h2, h3;
+    DWORD dummy;
+    DWORD cnt1, cnt2, cnt3;
+
+    if (!pInitializeSRWLock) {
+        /* function is not yet in XP, only in newer Windows */
+        win_skip("no srw lock support.\n");
+        return;
+    }
+
+    pInitializeSRWLock(&srwlock_example);
+
+    cnt1 = cnt2 = cnt3 = 0;
+
+    h1 = CreateThread(NULL, 0, srwlock_example_thread, &cnt1, 0, &dummy);
+    h2 = CreateThread(NULL, 0, srwlock_example_thread, &cnt2, 0, &dummy);
+    h3 = CreateThread(NULL, 0, srwlock_example_thread, &cnt3, 0, &dummy);
+
+    /* limit run to 1 second. */
+    Sleep(1000);
+
+    /* tear down start */
+    srwlock_stop = TRUE;
+
+    WaitForSingleObject(h1, 1000);
+    WaitForSingleObject(h2, 1000);
+    WaitForSingleObject(h3, 1000);
+
+    ok(!srwlock_inside, "threads didn't terminate properly, srwlock_inside is %ld.\n", srwlock_inside);
+    ok(!srwlock_example_errors, "errors occurred while running SRWLock example test (number of errors: %ld)\n",
+            srwlock_example_errors);
+
+    trace("number of shared accesses per thread are c1 %ld, c2 %ld, c3 %ld\n", cnt1, cnt2, cnt3);
+    trace("number of total exclusive accesses is %ld\n", srwlock_protected_value);
+}
+
+static void test_srwlock_quirk(void)
+{
+    union { SRWLOCK *s; LONG *l; } u = { &srwlock_example };
+
+    if (!pInitializeSRWLock) {
+        /* function is not yet in XP, only in newer Windows */
+        win_skip("no srw lock support.\n");
+        return;
+    }
+
+    /* WeCom 4.x checks releasing a lock with value 0x1 results in it becoming 0x0. */
+    *u.l = 1;
+    pReleaseSRWLockExclusive(&srwlock_example);
+    ok(*u.l == 0, "expected 0x0, got %lx\n", *u.l);
+}
+
+static DWORD WINAPI alertable_wait_thread(void *param)
+{
+    HANDLE *semaphores = param;
+    LARGE_INTEGER timeout;
+    NTSTATUS status;
+    DWORD result;
+
+    ReleaseSemaphore(semaphores[0], 1, NULL);
+    result = WaitForMultipleObjectsEx(1, &semaphores[1], TRUE, 1000, TRUE);
+    ok(result == WAIT_IO_COMPLETION, "expected WAIT_IO_COMPLETION, got %lu\n", result);
+    result = WaitForMultipleObjectsEx(1, &semaphores[1], TRUE, 200, TRUE);
+    ok(result == WAIT_OBJECT_0, "expected WAIT_OBJECT_0, got %lu\n", result);
+
+    ReleaseSemaphore(semaphores[0], 1, NULL);
+    timeout.QuadPart = -10000000;
+    status = pNtWaitForMultipleObjects(1, &semaphores[1], FALSE, TRUE, &timeout);
+    ok(status == STATUS_USER_APC, "expected STATUS_USER_APC, got %08lx\n", status);
+    timeout.QuadPart = -2000000;
+    status = pNtWaitForMultipleObjects(1, &semaphores[1], FALSE, TRUE, &timeout);
+    ok(status == STATUS_WAIT_0, "expected STATUS_WAIT_0, got %08lx\n", status);
+
+    ReleaseSemaphore(semaphores[0], 1, NULL);
+    timeout.QuadPart = -10000000;
+    status = pNtWaitForMultipleObjects(1, &semaphores[1], FALSE, TRUE, &timeout);
+    ok(status == STATUS_USER_APC, "expected STATUS_USER_APC, got %08lx\n", status);
+    result = WaitForSingleObject(semaphores[0], 0);
+    ok(result == WAIT_TIMEOUT, "expected WAIT_TIMEOUT, got %lu\n", result);
+
+    return 0;
+}
+
+static void CALLBACK alertable_wait_apc(ULONG_PTR userdata)
+{
+    HANDLE *semaphores = (void *)userdata;
+    ReleaseSemaphore(semaphores[1], 1, NULL);
+}
+
+static void CALLBACK alertable_wait_apc2(ULONG_PTR userdata)
+{
+    HANDLE *semaphores = (void *)userdata;
+    DWORD result;
+
+    result = WaitForSingleObject(semaphores[0], 1000);
+    ok(result == WAIT_OBJECT_0, "expected WAIT_OBJECT_0, got %lu\n", result);
+}
+
+static void test_alertable_wait(void)
+{
+    HANDLE thread, semaphores[2];
+    DWORD result;
+
+    semaphores[0] = CreateSemaphoreW(NULL, 0, 2, NULL);
+    ok(semaphores[0] != NULL, "CreateSemaphore failed with %lu\n", GetLastError());
+    semaphores[1] = CreateSemaphoreW(NULL, 0, 1, NULL);
+    ok(semaphores[1] != NULL, "CreateSemaphore failed with %lu\n", GetLastError());
+    thread = CreateThread(NULL, 0, alertable_wait_thread, semaphores, 0, NULL);
+    ok(thread != NULL, "CreateThread failed with %lu\n", GetLastError());
+
+    result = WaitForSingleObject(semaphores[0], 1000);
+    ok(result == WAIT_OBJECT_0, "expected WAIT_OBJECT_0, got %lu\n", result);
+    Sleep(100); /* ensure the thread is blocking in WaitForMultipleObjectsEx */
+    result = QueueUserAPC(alertable_wait_apc, thread, (ULONG_PTR)semaphores);
+    ok(result != 0, "QueueUserAPC failed with %lu\n", GetLastError());
+
+    result = WaitForSingleObject(semaphores[0], 1000);
+    ok(result == WAIT_OBJECT_0, "expected WAIT_OBJECT_0, got %lu\n", result);
+    Sleep(100); /* ensure the thread is blocking in NtWaitForMultipleObjects */
+    result = QueueUserAPC(alertable_wait_apc, thread, (ULONG_PTR)semaphores);
+    ok(result != 0, "QueueUserAPC failed with %lu\n", GetLastError());
+
+    result = WaitForSingleObject(semaphores[0], 1000);
+    ok(result == WAIT_OBJECT_0, "expected WAIT_OBJECT_0, got %lu\n", result);
+    Sleep(100); /* ensure the thread is blocking in NtWaitForMultipleObjects */
+    result = QueueUserAPC(alertable_wait_apc2, thread, (ULONG_PTR)semaphores);
+    ok(result != 0, "QueueUserAPC failed with %lu\n", GetLastError());
+    result = QueueUserAPC(alertable_wait_apc2, thread, (ULONG_PTR)semaphores);
+    ok(result != 0, "QueueUserAPC failed with %lu\n", GetLastError());
+    ReleaseSemaphore(semaphores[0], 2, NULL);
+
+    result = WaitForSingleObject(thread, 1000);
+    ok(result == WAIT_OBJECT_0, "expected WAIT_OBJECT_0, got %lu\n", result);
+    CloseHandle(thread);
+    CloseHandle(semaphores[0]);
+    CloseHandle(semaphores[1]);
+}
+
+struct apc_deadlock_info
+{
+    PROCESS_INFORMATION *pi;
+    HANDLE event;
+    BOOL running;
+};
+
+static DWORD WINAPI apc_deadlock_thread(void *param)
+{
+    struct apc_deadlock_info *info = param;
+    PROCESS_INFORMATION *pi = info->pi;
+    NTSTATUS status;
+    SIZE_T size;
+    void *base;
+
+    while (info->running)
+    {
+        base = NULL;
+        size = 0x1000;
+        status = pNtAllocateVirtualMemory(pi->hProcess, &base, 0, &size,
+                                          MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
+        ok(!status, "expected STATUS_SUCCESS, got %08lx\n", status);
+        ok(base != NULL, "expected base != NULL, got %p\n", base);
+        SetEvent(info->event);
+
+        size = 0;
+        status = pNtFreeVirtualMemory(pi->hProcess, &base, &size, MEM_RELEASE);
+        ok(!status, "expected STATUS_SUCCESS, got %08lx\n", status);
+        SetEvent(info->event);
+    }
+
+    return 0;
+}
+
+static void test_apc_deadlock(void)
+{
+    struct apc_deadlock_info info;
+    PROCESS_INFORMATION pi;
+    STARTUPINFOA si = { sizeof(si) };
+    char cmdline[MAX_PATH];
+    HANDLE event, thread;
+    DWORD result;
+    BOOL success;
+    char **argv;
+    int i;
+
+    winetest_get_mainargs(&argv);
+    sprintf(cmdline, "\"%s\" sync apc_deadlock", argv[0]);
+    success = CreateProcessA(argv[0], cmdline, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
+    ok(success, "CreateProcess failed with %lu\n", GetLastError());
+
+    event = CreateEventA(NULL, FALSE, FALSE, NULL);
+    ok(event != NULL, "CreateEvent failed with %lu\n", GetLastError());
+
+    info.pi = &pi;
+    info.event = event;
+    info.running = TRUE;
+
+    thread = CreateThread(NULL, 0, apc_deadlock_thread, &info, 0, NULL);
+    ok(thread != NULL, "CreateThread failed with %lu\n", GetLastError());
+    result = WaitForSingleObject(event, 1000);
+    ok(result == WAIT_OBJECT_0, "expected WAIT_OBJECT_0, got %lu\n", result);
+
+    for (i = 0; i < 1000 && info.running; i++)
+    {
+        result = SuspendThread(pi.hThread);
+        ok(result == 0, "expected 0, got %lu\n", result);
+
+        WaitForSingleObject(event, 0); /* reset event */
+        result = WaitForSingleObject(event, 1000);
+        if (result == WAIT_TIMEOUT)
+        {
+            todo_wine
+            ok(result == WAIT_OBJECT_0, "expected WAIT_OBJECT_0, got %lu\n", result);
+            info.running = FALSE;
+        }
+        else
+            ok(result == WAIT_OBJECT_0, "expected WAIT_OBJECT_0, got %lu\n", result);
+
+        result = ResumeThread(pi.hThread);
+        ok(result == 1, "expected 1, got %lu\n", result);
+        Sleep(1);
+    }
+
+    info.running = FALSE;
+    result = WaitForSingleObject(thread, 1000);
+    ok(result == WAIT_OBJECT_0, "expected WAIT_OBJECT_0, got %lu\n", result);
+    CloseHandle(thread);
+    CloseHandle(event);
+
+    TerminateProcess(pi.hProcess, 0);
+    CloseHandle(pi.hThread);
+    CloseHandle(pi.hProcess);
+}
+
+static jmp_buf bad_cs_jmpbuf;
+
+static LONG WINAPI bad_cs_handler( EXCEPTION_POINTERS *eptr )
+{
+    EXCEPTION_RECORD *rec = eptr->ExceptionRecord;
+
+    ok(!rec->NumberParameters, "got %lu.\n", rec->NumberParameters);
+    ok(rec->ExceptionFlags == EXCEPTION_NONCONTINUABLE
+            || rec->ExceptionFlags == (EXCEPTION_NONCONTINUABLE | EXCEPTION_SOFTWARE_ORIGINATE),
+            "got %#lx.\n", rec->ExceptionFlags);
+    longjmp(bad_cs_jmpbuf, rec->ExceptionCode);
+    return EXCEPTION_CONTINUE_SEARCH;
+}
+
+static void test_crit_section(void)
+{
+    void *vectored_handler;
+    CRITICAL_SECTION cs;
+    int exc_code;
+    HANDLE old;
+    BOOL ret;
+
+    /* Win8+ does not initialize debug info, one has to use RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO
+       to override that. */
+    memset(&cs, 0, sizeof(cs));
+    InitializeCriticalSection(&cs);
+    ok(cs.DebugInfo == (void *)(ULONG_PTR)-1 || broken(!!cs.DebugInfo) /* before Win8 */,
+            "Unexpected debug info pointer %p.\n", cs.DebugInfo);
+    DeleteCriticalSection(&cs);
+    ok(cs.DebugInfo == NULL, "Unexpected debug info pointer %p.\n", cs.DebugInfo);
+
+    if (!pInitializeCriticalSectionEx)
+    {
+        win_skip("InitializeCriticalSectionEx isn't available, skipping tests.\n");
+        return;
+    }
+
+    memset(&cs, 0, sizeof(cs));
+    ret = pInitializeCriticalSectionEx(&cs, 0, 0);
+    ok(ret, "Failed to initialize critical section.\n");
+    ok(cs.DebugInfo == (void *)(ULONG_PTR)-1  || broken(!!cs.DebugInfo) /* before Win8 */,
+            "Unexpected debug info pointer %p.\n", cs.DebugInfo);
+    DeleteCriticalSection(&cs);
+    ok(cs.DebugInfo == NULL, "Unexpected debug info pointer %p.\n", cs.DebugInfo);
+
+    memset(&cs, 0, sizeof(cs));
+    ret = pInitializeCriticalSectionEx(&cs, 0, CRITICAL_SECTION_NO_DEBUG_INFO);
+    ok(ret, "Failed to initialize critical section.\n");
+    ok(cs.DebugInfo == (void *)(ULONG_PTR)-1, "Unexpected debug info pointer %p.\n", cs.DebugInfo);
+    DeleteCriticalSection(&cs);
+    ok(cs.DebugInfo == NULL, "Unexpected debug info pointer %p.\n", cs.DebugInfo);
+
+    memset(&cs, 0, sizeof(cs));
+    ret = pInitializeCriticalSectionEx(&cs, 0, 0);
+    ok(ret, "Failed to initialize critical section.\n");
+    ok(cs.DebugInfo == (void *)(ULONG_PTR)-1 || broken(!!cs.DebugInfo) /* before Win8 */,
+            "Unexpected debug info pointer %p.\n", cs.DebugInfo);
+    DeleteCriticalSection(&cs);
+    ok(cs.DebugInfo == NULL, "Unexpected debug info pointer %p.\n", cs.DebugInfo);
+
+    memset(&cs, 0, sizeof(cs));
+    ret = pInitializeCriticalSectionEx(&cs, 0, RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO);
+    ok(ret || broken(GetLastError() == ERROR_INVALID_PARAMETER) /* before Win8 */,
+            "Failed to initialize critical section, error %lu.\n", GetLastError());
+    if (!ret)
+    {
+        ret = pInitializeCriticalSectionEx(&cs, 0, 0);
+        ok(ret, "Failed to initialize critical section.\n");
+    }
+    ok(cs.DebugInfo && cs.DebugInfo != (void *)(ULONG_PTR)-1, "Unexpected debug info pointer %p.\n", cs.DebugInfo);
+
+    ret = TryEnterCriticalSection(&cs);
+    ok(ret, "Failed to enter critical section.\n");
+    LeaveCriticalSection(&cs);
+
+    cs.DebugInfo = NULL;
+
+    ret = TryEnterCriticalSection(&cs);
+    ok(ret, "Failed to enter critical section.\n");
+    LeaveCriticalSection(&cs);
+
+    DeleteCriticalSection(&cs);
+    ok(cs.DebugInfo == NULL, "Unexpected debug info pointer %p.\n", cs.DebugInfo);
+
+    ret = pInitializeCriticalSectionEx(&cs, 0, 0);
+    ok(ret, "got error %lu.\n", GetLastError());
+    old = cs.LockSemaphore;
+    cs.LockSemaphore = (HANDLE)0xdeadbeef;
+
+    cs.LockCount = 0;
+    vectored_handler = AddVectoredExceptionHandler(TRUE, bad_cs_handler);
+    if (!(exc_code = setjmp(bad_cs_jmpbuf)))
+        EnterCriticalSection(&cs);
+    ok(cs.LockCount, "got %ld.\n", cs.LockCount);
+    ok(exc_code == STATUS_INVALID_HANDLE, "got %#x.\n", exc_code);
+    RemoveVectoredExceptionHandler(vectored_handler);
+    cs.LockSemaphore = old;
+    DeleteCriticalSection(&cs);
+}
+
+static DWORD WINAPI thread_proc(LPVOID unused)
+{
+    Sleep(INFINITE);
+    return 0;
+}
+
+static int apc_count;
+
+static void CALLBACK user_apc(ULONG_PTR unused)
+{
+    apc_count++;
+}
+
+static void CALLBACK call_user_apc(ULONG_PTR arg1, ULONG_PTR arg2, ULONG_PTR arg3)
+{
+    PAPCFUNC func = (PAPCFUNC)arg1;
+    func(arg2);
+}
+
+static void test_QueueUserAPC(void)
+{
+    HANDLE thread;
+    DWORD tid, ret;
+    NTSTATUS status;
+
+    thread = CreateThread(NULL, 0, thread_proc, NULL, CREATE_SUSPENDED, &tid);
+    ok(thread != NULL, "CreateThread error %lu\n", GetLastError());
+
+    ret = TerminateThread(thread, 0xdeadbeef);
+    ok(ret, "TerminateThread error %lu\n", GetLastError());
+
+    ret = WaitForSingleObject(thread, 1000);
+    ok(ret == WAIT_OBJECT_0, "got %lu\n", ret);
+
+    ret = pNtQueueApcThread(thread, call_user_apc, (ULONG_PTR)user_apc, 0, 0);
+    ok(ret == STATUS_UNSUCCESSFUL, "got %#lx\n", ret);
+    ret = pNtQueueApcThread(thread, NULL, 0, 0, 0);
+    ok(ret == STATUS_UNSUCCESSFUL, "got %#lx\n", ret);
+    ret = pNtQueueApcThread((HANDLE)0xdeadbeef, call_user_apc, (ULONG_PTR)user_apc, 0, 0);
+    ok(ret == STATUS_INVALID_HANDLE, "got %#lx\n", ret);
+
+    SetLastError(0xdeadbeef);
+    ret = QueueUserAPC(user_apc, thread, 0);
+    ok(!ret, "QueueUserAPC should fail\n");
+    ok(GetLastError() == ERROR_GEN_FAILURE, "got %lu\n", GetLastError());
+
+    CloseHandle(thread);
+
+    apc_count = 0;
+    ret = QueueUserAPC(user_apc, GetCurrentThread(), 0);
+    ok(ret, "QueueUserAPC failed err %lu\n", GetLastError());
+    ok(!apc_count, "APC count %u\n", apc_count);
+    ret = SleepEx( 100, TRUE );
+    ok( ret == WAIT_IO_COMPLETION, "SleepEx returned %lu\n", ret);
+    ok(apc_count == 1, "APC count %u\n", apc_count);
+
+    ret = pNtQueueApcThread( GetCurrentThread(), NULL, 0, 0, 0 );
+    ok( !ret, "got %#lx\n", ret);
+    ret = SleepEx( 100, TRUE );
+    ok( ret == WAIT_OBJECT_0, "SleepEx returned %lu\n", ret);
+
+    apc_count = 0;
+    ret = QueueUserAPC(user_apc, GetCurrentThread(), 0);
+    ok(ret, "QueueUserAPC failed err %lu\n", GetLastError());
+    ok(!apc_count, "APC count %u\n", apc_count);
+    status = pNtTestAlert();
+    ok(!status, "got %lx\n", status);
+    ok(apc_count == 1, "APC count %u\n", apc_count);
+    status = pNtTestAlert();
+    ok(!status, "got %lx\n", status);
+    ok(apc_count == 1, "APC count %u\n", apc_count);
+
+    if (!pQueueUserAPC2)
+    {
+        win_skip("QueueUserAPC2 is not available.\n");
+        return;
+    }
+
+    apc_count = 0;
+    ret = pQueueUserAPC2(user_apc, GetCurrentThread(), 0, QUEUE_USER_APC_FLAGS_NONE);
+    ok(ret, "QueueUserAPC failed err %lu\n", GetLastError());
+    ok(!apc_count, "got %d.\n", apc_count);
+    SleepEx( 0, TRUE );
+    ok(apc_count == 1, "got %d.\n", apc_count);
+
+    apc_count = 0;
+    ret = pQueueUserAPC2(user_apc, GetCurrentThread(), 0, QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC);
+    if (sizeof(void *) == 4)
+        ok(!ret && GetLastError() == ERROR_NOT_SUPPORTED, "got ret %lu, error %lu.\n", ret, GetLastError());
+    else
+        ok(ret, "got error %lu.\n", GetLastError());
+
+    if (ret)
+    {
+        todo_wine ok(apc_count == 1, "got %d.\n", apc_count);
+        SleepEx( 0, TRUE );
+        ok(apc_count == 1, "got %d.\n", apc_count);
+    }
+}
+
+START_TEST(sync)
+{
+    char **argv;
+    int argc;
+    HMODULE hdll = GetModuleHandleA("kernel32.dll");
+    HMODULE hntdll = GetModuleHandleA("ntdll.dll");
+
+    pInitOnceInitialize = (void *)GetProcAddress(hdll, "InitOnceInitialize");
+    pInitOnceExecuteOnce = (void *)GetProcAddress(hdll, "InitOnceExecuteOnce");
+    pInitOnceBeginInitialize = (void *)GetProcAddress(hdll, "InitOnceBeginInitialize");
+    pInitOnceComplete = (void *)GetProcAddress(hdll, "InitOnceComplete");
+    pInitializeConditionVariable = (void *)GetProcAddress(hdll, "InitializeConditionVariable");
+    pSleepConditionVariableCS = (void *)GetProcAddress(hdll, "SleepConditionVariableCS");
+    pSleepConditionVariableSRW = (void *)GetProcAddress(hdll, "SleepConditionVariableSRW");
+    pWakeAllConditionVariable = (void *)GetProcAddress(hdll, "WakeAllConditionVariable");
+    pWakeConditionVariable = (void *)GetProcAddress(hdll, "WakeConditionVariable");
+    pInitializeCriticalSectionEx = (void *)GetProcAddress(hdll, "InitializeCriticalSectionEx");
+    pInitializeSRWLock = (void *)GetProcAddress(hdll, "InitializeSRWLock");
+    pAcquireSRWLockExclusive = (void *)GetProcAddress(hdll, "AcquireSRWLockExclusive");
+    pAcquireSRWLockShared = (void *)GetProcAddress(hdll, "AcquireSRWLockShared");
+    pReleaseSRWLockExclusive = (void *)GetProcAddress(hdll, "ReleaseSRWLockExclusive");
+    pReleaseSRWLockShared = (void *)GetProcAddress(hdll, "ReleaseSRWLockShared");
+    pTryAcquireSRWLockExclusive = (void *)GetProcAddress(hdll, "TryAcquireSRWLockExclusive");
+    pTryAcquireSRWLockShared = (void *)GetProcAddress(hdll, "TryAcquireSRWLockShared");
+    pQueueUserAPC2 = (void *)GetProcAddress(hdll, "QueueUserAPC2");
+    pNtAllocateVirtualMemory = (void *)GetProcAddress(hntdll, "NtAllocateVirtualMemory");
+    pNtFreeVirtualMemory = (void *)GetProcAddress(hntdll, "NtFreeVirtualMemory");
+    pNtWaitForSingleObject = (void *)GetProcAddress(hntdll, "NtWaitForSingleObject");
+    pNtWaitForMultipleObjects = (void *)GetProcAddress(hntdll, "NtWaitForMultipleObjects");
+    pRtlInterlockedPushListSList = (void *)GetProcAddress(hntdll, "RtlInterlockedPushListSList");
+    pRtlInterlockedPushListSListEx = (void *)GetProcAddress(hntdll, "RtlInterlockedPushListSListEx");
+    pNtQueueApcThread = (void *)GetProcAddress(hntdll, "NtQueueApcThread");
+    pNtTestAlert = (void *)GetProcAddress(hntdll, "NtTestAlert");
+
+    argc = winetest_get_mainargs( &argv );
+    if (argc >= 3)
+    {
+        if (!strcmp(argv[2], "apc_deadlock"))
+        {
+            for (;;) SleepEx(INFINITE, TRUE);
+        }
+        return;
+    }
+
+    init_fastcall_thunk();
+
+    test_QueueUserAPC();
+    test_signalandwait();
+    test_temporary_objects();
+    test_mutex();
+    test_slist();
+    test_event();
+    test_semaphore();
+    test_waitable_timer();
+    test_iocp_callback();
+    test_timer_queue();
+    test_WaitForSingleObject();
+    test_WaitForMultipleObjects();
+    test_initonce();
+    test_condvars_base(&aligned_cv);
+    test_condvars_base(&unaligned_cv.cv);
+    test_condvars_consumer_producer();
+    test_srwlock_base(&aligned_srwlock);
+    test_srwlock_quirk();
+#if defined(__i386__) || defined(__x86_64__)
+    /* unaligned locks only work on x86 platforms */
+    test_srwlock_base(&unaligned_srwlock.lock);
+#endif
+    test_srwlock_example();
+    test_alertable_wait();
+    test_apc_deadlock();
+    test_crit_section();
+}
diff -ruN --show-c-function dlls/ntdll/Makefile.in dlls/ntdll/Makefile.in
--- dlls/ntdll/Makefile.in	2025-10-10 10:17:59.214615660 -0700
+++ dlls/ntdll/Makefile.in	2025-10-10 10:22:24.812697385 -0700
@@ -49,6 +49,7 @@ SOURCES = \
 	unix/cdrom.c \
 	unix/debug.c \
 	unix/env.c \
+	unix/esync.c \
 	unix/file.c \
 	unix/loader.c \
 	unix/loadorder.c \
diff -ruN --show-c-function dlls/ntdll/Makefile.in.orig dlls/ntdll/Makefile.in.orig
--- dlls/ntdll/Makefile.in.orig	1969-12-31 16:00:00.000000000 -0800
+++ dlls/ntdll/Makefile.in.orig	2025-10-10 10:22:13.459291182 -0700
@@ -0,0 +1,81 @@
+EXTRADEFS = -D_NTSYSTEM_ -D_ACRTIMP= -DWINBASEAPI=
+MODULE    = ntdll.dll
+UNIXLIB   = ntdll.so
+IMPORTLIB = ntdll
+IMPORTS   = $(TOMCRYPT_PE_LIBS) $(MUSL_PE_LIBS)
+EXTRAINCL = $(TOMCRYPT_PE_CFLAGS)
+UNIX_CFLAGS  = $(UNWIND_CFLAGS)
+UNIX_LIBS    = $(IOKIT_LIBS) $(COREFOUNDATION_LIBS) $(CORESERVICES_LIBS) $(RT_LIBS) $(PTHREAD_LIBS) $(UNWIND_LIBS) $(I386_LIBS) $(PROCSTAT_LIBS)
+
+EXTRADLLFLAGS = -nodefaultlibs
+i386_EXTRADLLFLAGS = -Wl,--image-base,0x7bc00000
+x86_64_EXTRADLLFLAGS = -Wl,--image-base,0x170000000
+
+SOURCES = \
+	actctx.c \
+	atom.c \
+	crypt.c \
+	debugbuffer.c \
+	env.c \
+	error.c \
+	exception.c \
+	handletable.c \
+	heap.c \
+	large_int.c \
+	loader.c \
+	locale.c \
+	math.c \
+	misc.c \
+	path.c \
+	printf.c \
+	process.c \
+	reg.c \
+	relay.c \
+	resource.c \
+	rtl.c \
+	rtlbitmap.c \
+	rtlstr.c \
+	sec.c \
+	signal_arm.c \
+	signal_arm64.c \
+	signal_arm64ec.c \
+	signal_i386.c \
+	signal_x86_64.c \
+	string.c \
+	sync.c \
+	thread.c \
+	threadpool.c \
+	time.c \
+	unix/cdrom.c \
+	unix/debug.c \
+	unix/env.c \
+	unix/file.c \
+	unix/loader.c \
+	unix/loadorder.c \
+	unix/process.c \
+	unix/registry.c \
+	unix/security.c \
+	unix/serial.c \
+	unix/server.c \
+	unix/signal_arm.c \
+	unix/signal_arm64.c \
+	unix/signal_i386.c \
+	unix/signal_x86_64.c \
+	unix/socket.c \
+	unix/sync.c \
+	unix/system.c \
+	unix/tape.c \
+	unix/thread.c \
+	unix/virtual.c \
+	unwind.c \
+	version.c \
+	version.rc \
+	wcstring.c
+
+EXTRA_OBJS = unix/version.o
+
+unix_loader_EXTRADEFS = \
+	-DBINDIR=\"${bindir}\" \
+	-DLIBDIR=\"${libdir}\" \
+	-DDATADIR=\"${datadir}\" \
+	-DSYSTEMDLLPATH=\"${system_dllpath}\"
diff -ruN --show-c-function dlls/ntdll/unix/esync.c dlls/ntdll/unix/esync.c
--- dlls/ntdll/unix/esync.c	1969-12-31 16:00:00.000000000 -0800
+++ dlls/ntdll/unix/esync.c	2025-10-10 10:22:17.174105897 -0700
@@ -0,0 +1,1325 @@
+/*
+ * eventfd-based synchronization objects
+ *
+ * Copyright (C) 2018 Zebediah Figura
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <sys/mman.h>
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#include <poll.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winternl.h"
+#include "wine/server.h"
+#include "wine/debug.h"
+
+#include "unix_private.h"
+#include "esync.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(esync);
+
+int do_esync(void)
+{
+#ifdef HAVE_SYS_EVENTFD_H
+    static int do_esync_cached = -1;
+
+    if (do_esync_cached == -1)
+        do_esync_cached = getenv("WINEESYNC") && atoi(getenv("WINEESYNC"));
+
+    return do_esync_cached;
+#else
+    static int once;
+    if (!once++)
+        FIXME("eventfd not supported on this platform.\n");
+    return 0;
+#endif
+}
+
+struct esync
+{
+    LONG type;
+    int fd;
+    void *shm;
+};
+
+struct semaphore
+{
+    LONG max;
+    LONG count;
+};
+C_ASSERT(sizeof(struct semaphore) == 8);
+
+struct mutex
+{
+    LONG tid;
+    LONG count;    /* recursion count */
+};
+C_ASSERT(sizeof(struct mutex) == 8);
+
+struct event
+{
+    LONG signaled;
+    LONG locked;
+};
+C_ASSERT(sizeof(struct event) == 8);
+
+static char shm_name[29];
+static int shm_fd;
+static void **shm_addrs;
+static int shm_addrs_size;  /* length of the allocated shm_addrs array */
+static long pagesize;
+
+static pthread_mutex_t shm_addrs_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+static void *get_shm( unsigned int idx )
+{
+    int entry  = (idx * 8) / pagesize;
+    int offset = (idx * 8) % pagesize;
+    void *ret;
+
+    pthread_mutex_lock( &shm_addrs_mutex );
+
+    if (entry >= shm_addrs_size)
+    {
+        int new_size = max(shm_addrs_size * 2, entry + 1);
+
+        if (!(shm_addrs = realloc( shm_addrs, new_size * sizeof(shm_addrs[0]) )))
+            ERR("Failed to grow shm_addrs array to size %d.\n", shm_addrs_size);
+        memset( shm_addrs + shm_addrs_size, 0, (new_size - shm_addrs_size) * sizeof(shm_addrs[0]) );
+        shm_addrs_size = new_size;
+    }
+
+    if (!shm_addrs[entry])
+    {
+        void *addr = mmap( NULL, pagesize, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, entry * pagesize );
+        if (addr == (void *)-1)
+            ERR("Failed to map page %d (offset %#lx).\n", entry, entry * pagesize);
+
+        TRACE("Mapping page %d at %p.\n", entry, addr);
+
+        if (InterlockedCompareExchangePointer( &shm_addrs[entry], addr, 0 ))
+            munmap( addr, pagesize ); /* someone beat us to it */
+    }
+
+    ret = (void *)((unsigned long)shm_addrs[entry] + offset);
+
+    pthread_mutex_unlock( &shm_addrs_mutex );
+
+    return ret;
+}
+
+/* We'd like lookup to be fast. To that end, we use a static list indexed by handle.
+ * This is copied and adapted from the fd cache code. */
+
+#define ESYNC_LIST_BLOCK_SIZE  (65536 / sizeof(struct esync))
+#define ESYNC_LIST_ENTRIES     256
+
+static struct esync *esync_list[ESYNC_LIST_ENTRIES];
+static struct esync esync_list_initial_block[ESYNC_LIST_BLOCK_SIZE];
+
+static inline UINT_PTR handle_to_index( HANDLE handle, UINT_PTR *entry )
+{
+    UINT_PTR idx = (((UINT_PTR)handle) >> 2) - 1;
+    *entry = idx / ESYNC_LIST_BLOCK_SIZE;
+    return idx % ESYNC_LIST_BLOCK_SIZE;
+}
+
+static struct esync *add_to_list( HANDLE handle, enum esync_type type, int fd, void *shm )
+{
+    UINT_PTR entry, idx = handle_to_index( handle, &entry );
+
+    if (entry >= ESYNC_LIST_ENTRIES)
+    {
+        FIXME( "too many allocated handles, not caching %p\n", handle );
+        return FALSE;
+    }
+
+    if (!esync_list[entry])  /* do we need to allocate a new block of entries? */
+    {
+        if (!entry) esync_list[0] = esync_list_initial_block;
+        else
+        {
+            void *ptr = anon_mmap_alloc( ESYNC_LIST_BLOCK_SIZE * sizeof(struct esync),
+                                         PROT_READ | PROT_WRITE );
+            if (ptr == MAP_FAILED) return FALSE;
+            esync_list[entry] = ptr;
+        }
+    }
+
+    if (!InterlockedCompareExchange( &esync_list[entry][idx].type, type, 0 ))
+    {
+        esync_list[entry][idx].fd = fd;
+        esync_list[entry][idx].shm = shm;
+    }
+    return &esync_list[entry][idx];
+}
+
+static struct esync *get_cached_object( HANDLE handle )
+{
+    UINT_PTR entry, idx = handle_to_index( handle, &entry );
+
+    if (entry >= ESYNC_LIST_ENTRIES || !esync_list[entry]) return NULL;
+    if (!esync_list[entry][idx].type) return NULL;
+
+    return &esync_list[entry][idx];
+}
+
+/* Gets an object. This is either a proper esync object (i.e. an event,
+ * semaphore, etc. created using create_esync) or a generic synchronizable
+ * server-side object which the server will signal (e.g. a process, thread,
+ * message queue, etc.) */
+static NTSTATUS get_object( HANDLE handle, struct esync **obj )
+{
+    int ret = STATUS_SUCCESS;
+    enum esync_type type = 0;
+    unsigned int shm_idx = 0;
+    obj_handle_t fd_handle;
+    sigset_t sigset;
+    int fd = -1;
+
+    if ((*obj = get_cached_object( handle ))) return STATUS_SUCCESS;
+
+    if ((INT_PTR)handle < 0)
+    {
+        /* We can deal with pseudo-handles, but it's just easier this way */
+        return STATUS_NOT_IMPLEMENTED;
+    }
+
+    if (!handle)
+    {
+        /* Shadow of the Tomb Raider really likes passing in NULL handles to
+         * various functions. Concerning, but let's avoid a server call. */
+        return STATUS_INVALID_HANDLE;
+    }
+
+    /* We need to try grabbing it from the server. */
+    server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
+    if (!(*obj = get_cached_object( handle )))
+    {
+        SERVER_START_REQ( get_esync_fd )
+        {
+            req->handle = wine_server_obj_handle( handle );
+            if (!(ret = wine_server_call( req )))
+            {
+                type = reply->type;
+                shm_idx = reply->shm_idx;
+                fd = receive_fd( &fd_handle );
+                assert( wine_server_ptr_handle(fd_handle) == handle );
+            }
+        }
+        SERVER_END_REQ;
+    }
+    server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
+
+    if (*obj)
+    {
+        /* We managed to grab it while in the CS; return it. */
+        return STATUS_SUCCESS;
+    }
+
+    if (ret)
+    {
+        WARN("Failed to retrieve fd for handle %p, status %#x.\n", handle, ret);
+        *obj = NULL;
+        return ret;
+    }
+
+    TRACE("Got fd %d for handle %p.\n", fd, handle);
+
+    *obj = add_to_list( handle, type, fd, shm_idx ? get_shm( shm_idx ) : 0 );
+    return ret;
+}
+
+NTSTATUS esync_close( HANDLE handle )
+{
+    UINT_PTR entry, idx = handle_to_index( handle, &entry );
+
+    TRACE("%p.\n", handle);
+
+    if (entry < ESYNC_LIST_ENTRIES && esync_list[entry])
+    {
+        if (InterlockedExchange(&esync_list[entry][idx].type, 0))
+        {
+            close( esync_list[entry][idx].fd );
+            return STATUS_SUCCESS;
+        }
+    }
+
+    return STATUS_INVALID_HANDLE;
+}
+
+static NTSTATUS create_esync( enum esync_type type, HANDLE *handle, ACCESS_MASK access,
+                              const OBJECT_ATTRIBUTES *attr, int initval, int max )
+{
+    NTSTATUS ret;
+    data_size_t len;
+    struct object_attributes *objattr;
+    obj_handle_t fd_handle;
+    unsigned int shm_idx;
+    sigset_t sigset;
+    int fd;
+
+    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
+
+    /* We have to synchronize on the fd cache CS so that our calls to
+     * receive_fd don't race with theirs. */
+    server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
+    SERVER_START_REQ( create_esync )
+    {
+        req->access  = access;
+        req->initval = initval;
+        req->type    = type;
+        req->max     = max;
+        wine_server_add_data( req, objattr, len );
+        ret = wine_server_call( req );
+        if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
+        {
+            *handle = wine_server_ptr_handle( reply->handle );
+            type = reply->type;
+            shm_idx = reply->shm_idx;
+            fd = receive_fd( &fd_handle );
+            assert( wine_server_ptr_handle(fd_handle) == *handle );
+        }
+    }
+    SERVER_END_REQ;
+    server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
+
+    if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
+    {
+        add_to_list( *handle, type, fd, shm_idx ? get_shm( shm_idx ) : 0 );
+        TRACE("-> handle %p, fd %d.\n", *handle, fd);
+    }
+
+    free( objattr );
+    return ret;
+}
+
+static NTSTATUS open_esync( enum esync_type type, HANDLE *handle,
+    ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
+{
+    NTSTATUS ret;
+    obj_handle_t fd_handle;
+    unsigned int shm_idx;
+    sigset_t sigset;
+    int fd;
+
+    server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
+    SERVER_START_REQ( open_esync )
+    {
+        req->access     = access;
+        req->attributes = attr->Attributes;
+        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
+        req->type       = type;
+        if (attr->ObjectName)
+            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
+        if (!(ret = wine_server_call( req )))
+        {
+            *handle = wine_server_ptr_handle( reply->handle );
+            type = reply->type;
+            shm_idx = reply->shm_idx;
+            fd = receive_fd( &fd_handle );
+            assert( wine_server_ptr_handle(fd_handle) == *handle );
+        }
+    }
+    SERVER_END_REQ;
+    server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
+
+    if (!ret)
+    {
+        add_to_list( *handle, type, fd, shm_idx ? get_shm( shm_idx ) : 0 );
+
+        TRACE("-> handle %p, fd %d.\n", *handle, fd);
+    }
+    return ret;
+}
+
+extern NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr, int initial, int max)
+{
+    TRACE("name %s, initial %d, max %d.\n",
+        attr ? debugstr_us(attr->ObjectName) : "<no name>", initial, max);
+
+    return create_esync( ESYNC_SEMAPHORE, handle, access, attr, initial, max );
+}
+
+NTSTATUS esync_open_semaphore( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr )
+{
+    TRACE("name %s.\n", debugstr_us(attr->ObjectName));
+
+    return open_esync( ESYNC_SEMAPHORE, handle, access, attr );
+}
+
+NTSTATUS esync_release_semaphore( HANDLE handle, unsigned int count, ULONG *prev )
+{
+    struct esync *obj;
+    struct semaphore *semaphore;
+    uint64_t count64 = count;
+    ULONG current;
+    NTSTATUS ret;
+
+    TRACE("%p, %d, %p.\n", handle, count, prev);
+
+    if ((ret = get_object( handle, &obj))) return ret;
+    semaphore = obj->shm;
+
+    do
+    {
+        current = semaphore->count;
+
+        if (count + current > semaphore->max)
+            return STATUS_SEMAPHORE_LIMIT_EXCEEDED;
+    } while (InterlockedCompareExchange( &semaphore->count, count + current, current ) != current);
+
+    if (prev) *prev = current;
+
+    /* We don't have to worry about a race between increasing the count and
+     * write(). The fact that we were able to increase the count means that we
+     * have permission to actually write that many releases to the semaphore. */
+
+    if (write( obj->fd, &count64, sizeof(count64) ) == -1)
+        return errno_to_status( errno );
+
+    return STATUS_SUCCESS;
+}
+
+NTSTATUS esync_query_semaphore( HANDLE handle, void *info, ULONG *ret_len )
+{
+    struct esync *obj;
+    struct semaphore *semaphore;
+    SEMAPHORE_BASIC_INFORMATION *out = info;
+    NTSTATUS ret;
+
+    TRACE("handle %p, info %p, ret_len %p.\n", handle, info, ret_len);
+
+    if ((ret = get_object( handle, &obj ))) return ret;
+    semaphore = obj->shm;
+
+    out->CurrentCount = semaphore->count;
+    out->MaximumCount = semaphore->max;
+    if (ret_len) *ret_len = sizeof(*out);
+
+    return STATUS_SUCCESS;
+}
+
+NTSTATUS esync_create_event( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr, EVENT_TYPE event_type, BOOLEAN initial )
+{
+    enum esync_type type = (event_type == SynchronizationEvent ? ESYNC_AUTO_EVENT : ESYNC_MANUAL_EVENT);
+
+    TRACE("name %s, %s-reset, initial %d.\n",
+        attr ? debugstr_us(attr->ObjectName) : "<no name>",
+        event_type == NotificationEvent ? "manual" : "auto", initial);
+
+    return create_esync( type, handle, access, attr, initial, 0 );
+}
+
+NTSTATUS esync_open_event( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr )
+{
+    TRACE("name %s.\n", debugstr_us(attr->ObjectName));
+
+    return open_esync( ESYNC_AUTO_EVENT, handle, access, attr ); /* doesn't matter which */
+}
+
+static inline void small_pause(void)
+{
+#ifdef __i386__
+    __asm__ __volatile__( "rep;nop" : : : "memory" );
+#else
+    __asm__ __volatile__( "" : : : "memory" );
+#endif
+}
+
+/* Manual-reset events are actually racier than other objects in terms of shm
+ * state. With other objects, races don't matter, because we only treat the shm
+ * state as a hint that lets us skip poll()—we still have to read(). But with
+ * manual-reset events we don't, which means that the shm state can be out of
+ * sync with the actual state.
+ *
+ * In general we shouldn't have to worry about races between modifying the
+ * event and waiting on it. If the state changes while we're waiting, it's
+ * equally plausible that we caught it before or after the state changed.
+ * However, we can have races between SetEvent() and ResetEvent(), so that the
+ * event has inconsistent internal state.
+ *
+ * To solve this we have to use the other field to lock the event. Currently
+ * this is implemented as a spinlock, but I'm not sure if a futex might be
+ * better. I'm also not sure if it's possible to obviate locking by arranging
+ * writes and reads in a certain way.
+ *
+ * Note that we don't have to worry about locking in esync_wait_objects().
+ * There's only two general patterns:
+ *
+ * WaitFor()    SetEvent()
+ * -------------------------
+ * read()
+ * signaled = 0
+ *              signaled = 1
+ *              write()
+ * -------------------------
+ * read()
+ *              signaled = 1
+ * signaled = 0
+ *              <no write(), because it was already signaled>
+ * -------------------------
+ *
+ * That is, if SetEvent() tries to signal the event before WaitFor() resets its
+ * signaled state, it won't bother trying to write(), and then the signaled
+ * state will be reset, so the result is a consistent non-signaled event.
+ * There's several variations to this pattern but all of them are protected in
+ * the same way. Note however this is why we have to use interlocked_xchg()
+ * event inside of the lock.
+ */
+
+/* Removing this spinlock is harder than it looks. esync_wait_objects() can
+ * deal with inconsistent state well enough, and a race between SetEvent() and
+ * ResetEvent() gives us license to yield either result as long as we act
+ * consistently, but that's not enough. Notably, esync_wait_objects() should
+ * probably act like a fence, so that the second half of esync_set_event() does
+ * not seep past a subsequent reset. That's one problem, but no guarantee there
+ * aren't others. */
+
+NTSTATUS esync_set_event( HANDLE handle )
+{
+    static const uint64_t value = 1;
+    struct esync *obj;
+    struct event *event;
+    NTSTATUS ret;
+
+    TRACE("%p.\n", handle);
+
+    if ((ret = get_object( handle, &obj ))) return ret;
+    event = obj->shm;
+
+    if (obj->type == ESYNC_MANUAL_EVENT)
+    {
+        /* Acquire the spinlock. */
+        while (InterlockedCompareExchange( &event->locked, 1, 0 ))
+            small_pause();
+    }
+
+    /* For manual-reset events, as long as we're in a lock, we can take the
+     * optimization of only calling write() if the event wasn't already
+     * signaled.
+     *
+     * For auto-reset events, esync_wait_objects() must grab the kernel object.
+     * Thus if we got into a race so that the shm state is signaled but the
+     * eventfd is unsignaled (i.e. reset shm, set shm, set fd, reset fd), we
+     * *must* signal the fd now, or any waiting threads will never wake up. */
+
+    if (!InterlockedExchange( &event->signaled, 1 ) || obj->type == ESYNC_AUTO_EVENT)
+    {
+        if (write( obj->fd, &value, sizeof(value) ) == -1)
+            ERR("write: %s\n", strerror(errno));
+    }
+
+    if (obj->type == ESYNC_MANUAL_EVENT)
+    {
+        /* Release the spinlock. */
+        event->locked = 0;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+NTSTATUS esync_reset_event( HANDLE handle )
+{
+    uint64_t value;
+    struct esync *obj;
+    struct event *event;
+    NTSTATUS ret;
+
+    TRACE("%p.\n", handle);
+
+    if ((ret = get_object( handle, &obj ))) return ret;
+    event = obj->shm;
+
+    if (obj->type == ESYNC_MANUAL_EVENT)
+    {
+        /* Acquire the spinlock. */
+        while (InterlockedCompareExchange( &event->locked, 1, 0 ))
+            small_pause();
+    }
+
+    /* For manual-reset events, as long as we're in a lock, we can take the
+     * optimization of only calling read() if the event was already signaled.
+     *
+     * For auto-reset events, we have no guarantee that the previous "signaled"
+     * state is actually correct. We need to leave both states unsignaled after
+     * leaving this function, so we always have to read(). */
+    if (InterlockedExchange( &event->signaled, 0 ) || obj->type == ESYNC_AUTO_EVENT)
+    {
+        if (read( obj->fd, &value, sizeof(value) ) == -1 && errno != EWOULDBLOCK && errno != EAGAIN)
+        {
+            ERR("read: %s\n", strerror(errno));
+        }
+    }
+
+    if (obj->type == ESYNC_MANUAL_EVENT)
+    {
+        /* Release the spinlock. */
+        event->locked = 0;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+NTSTATUS esync_pulse_event( HANDLE handle )
+{
+    uint64_t value = 1;
+    struct esync *obj;
+    NTSTATUS ret;
+
+    TRACE("%p.\n", handle);
+
+    if ((ret = get_object( handle, &obj ))) return ret;
+
+    /* This isn't really correct; an application could miss the write.
+     * Unfortunately we can't really do much better. Fortunately this is rarely
+     * used (and publicly deprecated). */
+    if (write( obj->fd, &value, sizeof(value) ) == -1)
+        return errno_to_status( errno );
+
+    /* Try to give other threads a chance to wake up. Hopefully erring on this
+     * side is the better thing to do... */
+    NtYieldExecution();
+
+    read( obj->fd, &value, sizeof(value) );
+
+    return STATUS_SUCCESS;
+}
+
+NTSTATUS esync_query_event( HANDLE handle, void *info, ULONG *ret_len )
+{
+    struct esync *obj;
+    EVENT_BASIC_INFORMATION *out = info;
+    struct pollfd fd;
+    NTSTATUS ret;
+
+    TRACE("handle %p, info %p, ret_len %p.\n", handle, info, ret_len);
+
+    if ((ret = get_object( handle, &obj ))) return ret;
+
+    fd.fd = obj->fd;
+    fd.events = POLLIN;
+    out->EventState = poll( &fd, 1, 0 );
+    out->EventType = (obj->type == ESYNC_AUTO_EVENT ? SynchronizationEvent : NotificationEvent);
+    if (ret_len) *ret_len = sizeof(*out);
+
+    return STATUS_SUCCESS;
+}
+
+NTSTATUS esync_create_mutex( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr, BOOLEAN initial )
+{
+    TRACE("name %s, initial %d.\n",
+        attr ? debugstr_us(attr->ObjectName) : "<no name>", initial);
+
+    return create_esync( ESYNC_MUTEX, handle, access, attr, initial ? 0 : 1, 0 );
+}
+
+NTSTATUS esync_open_mutex( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr )
+{
+    TRACE("name %s.\n", debugstr_us(attr->ObjectName));
+
+    return open_esync( ESYNC_MUTEX, handle, access, attr );
+}
+
+NTSTATUS esync_release_mutex( HANDLE *handle, LONG *prev )
+{
+    struct esync *obj;
+    struct mutex *mutex;
+    static const uint64_t value = 1;
+    NTSTATUS ret;
+
+    TRACE("%p, %p.\n", handle, prev);
+
+    if ((ret = get_object( handle, &obj ))) return ret;
+    mutex = obj->shm;
+
+    /* This is thread-safe, because the only thread that can change the tid to
+     * or from our tid is ours. */
+    if (mutex->tid != GetCurrentThreadId()) return STATUS_MUTANT_NOT_OWNED;
+
+    if (prev) *prev = mutex->count;
+
+    mutex->count--;
+
+    if (!mutex->count)
+    {
+        /* This is also thread-safe, as long as signaling the file is the last
+         * thing we do. Other threads don't care about the tid if it isn't
+         * theirs. */
+        mutex->tid = 0;
+
+        if (write( obj->fd, &value, sizeof(value) ) == -1)
+            return errno_to_status( errno );
+    }
+
+    return STATUS_SUCCESS;
+}
+
+NTSTATUS esync_query_mutex( HANDLE handle, void *info, ULONG *ret_len )
+{
+    struct esync *obj;
+    struct mutex *mutex;
+    MUTANT_BASIC_INFORMATION *out = info;
+    NTSTATUS ret;
+
+    TRACE("handle %p, info %p, ret_len %p.\n", handle, info, ret_len);
+
+    if ((ret = get_object( handle, &obj ))) return ret;
+    mutex = obj->shm;
+
+    out->CurrentCount = 1 - mutex->count;
+    out->OwnedByCaller = (mutex->tid == GetCurrentThreadId());
+    out->AbandonedState = (mutex->tid == ~0);
+    if (ret_len) *ret_len = sizeof(*out);
+
+    return STATUS_SUCCESS;
+}
+
+#define TICKSPERSEC        10000000
+#define TICKSPERMSEC       10000
+
+static LONGLONG update_timeout( ULONGLONG end )
+{
+    LARGE_INTEGER now;
+    LONGLONG timeleft;
+
+    NtQuerySystemTime( &now );
+    timeleft = end - now.QuadPart;
+    if (timeleft < 0) timeleft = 0;
+    return timeleft;
+}
+
+static int do_poll( struct pollfd *fds, nfds_t nfds, ULONGLONG *end )
+{
+    int ret;
+
+    do
+    {
+        if (end)
+        {
+            LONGLONG timeleft = update_timeout( *end );
+
+#ifdef HAVE_PPOLL
+            /* We use ppoll() if available since the time granularity is better. */
+            struct timespec tmo_p;
+            tmo_p.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
+            tmo_p.tv_nsec = (timeleft % TICKSPERSEC) * 100;
+            ret = ppoll( fds, nfds, &tmo_p, NULL );
+#else
+            ret = poll( fds, nfds, timeleft / TICKSPERMSEC );
+#endif
+        }
+        else
+            ret = poll( fds, nfds, -1 );
+
+    /* If we receive EINTR we were probably suspended (SIGUSR1), possibly for a
+     * system APC. The right thing to do is just try again. */
+    } while (ret < 0 && errno == EINTR);
+
+    return ret;
+}
+
+/* Return TRUE if abandoned. */
+static BOOL update_grabbed_object( struct esync *obj )
+{
+    BOOL ret = FALSE;
+
+    if (obj->type == ESYNC_MUTEX)
+    {
+        struct mutex *mutex = obj->shm;
+        /* We don't have to worry about a race between this and read(); the
+         * fact that we grabbed it means the count is now zero, so nobody else
+         * can (and the only thread that can release it is us). */
+        if (mutex->tid == ~0)
+            ret = TRUE;
+        mutex->tid = GetCurrentThreadId();
+        mutex->count++;
+    }
+    else if (obj->type == ESYNC_SEMAPHORE)
+    {
+        struct semaphore *semaphore = obj->shm;
+        /* We don't have to worry about a race between this and read(); the
+         * fact that we were able to grab it at all means the count is nonzero,
+         * and if someone else grabbed it then the count must have been >= 2,
+         * etc. */
+        InterlockedExchangeAdd( &semaphore->count, -1 );
+    }
+    else if (obj->type == ESYNC_AUTO_EVENT)
+    {
+        struct event *event = obj->shm;
+        /* We don't have to worry about a race between this and read(), since
+         * this is just a hint, and the real state is in the kernel object.
+         * This might already be 0, but that's okay! */
+        event->signaled = 0;
+    }
+
+    return ret;
+}
+
+/* A value of STATUS_NOT_IMPLEMENTED returned from this function means that we
+ * need to delegate to server_select(). */
+static NTSTATUS __esync_wait_objects( unsigned int count, const HANDLE *handles, BOOLEAN wait_any,
+                             BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    static const LARGE_INTEGER zero;
+
+    struct esync *objs[MAXIMUM_WAIT_OBJECTS];
+    struct pollfd fds[MAXIMUM_WAIT_OBJECTS + 1];
+    int has_esync = 0, has_server = 0;
+    BOOL msgwait = FALSE;
+    LONGLONG timeleft;
+    LARGE_INTEGER now;
+    DWORD pollcount;
+    ULONGLONG end;
+    int64_t value;
+    ssize_t size;
+    int i, j, ret;
+
+    /* Grab the APC fd if we don't already have it. */
+    if (alertable && ntdll_get_thread_data()->esync_apc_fd == -1)
+    {
+        obj_handle_t fd_handle;
+        sigset_t sigset;
+        int fd = -1;
+
+        server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
+        SERVER_START_REQ( get_esync_apc_fd )
+        {
+            if (!(ret = wine_server_call( req )))
+            {
+                fd = receive_fd( &fd_handle );
+                assert( fd_handle == GetCurrentThreadId() );
+            }
+        }
+        SERVER_END_REQ;
+        server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
+
+        ntdll_get_thread_data()->esync_apc_fd = fd;
+    }
+
+    NtQuerySystemTime( &now );
+    if (timeout)
+    {
+        if (timeout->QuadPart == TIMEOUT_INFINITE)
+            timeout = NULL;
+        else if (timeout->QuadPart >= 0)
+            end = timeout->QuadPart;
+        else
+            end = now.QuadPart - timeout->QuadPart;
+    }
+
+    for (i = 0; i < count; i++)
+    {
+        ret = get_object( handles[i], &objs[i] );
+        if (ret == STATUS_SUCCESS)
+            has_esync = 1;
+        else if (ret == STATUS_NOT_IMPLEMENTED)
+            has_server = 1;
+        else
+            return ret;
+    }
+
+    if (objs[count - 1] && objs[count - 1]->type == ESYNC_QUEUE)
+        msgwait = TRUE;
+
+    if (has_esync && has_server)
+        FIXME("Can't wait on esync and server objects at the same time!\n");
+    else if (has_server)
+        return STATUS_NOT_IMPLEMENTED;
+
+    if (TRACE_ON(esync))
+    {
+        TRACE("Waiting for %s of %d handles:", wait_any ? "any" : "all", count);
+        for (i = 0; i < count; i++)
+            TRACE(" %p", handles[i]);
+
+        if (msgwait)
+            TRACE(" or driver events");
+        if (alertable)
+            TRACE(", alertable");
+
+        if (!timeout)
+            TRACE(", timeout = INFINITE.\n");
+        else
+        {
+            timeleft = update_timeout( end );
+            TRACE(", timeout = %ld.%07ld sec.\n",
+                (long) timeleft / TICKSPERSEC, (long) timeleft % TICKSPERSEC);
+        }
+    }
+
+    if (wait_any || count == 1)
+    {
+        /* Try to check objects now, so we can obviate poll() at least. */
+        for (i = 0; i < count; i++)
+        {
+            struct esync *obj = objs[i];
+
+            if (obj)
+            {
+                switch (obj->type)
+                {
+                case ESYNC_MUTEX:
+                {
+                    struct mutex *mutex = obj->shm;
+
+                    if (mutex->tid == GetCurrentThreadId())
+                    {
+                        TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                        mutex->count++;
+                        return i;
+                    }
+                    else if (!mutex->count)
+                    {
+                        if ((size = read( obj->fd, &value, sizeof(value) )) == sizeof(value))
+                        {
+                            if (mutex->tid == ~0)
+                            {
+                                TRACE("Woken up by abandoned mutex %p [%d].\n", handles[i], i);
+                                i += STATUS_ABANDONED_WAIT_0;
+                            }
+                            else
+                                TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                            mutex->tid = GetCurrentThreadId();
+                            mutex->count++;
+                            return i;
+                        }
+                    }
+                    break;
+                }
+                case ESYNC_SEMAPHORE:
+                {
+                    struct semaphore *semaphore = obj->shm;
+
+                    if (semaphore->count)
+                    {
+                        if ((size = read( obj->fd, &value, sizeof(value) )) == sizeof(value))
+                        {
+                            TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                            InterlockedDecrement( &semaphore->count );
+                            return i;
+                        }
+                    }
+                    break;
+                }
+                case ESYNC_AUTO_EVENT:
+                {
+                    struct event *event = obj->shm;
+
+                    if (event->signaled)
+                    {
+                        if ((size = read( obj->fd, &value, sizeof(value) )) == sizeof(value))
+                        {
+                            TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                            event->signaled = 0;
+                            return i;
+                        }
+                    }
+                    break;
+                }
+                case ESYNC_MANUAL_EVENT:
+                {
+                    struct event *event = obj->shm;
+
+                    if (event->signaled)
+                    {
+                        TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                        return i;
+                    }
+                    break;
+                }
+                case ESYNC_AUTO_SERVER:
+                case ESYNC_MANUAL_SERVER:
+                case ESYNC_QUEUE:
+                    /* We can't wait on any of these. Fortunately I don't think
+                     * they'll ever be uncontended anyway (at least, they won't be
+                     * performance-critical). */
+                    break;
+                }
+            }
+
+            fds[i].fd = obj ? obj->fd : -1;
+            fds[i].events = POLLIN;
+        }
+        if (alertable)
+        {
+            fds[i].fd = ntdll_get_thread_data()->esync_apc_fd;
+            fds[i].events = POLLIN;
+            i++;
+        }
+        pollcount = i;
+
+        while (1)
+        {
+            ret = do_poll( fds, pollcount, timeout ? &end : NULL );
+            if (ret > 0)
+            {
+                /* We must check this first! The server may set an event that
+                 * we're waiting on, but we need to return STATUS_USER_APC. */
+                if (alertable)
+                {
+                    if (fds[pollcount - 1].revents & POLLIN)
+                        goto userapc;
+                }
+
+                /* Find out which object triggered the wait. */
+                for (i = 0; i < count; i++)
+                {
+                    struct esync *obj = objs[i];
+
+                    if (fds[i].revents & (POLLERR | POLLHUP | POLLNVAL))
+                    {
+                        ERR("Polling on fd %d returned %#x.\n", fds[i].fd, fds[i].revents);
+                        return STATUS_INVALID_HANDLE;
+                    }
+
+                    if (obj)
+                    {
+                        if (obj->type == ESYNC_MANUAL_EVENT
+                                || obj->type == ESYNC_MANUAL_SERVER
+                                || obj->type == ESYNC_QUEUE)
+                        {
+                            /* Don't grab the object, just check if it's signaled. */
+                            if (fds[i].revents & POLLIN)
+                            {
+                                TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                                return i;
+                            }
+                        }
+                        else
+                        {
+                            if ((size = read( fds[i].fd, &value, sizeof(value) )) == sizeof(value))
+                            {
+                                /* We found our object. */
+                                TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                                if (update_grabbed_object( obj ))
+                                    return STATUS_ABANDONED_WAIT_0 + i;
+                                return i;
+                            }
+                        }
+                    }
+                }
+
+                /* If we got here, someone else stole (or reset, etc.) whatever
+                 * we were waiting for. So keep waiting. */
+                NtQuerySystemTime( &now );
+            }
+            else
+                goto err;
+        }
+    }
+    else
+    {
+        /* Wait-all is a little trickier to implement correctly. Fortunately,
+         * it's not as common.
+         *
+         * The idea is basically just to wait in sequence on every object in the
+         * set. Then when we're done, try to grab them all in a tight loop. If
+         * that fails, release any resources we've grabbed (and yes, we can
+         * reliably do this—it's just mutexes and semaphores that we have to
+         * put back, and in both cases we just put back 1), and if any of that
+         * fails we start over.
+         *
+         * What makes this inherently bad is that we might temporarily grab a
+         * resource incorrectly. Hopefully it'll be quick (and hey, it won't
+         * block on wineserver) so nobody will notice. Besides, consider: if
+         * object A becomes signaled but someone grabs it before we can grab it
+         * and everything else, then they could just as well have grabbed it
+         * before it became signaled. Similarly if object A was signaled and we
+         * were blocking on object B, then B becomes available and someone grabs
+         * A before we can, then they might have grabbed A before B became
+         * signaled. In either case anyone who tries to wait on A or B will be
+         * waiting for an instant while we put things back. */
+
+        while (1)
+        {
+tryagain:
+            /* First step: try to poll on each object in sequence. */
+            fds[0].events = POLLIN;
+            pollcount = 1;
+            if (alertable)
+            {
+                /* We also need to wait on APCs. */
+                fds[1].fd = ntdll_get_thread_data()->esync_apc_fd;
+                fds[1].events = POLLIN;
+                pollcount++;
+            }
+            for (i = 0; i < count; i++)
+            {
+                struct esync *obj = objs[i];
+
+                fds[0].fd = obj ? obj->fd : -1;
+
+                if (obj && obj->type == ESYNC_MUTEX)
+                {
+                    /* It might be ours. */
+                    struct mutex *mutex = obj->shm;
+
+                    if (mutex->tid == GetCurrentThreadId())
+                        continue;
+                }
+
+                ret = do_poll( fds, pollcount, timeout ? &end : NULL );
+                if (ret <= 0)
+                    goto err;
+                else if (alertable && (fds[1].revents & POLLIN))
+                    goto userapc;
+
+                if (fds[0].revents & (POLLHUP | POLLERR | POLLNVAL))
+                {
+                    ERR("Polling on fd %d returned %#x.\n", fds[0].fd, fds[0].revents);
+                    return STATUS_INVALID_HANDLE;
+                }
+            }
+
+            /* If we got here and we haven't timed out, that means all of the
+             * handles were signaled. Check to make sure they still are. */
+            for (i = 0; i < count; i++)
+            {
+                fds[i].fd = objs[i] ? objs[i]->fd : -1;
+                fds[i].events = POLLIN;
+            }
+            /* There's no reason to check for APCs here. */
+            pollcount = i;
+
+            /* Poll everything to see if they're still signaled. */
+            ret = poll( fds, pollcount, 0 );
+            if (ret == pollcount)
+            {
+                BOOL abandoned = FALSE;
+
+                /* Quick, grab everything. */
+                for (i = 0; i < count; i++)
+                {
+                    struct esync *obj = objs[i];
+
+                    switch (obj->type)
+                    {
+                    case ESYNC_MUTEX:
+                    {
+                        struct mutex *mutex = obj->shm;
+                        if (mutex->tid == GetCurrentThreadId())
+                            break;
+                        /* otherwise fall through */
+                    }
+                    case ESYNC_SEMAPHORE:
+                    case ESYNC_AUTO_EVENT:
+                        if ((size = read( fds[i].fd, &value, sizeof(value) )) != sizeof(value))
+                        {
+                            /* We were too slow. Put everything back. */
+                            value = 1;
+                            for (j = i; j >= 0; j--)
+                            {
+                                if (write( obj->fd, &value, sizeof(value) ) == -1)
+                                    return errno_to_status( errno );
+                            }
+
+                            goto tryagain;  /* break out of two loops and a switch */
+                        }
+                        break;
+                    default:
+                        /* If a manual-reset event changed between there and
+                         * here, it's shouldn't be a problem. */
+                        break;
+                    }
+                }
+
+                /* If we got here, we successfully waited on every object. */
+                /* Make sure to let ourselves know that we grabbed the mutexes
+                 * and semaphores. */
+                for (i = 0; i < count; i++)
+                    abandoned |= update_grabbed_object( objs[i] );
+
+                if (abandoned)
+                {
+                    TRACE("Wait successful, but some object(s) were abandoned.\n");
+                    return STATUS_ABANDONED;
+                }
+                TRACE("Wait successful.\n");
+                return STATUS_SUCCESS;
+            }
+
+            /* If we got here, ppoll() returned less than all of our objects.
+             * So loop back to the beginning and try again. */
+        } /* while(1) */
+    } /* else (wait-all) */
+
+err:
+    /* We should only get here if poll() failed. */
+
+    if (ret == 0)
+    {
+        TRACE("Wait timed out.\n");
+        return STATUS_TIMEOUT;
+    }
+    else
+    {
+        ERR("ppoll failed: %s\n", strerror(errno));
+        return errno_to_status( errno );
+    }
+
+userapc:
+    TRACE("Woken up by user APC.\n");
+
+    /* We have to make a server call anyway to get the APC to execute, so just
+     * delegate down to server_select(). */
+    ret = server_wait( NULL, 0, SELECT_INTERRUPTIBLE | SELECT_ALERTABLE, &zero );
+
+    /* This can happen if we received a system APC, and the APC fd was woken up
+     * before we got SIGUSR1. poll() doesn't return EINTR in that case. The
+     * right thing to do seems to be to return STATUS_USER_APC anyway. */
+    if (ret == STATUS_TIMEOUT) ret = STATUS_USER_APC;
+    return ret;
+}
+
+/* We need to let the server know when we are doing a message wait, and when we
+ * are done with one, so that all of the code surrounding hung queues works.
+ * We also need this for WaitForInputIdle(). */
+static void server_set_msgwait( int in_msgwait )
+{
+    SERVER_START_REQ( esync_msgwait )
+    {
+        req->in_msgwait = in_msgwait;
+        wine_server_call( req );
+    }
+    SERVER_END_REQ;
+}
+
+/* This is a very thin wrapper around the proper implementation above. The
+ * purpose is to make sure the server knows when we are doing a message wait.
+ * This is separated into a wrapper function since there are at least a dozen
+ * exit paths from esync_wait_objects(). */
+NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
+                             BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    BOOL msgwait = FALSE;
+    struct esync *obj;
+    NTSTATUS ret;
+
+    if (count && !get_object( handles[count - 1], &obj ) && obj->type == ESYNC_QUEUE)
+    {
+        msgwait = TRUE;
+        server_set_msgwait( 1 );
+    }
+
+    ret = __esync_wait_objects( count, handles, wait_any, alertable, timeout );
+
+    if (msgwait)
+        server_set_msgwait( 0 );
+
+    return ret;
+}
+
+NTSTATUS esync_signal_and_wait( HANDLE signal, HANDLE wait, BOOLEAN alertable,
+    const LARGE_INTEGER *timeout )
+{
+    struct esync *obj;
+    NTSTATUS ret;
+
+    if ((ret = get_object( signal, &obj ))) return ret;
+
+    switch (obj->type)
+    {
+    case ESYNC_SEMAPHORE:
+        ret = esync_release_semaphore( signal, 1, NULL );
+        break;
+    case ESYNC_AUTO_EVENT:
+    case ESYNC_MANUAL_EVENT:
+        ret = esync_set_event( signal );
+        break;
+    case ESYNC_MUTEX:
+        ret = esync_release_mutex( signal, NULL );
+        break;
+    default:
+        return STATUS_OBJECT_TYPE_MISMATCH;
+    }
+    if (ret) return ret;
+
+    return esync_wait_objects( 1, &wait, TRUE, alertable, timeout );
+}
+
+void esync_init(void)
+{
+    struct stat st;
+
+    if (!do_esync())
+    {
+        /* make sure the server isn't running with WINEESYNC */
+        HANDLE handle;
+        NTSTATUS ret;
+
+        ret = create_esync( 0, &handle, 0, NULL, 0, 0 );
+        if (ret != STATUS_NOT_IMPLEMENTED)
+        {
+            ERR("Server is running with WINEESYNC but this process is not, please enable WINEESYNC or restart wineserver.\n");
+            exit(1);
+        }
+
+        return;
+    }
+
+    if (stat( config_dir, &st ) == -1)
+        ERR("Cannot stat %s\n", config_dir);
+
+    if (st.st_ino != (unsigned long)st.st_ino)
+        sprintf( shm_name, "/wine-%lx%08lx-esync", (unsigned long)((unsigned long long)st.st_ino >> 32), (unsigned long)st.st_ino );
+    else
+        sprintf( shm_name, "/wine-%lx-esync", (unsigned long)st.st_ino );
+
+    if ((shm_fd = shm_open( shm_name, O_RDWR, 0644 )) == -1)
+    {
+        /* probably the server isn't running with WINEESYNC, tell the user and bail */
+        if (errno == ENOENT)
+            ERR("Failed to open esync shared memory file; make sure no stale wineserver instances are running without WINEESYNC.\n");
+        else
+            ERR("Failed to initialize shared memory: %s\n", strerror( errno ));
+        exit(1);
+    }
+
+    pagesize = sysconf( _SC_PAGESIZE );
+
+    shm_addrs = calloc( 128, sizeof(shm_addrs[0]) );
+    shm_addrs_size = 128;
+}
diff -ruN --show-c-function dlls/ntdll/unix/esync.h dlls/ntdll/unix/esync.h
--- dlls/ntdll/unix/esync.h	1969-12-31 16:00:00.000000000 -0800
+++ dlls/ntdll/unix/esync.h	2025-10-10 10:22:17.174256673 -0700
@@ -0,0 +1,61 @@
+/*
+ * eventfd-based synchronization objects
+ *
+ * Copyright (C) 2018 Zebediah Figura
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+extern int do_esync(void);
+extern void esync_init(void);
+extern NTSTATUS esync_close( HANDLE handle );
+
+extern NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr, int initial, int max);
+extern NTSTATUS esync_open_semaphore( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr );
+extern NTSTATUS esync_query_semaphore( HANDLE handle, void *info, ULONG *ret_len );
+extern NTSTATUS esync_release_semaphore( HANDLE handle, unsigned int count, ULONG *prev );
+
+extern NTSTATUS esync_create_event( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr, EVENT_TYPE type, BOOLEAN initial );
+extern NTSTATUS esync_open_event( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr );
+extern NTSTATUS esync_pulse_event( HANDLE handle );
+extern NTSTATUS esync_query_event( HANDLE handle, void *info, ULONG *ret_len );
+extern NTSTATUS esync_reset_event( HANDLE handle );
+extern NTSTATUS esync_set_event( HANDLE handle );
+
+extern NTSTATUS esync_create_mutex( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr, BOOLEAN initial );
+extern NTSTATUS esync_open_mutex( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr );
+extern NTSTATUS esync_query_mutex( HANDLE handle, void *info, ULONG *ret_len );
+extern NTSTATUS esync_release_mutex( HANDLE *handle, LONG *prev );
+
+extern NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
+                                    BOOLEAN alertable, const LARGE_INTEGER *timeout );
+extern NTSTATUS esync_signal_and_wait( HANDLE signal, HANDLE wait, BOOLEAN alertable,
+    const LARGE_INTEGER *timeout );
+
+
+/* We have to synchronize on the fd cache mutex so that our calls to receive_fd
+ * don't race with theirs. It looks weird, I know.
+ *
+ * If we weren't trying to avoid touching the code I'd rename the mutex to
+ * "server_fd_mutex" or something similar. */
+extern pthread_mutex_t fd_cache_mutex;
+
+extern int receive_fd( obj_handle_t *handle );
diff -ruN --show-c-function dlls/ntdll/unix/loader.c dlls/ntdll/unix/loader.c
--- dlls/ntdll/unix/loader.c	2025-10-10 10:17:48.573775205 -0700
+++ dlls/ntdll/unix/loader.c	2025-10-10 10:22:17.145276472 -0700
@@ -90,6 +90,7 @@
 #include "winioctl.h"
 #include "winternl.h"
 #include "unix_private.h"
+#include "esync.h"
 #include "wine/list.h"
 #include "ntsyscalls.h"
 #include "wine/debug.h"
@@ -1896,6 +1897,7 @@ static void start_main_thread(void)
     signal_init_threading();
     dbg_init();
     startup_info_size = server_init_process();
+    esync_init();
     virtual_map_user_shared_data();
     init_cpu_info();
     init_files();
diff -ruN --show-c-function dlls/ntdll/unix/loader.c.orig dlls/ntdll/unix/loader.c.orig
--- dlls/ntdll/unix/loader.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ dlls/ntdll/unix/loader.c.orig	2025-10-10 10:22:13.459291182 -0700
@@ -0,0 +1,2292 @@
+/*
+ * Unix interface for loader functions
+ *
+ * Copyright (C) 2020 Alexandre Julliard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <signal.h>
+#include <spawn.h>
+#include <string.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <sys/wait.h>
+#include <unistd.h>
+#include <dlfcn.h>
+#ifdef HAVE_PWD_H
+# include <pwd.h>
+#endif
+#ifdef HAVE_ELF_H
+# include <elf.h>
+#endif
+#ifdef HAVE_LINK_H
+# include <link.h>
+#endif
+#ifdef HAVE_SYS_AUXV_H
+# include <sys/auxv.h>
+#endif
+#ifdef HAVE_SYS_RESOURCE_H
+# include <sys/resource.h>
+#endif
+#include <limits.h>
+#ifdef HAVE_SYS_SYSCTL_H
+# include <sys/sysctl.h>
+#endif
+#ifdef __APPLE__
+# include <CoreFoundation/CoreFoundation.h>
+# define LoadResource MacLoadResource
+# define GetCurrentThread MacGetCurrentThread
+# include <CoreServices/CoreServices.h>
+# undef LoadResource
+# undef GetCurrentThread
+# include <pthread.h>
+# include <mach/mach.h>
+# include <mach/mach_error.h>
+# include <mach-o/getsect.h>
+# include <crt_externs.h>
+# ifndef _POSIX_SPAWN_DISABLE_ASLR
+#  define _POSIX_SPAWN_DISABLE_ASLR 0x0100
+# endif
+# define environ (*_NSGetEnviron())
+#else
+  extern char **environ;
+#endif
+#ifdef __ANDROID__
+# include <jni.h>
+#endif
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winnt.h"
+#include "winbase.h"
+#include "winnls.h"
+#include "winioctl.h"
+#include "winternl.h"
+#include "unix_private.h"
+#include "wine/list.h"
+#include "ntsyscalls.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(module);
+WINE_DECLARE_DEBUG_CHANNEL(syscall);
+
+#if defined __i386__ || defined __x86_64__
+#define SO_DLLS_SUPPORTED
+#endif
+
+void *pDbgUiRemoteBreakin = NULL;
+void *pKiRaiseUserExceptionDispatcher = NULL;
+void *pKiUserExceptionDispatcher = NULL;
+void *pKiUserApcDispatcher = NULL;
+void *pKiUserCallbackDispatcher = NULL;
+void *pKiUserEmulationDispatcher = NULL;
+void *pLdrInitializeThunk = NULL;
+void *pRtlUserThreadStart = NULL;
+void *p__wine_ctrl_routine = NULL;
+SYSTEM_DLL_INIT_BLOCK *pLdrSystemDllInitBlock = NULL;
+
+static void stub_syscall( const char *name )
+{
+    CONTEXT context = { .ContextFlags = CONTEXT_FULL };
+    EXCEPTION_RECORD rec =
+    {
+        .ExceptionCode = EXCEPTION_WINE_STUB,
+        .ExceptionFlags = EXCEPTION_NONCONTINUABLE,
+        .NumberParameters = 2,
+        .ExceptionInformation[0] = (ULONG_PTR)"ntdll",
+        .ExceptionInformation[1] = (ULONG_PTR)name,
+    };
+    NtGetContextThread( GetCurrentThread(), &context );
+#ifdef __i386__
+    rec.ExceptionAddress = (void *)context.Eip;
+#elif defined __x86_64__
+    rec.ExceptionAddress = (void *)context.Rip;
+#elif defined __arm__ || defined __aarch64__
+    rec.ExceptionAddress = (void *)context.Pc;
+#endif
+    NtRaiseException( &rec, &context, TRUE );
+}
+
+
+#define SYSCALL_STUB(name) static void name(void) { stub_syscall( #name ); }
+ALL_SYSCALL_STUBS
+
+static void * const syscalls[] =
+{
+#define SYSCALL_ENTRY(id,name,args) name,
+    ALL_SYSCALLS
+#undef SYSCALL_ENTRY
+};
+
+static BYTE syscall_args[ARRAY_SIZE(syscalls)] =
+{
+#define SYSCALL_ENTRY(id,name,args) args,
+    ALL_SYSCALLS
+#undef SYSCALL_ENTRY
+};
+
+SYSTEM_SERVICE_TABLE KeServiceDescriptorTable[4] =
+{
+    { (ULONG_PTR *)syscalls, NULL, ARRAY_SIZE(syscalls), syscall_args }
+};
+
+static const char *ntsyscall_names[] =
+{
+#define SYSCALL_ENTRY(id,name,args) #name,
+    ALL_SYSCALLS
+#undef SYSCALL_ENTRY
+};
+
+static const char **syscall_names[4] = { ntsyscall_names };
+static const char **usercall_names;
+
+void ntdll_add_syscall_debug_info( UINT idx, const char **names, const char **user_names )
+{
+    syscall_names[idx] = names;
+    usercall_names = user_names;
+}
+
+#ifdef __GNUC__
+static void fatal_error( const char *err, ... ) __attribute__((noreturn, format(printf,1,2)));
+#endif
+
+static const char *bin_dir;
+static const char *dll_dir;
+static const char *ntdll_dir;
+static const char *alt_build_dir;
+static SIZE_T dll_path_maxlen;
+
+const char *home_dir = NULL;
+const char *data_dir = NULL;
+const char *build_dir = NULL;
+const char *config_dir = NULL;
+const char *wineloader = NULL;
+const char **dll_paths = NULL;
+const char **system_dll_paths = NULL;
+const char *user_name = NULL;
+SECTION_IMAGE_INFORMATION main_image_info = { NULL };
+
+/* die on a fatal error; use only during initialization */
+static void fatal_error( const char *err, ... )
+{
+    va_list args;
+
+    va_start( args, err );
+    fprintf( stderr, "wine: " );
+    vfprintf( stderr, err, args );
+    va_end( args );
+    exit(1);
+}
+
+static void set_max_limit( int limit )
+{
+    struct rlimit rlimit;
+
+    if (!getrlimit( limit, &rlimit ))
+    {
+        rlimit.rlim_cur = rlimit.rlim_max;
+        if (!setrlimit( limit, &rlimit )) return;
+#ifdef __APPLE__
+        if (limit == RLIMIT_NOFILE)
+        {
+            /* macOS before Big Sur fails if rlim_max is larger than maxfilesperproc */
+            unsigned int nlimit = 0;
+            size_t size = sizeof(nlimit);
+            sysctlbyname("kern.maxfilesperproc", &nlimit, &size, NULL, 0);
+            rlimit.rlim_cur = max( nlimit, OPEN_MAX );
+            if (!setrlimit( RLIMIT_NOFILE, &rlimit )) return;
+        }
+#endif
+        WARN("Failed to raise limit %d\n", limit);
+    }
+}
+
+/* canonicalize path and return its directory name */
+static char *realpath_dirname( const char *name )
+{
+    char *p, *fullpath = realpath( name, NULL );
+
+    if (fullpath)
+    {
+        p = strrchr( fullpath, '/' );
+        if (p == fullpath) p++;
+        if (p) *p = 0;
+    }
+    return fullpath;
+}
+
+/* if string ends with tail, remove it */
+static char *remove_tail( const char *str, const char *tail )
+{
+    size_t len = strlen( str );
+    size_t tail_len = strlen( tail );
+    char *ret;
+
+    if (len < tail_len) return NULL;
+    if (strcmp( str + len - tail_len, tail )) return NULL;
+    ret = malloc( len - tail_len + 1 );
+    memcpy( ret, str, len - tail_len );
+    ret[len - tail_len] = 0;
+    return ret;
+}
+
+/* build a path from the specified dir and name */
+static char *build_path( const char *dir, const char *name )
+{
+    size_t len = strlen( dir );
+    char *ret = malloc( len + strlen( name ) + 2 );
+
+    if (len)
+    {
+        memcpy( ret, dir, len );
+        if (ret[len - 1] != '/') ret[len++] = '/';
+        if (name[0] == '/') name++;
+    }
+    strcpy( ret + len, name );
+    return ret;
+}
+
+/* build a path with the relative dir from 'from' to 'dest' appended to base */
+static char *build_relative_path( const char *base, const char *from, const char *dest )
+{
+    const char *start;
+    char *ret;
+    unsigned int dotdots = 0;
+
+    for (;;)
+    {
+        while (*from == '/') from++;
+        while (*dest == '/') dest++;
+        start = dest;  /* save start of next path element */
+        if (!*from) break;
+
+        while (*from && *from != '/' && *from == *dest) { from++; dest++; }
+        if ((!*from || *from == '/') && (!*dest || *dest == '/')) continue;
+
+        do  /* count remaining elements in 'from' */
+        {
+            dotdots++;
+            while (*from && *from != '/') from++;
+            while (*from == '/') from++;
+        }
+        while (*from);
+        break;
+    }
+
+    ret = malloc( strlen(base) + 3 * dotdots + strlen(start) + 2 );
+    strcpy( ret, base );
+    while (dotdots--) strcat( ret, "/.." );
+
+    if (!start[0]) return ret;
+    strcat( ret, "/" );
+    strcat( ret, start );
+    return ret;
+}
+
+/* build a path to a binary and exec it */
+static int build_path_and_exec( pid_t *pid, const char *dir, const char *name, char **argv )
+{
+    int ret;
+
+    argv[0] = build_path( dir, name );
+    ret = posix_spawn( pid, argv[0], NULL, NULL, argv, environ );
+    free( argv[0] );
+    return ret;
+}
+
+
+static const char *get_so_dir( WORD machine )
+{
+    switch (machine)
+    {
+    case IMAGE_FILE_MACHINE_I386:  return "/i386-unix";
+    case IMAGE_FILE_MACHINE_AMD64: return "/x86_64-unix";
+    case IMAGE_FILE_MACHINE_ARMNT: return "/arm-unix";
+    case IMAGE_FILE_MACHINE_ARM64: return "/aarch64-unix";
+    default: return "";
+    }
+}
+
+static const char *get_pe_dir( WORD machine )
+{
+    switch(machine)
+    {
+    case IMAGE_FILE_MACHINE_I386:  return "/i386-windows";
+    case IMAGE_FILE_MACHINE_AMD64: return "/x86_64-windows";
+    case IMAGE_FILE_MACHINE_ARMNT: return "/arm-windows";
+    case IMAGE_FILE_MACHINE_ARM64: return "/aarch64-windows";
+    default: return "";
+    }
+}
+
+static WORD get_alt_machine( WORD machine )
+{
+    switch (machine)
+    {
+    case IMAGE_FILE_MACHINE_I386:  return IMAGE_FILE_MACHINE_AMD64;
+    case IMAGE_FILE_MACHINE_AMD64: return IMAGE_FILE_MACHINE_I386;
+    case IMAGE_FILE_MACHINE_ARMNT: return IMAGE_FILE_MACHINE_ARM64;
+    case IMAGE_FILE_MACHINE_ARM64: return IMAGE_FILE_MACHINE_ARMNT;
+    default: return machine;
+    }
+}
+
+static void set_dll_path(void)
+{
+    char *p, *path = getenv( "WINEDLLPATH" );
+    int i, count = 0;
+
+    if (path) for (p = path, count = 1; *p; p++) if (*p == ':') count++;
+
+    dll_paths = malloc( (count + 2) * sizeof(*dll_paths) );
+    count = 0;
+
+    if (!build_dir) dll_paths[count++] = dll_dir;
+
+    if (path)
+    {
+        path = strdup(path);
+        for (p = strtok( path, ":" ); p; p = strtok( NULL, ":" )) dll_paths[count++] = strdup( p );
+        free( path );
+    }
+
+    for (i = 0; i < count; i++) dll_path_maxlen = max( dll_path_maxlen, strlen(dll_paths[i]) );
+    dll_paths[count] = NULL;
+}
+
+
+static void set_system_dll_path(void)
+{
+    const char *p, *path = SYSTEMDLLPATH;
+    int count = 0;
+
+    if (path && *path) for (p = path, count = 1; *p; p++) if (*p == ':') count++;
+
+    system_dll_paths = malloc( (count + 1) * sizeof(*system_dll_paths) );
+    count = 0;
+
+    if (path && *path)
+    {
+        char *path_copy = strdup(path);
+        for (p = strtok( path_copy, ":" ); p; p = strtok( NULL, ":" ))
+            system_dll_paths[count++] = strdup( p );
+        free( path_copy );
+    }
+    system_dll_paths[count] = NULL;
+}
+
+
+static void set_home_dir(void)
+{
+    const char *home = getenv( "HOME" );
+    const char *name = getenv( "USER" );
+    const char *p;
+
+    if (!home || !name)
+    {
+        struct passwd *pwd = getpwuid( getuid() );
+        if (pwd)
+        {
+            if (!home) home = pwd->pw_dir;
+            if (!name) name = pwd->pw_name;
+        }
+        if (!name) name = "wine";
+    }
+    if ((p = strrchr( name, '/' ))) name = p + 1;
+    if ((p = strrchr( name, '\\' ))) name = p + 1;
+    home_dir = strdup( home );
+    user_name = strdup( name );
+}
+
+
+static void set_config_dir(void)
+{
+    char *p, *dir;
+    const char *prefix = getenv( "WINEPREFIX" );
+
+    if (prefix)
+    {
+        if (prefix[0] != '/')
+            fatal_error( "invalid directory %s in WINEPREFIX: not an absolute path\n", prefix );
+        config_dir = dir = strdup( prefix );
+        for (p = dir + strlen(dir) - 1; p > dir && *p == '/'; p--) *p = 0;
+    }
+    else
+    {
+        if (!home_dir) fatal_error( "could not determine your home directory\n" );
+        if (home_dir[0] != '/') fatal_error( "the home directory %s is not an absolute path\n", home_dir );
+        config_dir = build_path( home_dir, ".wine" );
+    }
+}
+
+static void init_paths(void)
+{
+    Dl_info info;
+
+    if (!dladdr( init_paths, &info ) || !(ntdll_dir = realpath_dirname( info.dli_fname )))
+        fatal_error( "cannot get path to ntdll.so\n" );
+
+    if ((build_dir = remove_tail( ntdll_dir, "/dlls/ntdll" )))
+    {
+        wineloader = build_path( build_dir, "loader/wine" );
+        alt_build_dir = realpath_dirname( build_path( build_dir, "loader-wow64" ));
+    }
+    else
+    {
+        if (!(dll_dir = remove_tail( ntdll_dir, get_so_dir(current_machine) ))) dll_dir = ntdll_dir;
+        bin_dir = build_relative_path( dll_dir, LIBDIR "/wine", BINDIR );
+        data_dir = build_relative_path( dll_dir, LIBDIR "/wine", DATADIR "/wine" );
+        wineloader = build_path( ntdll_dir, "wine" );
+    }
+
+    set_dll_path();
+    set_system_dll_path();
+    set_home_dir();
+    set_config_dir();
+}
+
+
+/***********************************************************************
+ *           get_alternate_wineloader
+ */
+char *get_alternate_wineloader( WORD machine )
+{
+    const char *arch;
+    BOOL force_wow64 = (arch = getenv( "WINEARCH" )) && !strcmp( arch, "wow64" );
+    char *ret = NULL;
+
+    if (is_win64)
+    {
+        if (force_wow64) return NULL;
+        if (machine != get_alt_machine( current_machine )) return NULL;
+    }
+    else
+    {
+        if (!force_wow64 && machine == current_machine) return NULL;
+        machine = get_alt_machine( current_machine );
+    }
+
+    if (!build_dir)
+        asprintf( &ret, "%s%s/wine", dll_dir, get_so_dir( machine ));
+    else if (alt_build_dir)
+        asprintf( &ret, "%s/loader/wine", alt_build_dir );
+
+    return ret;
+}
+
+
+static void preloader_exec( char **argv )
+{
+#ifdef HAVE_WINE_PRELOADER
+    asprintf( &argv[0], "%s-preloader", argv[1] );
+#ifdef __APPLE__
+    {
+        posix_spawnattr_t attr;
+        posix_spawnattr_init( &attr );
+        posix_spawnattr_setflags( &attr, POSIX_SPAWN_SETEXEC | _POSIX_SPAWN_DISABLE_ASLR );
+        posix_spawn( NULL, argv[0], NULL, &attr, argv, *_NSGetEnviron() );
+        posix_spawnattr_destroy( &attr );
+    }
+#endif
+    execv( argv[0], argv );
+    free( argv[0] );
+#endif
+    execv( argv[1], argv + 1 );
+}
+
+/* exec the appropriate wine loader for the specified machine */
+static NTSTATUS loader_exec( char **argv, WORD machine )
+{
+    if (((argv[1] = get_alternate_wineloader( machine )))) preloader_exec( argv );
+
+    argv[1] = strdup( wineloader );
+    preloader_exec( argv );
+    return STATUS_INVALID_IMAGE_FORMAT;
+}
+
+
+/***********************************************************************
+ *           exec_wineloader
+ *
+ * argv[0] and argv[1] must be reserved for the preloader and loader respectively.
+ */
+NTSTATUS exec_wineloader( char **argv, int socketfd, const struct pe_image_info *pe_info )
+{
+    WORD machine = pe_info->machine;
+    ULONGLONG res_start = pe_info->base;
+    ULONGLONG res_end = pe_info->base + pe_info->map_size;
+    char preloader_reserve[64], socket_env[64];
+
+    if (pe_info->wine_fakedll) res_start = res_end = 0;
+    if (pe_info->image_flags & IMAGE_FLAGS_ComPlusNativeReady) machine = native_machine;
+
+    signal( SIGPIPE, SIG_DFL );
+
+    snprintf( socket_env, sizeof(socket_env), "WINESERVERSOCKET=%u", socketfd );
+    snprintf( preloader_reserve, sizeof(preloader_reserve), "WINEPRELOADRESERVE=%x%08x-%x%08x",
+             (UINT)(res_start >> 32), (UINT)res_start, (UINT)(res_end >> 32), (UINT)res_end );
+
+    putenv( preloader_reserve );
+    putenv( socket_env );
+
+    return loader_exec( argv, machine );
+}
+
+
+/***********************************************************************
+ *           exec_wineserver
+ *
+ * Exec a new wine server.
+ */
+static int exec_wineserver( pid_t *pid, char **argv )
+{
+    char *path;
+
+    if (!is_win64 && alt_build_dir)  /* look for 64-bit server */
+        return build_path_and_exec( pid, alt_build_dir, "server/wineserver", argv );
+
+    if (build_dir)
+        return build_path_and_exec( pid, build_dir, "server/wineserver", argv );
+
+    if (!build_path_and_exec( pid, bin_dir, "wineserver", argv )) return 0;
+    if ((path = getenv( "WINESERVER" )) && !build_path_and_exec( pid, "", path, argv )) return 0;
+
+    if ((path = getenv( "PATH" )))
+    {
+        for (path = strtok( strdup( path ), ":" ); path; path = strtok( NULL, ":" ))
+            if (!build_path_and_exec( pid, path, "wineserver", argv )) return 0;
+    }
+    return build_path_and_exec( pid, BINDIR, "wineserver", argv );
+}
+
+
+/***********************************************************************
+ *           start_server
+ *
+ * Start a new wine server.
+ */
+void start_server( BOOL debug )
+{
+    static BOOL started;  /* we only try once */
+    char *argv[3];
+    static char debug_flag[] = "-d";
+
+    if (!started)
+    {
+        int status;
+        pid_t pid;
+
+        argv[1] = debug ? debug_flag : NULL;
+        argv[2] = NULL;
+        if (exec_wineserver( &pid, argv )) fatal_error( "could not exec wineserver\n" );
+        waitpid( pid, &status, 0 );
+        status = WIFEXITED(status) ? WEXITSTATUS(status) : 1;
+        if (status == 2) return;  /* server lock held by someone else, will retry later */
+        if (status) exit(status);  /* server failed */
+        started = TRUE;
+    }
+}
+
+
+/***********************************************************************
+ *           KeAddSystemServiceTable
+ */
+BOOLEAN KeAddSystemServiceTable( ULONG_PTR *funcs, ULONG_PTR *counters, ULONG limit,
+                                 BYTE *arguments, ULONG index )
+{
+    if (index >= ARRAY_SIZE(KeServiceDescriptorTable)) return FALSE;
+    KeServiceDescriptorTable[index].ServiceTable  = funcs;
+    KeServiceDescriptorTable[index].CounterTable  = counters;
+    KeServiceDescriptorTable[index].ServiceLimit  = limit;
+    KeServiceDescriptorTable[index].ArgumentTable = arguments;
+    return TRUE;
+}
+
+void trace_syscall( UINT id, ULONG_PTR *args, ULONG len )
+{
+    UINT idx = (id >> 12) & 3, num = id & 0xfff;
+    const char **names = syscall_names[idx];
+
+    if (names && names[num])
+        TRACE_(syscall)( "\1SysCall  %s(", names[num] );
+    else
+        TRACE_(syscall)( "\1SysCall  %04x(", id );
+
+    len /= sizeof(ULONG_PTR);
+    for (ULONG i = 0; i < len; i++)
+    {
+        TRACE_(syscall)( "%08lx", args[i] );
+        if (i < len - 1) TRACE_(syscall)( "," );
+    }
+    TRACE_(syscall)( ")\n" );
+}
+
+void trace_sysret( UINT id, ULONG_PTR retval )
+{
+    UINT idx = (id >> 12) & 3, num = id & 0xfff;
+    const char **names = syscall_names[idx];
+
+    if (names && names[num])
+        TRACE_(syscall)( "\1SysRet   %s() retval=%08lx\n", names[num], retval );
+    else
+        TRACE_(syscall)( "\1SysRet   %04x() retval=%08lx\n", id, retval );
+}
+
+void trace_usercall( UINT id, ULONG_PTR *args, ULONG len )
+{
+    if (usercall_names)
+        TRACE_(syscall)("\1UserCall %s(%p,%u)\n", usercall_names[id], args, len );
+    else
+        TRACE_(syscall)("\1UserCall %04x(%p,%u)\n", id, args, len );
+}
+
+void trace_userret( void *ret_ptr, ULONG len, NTSTATUS status, UINT id )
+{
+    if (usercall_names)
+        TRACE_(syscall)("\1UserRet  %s(%p,%u) retval=%08x\n", usercall_names[id], ret_ptr, len, status );
+    else
+        TRACE_(syscall)("\1UserRet  %04x(%p,%u) retval=%08x\n", id, ret_ptr, len, status );
+}
+
+#ifdef SO_DLLS_SUPPORTED
+
+/* adjust an array of pointers to make them into RVAs */
+static inline void fixup_rva_ptrs( void *array, BYTE *base, unsigned int count )
+{
+    BYTE **src = array;
+    DWORD *dst = array;
+
+    for ( ; count; count--, src++, dst++) *dst = *src ? *src - base : 0;
+}
+
+/* fixup an array of RVAs by adding the specified delta */
+static inline void fixup_rva_dwords( DWORD *ptr, int delta, unsigned int count )
+{
+    for ( ; count; count--, ptr++) if (*ptr) *ptr += delta;
+}
+
+
+/* fixup an array of name/ordinal RVAs by adding the specified delta */
+static inline void fixup_rva_names( UINT_PTR *ptr, int delta )
+{
+    for ( ; *ptr; ptr++) if (!(*ptr & IMAGE_ORDINAL_FLAG)) *ptr += delta;
+}
+
+
+/* fixup RVAs in the resource directory */
+static void fixup_so_resources( IMAGE_RESOURCE_DIRECTORY *dir, BYTE *root, int delta )
+{
+    IMAGE_RESOURCE_DIRECTORY_ENTRY *entry = (IMAGE_RESOURCE_DIRECTORY_ENTRY *)(dir + 1);
+    unsigned int i;
+
+    for (i = 0; i < dir->NumberOfNamedEntries + dir->NumberOfIdEntries; i++, entry++)
+    {
+        void *ptr = root + entry->OffsetToDirectory;
+        if (entry->DataIsDirectory) fixup_so_resources( ptr, root, delta );
+        else fixup_rva_dwords( &((IMAGE_RESOURCE_DATA_ENTRY *)ptr)->OffsetToData, delta, 1 );
+    }
+}
+
+/***********************************************************************
+ *           fill_builtin_image_info
+ */
+static void fill_builtin_image_info( void *module, struct pe_image_info *info )
+{
+    const IMAGE_DOS_HEADER *dos = (const IMAGE_DOS_HEADER *)module;
+    const IMAGE_NT_HEADERS *nt = (IMAGE_NT_HEADERS *)((const BYTE *)dos + dos->e_lfanew);
+
+    memset( info, 0, sizeof(*info) );
+    info->base            = nt->OptionalHeader.ImageBase;
+    info->entry_point     = nt->OptionalHeader.AddressOfEntryPoint;
+    info->map_size        = nt->OptionalHeader.SizeOfImage;
+    info->stack_size      = nt->OptionalHeader.SizeOfStackReserve;
+    info->stack_commit    = nt->OptionalHeader.SizeOfStackCommit;
+    info->subsystem       = nt->OptionalHeader.Subsystem;
+    info->subsystem_minor = nt->OptionalHeader.MinorSubsystemVersion;
+    info->subsystem_major = nt->OptionalHeader.MajorSubsystemVersion;
+    info->osversion_major = nt->OptionalHeader.MajorOperatingSystemVersion;
+    info->osversion_minor = nt->OptionalHeader.MinorOperatingSystemVersion;
+    info->image_charact   = nt->FileHeader.Characteristics;
+    info->dll_charact     = nt->OptionalHeader.DllCharacteristics;
+    info->machine         = nt->FileHeader.Machine;
+    info->contains_code   = TRUE;
+    info->wine_builtin    = TRUE;
+    info->header_size     = nt->OptionalHeader.SizeOfHeaders;
+    info->file_size       = nt->OptionalHeader.SizeOfImage;
+    info->checksum        = nt->OptionalHeader.CheckSum;
+}
+
+/*************************************************************************
+ *		map_so_dll
+ *
+ * Map a builtin dll in memory and fixup RVAs.
+ */
+static NTSTATUS map_so_dll( const IMAGE_NT_HEADERS *nt_descr, HMODULE module )
+{
+    static const char builtin_signature[32] = "Wine builtin DLL";
+    IMAGE_DATA_DIRECTORY *dir;
+    IMAGE_DOS_HEADER *dos;
+    IMAGE_NT_HEADERS *nt;
+    IMAGE_SECTION_HEADER *sec;
+    BYTE *addr = (BYTE *)module;
+    DWORD code_start, code_end, data_start, data_end;
+    DWORD align_mask = nt_descr->OptionalHeader.SectionAlignment - 1;
+    int delta, nb_sections = 2;  /* code + data */
+    unsigned int i;
+
+    code_start = (sizeof(IMAGE_DOS_HEADER)
+                  + sizeof(builtin_signature)
+                  + sizeof(IMAGE_NT_HEADERS)
+                  + nb_sections * sizeof(IMAGE_SECTION_HEADER)
+                  + align_mask) & ~align_mask;
+
+    if (anon_mmap_fixed( addr, code_start, PROT_READ | PROT_WRITE, 0 ) != addr) return STATUS_NO_MEMORY;
+
+    dos = (IMAGE_DOS_HEADER *)addr;
+    nt  = (IMAGE_NT_HEADERS *)((BYTE *)(dos + 1) + sizeof(builtin_signature));
+    sec = (IMAGE_SECTION_HEADER *)(nt + 1);
+
+    /* build the DOS and NT headers */
+
+    dos->e_magic    = IMAGE_DOS_SIGNATURE;
+    dos->e_cblp     = 0x90;
+    dos->e_cp       = 3;
+    dos->e_cparhdr  = (sizeof(*dos) + 0xf) / 0x10;
+    dos->e_minalloc = 0;
+    dos->e_maxalloc = 0xffff;
+    dos->e_ss       = 0x0000;
+    dos->e_sp       = 0x00b8;
+    dos->e_lfanew   = sizeof(*dos) + sizeof(builtin_signature);
+    memcpy( dos + 1, builtin_signature, sizeof(builtin_signature) );
+
+    *nt = *nt_descr;
+
+    delta      = (const BYTE *)nt_descr - addr;
+    data_start = delta & ~align_mask;
+#ifdef __APPLE__
+    {
+        Dl_info dli;
+        unsigned long data_size;
+        /* need the mach_header, not the PE header, to give to getsegmentdata(3) */
+        dladdr(addr, &dli);
+        code_end   = getsegmentdata(dli.dli_fbase, "__DATA", &data_size) - addr;
+        data_end   = (code_end + data_size + align_mask) & ~align_mask;
+    }
+#else
+    code_end   = data_start;
+    data_end   = (nt->OptionalHeader.SizeOfImage + delta + align_mask) & ~align_mask;
+#endif
+
+    fixup_rva_ptrs( &nt->OptionalHeader.AddressOfEntryPoint, addr, 1 );
+
+    nt->FileHeader.NumberOfSections                = nb_sections;
+    nt->OptionalHeader.BaseOfCode                  = code_start;
+#ifndef _WIN64
+    nt->OptionalHeader.BaseOfData                  = data_start;
+#endif
+    nt->OptionalHeader.SizeOfCode                  = code_end - code_start;
+    nt->OptionalHeader.SizeOfInitializedData       = data_end - data_start;
+    nt->OptionalHeader.SizeOfUninitializedData     = 0;
+    nt->OptionalHeader.SizeOfImage                 = data_end;
+    nt->OptionalHeader.ImageBase                   = (ULONG_PTR)addr;
+
+    /* build the code section */
+
+    memcpy( sec->Name, ".text", sizeof(".text") );
+    sec->SizeOfRawData = code_end - code_start;
+    sec->Misc.VirtualSize = sec->SizeOfRawData;
+    sec->VirtualAddress   = code_start;
+    sec->PointerToRawData = code_start;
+    sec->Characteristics  = (IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ);
+    sec++;
+
+    /* build the data section */
+
+    memcpy( sec->Name, ".data", sizeof(".data") );
+    sec->SizeOfRawData = data_end - data_start;
+    sec->Misc.VirtualSize = sec->SizeOfRawData;
+    sec->VirtualAddress   = data_start;
+    sec->PointerToRawData = data_start;
+    sec->Characteristics  = (IMAGE_SCN_CNT_INITIALIZED_DATA |
+                             IMAGE_SCN_MEM_WRITE | IMAGE_SCN_MEM_READ);
+    sec++;
+
+    for (i = 0; i < nt->OptionalHeader.NumberOfRvaAndSizes; i++)
+        fixup_rva_dwords( &nt->OptionalHeader.DataDirectory[i].VirtualAddress, delta, 1 );
+
+    /* build the import directory */
+
+    dir = &nt->OptionalHeader.DataDirectory[IMAGE_FILE_IMPORT_DIRECTORY];
+    if (dir->Size)
+    {
+        IMAGE_IMPORT_DESCRIPTOR *imports = (IMAGE_IMPORT_DESCRIPTOR *)(addr + dir->VirtualAddress);
+
+        while (imports->Name)
+        {
+            fixup_rva_dwords( &imports->OriginalFirstThunk, delta, 1 );
+            fixup_rva_dwords( &imports->Name, delta, 1 );
+            fixup_rva_dwords( &imports->FirstThunk, delta, 1 );
+            if (imports->OriginalFirstThunk)
+                fixup_rva_names( (UINT_PTR *)(addr + imports->OriginalFirstThunk), delta );
+            if (imports->FirstThunk)
+                fixup_rva_names( (UINT_PTR *)(addr + imports->FirstThunk), delta );
+            imports++;
+        }
+    }
+
+    /* build the resource directory */
+
+    dir = &nt->OptionalHeader.DataDirectory[IMAGE_FILE_RESOURCE_DIRECTORY];
+    if (dir->Size)
+    {
+        void *ptr = addr + dir->VirtualAddress;
+        fixup_so_resources( ptr, ptr, delta );
+    }
+
+    /* build the export directory */
+
+    dir = &nt->OptionalHeader.DataDirectory[IMAGE_FILE_EXPORT_DIRECTORY];
+    if (dir->Size)
+    {
+        IMAGE_EXPORT_DIRECTORY *exports = (IMAGE_EXPORT_DIRECTORY *)(addr + dir->VirtualAddress);
+
+        fixup_rva_dwords( &exports->Name, delta, 1 );
+        fixup_rva_dwords( &exports->AddressOfFunctions, delta, 1 );
+        fixup_rva_dwords( &exports->AddressOfNames, delta, 1 );
+        fixup_rva_dwords( &exports->AddressOfNameOrdinals, delta, 1 );
+        fixup_rva_dwords( (DWORD *)(addr + exports->AddressOfNames), delta, exports->NumberOfNames );
+        fixup_rva_ptrs( addr + exports->AddressOfFunctions, addr, exports->NumberOfFunctions );
+    }
+
+    /* build the delay import directory */
+
+    dir = &nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT];
+    if (dir->Size)
+    {
+        IMAGE_DELAYLOAD_DESCRIPTOR *imports = (IMAGE_DELAYLOAD_DESCRIPTOR *)(addr + dir->VirtualAddress);
+
+        while (imports->DllNameRVA)
+        {
+            fixup_rva_dwords( &imports->DllNameRVA, delta, 1 );
+            fixup_rva_dwords( &imports->ModuleHandleRVA, delta, 1 );
+            fixup_rva_dwords( &imports->ImportAddressTableRVA, delta, 1 );
+            fixup_rva_dwords( &imports->ImportNameTableRVA, delta, 1 );
+            fixup_rva_dwords( &imports->BoundImportAddressTableRVA, delta, 1 );
+            fixup_rva_dwords( &imports->UnloadInformationTableRVA, delta, 1 );
+            fixup_rva_names( (UINT_PTR *)(addr + imports->ImportNameTableRVA), delta );
+            imports++;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
+
+/***********************************************************************
+ *           dlopen_dll
+ */
+static NTSTATUS dlopen_dll( const char *so_name, UNICODE_STRING *nt_name, void **ret_module,
+                            struct pe_image_info *image_info, BOOL prefer_native )
+{
+    void *module, *handle;
+    const IMAGE_NT_HEADERS *nt;
+
+    handle = dlopen( so_name, RTLD_NOW );
+    if (!handle)
+    {
+        WARN( "failed to load .so lib %s: %s\n", debugstr_a(so_name), dlerror() );
+        return STATUS_INVALID_IMAGE_FORMAT;
+    }
+
+    if (!(nt = dlsym( handle, "__wine_spec_nt_header" )))
+    {
+        ERR( "invalid .so library %s, too old?\n", debugstr_a(so_name));
+        return STATUS_INVALID_IMAGE_FORMAT;
+    }
+
+    module = (HMODULE)((nt->OptionalHeader.ImageBase + 0xffff) & ~0xffff);
+    if (get_builtin_so_handle( module ))  /* already loaded */
+    {
+        fill_builtin_image_info( module, image_info );
+        *ret_module = module;
+        dlclose( handle );
+        return STATUS_SUCCESS;
+    }
+
+    if (map_so_dll( nt, module ))
+    {
+        dlclose( handle );
+        return STATUS_NO_MEMORY;
+    }
+
+    fill_builtin_image_info( module, image_info );
+    if (prefer_native && (image_info->dll_charact & IMAGE_DLLCHARACTERISTICS_PREFER_NATIVE))
+    {
+        TRACE( "%s has prefer-native flag, ignoring builtin\n", debugstr_a(so_name) );
+        dlclose( handle );
+        return STATUS_IMAGE_ALREADY_LOADED;
+    }
+
+    if (virtual_create_builtin_view( module, nt_name, image_info, handle ))
+    {
+        dlclose( handle );
+        return STATUS_NO_MEMORY;
+    }
+    *ret_module = module;
+    return STATUS_SUCCESS;
+}
+
+
+/***********************************************************************
+ *           load_so_dll
+ */
+static NTSTATUS load_so_dll( void *args )
+{
+    static const WCHAR soW[] = {'.','s','o',0};
+    struct load_so_dll_params *params = args;
+    UNICODE_STRING *nt_name = &params->nt_name;
+    OBJECT_ATTRIBUTES attr;
+    UNICODE_STRING true_nt_name;
+    struct pe_image_info info;
+    char *unix_name;
+    NTSTATUS status;
+    DWORD len;
+
+    if (get_load_order( nt_name ) == LO_DISABLED) return STATUS_DLL_NOT_FOUND;
+    InitializeObjectAttributes( &attr, nt_name, OBJ_CASE_INSENSITIVE, 0, 0 );
+    if (!get_nt_and_unix_names( &attr, &true_nt_name, &unix_name, FILE_OPEN ))
+    {
+        /* remove .so extension from Windows name */
+        len = nt_name->Length / sizeof(WCHAR);
+        if (len > 3 && !wcsicmp( nt_name->Buffer + len - 3, soW )) nt_name->Length -= 3 * sizeof(WCHAR);
+
+        status = dlopen_dll( unix_name, nt_name, params->module, &info, FALSE );
+    }
+    else status = STATUS_DLL_NOT_FOUND;
+
+    free( unix_name );
+    free( true_nt_name.Buffer );
+    return status;
+}
+
+/* check if the library is the correct architecture */
+/* only returns false for a valid library of the wrong arch */
+static int check_library_arch( int fd )
+{
+#ifdef __APPLE__
+    struct  /* Mach-O header */
+    {
+        unsigned int magic;
+        unsigned int cputype;
+    } header;
+
+    if (read( fd, &header, sizeof(header) ) != sizeof(header)) return 1;
+    if (header.magic != 0xfeedface) return 1;
+    if (sizeof(void *) == sizeof(int)) return !(header.cputype >> 24);
+    else return (header.cputype >> 24) == 1; /* CPU_ARCH_ABI64 */
+#else
+    struct  /* ELF header */
+    {
+        unsigned char magic[4];
+        unsigned char class;
+        unsigned char data;
+        unsigned char version;
+    } header;
+
+    if (read( fd, &header, sizeof(header) ) != sizeof(header)) return 1;
+    if (memcmp( header.magic, "\177ELF", 4 )) return 1;
+    if (header.version != 1 /* EV_CURRENT */) return 1;
+#ifdef WORDS_BIGENDIAN
+    if (header.data != 2 /* ELFDATA2MSB */) return 1;
+#else
+    if (header.data != 1 /* ELFDATA2LSB */) return 1;
+#endif
+    if (sizeof(void *) == sizeof(int)) return header.class == 1; /* ELFCLASS32 */
+    else return header.class == 2; /* ELFCLASS64 */
+#endif
+}
+
+/***********************************************************************
+ *           open_builtin_so_file
+ */
+static NTSTATUS open_builtin_so_file( char *name, OBJECT_ATTRIBUTES *attr, void **module,
+                                      SECTION_IMAGE_INFORMATION *image_info, USHORT search_machine,
+                                      USHORT load_machine, BOOL prefer_native )
+{
+    NTSTATUS status = STATUS_DLL_NOT_FOUND;
+    int fd;
+    char *end = name + strlen( name );
+
+    if (search_machine != current_machine) return status;
+    if (load_machine && load_machine != current_machine) return status;
+
+    *module = NULL;
+    strcpy( end, ".so" );
+    if ((fd = open( name, O_RDONLY )) == -1) goto done;
+
+    if (check_library_arch( fd ))
+    {
+        struct pe_image_info info;
+
+        status = dlopen_dll( name, attr->ObjectName, module, &info, prefer_native );
+        if (!status) virtual_fill_image_information( &info, image_info );
+        else if (status != STATUS_IMAGE_ALREADY_LOADED)
+        {
+            ERR( "failed to load .so lib %s\n", debugstr_a(name) );
+            status = STATUS_PROCEDURE_NOT_FOUND;
+        }
+    }
+    else status = STATUS_NOT_SUPPORTED;
+
+    close( fd );
+ done:
+    *end = 0;
+    return status;
+}
+
+/***********************************************************************
+ *           open_main_image_so_file
+ */
+static NTSTATUS open_main_image_so_file( const char *name, UNICODE_STRING *nt_name, void **module,
+                                         SECTION_IMAGE_INFORMATION *image_info )
+{
+    struct pe_image_info pe_info;
+    NTSTATUS status;
+
+    /* remove .so extension from Windows name */
+    if (nt_name->Length > 3 * sizeof(WCHAR))
+    {
+        static const WCHAR soW[] = {'.','s','o',0};
+        WCHAR *p = nt_name->Buffer + nt_name->Length / sizeof(WCHAR);
+        if (!wcsicmp( p - 3, soW ))
+        {
+            p[-3] = 0;
+            nt_name->Length -= 3 * sizeof(WCHAR);
+        }
+    }
+    status = dlopen_dll( name, nt_name, module, &pe_info, FALSE );
+    if (!status) virtual_fill_image_information( &pe_info, image_info );
+    return status;
+}
+
+extern NTSTATUS unwind_builtin_dll( void *args );
+
+#else /* SO_DLLS_SUPPORTED */
+
+static NTSTATUS open_builtin_so_file( char *name, OBJECT_ATTRIBUTES *attr, void **module,
+                                      SECTION_IMAGE_INFORMATION *image_info, USHORT search_machine,
+                                      USHORT load_machine, BOOL prefer_native )
+{
+    return STATUS_DLL_NOT_FOUND;
+}
+
+static NTSTATUS open_main_image_so_file( const char *name, UNICODE_STRING *nt_name, void **module,
+                                         SECTION_IMAGE_INFORMATION *image_info )
+{
+    return STATUS_INVALID_IMAGE_FORMAT;
+}
+
+static NTSTATUS load_so_dll( void *args )
+{
+    return STATUS_INVALID_IMAGE_FORMAT;
+}
+
+static NTSTATUS unwind_builtin_dll( void *args )
+{
+    return STATUS_UNSUCCESSFUL;
+}
+
+#endif /* SO_DLLS_SUPPORTED */
+
+
+static const unixlib_entry_t unix_call_funcs[] =
+{
+    load_so_dll,
+    unwind_builtin_dll,
+    unixcall_wine_dbg_write,
+    unixcall_wine_server_call,
+    unixcall_wine_server_fd_to_handle,
+    unixcall_wine_server_handle_to_fd,
+    unixcall_wine_spawnvp,
+    system_time_precise,
+};
+
+
+#ifdef _WIN64
+
+static NTSTATUS wow64_load_so_dll( void *args ) { return STATUS_INVALID_IMAGE_FORMAT; }
+static NTSTATUS wow64_unwind_builtin_dll( void *args ) { return STATUS_UNSUCCESSFUL; }
+
+const unixlib_entry_t unix_call_wow64_funcs[] =
+{
+    wow64_load_so_dll,
+    wow64_unwind_builtin_dll,
+    wow64_wine_dbg_write,
+    wow64_wine_server_call,
+    wow64_wine_server_fd_to_handle,
+    wow64_wine_server_handle_to_fd,
+    wow64_wine_spawnvp,
+    system_time_precise,
+};
+
+#endif  /* _WIN64 */
+
+
+static inline char *prepend( char *buffer, const char *str, size_t len )
+{
+    return memcpy( buffer - len, str, len );
+}
+
+static inline char *prepend_build_dir_path( char *ptr, const char *ext, const char *arch_dir,
+                                            const char *top_dir, const char *build_dir )
+{
+    char *name = ptr;
+    unsigned int namelen = strlen(name), extlen = strlen(ext);
+
+    if (namelen > extlen && !strcmp( name + namelen - extlen, ext )) namelen -= extlen;
+    ptr = prepend( ptr, arch_dir, strlen(arch_dir) );
+    ptr = prepend( ptr, name, namelen );
+    ptr = prepend( ptr, top_dir, strlen(top_dir) );
+    ptr = prepend( ptr, build_dir, strlen(build_dir) );
+    return ptr;
+}
+
+
+/***********************************************************************
+ *	open_dll_file
+ *
+ * Open a file for a new dll. Helper for open_builtin_pe_file.
+ */
+static NTSTATUS open_dll_file( const char *name, OBJECT_ATTRIBUTES *attr, HANDLE *mapping )
+{
+    LARGE_INTEGER size;
+    NTSTATUS status;
+    HANDLE handle;
+
+    if ((status = open_unix_file( &handle, name, GENERIC_READ | SYNCHRONIZE, attr, 0,
+                                  FILE_SHARE_READ | FILE_SHARE_DELETE, FILE_OPEN,
+                                  FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE, NULL, 0 )))
+    {
+        if (status != STATUS_OBJECT_PATH_NOT_FOUND && status != STATUS_OBJECT_NAME_NOT_FOUND)
+        {
+            /* if the file exists but failed to open, report the error */
+            struct stat st;
+            if (!stat( name, &st )) return status;
+        }
+        /* otherwise continue searching */
+        return STATUS_DLL_NOT_FOUND;
+    }
+
+    size.QuadPart = 0;
+    status = NtCreateSection( mapping, STANDARD_RIGHTS_REQUIRED | SECTION_QUERY |
+                              SECTION_MAP_READ | SECTION_MAP_EXECUTE,
+                              NULL, &size, PAGE_EXECUTE_READ, SEC_IMAGE, handle );
+    NtClose( handle );
+    return status;
+}
+
+
+/***********************************************************************
+ *           open_builtin_pe_file
+ */
+static NTSTATUS open_builtin_pe_file( const char *name, OBJECT_ATTRIBUTES *attr, void **module,
+                                      SIZE_T *size, SECTION_IMAGE_INFORMATION *image_info,
+                                      ULONG_PTR limit_low, ULONG_PTR limit_high,
+                                      WORD machine, BOOL prefer_native )
+{
+    NTSTATUS status;
+    HANDLE mapping;
+
+    *module = NULL;
+    status = open_dll_file( name, attr, &mapping );
+    if (!status)
+    {
+        status = virtual_map_builtin_module( mapping, module, size, image_info,
+                                             limit_low, limit_high, machine, prefer_native );
+        NtClose( mapping );
+    }
+    return status;
+}
+
+
+/***********************************************************************
+ *           find_builtin_dll
+ */
+static NTSTATUS find_builtin_dll( UNICODE_STRING *nt_name, void **module, SIZE_T *size_ptr,
+                                  SECTION_IMAGE_INFORMATION *image_info, ULONG_PTR limit_low,
+                                  ULONG_PTR limit_high, USHORT search_machine,
+                                  USHORT load_machine, BOOL prefer_native )
+{
+    unsigned int i, pos, namepos, maxlen = 0;
+    unsigned int len = nt_name->Length / sizeof(WCHAR);
+    char *ptr = NULL, *file, *ext = NULL;
+    const char *pe_dir = get_pe_dir( search_machine );
+    const char *so_dir = get_so_dir( current_machine );
+    const char *pe_build_dir = build_dir;
+    OBJECT_ATTRIBUTES attr;
+    NTSTATUS status = STATUS_DLL_NOT_FOUND;
+    BOOL found_image = FALSE;
+
+    for (i = namepos = 0; i < len; i++)
+        if (nt_name->Buffer[i] == '/' || nt_name->Buffer[i] == '\\') namepos = i + 1;
+    len -= namepos;
+    if (!len) return STATUS_DLL_NOT_FOUND;
+    InitializeObjectAttributes( &attr, nt_name, 0, 0, NULL );
+
+    if (build_dir)
+    {
+        if (alt_build_dir && search_machine == get_alt_machine( current_machine ))
+            pe_build_dir = alt_build_dir;
+        maxlen = max( strlen(build_dir), strlen(pe_build_dir) ) + sizeof("/programs/") + len;
+    }
+    maxlen = max( maxlen, dll_path_maxlen + 1 ) + len + sizeof("/aarch64-windows") + sizeof(".so");
+
+    if (!(file = malloc( maxlen ))) return STATUS_NO_MEMORY;
+
+    pos = maxlen - len - sizeof(".so");
+    /* we don't want to depend on the current codepage here */
+    for (i = 0; i < len; i++)
+    {
+        if (nt_name->Buffer[namepos + i] > 127) goto done;
+        file[pos + i] = (char)nt_name->Buffer[namepos + i];
+        if (file[pos + i] >= 'A' && file[pos + i] <= 'Z') file[pos + i] += 'a' - 'A';
+        else if (file[pos + i] == '.') ext = file + pos + i;
+    }
+    file[pos + len] = 0;
+    file[--pos] = '/';
+
+    if (build_dir)
+    {
+        /* try as a dll */
+        ptr = prepend_build_dir_path( file + pos, ".dll", pe_dir, "/dlls", pe_build_dir );
+        status = open_builtin_pe_file( ptr, &attr, module, size_ptr, image_info,
+                                       limit_low, limit_high, load_machine, prefer_native );
+        ptr = prepend_build_dir_path( file + pos, ".dll", "", "/dlls", build_dir );
+        if (status != STATUS_DLL_NOT_FOUND) goto done;
+        status = open_builtin_so_file( ptr, &attr, module, image_info,
+                                       search_machine, load_machine, prefer_native );
+        if (status != STATUS_DLL_NOT_FOUND) goto done;
+
+        /* now as a program */
+        ptr = prepend_build_dir_path( file + pos, ".exe", pe_dir, "/programs", pe_build_dir );
+        status = open_builtin_pe_file( ptr, &attr, module, size_ptr, image_info,
+                                       limit_low, limit_high, load_machine, prefer_native );
+        ptr = prepend_build_dir_path( file + pos, ".exe", "", "/programs", build_dir );
+        if (status != STATUS_DLL_NOT_FOUND) goto done;
+        status = open_builtin_so_file( ptr, &attr, module, image_info,
+                                       search_machine, load_machine, prefer_native );
+        if (status != STATUS_DLL_NOT_FOUND) goto done;
+    }
+
+    for (i = 0; dll_paths[i]; i++)
+    {
+        ptr = file + pos;
+        ptr = prepend( ptr, pe_dir, strlen(pe_dir) );
+        ptr = prepend( ptr, dll_paths[i], strlen(dll_paths[i]) );
+        status = open_builtin_pe_file( ptr, &attr, module, size_ptr, image_info, limit_low, limit_high,
+                                       load_machine, prefer_native );
+        /* use so dir for unix lib */
+        ptr = file + pos;
+        ptr = prepend( ptr, so_dir, strlen(so_dir) );
+        ptr = prepend( ptr, dll_paths[i], strlen(dll_paths[i]) );
+        if (status != STATUS_DLL_NOT_FOUND) goto done;
+        status = open_builtin_so_file( ptr, &attr, module, image_info,
+                                       search_machine, load_machine, prefer_native );
+        if (status != STATUS_DLL_NOT_FOUND) goto done;
+        ptr = prepend( file + pos, dll_paths[i], strlen(dll_paths[i]) );
+        status = open_builtin_pe_file( ptr, &attr, module, size_ptr, image_info, limit_low, limit_high,
+                                       load_machine, prefer_native );
+        if (status == STATUS_NOT_SUPPORTED)
+        {
+            found_image = TRUE;
+            continue;
+        }
+        if (status != STATUS_DLL_NOT_FOUND) goto done;
+        status = open_builtin_so_file( ptr, &attr, module, image_info,
+                                       search_machine, load_machine, prefer_native );
+        if (status == STATUS_NOT_SUPPORTED) found_image = TRUE;
+        else if (status != STATUS_DLL_NOT_FOUND) goto done;
+    }
+
+    if (found_image) status = STATUS_NOT_SUPPORTED;
+    WARN( "cannot find builtin library for %s\n", debugstr_us(nt_name) );
+done:
+    if (NT_SUCCESS(status) && ext)
+    {
+        strcpy( ext, ".so" );
+        load_builtin_unixlib( *module, ptr );
+    }
+    free( file );
+    return status;
+}
+
+
+/***********************************************************************
+ *           load_builtin
+ *
+ * Load the builtin dll if specified by load order configuration.
+ * Return STATUS_IMAGE_ALREADY_LOADED if we should keep the native one that we have found.
+ */
+NTSTATUS load_builtin( const struct pe_image_info *image_info, WCHAR *filename, USHORT machine,
+                       SECTION_IMAGE_INFORMATION *info, void **module, SIZE_T *size,
+                       ULONG_PTR limit_low, ULONG_PTR limit_high )
+{
+    NTSTATUS status;
+    UNICODE_STRING nt_name;
+    USHORT search_machine = image_info->machine;
+    enum loadorder loadorder;
+
+    init_unicode_string( &nt_name, filename );
+    loadorder = get_load_order( &nt_name );
+
+    if (loadorder == LO_DISABLED) return STATUS_DLL_NOT_FOUND;
+
+    if (image_info->wine_builtin)
+    {
+        if (loadorder == LO_NATIVE) return STATUS_DLL_NOT_FOUND;
+        loadorder = LO_BUILTIN_NATIVE;  /* load builtin, then fallback to the file we found */
+    }
+    else if (image_info->wine_fakedll)
+    {
+        TRACE( "%s is a fake Wine dll\n", debugstr_w(filename) );
+        if (loadorder == LO_NATIVE) return STATUS_DLL_NOT_FOUND;
+        loadorder = LO_BUILTIN;  /* builtin with no fallback since mapping a fake dll is not useful */
+    }
+
+    if (is_arm64ec() && image_info->is_hybrid && search_machine == IMAGE_FILE_MACHINE_AMD64)
+        search_machine = current_machine;
+
+    switch (loadorder)
+    {
+    case LO_NATIVE:
+    case LO_NATIVE_BUILTIN:
+        return STATUS_IMAGE_ALREADY_LOADED;
+    case LO_BUILTIN:
+        return find_builtin_dll( &nt_name, module, size, info, limit_low, limit_high,
+                                 search_machine, machine, FALSE );
+    default:
+        status = find_builtin_dll( &nt_name, module, size, info, limit_low, limit_high,
+                                   search_machine, machine, (loadorder == LO_DEFAULT) );
+        if (status == STATUS_DLL_NOT_FOUND || status == STATUS_NOT_SUPPORTED)
+            return STATUS_IMAGE_ALREADY_LOADED;
+        return status;
+    }
+}
+
+
+/***************************************************************************
+ *	get_machine_wow64_dir
+ *
+ * cf. GetSystemWow64Directory2.
+ */
+static const WCHAR *get_machine_wow64_dir( WORD machine )
+{
+    static const WCHAR system32[] = {'\\','?','?','\\','C',':','\\','w','i','n','d','o','w','s','\\','s','y','s','t','e','m','3','2','\\',0};
+    static const WCHAR syswow64[] = {'\\','?','?','\\','C',':','\\','w','i','n','d','o','w','s','\\','s','y','s','w','o','w','6','4','\\',0};
+    static const WCHAR sysarm32[] = {'\\','?','?','\\','C',':','\\','w','i','n','d','o','w','s','\\','s','y','s','a','r','m','3','2','\\',0};
+
+    if (machine == native_machine) machine = IMAGE_FILE_MACHINE_TARGET_HOST;
+
+    switch (machine)
+    {
+    case IMAGE_FILE_MACHINE_TARGET_HOST: return system32;
+    case IMAGE_FILE_MACHINE_I386:        return syswow64;
+    case IMAGE_FILE_MACHINE_ARMNT:       return sysarm32;
+    default: return NULL;
+    }
+}
+
+
+/***************************************************************************
+ *	is_builtin_path
+ *
+ * Check if path is inside a system directory, to support loading builtins
+ * when the corresponding file doesn't exist yet.
+ */
+BOOL is_builtin_path( const UNICODE_STRING *path, WORD *machine )
+{
+    unsigned int i, len = path->Length / sizeof(WCHAR), dirlen;
+    const WCHAR *sysdir, *p = path->Buffer;
+
+    /* only fake builtin existence during prefix bootstrap */
+    if (!is_prefix_bootstrap) return FALSE;
+
+    for (i = 0; i < supported_machines_count; i++)
+    {
+        sysdir = get_machine_wow64_dir( supported_machines[i] );
+        if (!sysdir) continue;
+        dirlen = wcslen( sysdir );
+        if (len <= dirlen) continue;
+        if (wcsnicmp( p, sysdir, dirlen )) continue;
+        /* check for remaining path components */
+        for (p += dirlen, len -= dirlen; len; p++, len--) if (*p == '\\') return FALSE;
+        *machine = supported_machines[i];
+        return TRUE;
+    }
+    return FALSE;
+}
+
+
+/***********************************************************************
+ *           open_main_image
+ */
+static NTSTATUS open_main_image( UNICODE_STRING *nt_name, void **module, SECTION_IMAGE_INFORMATION *info,
+                                 enum loadorder loadorder, USHORT machine )
+{
+    OBJECT_ATTRIBUTES attr;
+    SIZE_T size = 0;
+    char *unix_name;
+    NTSTATUS status;
+    HANDLE mapping;
+    UNICODE_STRING true_nt_name;
+
+    if (loadorder == LO_DISABLED) NtTerminateProcess( GetCurrentProcess(), STATUS_DLL_NOT_FOUND );
+
+    InitializeObjectAttributes( &attr, nt_name, OBJ_CASE_INSENSITIVE, 0, NULL );
+    if (get_nt_and_unix_names( &attr, &true_nt_name, &unix_name, FILE_OPEN )) return STATUS_DLL_NOT_FOUND;
+
+    status = open_dll_file( unix_name, &attr, &mapping );
+    if (!status)
+    {
+        status = virtual_map_module( mapping, module, &size, info, 0, 0, machine );
+        if (status == STATUS_IMAGE_MACHINE_TYPE_MISMATCH && info->ComPlusNativeReady)
+        {
+            info->Machine = native_machine;
+            status = STATUS_SUCCESS;
+        }
+        NtClose( mapping );
+    }
+    else if (status == STATUS_INVALID_IMAGE_NOT_MZ && loadorder != LO_NATIVE)
+    {
+        status = open_main_image_so_file( unix_name, attr.ObjectName, module, info );
+    }
+    free( unix_name );
+    free( true_nt_name.Buffer );
+    return status;
+}
+
+
+/***********************************************************************
+ *           load_main_exe
+ */
+NTSTATUS load_main_exe( UNICODE_STRING *nt_name, USHORT load_machine, void **module )
+{
+    enum loadorder loadorder = get_load_order( nt_name );
+    unsigned int status;
+    SIZE_T size;
+    USHORT search_machine;
+
+    status = open_main_image( nt_name, module, &main_image_info, loadorder, load_machine );
+    if (status != STATUS_DLL_NOT_FOUND) return status;
+
+    /* if path is in system dir, we can load the builtin even if the file itself doesn't exist */
+    if (loadorder != LO_NATIVE && is_builtin_path( nt_name, &search_machine ))
+        status = find_builtin_dll( nt_name, module, &size, &main_image_info, 0, 0,
+                                   search_machine, load_machine, FALSE );
+    return status;
+}
+
+
+/***********************************************************************
+ *           load_start_exe
+ *
+ * Load start.exe as main image.
+ */
+NTSTATUS load_start_exe( UNICODE_STRING *nt_name, void **module )
+{
+    static const WCHAR startW[] = {'s','t','a','r','t','.','e','x','e',0};
+    unsigned int status;
+    SIZE_T size;
+    WCHAR *image = malloc( sizeof("\\??\\C:\\windows\\system32\\start.exe") * sizeof(WCHAR) );
+
+    wcscpy( image, get_machine_wow64_dir( current_machine ));
+    wcscat( image, startW );
+    init_unicode_string( nt_name, image );
+    status = find_builtin_dll( nt_name, module, &size, &main_image_info, 0, 0, current_machine, 0, FALSE );
+    if (!NT_SUCCESS(status))
+    {
+        MESSAGE( "wine: failed to load start.exe: %x\n", status );
+        NtTerminateProcess( GetCurrentProcess(), status );
+    }
+    return status;
+}
+
+static ULONG_PTR find_ordinal_export( HMODULE module, const IMAGE_EXPORT_DIRECTORY *exports, DWORD ordinal )
+{
+    const DWORD *functions = (const DWORD *)((BYTE *)module + exports->AddressOfFunctions);
+
+    if (ordinal >= exports->NumberOfFunctions) return 0;
+    if (!functions[ordinal]) return 0;
+    return (ULONG_PTR)module + functions[ordinal];
+}
+
+static ULONG_PTR find_named_export( HMODULE module, const IMAGE_EXPORT_DIRECTORY *exports,
+                                    const char *name )
+{
+    const WORD *ordinals = (const WORD *)((BYTE *)module + exports->AddressOfNameOrdinals);
+    const DWORD *names = (const DWORD *)((BYTE *)module + exports->AddressOfNames);
+    int min = 0, max = exports->NumberOfNames - 1;
+
+    while (min <= max)
+    {
+        int res, pos = (min + max) / 2;
+        char *ename = (char *)module + names[pos];
+        if (!(res = strcmp( ename, name ))) return find_ordinal_export( module, exports, ordinals[pos] );
+        if (res > 0) max = pos - 1;
+        else min = pos + 1;
+    }
+    return 0;
+}
+
+static inline void *get_rva( void *module, ULONG_PTR addr )
+{
+    return (BYTE *)module + addr;
+}
+
+static const void *get_module_data_dir( HMODULE module, ULONG dir, ULONG *size )
+{
+    const IMAGE_NT_HEADERS *nt = get_rva( module, ((IMAGE_DOS_HEADER *)module)->e_lfanew );
+    const IMAGE_DATA_DIRECTORY *data;
+
+    if (nt->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
+        data = &((const IMAGE_NT_HEADERS64 *)nt)->OptionalHeader.DataDirectory[dir];
+    else if (nt->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
+        data = &((const IMAGE_NT_HEADERS32 *)nt)->OptionalHeader.DataDirectory[dir];
+    else
+        return NULL;
+    if (!data->VirtualAddress || !data->Size) return NULL;
+    if (size) *size = data->Size;
+    return get_rva( module, data->VirtualAddress );
+}
+
+/***********************************************************************
+ *           load_ntdll_functions
+ */
+static void load_ntdll_functions( HMODULE module )
+{
+    void **p__wine_syscall_dispatcher;
+    void **p__wine_unix_call_dispatcher;
+    void **p__wine_unix_call_dispatcher_arm64ec = NULL;
+    unixlib_handle_t *p__wine_unixlib_handle;
+    const IMAGE_EXPORT_DIRECTORY *exports;
+
+    exports = get_module_data_dir( module, IMAGE_DIRECTORY_ENTRY_EXPORT, NULL );
+    assert( exports );
+
+#define GET_FUNC(name) \
+    if (!(p##name = (void *)find_named_export( module, exports, #name ))) \
+        ERR( "%s not found\n", #name )
+
+    GET_FUNC( DbgUiRemoteBreakin );
+    GET_FUNC( KiRaiseUserExceptionDispatcher );
+    GET_FUNC( KiUserExceptionDispatcher );
+    GET_FUNC( KiUserApcDispatcher );
+    GET_FUNC( KiUserCallbackDispatcher );
+    GET_FUNC( LdrInitializeThunk );
+    GET_FUNC( LdrSystemDllInitBlock );
+    GET_FUNC( RtlUserThreadStart );
+    GET_FUNC( __wine_ctrl_routine );
+    GET_FUNC( __wine_syscall_dispatcher );
+    GET_FUNC( __wine_unix_call_dispatcher );
+    GET_FUNC( __wine_unixlib_handle );
+    if (is_arm64ec())
+    {
+        GET_FUNC( __wine_unix_call_dispatcher_arm64ec );
+        GET_FUNC( KiUserEmulationDispatcher );
+    }
+    *p__wine_syscall_dispatcher = __wine_syscall_dispatcher;
+    *p__wine_unixlib_handle = (UINT_PTR)unix_call_funcs;
+    if (p__wine_unix_call_dispatcher_arm64ec)
+    {
+        /* redirect __wine_unix_call_dispatcher to __wine_unix_call_dispatcher_arm64ec */
+        *p__wine_unix_call_dispatcher = *p__wine_unix_call_dispatcher_arm64ec;
+        *p__wine_unix_call_dispatcher_arm64ec = __wine_unix_call_dispatcher;
+    }
+    else *p__wine_unix_call_dispatcher = __wine_unix_call_dispatcher;
+#undef GET_FUNC
+}
+
+
+/***********************************************************************
+ *           load_ntdll_wow64_functions
+ */
+static void load_ntdll_wow64_functions( HMODULE module )
+{
+    const IMAGE_EXPORT_DIRECTORY *exports;
+
+    exports = get_module_data_dir( module, IMAGE_FILE_EXPORT_DIRECTORY, NULL );
+    assert( exports );
+
+    pLdrSystemDllInitBlock->ntdll_handle = (ULONG_PTR)module;
+
+#define GET_FUNC(name) pLdrSystemDllInitBlock->p##name = find_named_export( module, exports, #name )
+    GET_FUNC( KiUserApcDispatcher );
+    GET_FUNC( KiUserCallbackDispatcher );
+    GET_FUNC( KiUserExceptionDispatcher );
+    GET_FUNC( LdrInitializeThunk );
+    GET_FUNC( LdrSystemDllInitBlock );
+    GET_FUNC( RtlUserThreadStart );
+    GET_FUNC( RtlpFreezeTimeBias );
+    GET_FUNC( RtlpQueryProcessDebugInformationRemote );
+#undef GET_FUNC
+
+    p__wine_ctrl_routine = (void *)find_named_export( module, exports, "__wine_ctrl_routine" );
+
+#ifdef _WIN64
+    {
+        unixlib_handle_t *p__wine_unixlib_handle = (void *)find_named_export( module, exports,
+                                                                              "__wine_unixlib_handle" );
+        *p__wine_unixlib_handle = (UINT_PTR)unix_call_wow64_funcs;
+    }
+#endif
+
+    /* also set the 32-bit LdrSystemDllInitBlock */
+    memcpy( (void *)(ULONG_PTR)pLdrSystemDllInitBlock->pLdrSystemDllInitBlock,
+            pLdrSystemDllInitBlock, sizeof(*pLdrSystemDllInitBlock) );
+}
+
+
+/***********************************************************************
+ *           redirect_arm64ec_rva
+ *
+ * Redirect an address through the arm64ec redirection table.
+ */
+ULONG_PTR redirect_arm64ec_rva( void *base, ULONG_PTR rva, const IMAGE_ARM64EC_METADATA *metadata )
+{
+    const IMAGE_ARM64EC_REDIRECTION_ENTRY *map = get_rva( base, metadata->RedirectionMetadata );
+    int min = 0, max = metadata->RedirectionMetadataCount - 1;
+
+    while (min <= max)
+    {
+        int pos = (min + max) / 2;
+        if (map[pos].Source == rva) return map[pos].Destination;
+        if (map[pos].Source < rva) min = pos + 1;
+        else max = pos - 1;
+    }
+    return rva;
+}
+
+
+/***********************************************************************
+ *           redirect_ntdll_functions
+ *
+ * Redirect ntdll functions on arm64ec.
+ */
+static void redirect_ntdll_functions( HMODULE module )
+{
+    const IMAGE_LOAD_CONFIG_DIRECTORY *loadcfg;
+    const IMAGE_ARM64EC_METADATA *metadata;
+
+    if (!(loadcfg = get_module_data_dir( module, IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG, NULL ))) return;
+    if (!(metadata = (void *)loadcfg->CHPEMetadataPointer)) return;
+#define REDIRECT(name) \
+    p##name = get_rva( module, redirect_arm64ec_rva( module, (char *)p##name - (char *)module, metadata ))
+    REDIRECT( DbgUiRemoteBreakin );
+    REDIRECT( KiRaiseUserExceptionDispatcher );
+    REDIRECT( KiUserExceptionDispatcher );
+    REDIRECT( KiUserApcDispatcher );
+    REDIRECT( KiUserCallbackDispatcher );
+    REDIRECT( KiUserEmulationDispatcher );
+    REDIRECT( LdrInitializeThunk );
+    REDIRECT( RtlUserThreadStart );
+#undef REDIRECT
+}
+
+
+/***********************************************************************
+ *           load_ntdll
+ */
+static void load_ntdll(void)
+{
+    static WCHAR path[] = {'\\','?','?','\\','C',':','\\','w','i','n','d','o','w','s','\\',
+                           's','y','s','t','e','m','3','2','\\','n','t','d','l','l','.','d','l','l',0};
+    const char *pe_dir = get_pe_dir( current_machine );
+    USHORT machine = current_machine;
+    unsigned int status;
+    SECTION_IMAGE_INFORMATION info;
+    OBJECT_ATTRIBUTES attr;
+    UNICODE_STRING str;
+    void *module;
+    SIZE_T size = 0;
+    char *name = NULL;
+
+    init_unicode_string( &str, path );
+    InitializeObjectAttributes( &attr, &str, 0, 0, NULL );
+
+    if (build_dir) asprintf( &name, "%s%s/ntdll.dll", ntdll_dir, pe_dir );
+    else asprintf( &name, "%s%s/ntdll.dll", dll_dir, pe_dir );
+
+    if (is_arm64ec()) machine = main_image_info.Machine;
+    status = open_builtin_pe_file( name, &attr, &module, &size, &info, 0, 0, machine, FALSE );
+    if (status == STATUS_DLL_NOT_FOUND)
+    {
+        free( name );
+        asprintf( &name, "%s/ntdll.dll%c.so", ntdll_dir, 0 );
+        status = open_builtin_so_file( name, &attr, &module, &info, machine, 0, FALSE );
+    }
+    if (status == STATUS_IMAGE_NOT_AT_BASE) status = virtual_relocate_module( module );
+    if (status) fatal_error( "failed to load %s error %x\n", name, status );
+    free( name );
+    load_ntdll_functions( module );
+    if (is_arm64ec()) redirect_ntdll_functions( module );
+}
+
+
+/***********************************************************************
+ *           load_apiset_dll
+ */
+static void load_apiset_dll(void)
+{
+    static WCHAR path[] = {'\\','?','?','\\','C',':','\\','w','i','n','d','o','w','s','\\',
+                           's','y','s','t','e','m','3','2','\\',
+                           'a','p','i','s','e','t','s','c','h','e','m','a','.','d','l','l',0};
+    const char *pe_dir = get_pe_dir( current_machine );
+    const IMAGE_NT_HEADERS *nt;
+    const IMAGE_SECTION_HEADER *sec;
+    API_SET_NAMESPACE *map;
+    OBJECT_ATTRIBUTES attr;
+    UNICODE_STRING str;
+    unsigned int status;
+    HANDLE handle, mapping;
+    SIZE_T size;
+    char *name = NULL;
+    void *ptr;
+    UINT i;
+
+    init_unicode_string( &str, path );
+    InitializeObjectAttributes( &attr, &str, 0, 0, NULL );
+
+    if (build_dir) asprintf( &name, "%s/dlls/apisetschema%s/apisetschema.dll", build_dir, pe_dir );
+    else asprintf( &name, "%s%s/apisetschema.dll", dll_dir, pe_dir );
+    status = open_unix_file( &handle, name, GENERIC_READ | SYNCHRONIZE, &attr, 0,
+                             FILE_SHARE_READ | FILE_SHARE_DELETE, FILE_OPEN,
+                             FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE, NULL, 0 );
+    free( name );
+
+    if (!status)
+    {
+        status = NtCreateSection( &mapping, STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ,
+                                  NULL, NULL, PAGE_READONLY, SEC_COMMIT, handle );
+        NtClose( handle );
+    }
+    if (!status)
+    {
+        status = map_section( mapping, &ptr, &size, PAGE_READONLY );
+        NtClose( mapping );
+    }
+    if (!status)
+    {
+        nt = get_rva( ptr, ((IMAGE_DOS_HEADER *)ptr)->e_lfanew );
+        sec = IMAGE_FIRST_SECTION( nt );
+
+        for (i = 0; i < nt->FileHeader.NumberOfSections; i++, sec++)
+        {
+            if (memcmp( (char *)sec->Name, ".apiset", 8 )) continue;
+            map = (API_SET_NAMESPACE *)((char *)ptr + sec->PointerToRawData);
+            if (sec->PointerToRawData < size &&
+                size - sec->PointerToRawData >= sec->Misc.VirtualSize &&
+                map->Version == 6 &&
+                map->Size <= sec->Misc.VirtualSize)
+            {
+                peb->ApiSetMap = map;
+                if (wow_peb) wow_peb->ApiSetMap = PtrToUlong(map);
+                TRACE( "loaded %s apiset at %p\n", debugstr_w(path), map );
+                return;
+            }
+            break;
+        }
+        NtUnmapViewOfSection( NtCurrentProcess(), ptr );
+        status = STATUS_APISET_NOT_PRESENT;
+    }
+    ERR( "failed to load apiset: %x\n", status );
+}
+
+
+/***********************************************************************
+ *           load_wow64_ntdll
+ */
+static void load_wow64_ntdll( USHORT machine )
+{
+    static const WCHAR ntdllW[] = {'n','t','d','l','l','.','d','l','l',0};
+    SECTION_IMAGE_INFORMATION info;
+    UNICODE_STRING nt_name;
+    void *module;
+    unsigned int status;
+    SIZE_T size;
+    const WCHAR *wow64_dir;
+    WCHAR *path;
+
+    if (machine == current_machine) return;
+    if (!(wow64_dir = get_machine_wow64_dir( machine ))) return;
+
+    path = malloc( sizeof("\\??\\C:\\windows\\system32\\ntdll.dll") * sizeof(WCHAR) );
+    wcscpy( path, wow64_dir );
+    wcscat( path, ntdllW );
+    init_unicode_string( &nt_name, path );
+    status = find_builtin_dll( &nt_name, &module, &size, &info, 0, 0, machine, 0, FALSE );
+    if (status == STATUS_IMAGE_NOT_AT_BASE) status = virtual_relocate_module( module );
+    if (status) fatal_error( "failed to load %s error %x\n", debugstr_w(path), status );
+    load_ntdll_wow64_functions( module );
+    TRACE("loaded %s at %p\n", debugstr_w(path), module );
+    free( path );
+}
+
+
+/***********************************************************************
+ *           get_image_address
+ */
+static ULONG_PTR get_image_address(void)
+{
+#ifdef HAVE_GETAUXVAL
+    ULONG_PTR size, num, phdr_addr = getauxval( AT_PHDR );
+    ElfW(Phdr) *phdr;
+
+    if (!phdr_addr) return 0;
+    phdr = (ElfW(Phdr) *)phdr_addr;
+    size = getauxval( AT_PHENT );
+    num = getauxval( AT_PHNUM );
+    while (num--)
+    {
+        if (phdr->p_type == PT_PHDR) return phdr_addr - phdr->p_offset;
+        phdr = (ElfW(Phdr) *)((char *)phdr + size);
+    }
+#elif defined(__APPLE__) && defined(TASK_DYLD_INFO)
+    struct task_dyld_info dyld_info;
+    mach_msg_type_number_t size = TASK_DYLD_INFO_COUNT;
+
+    if (task_info(mach_task_self(), TASK_DYLD_INFO, (task_info_t)&dyld_info, &size) == KERN_SUCCESS)
+        return dyld_info.all_image_info_addr;
+#endif
+    return 0;
+}
+
+/***********************************************************************
+ *           start_main_thread
+ */
+static void start_main_thread(void)
+{
+    TEB *teb = virtual_alloc_first_teb();
+
+    signal_init_threading();
+    dbg_init();
+    startup_info_size = server_init_process();
+    virtual_map_user_shared_data();
+    init_cpu_info();
+    init_files();
+    init_startup_info();
+    *(ULONG_PTR *)&peb->CloudFileFlags = get_image_address();
+    set_load_order_app_name( main_wargv[0] );
+    init_thread_stack( teb, 0, 0, 0 );
+    NtCreateKeyedEvent( &keyed_event, GENERIC_READ | GENERIC_WRITE, NULL, 0 );
+    load_ntdll();
+    load_wow64_ntdll( main_image_info.Machine );
+    load_apiset_dll();
+    server_init_process_done();
+}
+
+#ifdef __ANDROID__
+
+#ifndef WINE_JAVA_CLASS
+#define WINE_JAVA_CLASS "org/winehq/wine/WineActivity"
+#endif
+
+JavaVM *java_vm = NULL;
+jobject java_object = 0;
+unsigned short java_gdt_sel = 0;
+
+/* main Wine initialisation */
+static jstring wine_init_jni( JNIEnv *env, jobject obj, jobjectArray cmdline, jobjectArray environment )
+{
+    char **argv;
+    char *str;
+    char error[1024];
+    int i, argc, length;
+
+    /* get the command line array */
+
+    argc = (*env)->GetArrayLength( env, cmdline );
+    for (i = length = 0; i < argc; i++)
+    {
+        jobject str_obj = (*env)->GetObjectArrayElement( env, cmdline, i );
+        length += (*env)->GetStringUTFLength( env, str_obj ) + 1;
+    }
+
+    argv = malloc( (argc + 1) * sizeof(*argv) + length );
+    str = (char *)(argv + argc + 1);
+    for (i = 0; i < argc; i++)
+    {
+        jobject str_obj = (*env)->GetObjectArrayElement( env, cmdline, i );
+        length = (*env)->GetStringUTFLength( env, str_obj );
+        (*env)->GetStringUTFRegion( env, str_obj, 0,
+                                    (*env)->GetStringLength( env, str_obj ), str );
+        argv[i] = str;
+        str[length] = 0;
+        str += length + 1;
+    }
+    argv[argc] = NULL;
+
+    /* set the environment variables */
+
+    if (environment)
+    {
+        int count = (*env)->GetArrayLength( env, environment );
+        for (i = 0; i < count - 1; i += 2)
+        {
+            jobject var_obj = (*env)->GetObjectArrayElement( env, environment, i );
+            jobject val_obj = (*env)->GetObjectArrayElement( env, environment, i + 1 );
+            const char *var = (*env)->GetStringUTFChars( env, var_obj, NULL );
+
+            if (val_obj)
+            {
+                const char *val = (*env)->GetStringUTFChars( env, val_obj, NULL );
+                setenv( var, val, 1 );
+                if (!strcmp( var, "LD_LIBRARY_PATH" ))
+                {
+                    void (*update_func)( const char * ) = dlsym( RTLD_DEFAULT,
+                                                                 "android_update_LD_LIBRARY_PATH" );
+                    if (update_func) update_func( val );
+                }
+                else if (!strcmp( var, "WINEDEBUGLOG" ))
+                {
+                    int fd = open( val, O_WRONLY | O_CREAT | O_APPEND, 0666 );
+                    if (fd != -1)
+                    {
+                        dup2( fd, 2 );
+                        close( fd );
+                    }
+                }
+                (*env)->ReleaseStringUTFChars( env, val_obj, val );
+            }
+            else unsetenv( var );
+
+            (*env)->ReleaseStringUTFChars( env, var_obj, var );
+        }
+    }
+
+    java_object = (*env)->NewGlobalRef( env, obj );
+
+    main_argc = argc;
+    main_argv = argv;
+
+    init_paths();
+    virtual_init();
+    init_environment();
+
+#ifdef __i386__
+    {
+        unsigned short java_fs;
+        __asm__( "mov %%fs,%0" : "=r" (java_fs) );
+        if (!(java_fs & 4)) java_gdt_sel = java_fs;
+        __asm__( "mov %0,%%fs" :: "r" (0) );
+        start_main_thread();
+        __asm__( "mov %0,%%fs" :: "r" (java_fs) );
+    }
+#else
+    start_main_thread();
+#endif
+    return (*env)->NewStringUTF( env, error );
+}
+
+jint JNI_OnLoad( JavaVM *vm, void *reserved )
+{
+    static const JNINativeMethod method =
+    {
+        "wine_init", "([Ljava/lang/String;[Ljava/lang/String;)Ljava/lang/String;", wine_init_jni
+    };
+
+    JNIEnv *env;
+    jclass class;
+
+    java_vm = vm;
+    if ((*vm)->AttachCurrentThread( vm, &env, NULL ) != JNI_OK) return JNI_ERR;
+    if (!(class = (*env)->FindClass( env, WINE_JAVA_CLASS ))) return JNI_ERR;
+    (*env)->RegisterNatives( env, class, &method, 1 );
+    return JNI_VERSION_1_6;
+}
+
+#endif  /* __ANDROID__ */
+
+#ifdef __APPLE__
+static void *apple_wine_thread( void *arg )
+{
+    start_main_thread();
+    return NULL;
+}
+
+/***********************************************************************
+ *           apple_create_wine_thread
+ *
+ * Spin off a secondary thread to complete Wine initialization, leaving
+ * the original thread for the Mac frameworks.
+ *
+ * Invoked as a CFRunLoopSource perform callback.
+ */
+static void apple_create_wine_thread( void *arg )
+{
+    pthread_t thread;
+    pthread_attr_t attr;
+
+    pthread_attr_init( &attr );
+    pthread_attr_setdetachstate( &attr, PTHREAD_CREATE_JOINABLE );
+    /* Use the same QoS class as the process main thread (user-interactive). */
+    if (&pthread_attr_set_qos_class_np)
+        pthread_attr_set_qos_class_np( &attr, QOS_CLASS_USER_INTERACTIVE, 0 );
+    if (pthread_create( &thread, &attr, apple_wine_thread, NULL )) exit(1);
+    pthread_attr_destroy( &attr );
+}
+
+
+/***********************************************************************
+ *           apple_main_thread
+ *
+ * Park the process's original thread in a Core Foundation run loop for
+ * use by the Mac frameworks, especially receiving and handling
+ * distributed notifications.  Spin off a new thread for the rest of the
+ * Wine initialization.
+ */
+static void apple_main_thread(void)
+{
+    CFRunLoopSourceContext source_context = { 0 };
+    CFRunLoopSourceRef source;
+
+    if (!pthread_main_np()) return;
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+    /* Multi-processing Services can get confused about the main thread if the
+     * first time it's used is on a secondary thread.  Use it here to make sure
+     * that doesn't happen. */
+    MPTaskIsPreemptive(MPCurrentTaskID());
+#pragma clang diagnostic pop
+
+    /* Give ourselves the best chance of having the distributed notification
+     * center scheduled on this thread's run loop.  In theory, it's scheduled
+     * in the first thread to ask for it. */
+    CFNotificationCenterGetDistributedCenter();
+
+    /* We use this run loop source for two purposes.  First, a run loop exits
+     * if it has no more sources scheduled.  So, we need at least one source
+     * to keep the run loop running.  Second, although it's not critical, it's
+     * preferable for the Wine initialization to not proceed until we know
+     * the run loop is running.  So, we signal our source immediately after
+     * adding it and have its callback spin off the Wine thread. */
+    source_context.perform = apple_create_wine_thread;
+    source = CFRunLoopSourceCreate( NULL, 0, &source_context );
+    CFRunLoopAddSource( CFRunLoopGetCurrent(), source, kCFRunLoopCommonModes );
+    CFRunLoopSourceSignal( source );
+    CFRelease( source );
+    CFRunLoopRun(); /* Should never return, except on error. */
+}
+#endif  /* __APPLE__ */
+
+
+#if defined(__linux__) && !defined(__ANDROID__) && (defined(__i386__) || defined(__arm__))
+
+static void check_vmsplit( void *stack )
+{
+    if (stack < (void *)0x80000000)
+    {
+        /* if the stack is below 0x80000000, assume we can safely try a munmap there */
+        if (munmap( (void *)0x80000000, 1 ) == -1 && errno == EINVAL)
+            ERR( "Warning: memory above 0x80000000 doesn't seem to be accessible.\n"
+                 "Wine requires a 3G/1G user/kernel memory split to work properly.\n" );
+    }
+}
+
+static int pre_exec(void)
+{
+    int temp;
+
+    check_vmsplit( &temp );
+    return 1;  /* we have a preloader on x86/arm */
+}
+
+#elif (defined(__FreeBSD__) || defined (__FreeBSD_kernel__) || defined(__DragonFly__))
+
+static int pre_exec(void)
+{
+    struct rlimit rl;
+
+    rl.rlim_cur = 0x02000000;
+    rl.rlim_max = 0x02000000;
+    setrlimit( RLIMIT_DATA, &rl );
+    return 1;
+}
+
+#elif defined(__APPLE__)
+
+static int pre_exec(void)
+{
+    if (build_dir)
+    {
+        char *path = getenv( "DYLD_LIBRARY_PATH" );
+        if (path) asprintf( &path, "%s/dlls/ntdll:%s/dlls/win32u:%s", build_dir, build_dir, path );
+        else asprintf( &path, "%s/dlls/ntdll:%s/dlls/win32u", build_dir, build_dir );
+        setenv( "DYLD_LIBRARY_PATH", path, 1 );
+        return 1;
+    }
+#ifdef HAVE_WINE_PRELOADER
+    return 1;
+#else
+    return 0;
+#endif
+}
+
+#else
+
+static int pre_exec(void)
+{
+#ifdef HAVE_WINE_PRELOADER
+    return 1;  /* we have a preloader */
+#else
+    return 0;  /* no exec needed */
+#endif
+}
+
+#endif
+
+
+static void reexec_loader( int argc, char *argv[], char *extra_arg )
+{
+    static char noexec[] = "WINELOADERNOEXEC=1";
+    WORD machine = current_machine;
+    char **new_argv;
+
+    /* have to exec if we have a preloader, or an argument, or if we are the initial wrapper */
+    if (!pre_exec() && !extra_arg && dlsym( RTLD_DEFAULT, "wine_main_preload_info" )) return;
+
+    if (extra_arg)
+    {
+        new_argv = malloc( (argc + 3) * sizeof(*argv) );
+        memcpy( new_argv + 3, argv + 1, argc * sizeof(*argv) );
+        new_argv[2] = extra_arg;
+    }
+    else
+    {
+        new_argv = malloc( (argc + 2) * sizeof(*argv) );
+        memcpy( new_argv + 2, argv + 1, argc * sizeof(*argv) );
+    }
+
+    /* default to 32-bit loader to support 32-bit prefixes */
+    if (machine == IMAGE_FILE_MACHINE_AMD64) machine = IMAGE_FILE_MACHINE_I386;
+
+    putenv( noexec );
+    loader_exec( new_argv, machine );
+    fatal_error( "could not exec the wine loader\n" );
+}
+
+/***********************************************************************
+ *           check_command_line
+ *
+ * Check if command line is one that needs to be handled specially.
+ */
+static void check_command_line( int argc, char *argv[] )
+{
+    char *basename;
+    static const char usage[] =
+        "Usage: wine PROGRAM [ARGUMENTS...]   Run the specified program\n"
+        "       wine --help                   Display this help and exit\n"
+        "       wine --version                Output version information and exit";
+
+    if ((basename = strrchr( argv[0], '/' ))) basename++;
+    else basename = argv[0];
+
+    if (strcmp( basename, "wine" )) /* check if there's a builtin exe corresponding to the base name */
+    {
+        const char *pe_dir = get_pe_dir( current_machine );
+        char *exe;
+
+        if (build_dir)
+        {
+            asprintf( &exe, "%s/programs/%s%s/%s.exe", build_dir, basename, pe_dir, basename );
+            if (!access( exe, R_OK )) reexec_loader( argc, argv, basename );
+            free( exe );
+        }
+        else
+        {
+            for (int i = 0; dll_paths[i]; i++)
+            {
+                asprintf( &exe, "%s%s/%s.exe", dll_paths[i], pe_dir, basename );
+                if (!access( exe, R_OK )) reexec_loader( argc, argv, basename );
+                free( exe );
+            }
+        }
+    }
+
+    if (argc <= 1)
+    {
+        fprintf( stderr, "%s\n", usage );
+        exit(1);
+    }
+    if (!strcmp( argv[1], "--help" ))
+    {
+        printf( "%s\n", usage );
+        exit(0);
+    }
+    if (!strcmp( argv[1], "--version" ))
+    {
+        printf( "%s\n", wine_build );
+        exit(0);
+    }
+
+    reexec_loader( argc, argv, NULL );
+}
+
+
+/***********************************************************************
+ *           __wine_main
+ *
+ * Main entry point called by the wine loader.
+ */
+DECLSPEC_EXPORT void __wine_main( int argc, char *argv[] )
+{
+    main_argc = argc;
+    main_argv = argv;
+
+    init_paths();
+    if (!getenv( "WINELOADERNOEXEC" ) || argc <= 1) check_command_line( argc, argv );
+
+#ifdef RLIMIT_NOFILE
+    set_max_limit( RLIMIT_NOFILE );
+#endif
+#ifdef RLIMIT_AS
+    set_max_limit( RLIMIT_AS );
+#endif
+#ifdef RLIMIT_NICE
+    set_max_limit( RLIMIT_NICE );
+#endif
+
+    virtual_init();
+    init_environment();
+
+#ifdef __APPLE__
+    apple_main_thread();
+#endif
+    start_main_thread();
+}
diff -ruN --show-c-function dlls/ntdll/unix/server.c dlls/ntdll/unix/server.c
--- dlls/ntdll/unix/server.c	2025-10-10 10:17:47.372819327 -0700
+++ dlls/ntdll/unix/server.c	2025-10-10 10:22:17.146955957 -0700
@@ -79,6 +79,7 @@
 #include "wine/server.h"
 #include "wine/debug.h"
 #include "unix_private.h"
+#include "esync.h"
 #include "ddk/wdm.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(server);
@@ -909,24 +910,15 @@ unsigned int server_queue_process_apc( H
         }
         else
         {
-            sigset_t sigset;
-
             NtWaitForSingleObject( handle, FALSE, NULL );
 
-            server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
-
-            /* remove the handle from the cache, get_apc_result will close it for us */
-            close_inproc_sync( handle );
-
             SERVER_START_REQ( get_apc_result )
             {
                 req->handle = wine_server_obj_handle( handle );
-                if (!(ret = server_call_unlocked( req ))) *result = reply->result;
+                if (!(ret = wine_server_call( req ))) *result = reply->result;
             }
             SERVER_END_REQ;
 
-            server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
-
             if (!ret && result->type == APC_NONE) continue;  /* APC didn't run, try again */
         }
         return ret;
@@ -985,7 +977,7 @@ void wine_server_send_fd( int fd )
  *
  * Receive a file descriptor passed from the server.
  */
-int wine_server_receive_fd( obj_handle_t *handle )
+int receive_fd( obj_handle_t *handle )
 {
     struct iovec vec;
     struct msghdr msghdr;
@@ -1180,7 +1172,7 @@ int server_get_unix_fd( HANDLE handle, u
                 if (type) *type = reply->type;
                 if (options) *options = reply->options;
                 access = reply->access;
-                if ((fd = wine_server_receive_fd( &fd_handle )) != -1)
+                if ((fd = receive_fd( &fd_handle )) != -1)
                 {
                     assert( wine_server_ptr_handle(fd_handle) == handle );
                     *needs_close = (!reply->cacheable ||
@@ -1594,7 +1586,6 @@ size_t server_init_process(void)
 {
     const char *arch = getenv( "WINEARCH" );
     const char *env_socket = getenv( "WINESERVERSOCKET" );
-    struct ntdll_thread_data *data = ntdll_get_thread_data();
     obj_handle_t version;
     unsigned int i;
     int ret, reply_pipe;
@@ -1634,7 +1625,7 @@ size_t server_init_process(void)
     pthread_sigmask( SIG_BLOCK, &server_block_set, NULL );
 
     /* receive the first thread request fd on the main socket */
-    data->request_fd = wine_server_receive_fd( &version );
+    ntdll_get_thread_data()->request_fd = receive_fd( &version );
 
 #ifdef SO_PASSCRED
     /* now that we hopefully received the server_pid, disable SO_PASSCRED */
@@ -1669,24 +1660,16 @@ size_t server_init_process(void)
         req->unix_pid    = getpid();
         req->unix_tid    = get_unix_tid();
         req->reply_fd    = reply_pipe;
-        req->wait_fd     = data->wait_fd[1];
+        req->wait_fd     = ntdll_get_thread_data()->wait_fd[1];
         req->debug_level = (TRACE_ON(server) != 0);
         wine_server_set_reply( req, supported_machines, sizeof(supported_machines) );
-        if (!(ret = wine_server_call( req )))
-        {
-            obj_handle_t handle;
-            pid               = reply->pid;
-            tid               = reply->tid;
-            peb->SessionId    = reply->session_id;
-            info_size         = reply->info_size;
-            server_start_time = reply->server_start;
-            supported_machines_count = wine_server_reply_size( reply ) / sizeof(*supported_machines);
-            if (reply->inproc_device)
-            {
-                inproc_device_fd = wine_server_receive_fd( &handle );
-                assert( handle == reply->inproc_device );
-            }
-        }
+        ret = wine_server_call( req );
+        pid               = reply->pid;
+        tid               = reply->tid;
+        peb->SessionId    = reply->session_id;
+        info_size         = reply->info_size;
+        server_start_time = reply->server_start;
+        supported_machines_count = wine_server_reply_size( reply ) / sizeof(*supported_machines);
     }
     SERVER_END_REQ;
     close( reply_pipe );
@@ -1855,17 +1838,12 @@ NTSTATUS WINAPI NtDuplicateObject( HANDL
         return result.dup_handle.status;
     }
 
-    /* hold fd_cache_mutex to prevent the fd from being added again between the
-     * call to remove_fd_from_cache and close_handle */
     server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
 
     /* always remove the cached fd; if the server request fails we'll just
      * retrieve it again */
     if (options & DUPLICATE_CLOSE_SOURCE)
-    {
         fd = remove_fd_from_cache( source );
-        close_inproc_sync( source );
-    }
 
     SERVER_START_REQ( dup_handle )
     {
@@ -1931,14 +1909,14 @@ NTSTATUS WINAPI NtClose( HANDLE handle )
     if (HandleToLong( handle ) >= ~5 && HandleToLong( handle ) <= ~0)
         return STATUS_SUCCESS;
 
-    /* hold fd_cache_mutex to prevent the fd from being added again between the
-     * call to remove_fd_from_cache and close_handle */
     server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
 
     /* always remove the cached fd; if the server request fails we'll just
      * retrieve it again */
     fd = remove_fd_from_cache( handle );
-    close_inproc_sync( handle );
+
+    if (do_esync())
+        esync_close( handle );
 
     SERVER_START_REQ( close_handle )
     {
diff -ruN --show-c-function dlls/ntdll/unix/sync.c dlls/ntdll/unix/sync.c
--- dlls/ntdll/unix/sync.c	2025-10-10 10:17:48.574775226 -0700
+++ dlls/ntdll/unix/sync.c	2025-10-10 10:22:17.172226112 -0700
@@ -30,11 +30,9 @@
 #include <assert.h>
 #include <errno.h>
 #include <fcntl.h>
-#include <inttypes.h>
 #include <limits.h>
 #include <signal.h>
 #include <sys/types.h>
-#include <sys/ioctl.h>
 #include <sys/mman.h>
 #ifdef HAVE_SYS_SYSCALL_H
 #include <sys/syscall.h>
@@ -50,7 +48,6 @@
 #endif
 #include <string.h>
 #include <stdarg.h>
-#include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <time.h>
@@ -60,9 +57,6 @@
 #ifdef HAVE_KQUEUE
 # include <sys/event.h>
 #endif
-#ifdef HAVE_LINUX_NTSYNC_H
-# include <linux/ntsync.h>
-#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -72,20 +66,18 @@
 #include "wine/server.h"
 #include "wine/debug.h"
 #include "unix_private.h"
+#include "esync.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(sync);
 
 HANDLE keyed_event = 0;
-int inproc_device_fd = -1;
 
 static const char *debugstr_timeout( const LARGE_INTEGER *timeout )
 {
     if (!timeout) return "(infinite)";
-    return wine_dbg_sprintf( "%lld.%07ld", (long long)(timeout->QuadPart / TICKSPERSEC),
-                             (long)(timeout->QuadPart % TICKSPERSEC) );
+    return wine_dbgstr_longlong( timeout->QuadPart );
 }
 
-
 /* return a monotonic time counter, in Win32 ticks */
 static inline ULONGLONG monotonic_counter(void)
 {
@@ -309,644 +301,6 @@ static unsigned int validate_open_object
     return STATUS_SUCCESS;
 }
 
-#ifdef NTSYNC_IOC_EVENT_READ
-
-static NTSTATUS linux_release_semaphore_obj( int obj, ULONG count, ULONG *prev_count )
-{
-    if (ioctl( obj, NTSYNC_IOC_SEM_RELEASE, &count ) < 0)
-    {
-        if (errno == EOVERFLOW) return STATUS_SEMAPHORE_LIMIT_EXCEEDED;
-        return errno_to_status( errno );
-    }
-    if (prev_count) *prev_count = count;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS linux_query_semaphore_obj( int obj, SEMAPHORE_BASIC_INFORMATION *info )
-{
-    struct ntsync_sem_args args = {0};
-    if (ioctl( obj, NTSYNC_IOC_SEM_READ, &args ) < 0) return errno_to_status( errno );
-    info->CurrentCount = args.count;
-    info->MaximumCount = args.max;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS linux_set_event_obj( int obj, LONG *prev_state )
-{
-    __u32 prev;
-    if (ioctl( obj, NTSYNC_IOC_EVENT_SET, &prev ) < 0) return errno_to_status( errno );
-    if (prev_state) *prev_state = prev;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS linux_reset_event_obj( int obj, LONG *prev_state )
-{
-    __u32 prev;
-    if (ioctl( obj, NTSYNC_IOC_EVENT_RESET, &prev ) < 0) return errno_to_status( errno );
-    if (prev_state) *prev_state = prev;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS linux_pulse_event_obj( int obj, LONG *prev_state )
-{
-    __u32 prev;
-    if (ioctl( obj, NTSYNC_IOC_EVENT_PULSE, &prev ) < 0) return errno_to_status( errno );
-    if (prev_state) *prev_state = prev;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS linux_query_event_obj( int obj, enum inproc_sync_type type, EVENT_BASIC_INFORMATION *info )
-{
-    struct ntsync_event_args args = {0};
-    if (ioctl( obj, NTSYNC_IOC_EVENT_READ, &args ) < 0) return errno_to_status( errno );
-    info->EventType = args.manual ? NotificationEvent : SynchronizationEvent;
-    info->EventState = args.signaled;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS linux_release_mutex_obj( int obj, LONG *prev_count )
-{
-    struct ntsync_mutex_args args = {.owner = GetCurrentThreadId()};
-    if (ioctl( obj, NTSYNC_IOC_MUTEX_UNLOCK, &args ) < 0)
-    {
-        if (errno == EOVERFLOW) return STATUS_MUTANT_LIMIT_EXCEEDED;
-        if (errno == EPERM) return STATUS_MUTANT_NOT_OWNED;
-        return errno_to_status( errno );
-    }
-    if (prev_count) *prev_count = 1 - args.count;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS linux_query_mutex_obj( int obj, MUTANT_BASIC_INFORMATION *info )
-{
-    struct ntsync_mutex_args args = {0};
-    if (ioctl( obj, NTSYNC_IOC_MUTEX_READ, &args ) < 0)
-    {
-        if (errno == EOWNERDEAD)
-        {
-            info->AbandonedState = TRUE;
-            info->OwnedByCaller = FALSE;
-            info->CurrentCount = 1;
-            return STATUS_SUCCESS;
-        }
-        return errno_to_status( errno );
-    }
-    info->AbandonedState = FALSE;
-    info->OwnedByCaller = (args.owner == GetCurrentThreadId());
-    info->CurrentCount = 1 - args.count;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS linux_wait_objs( int device, const DWORD count, const int *objs,
-                                 BOOLEAN wait_any, int alert_fd, const LARGE_INTEGER *timeout )
-{
-    struct ntsync_wait_args args = {0};
-    unsigned long request;
-    struct timespec now;
-    int ret;
-
-    if (!timeout || timeout->QuadPart == TIMEOUT_INFINITE)
-    {
-        args.timeout = ~(__u64)0;
-    }
-    else if (timeout->QuadPart <= 0)
-    {
-        clock_gettime( CLOCK_MONOTONIC, &now );
-        args.timeout = (now.tv_sec * NSECPERSEC) + now.tv_nsec + (-timeout->QuadPart * 100);
-    }
-    else
-    {
-        args.timeout = (timeout->QuadPart * 100) - (SECS_1601_TO_1970 * NSECPERSEC);
-        args.flags |= NTSYNC_WAIT_REALTIME;
-    }
-
-    args.objs = (uintptr_t)objs;
-    args.count = count;
-    args.owner = GetCurrentThreadId();
-    args.index = ~0u;
-    args.alert = alert_fd;
-
-    if (wait_any || count == 1) request = NTSYNC_IOC_WAIT_ANY;
-    else request = NTSYNC_IOC_WAIT_ALL;
-
-    do { ret = ioctl( device, request, &args ); }
-    while (ret < 0 && errno == EINTR);
-
-    if (!ret)
-    {
-        if (args.index == count)
-        {
-            static const LARGE_INTEGER timeout;
-
-            ret = server_wait( NULL, 0, SELECT_INTERRUPTIBLE | SELECT_ALERTABLE, &timeout );
-            assert( ret == STATUS_USER_APC );
-            return ret;
-        }
-
-        return wait_any ? args.index : 0;
-    }
-    if (errno == EOWNERDEAD) return STATUS_ABANDONED + (wait_any ? args.index : 0);
-    if (errno == ETIMEDOUT) return STATUS_TIMEOUT;
-    return errno_to_status( errno );
-}
-
-#else /* NTSYNC_IOC_EVENT_READ */
-
-static NTSTATUS linux_release_semaphore_obj( int obj, ULONG count, ULONG *prev_count )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-static NTSTATUS linux_query_semaphore_obj( int obj, SEMAPHORE_BASIC_INFORMATION *info )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-static NTSTATUS linux_set_event_obj( int obj, LONG *prev_state )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-static NTSTATUS linux_reset_event_obj( int obj, LONG *prev_state )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-static NTSTATUS linux_pulse_event_obj( int obj, LONG *prev_state )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-static NTSTATUS linux_query_event_obj( int obj, enum inproc_sync_type type, EVENT_BASIC_INFORMATION *info )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-static NTSTATUS linux_release_mutex_obj( int obj, LONG *prev_count )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-static NTSTATUS linux_query_mutex_obj( int obj, MUTANT_BASIC_INFORMATION *info )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-static NTSTATUS linux_wait_objs( int device, const DWORD count, const int *objs,
-                                 BOOLEAN wait_any, int alert_fd, const LARGE_INTEGER *timeout )
-{
-    return STATUS_NOT_IMPLEMENTED;
-}
-
-#endif /* NTSYNC_IOC_EVENT_READ */
-
-/* It's possible for synchronization primitives to remain alive even after being
- * closed, because a thread is still waiting on them. It's rare in practice, and
- * documented as being undefined behaviour by Microsoft, but it works, and some
- * applications rely on it. This means we need to refcount handles, and defer
- * deleting them on the server side until the refcount reaches zero. We do this
- * by having each client process hold a handle to the in-process synchronization
- * object, as well as a private refcount. When the client refcount reaches zero,
- * it closes the handle; when all handles are closed, the server deletes the
- * in-process synchronization object.
- *
- * We also need this for signal-and-wait. The signal and wait operations aren't
- * atomic, but we can't perform the signal and then return STATUS_INVALID_HANDLE
- * for the wait—we need to either do both operations or neither. That means we
- * need to grab references to both objects, and prevent them from being
- * destroyed before we're done with them.
- *
- * We want lookup of objects from the cache to be very fast; ideally, it should
- * be lock-free. We achieve this by using atomic modifications to "refcount",
- * and guaranteeing that all other fields are valid and correct *as long as*
- * refcount is nonzero, and we store the entire structure in memory which will
- * never be freed.
- *
- * This means that acquiring the object can't use a simple atomic increment; it
- * has to use a compare-and-swap loop to ensure that it doesn't try to increment
- * an object with a zero refcount. That's still leagues better than a real lock,
- * though, and release can be a single atomic decrement.
- *
- * It also means that threads modifying the cache need to take a lock, to
- * prevent other threads from writing to it concurrently.
- *
- * It's possible for an object currently in use (by a waiter) to be closed and
- * the same handle immediately reallocated to a different object. This should be
- * a very rare situation, and in that case we simply don't cache the handle.
- */
-struct inproc_sync
-{
-    LONG           refcount;  /* reference count of the sync object */
-    int            fd;        /* unix file descriptor */
-    unsigned int   access;    /* handle access rights */
-    unsigned short type;      /* enum inproc_sync_type as short to save space */
-    unsigned short closed;    /* fd has been closed but sync is still referenced */
-};
-
-#define INPROC_SYNC_CACHE_BLOCK_SIZE  (65536 / sizeof(struct inproc_sync))
-#define INPROC_SYNC_CACHE_ENTRIES     128
-
-static struct inproc_sync *inproc_sync_cache[INPROC_SYNC_CACHE_ENTRIES];
-static struct inproc_sync inproc_sync_cache_initial_block[INPROC_SYNC_CACHE_BLOCK_SIZE];
-
-static inline unsigned int inproc_sync_handle_to_index( HANDLE handle, unsigned int *entry )
-{
-    unsigned int idx = (wine_server_obj_handle(handle) >> 2) - 1;
-    *entry = idx / INPROC_SYNC_CACHE_BLOCK_SIZE;
-    return idx % INPROC_SYNC_CACHE_BLOCK_SIZE;
-}
-
-static struct inproc_sync *cache_inproc_sync( HANDLE handle, struct inproc_sync *sync )
-{
-    unsigned int entry, idx = inproc_sync_handle_to_index( handle, &entry );
-    struct inproc_sync *cache;
-    int refcount;
-
-    /* don't cache pseudo-handles; waiting on them is pointless anyway */
-    if ((ULONG)(ULONG_PTR)handle > 0xfffffffa) return sync;
-
-    if (entry >= INPROC_SYNC_CACHE_ENTRIES)
-    {
-        FIXME( "too many allocated handles, not caching %p\n", handle );
-        return sync;
-    }
-
-    if (!inproc_sync_cache[entry])  /* do we need to allocate a new block of entries? */
-    {
-        if (!entry) inproc_sync_cache[0] = inproc_sync_cache_initial_block;
-        else
-        {
-            static const size_t size = INPROC_SYNC_CACHE_BLOCK_SIZE * sizeof(struct inproc_sync);
-            void *ptr = anon_mmap_alloc( size, PROT_READ | PROT_WRITE );
-            if (ptr == MAP_FAILED) return sync;
-            if (InterlockedCompareExchangePointer( (void **)&inproc_sync_cache[entry], ptr, NULL ))
-                munmap( ptr, size ); /* someone beat us to it */
-        }
-    }
-
-    cache = &inproc_sync_cache[entry][idx];
-
-    if (InterlockedCompareExchange( &cache->refcount, 0, 0 ))
-    {
-        /* The handle is currently being used for another object (i.e. it was
-         * closed and then reused, but some thread is waiting on the old handle
-         * or otherwise simultaneously using the old object). We can't cache
-         * this object until the old one is completely destroyed. */
-        return sync;
-    }
-
-    cache->fd = sync->fd;
-    cache->access = sync->access;
-    cache->type = sync->type;
-    cache->closed = sync->closed;
-    /* Make sure we set the other members before the refcount; this store needs
-     * release semantics [paired with the load in get_cached_inproc_sync()].
-     * Set the refcount to 2 (one for the handle, one for the caller). */
-    refcount = InterlockedExchange( &cache->refcount, 2 );
-    assert( !refcount );
-
-    assert( sync->refcount == 1 );
-    memset( sync, 0, sizeof(*sync) );
-
-    return cache;
-}
-
-/* returns the previous value */
-static inline LONG interlocked_inc_if_nonzero( LONG *dest )
-{
-    LONG val, tmp;
-    for (val = *dest;; val = tmp)
-    {
-        if (!val || (tmp = InterlockedCompareExchange( dest, val + 1, val )) == val)
-            break;
-    }
-    return val;
-}
-
-static void release_inproc_sync( struct inproc_sync *sync )
-{
-    /* save the fd now; as soon as the refcount hits 0 we cannot
-     * access the cache anymore */
-    int fd = sync->fd;
-    LONG ref = InterlockedDecrement( &sync->refcount );
-
-    assert( ref >= 0 );
-    if (!ref) close( fd );
-}
-
-static struct inproc_sync *get_cached_inproc_sync( HANDLE handle )
-{
-    unsigned int entry, idx = inproc_sync_handle_to_index( handle, &entry );
-    struct inproc_sync *cache;
-
-    if (entry >= INPROC_SYNC_CACHE_ENTRIES || !inproc_sync_cache[entry]) return NULL;
-
-    cache = &inproc_sync_cache[entry][idx];
-
-    /* this load needs acquire semantics [paired with the store in
-     * cache_inproc_sync()] */
-    if (!interlocked_inc_if_nonzero( &cache->refcount )) return NULL;
-
-    if (cache->closed)
-    {
-        /* The object is still being used, but "handle" has been closed. The
-         * handle value might have been reused for another object in the
-         * meantime, in which case we have to report that valid object, so
-         * force the caller to check the server. */
-        release_inproc_sync( cache );
-        return NULL;
-    }
-
-    return cache;
-}
-
-/* fd_cache_mutex must be held to avoid races with other thread receiving fds */
-static NTSTATUS get_server_inproc_sync( HANDLE handle, struct inproc_sync *sync )
-{
-    NTSTATUS ret;
-
-    SERVER_START_REQ( get_inproc_sync_fd )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        if (!(ret = wine_server_call( req )))
-        {
-            obj_handle_t fd_handle;
-            sync->refcount = 1;
-            sync->fd = wine_server_receive_fd( &fd_handle );
-            assert( wine_server_ptr_handle(fd_handle) == handle );
-            sync->access = reply->access;
-            sync->type = reply->type;
-            sync->closed = 0;
-        }
-    }
-    SERVER_END_REQ;
-
-    return ret;
-}
-
-/* returns a pointer to a cache entry; if the object could not be cached,
- * returns "cache" instead, which should be allocated on stack */
-static NTSTATUS get_inproc_sync( HANDLE handle, enum inproc_sync_type desired_type, ACCESS_MASK desired_access,
-                                 struct inproc_sync *stack, struct inproc_sync **out )
-{
-    struct inproc_sync *sync;
-    sigset_t sigset;
-    NTSTATUS ret;
-
-    /* try to find it in the cache already */
-    if ((sync = get_cached_inproc_sync( handle ))) ret = STATUS_SUCCESS;
-    else
-    {
-        /* We need to use fd_cache_mutex here to protect against races with
-         * other threads trying to receive fds for the fd cache,
-         * and we need to use an uninterrupted section to prevent reentrancy.
-         * We also need fd_cache_mutex to protect against the same race with
-         * NtClose, that is, to prevent the object from being cached again between
-         * close_inproc_sync() and close_handle. */
-        server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
-        if ((sync = get_cached_inproc_sync( handle ))) ret = STATUS_SUCCESS;
-        else ret = get_server_inproc_sync( handle, stack );
-        server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
-        if (ret) return ret;
-
-        if (!sync) sync = cache_inproc_sync( handle, stack );
-    }
-
-    if (desired_type != INPROC_SYNC_UNKNOWN && desired_type != sync->type)
-    {
-        release_inproc_sync( sync );
-        return STATUS_OBJECT_TYPE_MISMATCH;
-    }
-    if ((sync->access & desired_access) != desired_access)
-    {
-        release_inproc_sync( sync );
-        return STATUS_ACCESS_DENIED;
-    }
-
-    *out = sync;
-    return STATUS_SUCCESS;
-}
-
-extern NTSTATUS check_signal_access( struct inproc_sync *sync )
-{
-    switch (sync->type)
-    {
-    case INPROC_SYNC_INTERNAL:
-        return STATUS_OBJECT_TYPE_MISMATCH;
-    case INPROC_SYNC_EVENT:
-        if (!(sync->access & EVENT_MODIFY_STATE)) return STATUS_ACCESS_DENIED;
-        return STATUS_SUCCESS;
-    case INPROC_SYNC_MUTEX:
-        if (!(sync->access & SYNCHRONIZE)) return STATUS_ACCESS_DENIED;
-        return STATUS_SUCCESS;
-    case INPROC_SYNC_SEMAPHORE:
-        if (!(sync->access & SEMAPHORE_MODIFY_STATE)) return STATUS_ACCESS_DENIED;
-        return STATUS_SUCCESS;
-    }
-
-    assert( 0 );
-    return STATUS_OBJECT_TYPE_MISMATCH;
-}
-
-/* caller must hold fd_cache_mutex */
-void close_inproc_sync( HANDLE handle )
-{
-    struct inproc_sync *cache;
-
-    if (inproc_device_fd < 0) return;
-    if ((cache = get_cached_inproc_sync( handle )))
-    {
-        cache->closed = 1;
-        /* once for the reference we just grabbed, and once for the handle */
-        release_inproc_sync( cache );
-        release_inproc_sync( cache );
-    }
-}
-
-static NTSTATUS inproc_release_semaphore( HANDLE handle, ULONG count, ULONG *prev_count )
-{
-    struct inproc_sync stack, *sync;
-    NTSTATUS ret;
-
-    if (inproc_device_fd < 0) return STATUS_NOT_IMPLEMENTED;
-    if ((ret = get_inproc_sync( handle, INPROC_SYNC_SEMAPHORE, SEMAPHORE_MODIFY_STATE, &stack, &sync ))) return ret;
-    ret = linux_release_semaphore_obj( sync->fd, count, prev_count );
-    release_inproc_sync( sync );
-    return ret;
-}
-
-static NTSTATUS inproc_query_semaphore( HANDLE handle, SEMAPHORE_BASIC_INFORMATION *info )
-{
-    struct inproc_sync stack, *sync;
-    NTSTATUS ret;
-
-    if (inproc_device_fd < 0) return STATUS_NOT_IMPLEMENTED;
-    if ((ret = get_inproc_sync( handle, INPROC_SYNC_SEMAPHORE, SEMAPHORE_QUERY_STATE, &stack, &sync ))) return ret;
-    ret = linux_query_semaphore_obj( sync->fd, info );
-    release_inproc_sync( sync );
-    return ret;
-}
-
-static NTSTATUS inproc_set_event( HANDLE handle, LONG *prev_state )
-{
-    struct inproc_sync stack, *sync;
-    NTSTATUS ret;
-
-    if (inproc_device_fd < 0) return STATUS_NOT_IMPLEMENTED;
-    if ((ret = get_inproc_sync( handle, INPROC_SYNC_EVENT, EVENT_MODIFY_STATE, &stack, &sync ))) return ret;
-    ret = linux_set_event_obj( sync->fd, prev_state );
-    release_inproc_sync( sync );
-    return ret;
-}
-
-static NTSTATUS inproc_reset_event( HANDLE handle, LONG *prev_state )
-{
-    struct inproc_sync stack, *sync;
-    NTSTATUS ret;
-
-    if (inproc_device_fd < 0) return STATUS_NOT_IMPLEMENTED;
-    if ((ret = get_inproc_sync( handle, INPROC_SYNC_EVENT, EVENT_MODIFY_STATE, &stack, &sync ))) return ret;
-    ret = linux_reset_event_obj( sync->fd, prev_state );
-    release_inproc_sync( sync );
-    return ret;
-}
-
-static NTSTATUS inproc_pulse_event( HANDLE handle, LONG *prev_state )
-{
-    struct inproc_sync stack, *sync;
-    NTSTATUS ret;
-
-    if (inproc_device_fd < 0) return STATUS_NOT_IMPLEMENTED;
-    if ((ret = get_inproc_sync( handle, INPROC_SYNC_EVENT, EVENT_MODIFY_STATE, &stack, &sync ))) return ret;
-    ret = linux_pulse_event_obj( sync->fd, prev_state );
-    release_inproc_sync( sync );
-    return ret;
-}
-
-static NTSTATUS inproc_query_event( HANDLE handle, EVENT_BASIC_INFORMATION *info )
-{
-    struct inproc_sync stack, *sync;
-    NTSTATUS ret;
-
-    if (inproc_device_fd < 0) return STATUS_NOT_IMPLEMENTED;
-    if ((ret = get_inproc_sync( handle, INPROC_SYNC_EVENT, EVENT_QUERY_STATE, &stack, &sync ))) return ret;
-    ret = linux_query_event_obj( sync->fd, sync->type, info );
-    release_inproc_sync( sync );
-    return ret;
-}
-
-static NTSTATUS inproc_release_mutex( HANDLE handle, LONG *prev_count )
-{
-    struct inproc_sync stack, *sync;
-    NTSTATUS ret;
-
-    if (inproc_device_fd < 0) return STATUS_NOT_IMPLEMENTED;
-    if ((ret = get_inproc_sync( handle, INPROC_SYNC_MUTEX, 0, &stack, &sync ))) return ret;
-    ret = linux_release_mutex_obj( sync->fd, prev_count );
-    release_inproc_sync( sync );
-    return ret;
-}
-
-static NTSTATUS inproc_query_mutex( HANDLE handle, MUTANT_BASIC_INFORMATION *info )
-{
-    struct inproc_sync stack, *sync;
-    NTSTATUS ret;
-
-    if (inproc_device_fd < 0) return STATUS_NOT_IMPLEMENTED;
-    if ((ret = get_inproc_sync( handle, INPROC_SYNC_MUTEX, MUTANT_QUERY_STATE, &stack, &sync ))) return ret;
-    ret = linux_query_mutex_obj( sync->fd, info );
-    release_inproc_sync( sync );
-    return ret;
-}
-
-static int get_inproc_alert_fd(void)
-{
-    struct ntdll_thread_data *data = ntdll_get_thread_data();
-    obj_handle_t token;
-    sigset_t sigset;
-    int fd;
-
-    if ((fd = data->alert_fd) < 0)
-    {
-        server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
-
-        SERVER_START_REQ( get_inproc_alert_fd )
-        {
-            if (!server_call_unlocked( req ))
-            {
-                data->alert_fd = fd = wine_server_receive_fd( &token );
-                assert( token == reply->handle );
-            }
-        }
-        SERVER_END_REQ;
-
-        server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
-    }
-
-    return fd;
-}
-
-static NTSTATUS inproc_wait( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
-                             BOOLEAN alertable, const LARGE_INTEGER *timeout )
-{
-    struct inproc_sync *syncs[64], stack[ARRAY_SIZE(syncs)];
-    int objs[ARRAY_SIZE(syncs)], alert_fd = 0;
-    NTSTATUS ret;
-
-    if (inproc_device_fd < 0) return STATUS_NOT_IMPLEMENTED;
-
-    assert( count <= ARRAY_SIZE(syncs) );
-    for (int i = 0; i < count; ++i)
-    {
-        if ((ret = get_inproc_sync( handles[i], INPROC_SYNC_UNKNOWN, SYNCHRONIZE, &stack[i], &syncs[i] )))
-        {
-            while (i--) release_inproc_sync( syncs[i] );
-            return ret;
-        }
-        objs[i] = syncs[i]->fd;
-    }
-
-    if (alertable) alert_fd = get_inproc_alert_fd();
-    ret = linux_wait_objs( inproc_device_fd, count, objs, wait_any, alert_fd, timeout );
-
-    while (count--) release_inproc_sync( syncs[count] );
-    return ret;
-}
-
-static NTSTATUS inproc_signal_and_wait( HANDLE signal, HANDLE wait,
-                                        BOOLEAN alertable, const LARGE_INTEGER *timeout )
-{
-    struct inproc_sync stack_signal, stack_wait, *signal_sync = &stack_signal, *wait_sync = &stack_wait;
-    int alert_fd = 0;
-    NTSTATUS ret;
-
-    if (inproc_device_fd < 0) return STATUS_NOT_IMPLEMENTED;
-
-    if ((ret = get_inproc_sync( signal, INPROC_SYNC_UNKNOWN, 0, &stack_signal, &signal_sync ))) return ret;
-    if ((ret = check_signal_access( signal_sync ))) goto done;
-
-    if ((ret = get_inproc_sync( wait, INPROC_SYNC_UNKNOWN, SYNCHRONIZE, &stack_wait, &wait_sync ))) goto done;
-
-    switch (signal_sync->type)
-    {
-    case INPROC_SYNC_EVENT:     ret = linux_set_event_obj( signal_sync->fd, NULL ); break;
-    case INPROC_SYNC_MUTEX:     ret = linux_release_mutex_obj( signal_sync->fd, NULL ); break;
-    case INPROC_SYNC_SEMAPHORE: ret = linux_release_semaphore_obj( signal_sync->fd, 1, NULL ); break;
-    default: assert( 0 ); break;
-    }
-
-    if (!ret)
-    {
-        if (alertable) alert_fd = get_inproc_alert_fd();
-        ret = linux_wait_objs( inproc_device_fd, 1, &wait_sync->fd, TRUE, alert_fd, timeout );
-    }
-
-    release_inproc_sync( wait_sync );
-done:
-    release_inproc_sync( signal_sync );
-    return ret;
-}
-
 
 /******************************************************************************
  *              NtCreateSemaphore (NTDLL.@)
@@ -958,13 +312,13 @@ NTSTATUS WINAPI NtCreateSemaphore( HANDL
     data_size_t len;
     struct object_attributes *objattr;
 
-    TRACE( "access %#x, name %s, initial %d, max %d\n", access,
-           attr ? debugstr_us(attr->ObjectName) : "(null)", initial, max );
-
     *handle = 0;
     if (max <= 0 || initial < 0 || initial > max) return STATUS_INVALID_PARAMETER;
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
+    if (do_esync())
+        return esync_create_semaphore( handle, access, attr, initial, max );
+
     SERVER_START_REQ( create_semaphore )
     {
         req->access  = access;
@@ -988,9 +342,11 @@ NTSTATUS WINAPI NtOpenSemaphore( HANDLE
 {
     unsigned int ret;
 
-    TRACE( "access %#x, name %s\n", access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
-
     *handle = 0;
+
+    if (do_esync())
+        return esync_open_semaphore( handle, access, attr );
+
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
     SERVER_START_REQ( open_semaphore )
@@ -1027,11 +383,8 @@ NTSTATUS WINAPI NtQuerySemaphore( HANDLE
 
     if (len != sizeof(SEMAPHORE_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
 
-    if ((ret = inproc_query_semaphore( handle, out )) != STATUS_NOT_IMPLEMENTED)
-    {
-        if (!ret && ret_len) *ret_len = sizeof(SEMAPHORE_BASIC_INFORMATION);
-        return ret;
-    }
+    if (do_esync())
+        return esync_query_semaphore( handle, info, ret_len );
 
     SERVER_START_REQ( query_semaphore )
     {
@@ -1055,10 +408,8 @@ NTSTATUS WINAPI NtReleaseSemaphore( HAND
 {
     unsigned int ret;
 
-    TRACE( "handle %p, count %u, prev_count %p\n", handle, count, previous );
-
-    if ((ret = inproc_release_semaphore( handle, count, previous )) != STATUS_NOT_IMPLEMENTED)
-        return ret;
+    if (do_esync())
+        return esync_release_semaphore( handle, count, previous );
 
     SERVER_START_REQ( release_semaphore )
     {
@@ -1084,11 +435,12 @@ NTSTATUS WINAPI NtCreateEvent( HANDLE *h
     data_size_t len;
     struct object_attributes *objattr;
 
-    TRACE( "access %#x, name %s, type %u, state %u\n", access,
-           attr ? debugstr_us(attr->ObjectName) : "(null)", type, state );
-
     *handle = 0;
     if (type != NotificationEvent && type != SynchronizationEvent) return STATUS_INVALID_PARAMETER;
+
+    if (do_esync())
+        return esync_create_event( handle, access, attr, type, state );
+
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
     SERVER_START_REQ( create_event )
@@ -1114,11 +466,12 @@ NTSTATUS WINAPI NtOpenEvent( HANDLE *han
 {
     unsigned int ret;
 
-    TRACE( "access %#x, name %s\n", access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
-
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
+    if (do_esync())
+        return esync_open_event( handle, access, attr );
+
     SERVER_START_REQ( open_event )
     {
         req->access     = access;
@@ -1139,12 +492,11 @@ NTSTATUS WINAPI NtOpenEvent( HANDLE *han
  */
 NTSTATUS WINAPI NtSetEvent( HANDLE handle, LONG *prev_state )
 {
+    /* This comment is a dummy to make sure this patch applies in the right place. */
     unsigned int ret;
 
-    TRACE( "handle %p, prev_state %p\n", handle, prev_state );
-
-    if ((ret = inproc_set_event( handle, prev_state )) != STATUS_NOT_IMPLEMENTED)
-        return ret;
+    if (do_esync())
+        return esync_set_event( handle );
 
     SERVER_START_REQ( event_op )
     {
@@ -1172,12 +524,12 @@ NTSTATUS WINAPI NtSetEventBoostPriority(
  */
 NTSTATUS WINAPI NtResetEvent( HANDLE handle, LONG *prev_state )
 {
+    /* This comment is a dummy to make sure this patch applies in the right place. */
     unsigned int ret;
 
-    TRACE( "handle %p, prev_state %p\n", handle, prev_state );
+    if (do_esync())
+        return esync_reset_event( handle );
 
-    if ((ret = inproc_reset_event( handle, prev_state )) != STATUS_NOT_IMPLEMENTED)
-        return ret;
 
     SERVER_START_REQ( event_op )
     {
@@ -1208,10 +560,8 @@ NTSTATUS WINAPI NtPulseEvent( HANDLE han
 {
     unsigned int ret;
 
-    TRACE( "handle %p, prev_state %p\n", handle, prev_state );
-
-    if ((ret = inproc_pulse_event( handle, prev_state )) != STATUS_NOT_IMPLEMENTED)
-        return ret;
+    if (do_esync())
+        return esync_pulse_event( handle );
 
     SERVER_START_REQ( event_op )
     {
@@ -1244,11 +594,8 @@ NTSTATUS WINAPI NtQueryEvent( HANDLE han
 
     if (len != sizeof(EVENT_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
 
-    if ((ret = inproc_query_event( handle, out )) != STATUS_NOT_IMPLEMENTED)
-    {
-        if (!ret && ret_len) *ret_len = sizeof(EVENT_BASIC_INFORMATION);
-        return ret;
-    }
+    if (do_esync())
+        return esync_query_event( handle, info, ret_len );
 
     SERVER_START_REQ( query_event )
     {
@@ -1275,10 +622,11 @@ NTSTATUS WINAPI NtCreateMutant( HANDLE *
     data_size_t len;
     struct object_attributes *objattr;
 
-    TRACE( "access %#x, name %s, owned %u\n", access,
-           attr ? debugstr_us(attr->ObjectName) : "(null)", owned );
-
     *handle = 0;
+
+    if (do_esync())
+        return esync_create_mutex( handle, access, attr, owned );
+
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
     SERVER_START_REQ( create_mutex )
@@ -1303,11 +651,12 @@ NTSTATUS WINAPI NtOpenMutant( HANDLE *ha
 {
     unsigned int ret;
 
-    TRACE( "access %#x, name %s\n", access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
-
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
+    if (do_esync())
+        return esync_open_mutex( handle, access, attr );
+
     SERVER_START_REQ( open_mutex )
     {
         req->access  = access;
@@ -1330,10 +679,8 @@ NTSTATUS WINAPI NtReleaseMutant( HANDLE
 {
     unsigned int ret;
 
-    TRACE( "handle %p, prev_count %p\n", handle, prev_count );
-
-    if ((ret = inproc_release_mutex( handle, prev_count )) != STATUS_NOT_IMPLEMENTED)
-        return ret;
+    if (do_esync())
+        return esync_release_mutex( handle, prev_count );
 
     SERVER_START_REQ( release_mutex )
     {
@@ -1365,11 +712,8 @@ NTSTATUS WINAPI NtQueryMutant( HANDLE ha
 
     if (len != sizeof(MUTANT_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
 
-    if ((ret = inproc_query_mutex( handle, out )) != STATUS_NOT_IMPLEMENTED)
-    {
-        if (!ret && ret_len) *ret_len = sizeof(MUTANT_BASIC_INFORMATION);
-        return ret;
-    }
+    if (do_esync())
+        return esync_query_mutex( handle, info, ret_len );
 
     SERVER_START_REQ( query_mutex )
     {
@@ -2140,9 +1484,6 @@ NTSTATUS WINAPI NtCreateTimer( HANDLE *h
     data_size_t len;
     struct object_attributes *objattr;
 
-    TRACE( "access %#x, name %s, type %u\n", access,
-           attr ? debugstr_us(attr->ObjectName) : "(null)", type );
-
     *handle = 0;
     if (type != NotificationTimer && type != SynchronizationTimer) return STATUS_INVALID_PARAMETER;
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
@@ -2170,8 +1511,6 @@ NTSTATUS WINAPI NtOpenTimer( HANDLE *han
 {
     unsigned int ret;
 
-    TRACE( "access %#x, name %s\n", access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
-
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
@@ -2225,8 +1564,6 @@ NTSTATUS WINAPI NtCancelTimer( HANDLE ha
 {
     unsigned int ret;
 
-    TRACE( "handle %p, state %p\n", handle, state );
-
     SERVER_START_REQ( cancel_timer )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -2295,29 +1632,20 @@ NTSTATUS WINAPI NtWaitForMultipleObjects
 {
     union select_op select_op;
     UINT i, flags = SELECT_INTERRUPTIBLE;
-    unsigned int ret;
 
     if (!count || count > MAXIMUM_WAIT_OBJECTS) return STATUS_INVALID_PARAMETER_1;
 
-    if (TRACE_ON(sync))
-    {
-        TRACE( "wait_any %u, alertable %u, handles {%p", wait_any, alertable, handles[0] );
-        for (i = 1; i < count; i++) TRACE( ", %p", handles[i] );
-        TRACE( "}, timeout %s\n", debugstr_timeout(timeout) );
-    }
-
-    if ((ret = inproc_wait( count, handles, wait_any, alertable, timeout )) != STATUS_NOT_IMPLEMENTED)
+    if (do_esync())
     {
-        TRACE( "-> %#x\n", ret );
-        return ret;
+        NTSTATUS ret = esync_wait_objects( count, handles, wait_any, alertable, timeout );
+        if (ret != STATUS_NOT_IMPLEMENTED)
+            return ret;
     }
 
     if (alertable) flags |= SELECT_ALERTABLE;
     select_op.wait.op = wait_any ? SELECT_WAIT : SELECT_WAIT_ALL;
     for (i = 0; i < count; i++) select_op.wait.handles[i] = wine_server_obj_handle( handles[i] );
-    ret = server_wait( &select_op, offsetof( union select_op, wait.handles[count] ), flags, timeout );
-    TRACE( "-> %#x\n", ret );
-    return ret;
+    return server_wait( &select_op, offsetof( union select_op, wait.handles[count] ), flags, timeout );
 }
 
 
@@ -2338,15 +1666,12 @@ NTSTATUS WINAPI NtSignalAndWaitForSingle
 {
     union select_op select_op;
     UINT flags = SELECT_INTERRUPTIBLE;
-    NTSTATUS ret;
 
-    TRACE( "signal %p, wait %p, alertable %u, timeout %s\n", signal, wait, alertable, debugstr_timeout(timeout) );
+    if (do_esync())
+        return esync_signal_and_wait( signal, wait, alertable, timeout );
 
     if (!signal) return STATUS_INVALID_HANDLE;
 
-    if ((ret = inproc_signal_and_wait( signal, wait, alertable, timeout )) != STATUS_NOT_IMPLEMENTED)
-        return ret;
-
     if (alertable) flags |= SELECT_ALERTABLE;
     select_op.signal_and_wait.op = SELECT_SIGNAL_AND_WAIT;
     select_op.signal_and_wait.wait = wine_server_obj_handle( wait );
@@ -2589,9 +1914,6 @@ NTSTATUS WINAPI NtCreateKeyedEvent( HAND
     data_size_t len;
     struct object_attributes *objattr;
 
-    TRACE( "access %#x, name %s, flags %#x\n", access,
-           attr ? debugstr_us(attr->ObjectName) : "(null)", flags );
-
     *handle = 0;
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
@@ -2616,8 +1938,6 @@ NTSTATUS WINAPI NtOpenKeyedEvent( HANDLE
 {
     unsigned int ret;
 
-    TRACE( "access %#x, name %s\n", access, attr ? debugstr_us(attr->ObjectName) : "(null)" );
-
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
@@ -2644,8 +1964,6 @@ NTSTATUS WINAPI NtWaitForKeyedEvent( HAN
     union select_op select_op;
     UINT flags = SELECT_INTERRUPTIBLE;
 
-    TRACE( "handle %p, key %p, alertable %u, timeout %s\n", handle, key, alertable, debugstr_timeout(timeout) );
-
     if (!handle) handle = keyed_event;
     if ((ULONG_PTR)key & 1) return STATUS_INVALID_PARAMETER_1;
     if (alertable) flags |= SELECT_ALERTABLE;
@@ -2665,8 +1983,6 @@ NTSTATUS WINAPI NtReleaseKeyedEvent( HAN
     union select_op select_op;
     UINT flags = SELECT_INTERRUPTIBLE;
 
-    TRACE( "handle %p, key %p, alertable %u, timeout %s\n", handle, key, alertable, debugstr_timeout(timeout) );
-
     if (!handle) handle = keyed_event;
     if ((ULONG_PTR)key & 1) return STATUS_INVALID_PARAMETER_1;
     if (alertable) flags |= SELECT_ALERTABLE;
diff -ruN --show-c-function dlls/ntdll/unix/thread.c dlls/ntdll/unix/thread.c
--- dlls/ntdll/unix/thread.c	2025-10-10 10:17:47.374749568 -0700
+++ dlls/ntdll/unix/thread.c	2025-10-10 10:22:17.110048705 -0700
@@ -1104,7 +1104,6 @@ static void contexts_from_server( CONTEX
  */
 static DECLSPEC_NORETURN void pthread_exit_wrapper( int status )
 {
-    close( ntdll_get_thread_data()->alert_fd );
     close( ntdll_get_thread_data()->wait_fd[0] );
     close( ntdll_get_thread_data()->wait_fd[1] );
     close( ntdll_get_thread_data()->reply_fd );
@@ -1844,15 +1843,8 @@ NTSTATUS get_thread_context( HANDLE hand
 
     if (ret == STATUS_PENDING)
     {
-        sigset_t sigset;
-
         NtWaitForSingleObject( context_handle, FALSE, NULL );
 
-        server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
-
-        /* remove the handle from the cache, get_thread_context will close it for us */
-        close_inproc_sync( context_handle );
-
         SERVER_START_REQ( get_thread_context )
         {
             req->context = wine_server_obj_handle( context_handle );
@@ -1860,12 +1852,10 @@ NTSTATUS get_thread_context( HANDLE hand
             req->machine = machine;
             req->native_flags = flags & get_native_context_flags( native_machine, machine );
             wine_server_set_reply( req, server_contexts, sizeof(server_contexts) );
-            ret = server_call_unlocked( req );
+            ret = wine_server_call( req );
             count = wine_server_reply_size( reply ) / sizeof(server_contexts[0]);
         }
         SERVER_END_REQ;
-
-        server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
     }
     if (!ret && count)
     {
diff -ruN --show-c-function dlls/ntdll/unix/unix_private.h dlls/ntdll/unix/unix_private.h
--- dlls/ntdll/unix/unix_private.h	2025-10-10 10:17:48.574775226 -0700
+++ dlls/ntdll/unix/unix_private.h	2025-10-10 10:22:17.165144485 -0700
@@ -105,10 +105,10 @@ struct ntdll_thread_data
     SYSTEM_SERVICE_TABLE     *syscall_table; /* 214/0370 syscall table */
     struct syscall_frame     *syscall_frame; /* 218/0378 current syscall frame */
     int                       syscall_trace; /* 21c/0380 syscall trace flag */
+    int                       esync_apc_fd;  /* fd to wait on for user APCs */
     int                       request_fd;    /* fd for sending server requests */
     int                       reply_fd;      /* fd for receiving server replies */
     int                       wait_fd[2];    /* fd for sleeping server requests */
-    int                       alert_fd;      /* inproc sync fd for user apc alerts */
     BOOL                      allow_writes;  /* ThreadAllowWrites flags */
     pthread_t                 pthread_id;    /* pthread thread id */
     void                     *kernel_stack;  /* stack for thread startup and kernel syscalls */
@@ -198,10 +198,8 @@ extern unsigned int supported_machines_c
 extern USHORT supported_machines[8];
 extern BOOL process_exiting;
 extern HANDLE keyed_event;
-extern int inproc_device_fd;
 extern timeout_t server_start_time;
 extern sigset_t server_block_set;
-extern pthread_mutex_t fd_cache_mutex;
 extern struct _KUSER_SHARED_DATA *user_shared_data;
 
 extern void init_environment(void);
@@ -234,7 +232,6 @@ extern unsigned int server_queue_process
 extern int server_get_unix_fd( HANDLE handle, unsigned int wanted_access, int *unix_fd,
                                int *needs_close, enum server_fd_type *type, unsigned int *options );
 extern void wine_server_send_fd( int fd );
-extern int wine_server_receive_fd( obj_handle_t *handle );
 extern void process_exit_wrapper( int status ) DECLSPEC_NORETURN;
 extern size_t server_init_process(void);
 extern void server_init_process_done(void);
@@ -390,8 +387,6 @@ extern NTSTATUS wow64_wine_spawnvp( void
 
 extern void dbg_init(void);
 
-extern void close_inproc_sync( HANDLE handle );
-
 extern NTSTATUS call_user_apc_dispatcher( CONTEXT *context_ptr, unsigned int flags, ULONG_PTR arg1, ULONG_PTR arg2,
                                           ULONG_PTR arg3, PNTAPCFUNC func, NTSTATUS status );
 extern NTSTATUS call_user_exception_dispatcher( EXCEPTION_RECORD *rec, CONTEXT *context );
@@ -400,7 +395,6 @@ extern void call_raise_user_exception_di
 #define IMAGE_DLLCHARACTERISTICS_PREFER_NATIVE 0x0010 /* Wine extension */
 
 #define TICKSPERSEC 10000000
-#define NSECPERSEC 1000000000
 #define SECS_1601_TO_1970  ((369 * 365 + 89) * (ULONGLONG)86400)
 
 static inline ULONGLONG ticks_from_time_t( time_t time )
diff -ruN --show-c-function dlls/ntdll/unix/virtual.c dlls/ntdll/unix/virtual.c
--- dlls/ntdll/unix/virtual.c	2025-10-10 10:17:48.575775247 -0700
+++ dlls/ntdll/unix/virtual.c	2025-10-10 10:22:17.165380342 -0700
@@ -4022,11 +4022,11 @@ static TEB *init_teb( void *ptr, BOOL is
     teb->StaticUnicodeString.Buffer = teb->StaticUnicodeBuffer;
     teb->StaticUnicodeString.MaximumLength = sizeof(teb->StaticUnicodeBuffer);
     thread_data = (struct ntdll_thread_data *)&teb->GdiTebBatch;
+    thread_data->esync_apc_fd = -1;
     thread_data->request_fd = -1;
     thread_data->reply_fd   = -1;
     thread_data->wait_fd[0] = -1;
     thread_data->wait_fd[1] = -1;
-    thread_data->alert_fd   = -1;
     list_add_head( &teb_list, &thread_data->entry );
     return teb;
 }
diff -ruN --show-c-function dlls/rpcrt4/rpc_server.c dlls/rpcrt4/rpc_server.c
--- dlls/rpcrt4/rpc_server.c	2025-10-10 10:17:47.419750531 -0700
+++ dlls/rpcrt4/rpc_server.c	2025-10-10 10:22:17.158610035 -0700
@@ -701,10 +701,6 @@ static DWORD CALLBACK RPCRT4_server_thre
   }
   LeaveCriticalSection(&cps->cs);
 
-  EnterCriticalSection(&listen_cs);
-  CloseHandle(cps->server_thread);
-  cps->server_thread = NULL;
-  LeaveCriticalSection(&listen_cs);
   TRACE("done\n");
   return 0;
 }
@@ -1570,7 +1566,10 @@ RPC_STATUS WINAPI RpcMgmtWaitServerListe
       LIST_FOR_EACH_ENTRY(protseq, &protseqs, RpcServerProtseq, entry)
       {
           if ((wait_thread = protseq->server_thread))
+          {
+              protseq->server_thread = NULL;
               break;
+          }
       }
       LeaveCriticalSection(&server_cs);
       if (!wait_thread)
@@ -1579,6 +1578,7 @@ RPC_STATUS WINAPI RpcMgmtWaitServerListe
       TRACE("waiting for thread %lu\n", GetThreadId(wait_thread));
       LeaveCriticalSection(&listen_cs);
       WaitForSingleObject(wait_thread, INFINITE);
+      CloseHandle(wait_thread);
       EnterCriticalSection(&listen_cs);
   }
   if (listen_done_event == event)
diff -ruN --show-c-function dlls/rpcrt4/rpc_server.c.orig dlls/rpcrt4/rpc_server.c.orig
--- dlls/rpcrt4/rpc_server.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ dlls/rpcrt4/rpc_server.c.orig	2025-10-10 10:22:12.330268196 -0700
@@ -0,0 +1,1747 @@
+/*
+ * RPC server API
+ *
+ * Copyright 2001 Ove Kåven, TransGaming Technologies
+ * Copyright 2004 Filip Navara
+ * Copyright 2006-2008 Robert Shearman (for CodeWeavers)
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winerror.h"
+
+#include "rpc.h"
+#include "rpcndr.h"
+#include "excpt.h"
+
+#include "wine/debug.h"
+#include "wine/exception.h"
+
+#include "rpc_server.h"
+#include "rpc_assoc.h"
+#include "rpc_message.h"
+#include "rpc_defs.h"
+#include "ncastatus.h"
+#include "secext.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(rpc);
+
+typedef struct _RpcPacket
+{
+  struct _RpcConnection* conn;
+  RpcPktHdr* hdr;
+  RPC_MESSAGE* msg;
+  unsigned char *auth_data;
+  ULONG auth_length;
+} RpcPacket;
+
+typedef struct _RpcObjTypeMap
+{
+  /* FIXME: a hash table would be better. */
+  struct _RpcObjTypeMap *next;
+  UUID Object;
+  UUID Type;
+} RpcObjTypeMap;
+
+static RpcObjTypeMap *RpcObjTypeMaps;
+
+/* list of type RpcServerProtseq */
+static struct list protseqs = LIST_INIT(protseqs);
+static struct list server_interfaces = LIST_INIT(server_interfaces);
+static struct list server_registered_auth_info = LIST_INIT(server_registered_auth_info);
+
+static CRITICAL_SECTION server_cs;
+static CRITICAL_SECTION_DEBUG server_cs_debug =
+{
+    0, 0, &server_cs,
+    { &server_cs_debug.ProcessLocksList, &server_cs_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": server_cs") }
+};
+static CRITICAL_SECTION server_cs = { &server_cs_debug, -1, 0, 0, 0, 0 };
+
+static CRITICAL_SECTION listen_cs;
+static CRITICAL_SECTION_DEBUG listen_cs_debug =
+{
+    0, 0, &listen_cs,
+    { &listen_cs_debug.ProcessLocksList, &listen_cs_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": listen_cs") }
+};
+static CRITICAL_SECTION listen_cs = { &listen_cs_debug, -1, 0, 0, 0, 0 };
+
+static CRITICAL_SECTION server_auth_info_cs;
+static CRITICAL_SECTION_DEBUG server_auth_info_cs_debug =
+{
+    0, 0, &server_auth_info_cs,
+    { &server_auth_info_cs_debug.ProcessLocksList, &server_auth_info_cs_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": server_auth_info_cs") }
+};
+static CRITICAL_SECTION server_auth_info_cs = { &server_auth_info_cs_debug, -1, 0, 0, 0, 0 };
+
+/* whether the server is currently listening */
+static BOOL std_listen;
+/* total listeners including auto listeners */
+static LONG listen_count;
+/* event set once all manual listening is finished */
+static HANDLE listen_done_event;
+
+static UUID uuid_nil;
+
+static inline RpcObjTypeMap *LookupObjTypeMap(UUID *ObjUuid)
+{
+  RpcObjTypeMap *rslt = RpcObjTypeMaps;
+  RPC_STATUS dummy;
+
+  while (rslt) {
+    if (! UuidCompare(ObjUuid, &rslt->Object, &dummy)) break;
+    rslt = rslt->next;
+  }
+
+  return rslt;
+}
+
+static inline UUID *LookupObjType(UUID *ObjUuid)
+{
+  RpcObjTypeMap *map = LookupObjTypeMap(ObjUuid);
+  if (map)
+    return &map->Type;
+  else
+    return &uuid_nil;
+}
+
+static RpcServerInterface* RPCRT4_find_interface(UUID* object,
+                                                 const RPC_SYNTAX_IDENTIFIER *if_id,
+                                                 const RPC_SYNTAX_IDENTIFIER *transfer_syntax,
+                                                 BOOL check_object)
+{
+  UUID* MgrType = NULL;
+  RpcServerInterface* cif;
+  RPC_STATUS status;
+
+  if (check_object)
+    MgrType = LookupObjType(object);
+  EnterCriticalSection(&server_cs);
+  LIST_FOR_EACH_ENTRY(cif, &server_interfaces, RpcServerInterface, entry) {
+    if (!memcmp(if_id, &cif->If->InterfaceId, sizeof(RPC_SYNTAX_IDENTIFIER)) &&
+        (!transfer_syntax || !memcmp(transfer_syntax, &cif->If->TransferSyntax, sizeof(RPC_SYNTAX_IDENTIFIER))) &&
+        (check_object == FALSE || UuidEqual(MgrType, &cif->MgrTypeUuid, &status)) &&
+        std_listen) {
+      InterlockedIncrement(&cif->CurrentCalls);
+      break;
+    }
+  }
+  LeaveCriticalSection(&server_cs);
+  if (&cif->entry == &server_interfaces) cif = NULL;
+  TRACE("returning %p for object %s, if_id { %d.%d %s }\n", cif,
+    debugstr_guid(object), if_id->SyntaxVersion.MajorVersion,
+    if_id->SyntaxVersion.MinorVersion, debugstr_guid(&if_id->SyntaxGUID));
+  return cif;
+}
+
+static void RPCRT4_release_server_interface(RpcServerInterface *sif)
+{
+  if (!InterlockedDecrement(&sif->CurrentCalls) &&
+      sif->Delete) {
+    /* sif must have been removed from server_interfaces before
+     * CallsCompletedEvent is set */
+    if (sif->CallsCompletedEvent)
+      SetEvent(sif->CallsCompletedEvent);
+    free(sif);
+  }
+}
+
+static RpcPktHdr *handle_bind_error(RpcConnection *conn, RPC_STATUS error)
+{
+    unsigned int reject_reason;
+    switch (error)
+    {
+    case RPC_S_SERVER_TOO_BUSY:
+        reject_reason = REJECT_TEMPORARY_CONGESTION;
+        break;
+    case ERROR_OUTOFMEMORY:
+    case RPC_S_OUT_OF_RESOURCES:
+        reject_reason = REJECT_LOCAL_LIMIT_EXCEEDED;
+        break;
+    case RPC_S_PROTOCOL_ERROR:
+        reject_reason = REJECT_PROTOCOL_VERSION_NOT_SUPPORTED;
+        break;
+    case RPC_S_UNKNOWN_AUTHN_SERVICE:
+        reject_reason = REJECT_UNKNOWN_AUTHN_SERVICE;
+        break;
+    case ERROR_ACCESS_DENIED:
+        reject_reason = REJECT_INVALID_CHECKSUM;
+        break;
+    default:
+        FIXME("unexpected status value %ld\n", error);
+        /* fall through */
+    case RPC_S_INVALID_BOUND:
+        reject_reason = REJECT_REASON_NOT_SPECIFIED;
+        break;
+    }
+    return RPCRT4_BuildBindNackHeader(NDR_LOCAL_DATA_REPRESENTATION,
+                                      RPC_VER_MAJOR, RPC_VER_MINOR,
+                                      reject_reason);
+}
+
+static RPC_STATUS process_bind_packet_no_send(
+    RpcConnection *conn, RpcPktBindHdr *hdr, RPC_MESSAGE *msg,
+    unsigned char *auth_data, ULONG auth_length, RpcPktHdr **ack_response,
+    unsigned char **auth_data_out, ULONG *auth_length_out)
+{
+  RPC_STATUS status;
+  RpcContextElement *ctxt_elem;
+  unsigned int i;
+  RpcResult *results;
+
+  /* validate data */
+  for (i = 0, ctxt_elem = msg->Buffer;
+       i < hdr->num_elements;
+       i++, ctxt_elem = (RpcContextElement *)&ctxt_elem->transfer_syntaxes[ctxt_elem->num_syntaxes])
+  {
+      if (((char *)ctxt_elem - (char *)msg->Buffer) > msg->BufferLength ||
+          ((char *)&ctxt_elem->transfer_syntaxes[ctxt_elem->num_syntaxes] - (char *)msg->Buffer) > msg->BufferLength)
+      {
+          ERR("inconsistent data in packet - packet length %d, num elements %d\n",
+              msg->BufferLength, hdr->num_elements);
+          return RPC_S_INVALID_BOUND;
+      }
+  }
+
+  if (hdr->max_tsize < RPC_MIN_PACKET_SIZE ||
+      !UuidIsNil(&conn->ActiveInterface.SyntaxGUID, &status) ||
+      conn->server_binding)
+  {
+    TRACE("packet size less than min size, or active interface syntax guid non-null\n");
+
+    return RPC_S_INVALID_BOUND;
+  }
+
+  results = malloc(hdr->num_elements * sizeof(*results));
+  if (!results)
+    return RPC_S_OUT_OF_RESOURCES;
+
+  for (i = 0, ctxt_elem = (RpcContextElement *)msg->Buffer;
+       i < hdr->num_elements;
+       i++, ctxt_elem = (RpcContextElement *)&ctxt_elem->transfer_syntaxes[ctxt_elem->num_syntaxes])
+  {
+      RpcServerInterface* sif = NULL;
+      unsigned int j;
+
+      for (j = 0; !sif && j < ctxt_elem->num_syntaxes; j++)
+      {
+          sif = RPCRT4_find_interface(NULL, &ctxt_elem->abstract_syntax,
+                                      &ctxt_elem->transfer_syntaxes[j], FALSE);
+          if (sif)
+              break;
+      }
+      if (sif)
+      {
+          RPCRT4_release_server_interface(sif);
+          TRACE("accepting bind request on connection %p for %s\n", conn,
+                debugstr_guid(&ctxt_elem->abstract_syntax.SyntaxGUID));
+          results[i].result = RESULT_ACCEPT;
+          results[i].reason = REASON_NONE;
+          results[i].transfer_syntax = ctxt_elem->transfer_syntaxes[j];
+
+          /* save the interface for later use */
+          /* FIXME: save linked list */
+          conn->ActiveInterface = ctxt_elem->abstract_syntax;
+      }
+      else if ((sif = RPCRT4_find_interface(NULL, &ctxt_elem->abstract_syntax,
+                                            NULL, FALSE)) != NULL)
+      {
+          RPCRT4_release_server_interface(sif);
+          TRACE("not accepting bind request on connection %p for %s - no transfer syntaxes supported\n",
+                conn, debugstr_guid(&ctxt_elem->abstract_syntax.SyntaxGUID));
+          results[i].result = RESULT_PROVIDER_REJECTION;
+          results[i].reason = REASON_TRANSFER_SYNTAXES_NOT_SUPPORTED;
+          memset(&results[i].transfer_syntax, 0, sizeof(results[i].transfer_syntax));
+      }
+      else
+      {
+          TRACE("not accepting bind request on connection %p for %s - abstract syntax not supported\n",
+                conn, debugstr_guid(&ctxt_elem->abstract_syntax.SyntaxGUID));
+          results[i].result = RESULT_PROVIDER_REJECTION;
+          results[i].reason = REASON_ABSTRACT_SYNTAX_NOT_SUPPORTED;
+          memset(&results[i].transfer_syntax, 0, sizeof(results[i].transfer_syntax));
+      }
+  }
+
+  /* create temporary binding */
+  status = RPCRT4_MakeBinding(&conn->server_binding, conn);
+  if (status != RPC_S_OK)
+  {
+      free(results);
+      return status;
+  }
+
+  status = RpcServerAssoc_GetAssociation(rpcrt4_conn_get_name(conn),
+                                         conn->NetworkAddr, conn->Endpoint,
+                                         conn->NetworkOptions,
+                                         hdr->assoc_gid,
+                                         &conn->server_binding->Assoc);
+  if (status != RPC_S_OK)
+  {
+      free(results);
+      return status;
+  }
+
+  if (auth_length)
+  {
+      status = RPCRT4_ServerConnectionAuth(conn, TRUE,
+                                           (RpcAuthVerifier *)auth_data,
+                                           auth_length, auth_data_out,
+                                           auth_length_out);
+      if (status != RPC_S_OK)
+      {
+          free(results);
+          return status;
+      }
+  }
+
+  *ack_response = RPCRT4_BuildBindAckHeader(NDR_LOCAL_DATA_REPRESENTATION,
+                                            RPC_MAX_PACKET_SIZE,
+                                            RPC_MAX_PACKET_SIZE,
+                                            conn->server_binding->Assoc->assoc_group_id,
+                                            conn->Endpoint, hdr->num_elements,
+                                            results);
+  free(results);
+
+  if (*ack_response)
+      conn->MaxTransmissionSize = hdr->max_tsize;
+  else
+      status = RPC_S_OUT_OF_RESOURCES;
+
+  return status;
+}
+
+static RPC_STATUS process_bind_packet(RpcConnection *conn, RpcPktBindHdr *hdr,
+                                      RPC_MESSAGE *msg,
+                                      unsigned char *auth_data,
+                                      ULONG auth_length)
+{
+    RPC_STATUS status;
+    RpcPktHdr *response = NULL;
+    unsigned char *auth_data_out = NULL;
+    ULONG auth_length_out = 0;
+
+    status = process_bind_packet_no_send(conn, hdr, msg, auth_data, auth_length,
+                                         &response, &auth_data_out,
+                                         &auth_length_out);
+    if (status != RPC_S_OK)
+        response = handle_bind_error(conn, status);
+    if (response)
+        status = RPCRT4_SendWithAuth(conn, response, NULL, 0, auth_data_out, auth_length_out);
+    else
+        status = ERROR_OUTOFMEMORY;
+    free(response);
+
+    return status;
+}
+
+
+static RPC_STATUS process_request_packet(RpcConnection *conn, RpcPktRequestHdr *hdr, RPC_MESSAGE *msg)
+{
+  RPC_STATUS status;
+  RpcPktHdr *response = NULL;
+  RpcServerInterface* sif;
+  RPC_DISPATCH_FUNCTION func;
+  BOOL exception;
+  UUID *object_uuid;
+  NDR_SCONTEXT context_handle;
+  void *buf = msg->Buffer;
+
+  /* fail if the connection isn't bound with an interface */
+  if (UuidIsNil(&conn->ActiveInterface.SyntaxGUID, &status)) {
+    /* FIXME: should send BindNack instead */
+    response = RPCRT4_BuildFaultHeader(NDR_LOCAL_DATA_REPRESENTATION,
+                                       status);
+
+    RPCRT4_Send(conn, response, NULL, 0);
+    free(response);
+    return RPC_S_OK;
+  }
+
+  if (hdr->common.flags & RPC_FLG_OBJECT_UUID) {
+    object_uuid = (UUID*)(hdr + 1);
+  } else {
+    object_uuid = NULL;
+  }
+
+  sif = RPCRT4_find_interface(object_uuid, &conn->ActiveInterface, NULL, TRUE);
+  if (!sif) {
+    WARN("interface %s no longer registered, returning fault packet\n", debugstr_guid(&conn->ActiveInterface.SyntaxGUID));
+    response = RPCRT4_BuildFaultHeader(NDR_LOCAL_DATA_REPRESENTATION,
+                                       NCA_S_UNK_IF);
+
+    RPCRT4_Send(conn, response, NULL, 0);
+    free(response);
+    return RPC_S_OK;
+  }
+  msg->RpcInterfaceInformation = sif->If;
+  /* copy the endpoint vector from sif to msg so that midl-generated code will use it */
+  msg->ManagerEpv = sif->MgrEpv;
+  if (object_uuid != NULL) {
+    RPCRT4_SetBindingObject(msg->Handle, object_uuid);
+  }
+
+  /* find dispatch function */
+  msg->ProcNum = hdr->opnum;
+  if (sif->Flags & RPC_IF_OLE) {
+    /* native ole32 always gives us a dispatch table with a single entry
+    * (I assume that's a wrapper for IRpcStubBuffer::Invoke) */
+    func = *sif->If->DispatchTable->DispatchTable;
+  } else {
+    if (msg->ProcNum >= sif->If->DispatchTable->DispatchTableCount) {
+      WARN("invalid procnum (%d/%d)\n", msg->ProcNum, sif->If->DispatchTable->DispatchTableCount);
+      response = RPCRT4_BuildFaultHeader(NDR_LOCAL_DATA_REPRESENTATION,
+                                         NCA_S_OP_RNG_ERROR);
+
+      RPCRT4_Send(conn, response, NULL, 0);
+      free(response);
+    }
+    func = sif->If->DispatchTable->DispatchTable[msg->ProcNum];
+  }
+
+  /* put in the drep. FIXME: is this more universally applicable?
+    perhaps we should move this outward... */
+  msg->DataRepresentation =
+    MAKELONG( MAKEWORD(hdr->common.drep[0], hdr->common.drep[1]),
+              MAKEWORD(hdr->common.drep[2], hdr->common.drep[3]));
+
+  exception = FALSE;
+
+  /* dispatch */
+  RPCRT4_SetThreadCurrentCallHandle(msg->Handle);
+  __TRY {
+    if (func) func(msg);
+  } __EXCEPT_ALL {
+    WARN("exception caught with code 0x%08lx = %ld\n", GetExceptionCode(), GetExceptionCode());
+    exception = TRUE;
+    if (GetExceptionCode() == STATUS_ACCESS_VIOLATION)
+      status = ERROR_NOACCESS;
+    else
+      status = GetExceptionCode();
+    response = RPCRT4_BuildFaultHeader(msg->DataRepresentation,
+                                       RPC2NCA_STATUS(status));
+  } __ENDTRY
+    RPCRT4_SetThreadCurrentCallHandle(NULL);
+
+  /* release any unmarshalled context handles */
+  while ((context_handle = RPCRT4_PopThreadContextHandle()) != NULL)
+    RpcServerAssoc_ReleaseContextHandle(conn->server_binding->Assoc, context_handle, TRUE);
+
+  if (!exception)
+    response = RPCRT4_BuildResponseHeader(msg->DataRepresentation,
+                                          msg->BufferLength);
+
+  /* send response packet */
+  if (response) {
+    status = RPCRT4_Send(conn, response, exception ? NULL : msg->Buffer,
+                         exception ? 0 : msg->BufferLength);
+    free(response);
+  } else
+    ERR("out of memory\n");
+
+  msg->RpcInterfaceInformation = NULL;
+  RPCRT4_release_server_interface(sif);
+
+  if (msg->Buffer == buf) buf = NULL;
+  TRACE("freeing Buffer=%p\n", buf);
+  I_RpcFree(buf);
+
+  return status;
+}
+
+static RPC_STATUS process_auth3_packet(RpcConnection *conn,
+                                       RpcPktCommonHdr *hdr,
+                                       RPC_MESSAGE *msg,
+                                       unsigned char *auth_data,
+                                       ULONG auth_length)
+{
+    RPC_STATUS status;
+
+    if (UuidIsNil(&conn->ActiveInterface.SyntaxGUID, &status) ||
+        !auth_length || msg->BufferLength != 0)
+        status = RPC_S_PROTOCOL_ERROR;
+    else
+    {
+        status = RPCRT4_ServerConnectionAuth(conn, FALSE,
+                                             (RpcAuthVerifier *)auth_data,
+                                             auth_length, NULL, NULL);
+    }
+
+    /* FIXME: client doesn't expect a response to this message so must store
+     * status in connection so that fault packet can be returned when next
+     * packet is received */
+
+    return RPC_S_OK;
+}
+
+static void RPCRT4_process_packet(RpcConnection* conn, RpcPktHdr* hdr,
+                                  RPC_MESSAGE* msg, unsigned char *auth_data,
+                                  ULONG auth_length)
+{
+  msg->Handle = (RPC_BINDING_HANDLE)conn->server_binding;
+
+  switch (hdr->common.ptype) {
+    case PKT_BIND:
+      TRACE("got bind packet\n");
+      process_bind_packet(conn, &hdr->bind, msg, auth_data, auth_length);
+      break;
+
+    case PKT_REQUEST:
+      TRACE("got request packet\n");
+      process_request_packet(conn, &hdr->request, msg);
+      break;
+
+    case PKT_AUTH3:
+      TRACE("got auth3 packet\n");
+      process_auth3_packet(conn, &hdr->common, msg, auth_data, auth_length);
+      break;
+    default:
+      FIXME("unhandled packet type %u\n", hdr->common.ptype);
+      break;
+  }
+
+  /* clean up */
+  I_RpcFree(msg->Buffer);
+  free(hdr);
+  free(msg);
+  free(auth_data);
+}
+
+static DWORD CALLBACK RPCRT4_worker_thread(LPVOID the_arg)
+{
+  RpcPacket *pkt = the_arg;
+  RPCRT4_process_packet(pkt->conn, pkt->hdr, pkt->msg, pkt->auth_data,
+                        pkt->auth_length);
+  RPCRT4_ReleaseConnection(pkt->conn);
+  free(pkt);
+  return 0;
+}
+
+static DWORD CALLBACK RPCRT4_io_thread(LPVOID the_arg)
+{
+  RpcConnection* conn = the_arg;
+  RpcPktHdr *hdr;
+  RPC_MESSAGE *msg;
+  RPC_STATUS status;
+  RpcPacket *packet;
+  unsigned char *auth_data;
+  ULONG auth_length;
+
+  TRACE("(%p)\n", conn);
+  SetThreadDescription(GetCurrentThread(), L"wine_rpcrt4_io");
+
+  for (;;) {
+    msg = calloc(1, sizeof(RPC_MESSAGE));
+    if (!msg) break;
+
+    status = RPCRT4_ReceiveWithAuth(conn, &hdr, msg, &auth_data, &auth_length);
+    if (status != RPC_S_OK) {
+      WARN("receive failed with error %lx\n", status);
+      free(msg);
+      break;
+    }
+
+    switch (hdr->common.ptype) {
+    case PKT_BIND:
+      TRACE("got bind packet\n");
+
+      status = process_bind_packet(conn, &hdr->bind, msg, auth_data,
+                                   auth_length);
+      break;
+
+    case PKT_REQUEST:
+      TRACE("got request packet\n");
+
+      packet = malloc(sizeof(RpcPacket));
+      if (!packet) {
+        I_RpcFree(msg->Buffer);
+        free(hdr);
+        free(msg);
+        free(auth_data);
+        goto exit;
+      }
+      packet->conn = RPCRT4_GrabConnection( conn );
+      packet->hdr = hdr;
+      packet->msg = msg;
+      packet->auth_data = auth_data;
+      packet->auth_length = auth_length;
+      if (!QueueUserWorkItem(RPCRT4_worker_thread, packet, WT_EXECUTELONGFUNCTION)) {
+        ERR("couldn't queue work item for worker thread, error was %ld\n", GetLastError());
+        free(packet);
+        status = RPC_S_OUT_OF_RESOURCES;
+      } else {
+        continue;
+      }
+      break;
+
+    case PKT_AUTH3:
+      TRACE("got auth3 packet\n");
+
+      status = process_auth3_packet(conn, &hdr->common, msg, auth_data,
+                                    auth_length);
+      break;
+    default:
+      FIXME("unhandled packet type %u\n", hdr->common.ptype);
+      break;
+    }
+
+    I_RpcFree(msg->Buffer);
+    free(hdr);
+    free(msg);
+    free(auth_data);
+
+    if (status != RPC_S_OK) {
+      WARN("processing packet failed with error %lu\n", status);
+      break;
+    }
+  }
+exit:
+  RPCRT4_ReleaseConnection(conn);
+  return 0;
+}
+
+void RPCRT4_new_client(RpcConnection* conn)
+{
+  HANDLE thread = CreateThread(NULL, 0, RPCRT4_io_thread, conn, 0, NULL);
+  if (!thread) {
+    DWORD err = GetLastError();
+    ERR("failed to create thread, error=%08lx\n", err);
+    RPCRT4_ReleaseConnection(conn);
+  }
+  /* we could set conn->thread, but then we'd have to make the io_thread wait
+   * for that, otherwise the thread might finish, destroy the connection, and
+   * free the memory we'd write to before we did, causing crashes and stuff -
+   * so let's implement that later, when we really need conn->thread */
+
+  CloseHandle( thread );
+}
+
+static DWORD CALLBACK RPCRT4_server_thread(LPVOID the_arg)
+{
+  int res;
+  unsigned int count;
+  void *objs = NULL;
+  RpcServerProtseq* cps = the_arg;
+  RpcConnection* conn;
+  BOOL set_ready_event = FALSE;
+
+  TRACE("(the_arg == ^%p)\n", the_arg);
+  SetThreadDescription(GetCurrentThread(), L"wine_rpcrt4_server");
+
+  for (;;) {
+    objs = cps->ops->get_wait_array(cps, objs, &count);
+
+    if (set_ready_event)
+    {
+        /* signal to function that changed state that we are now sync'ed */
+        SetEvent(cps->server_ready_event);
+        set_ready_event = FALSE;
+    }
+
+    /* start waiting */
+    res = cps->ops->wait_for_new_connection(cps, count, objs);
+
+    if (res == -1 || (res == 0 && !std_listen))
+    {
+      /* cleanup */
+      cps->ops->free_wait_array(cps, objs);
+      break;
+    }
+    else if (res == 0)
+      set_ready_event = TRUE;
+  }
+
+  TRACE("closing connections\n");
+
+  EnterCriticalSection(&cps->cs);
+  LIST_FOR_EACH_ENTRY(conn, &cps->listeners, RpcConnection, protseq_entry)
+    RPCRT4_CloseConnection(conn);
+  LIST_FOR_EACH_ENTRY(conn, &cps->connections, RpcConnection, protseq_entry)
+  {
+    RPCRT4_GrabConnection(conn);
+    rpcrt4_conn_close_read(conn);
+  }
+  LeaveCriticalSection(&cps->cs);
+
+  if (res == 0 && !std_listen)
+      SetEvent(cps->server_ready_event);
+
+  TRACE("waiting for active connections to close\n");
+
+  EnterCriticalSection(&cps->cs);
+  while (!list_empty(&cps->connections))
+  {
+    conn = LIST_ENTRY(list_head(&cps->connections), RpcConnection, protseq_entry);
+    LeaveCriticalSection(&cps->cs);
+    rpcrt4_conn_release_and_wait(conn);
+    EnterCriticalSection(&cps->cs);
+  }
+  LeaveCriticalSection(&cps->cs);
+
+  EnterCriticalSection(&listen_cs);
+  CloseHandle(cps->server_thread);
+  cps->server_thread = NULL;
+  LeaveCriticalSection(&listen_cs);
+  TRACE("done\n");
+  return 0;
+}
+
+/* tells the server thread that the state has changed and waits for it to
+ * make the changes */
+static void RPCRT4_sync_with_server_thread(RpcServerProtseq *ps)
+{
+  /* make sure we are the only thread sync'ing the server state, otherwise
+   * there is a race with the server thread setting an older state and setting
+   * the server_ready_event when the new state hasn't yet been applied */
+  WaitForSingleObject(ps->mgr_mutex, INFINITE);
+
+  ps->ops->signal_state_changed(ps);
+
+  /* wait for server thread to make the requested changes before returning */
+  WaitForSingleObject(ps->server_ready_event, INFINITE);
+
+  ReleaseMutex(ps->mgr_mutex);
+}
+
+static RPC_STATUS RPCRT4_start_listen_protseq(RpcServerProtseq *ps, BOOL auto_listen)
+{
+  RPC_STATUS status = RPC_S_OK;
+
+  EnterCriticalSection(&listen_cs);
+  if (ps->server_thread) goto done;
+
+  if (!ps->mgr_mutex) ps->mgr_mutex = CreateMutexW(NULL, FALSE, NULL);
+  if (!ps->server_ready_event) ps->server_ready_event = CreateEventW(NULL, FALSE, FALSE, NULL);
+  ps->server_thread = CreateThread(NULL, 0, RPCRT4_server_thread, ps, 0, NULL);
+  if (!ps->server_thread)
+    status = RPC_S_OUT_OF_RESOURCES;
+
+done:
+  LeaveCriticalSection(&listen_cs);
+  return status;
+}
+
+static RPC_STATUS RPCRT4_start_listen(BOOL auto_listen)
+{
+  RPC_STATUS status = RPC_S_ALREADY_LISTENING;
+  RpcServerProtseq *cps;
+
+  TRACE("\n");
+
+  EnterCriticalSection(&listen_cs);
+  if (auto_listen || !listen_done_event)
+  {
+    status = RPC_S_OK;
+    if(!auto_listen)
+      listen_done_event = CreateEventW(NULL, TRUE, FALSE, NULL);
+    if (++listen_count == 1)
+      std_listen = TRUE;
+  }
+  LeaveCriticalSection(&listen_cs);
+  if (status) return status;
+
+  if (std_listen)
+  {
+    EnterCriticalSection(&server_cs);
+    LIST_FOR_EACH_ENTRY(cps, &protseqs, RpcServerProtseq, entry)
+    {
+      status = RPCRT4_start_listen_protseq(cps, TRUE);
+      if (status != RPC_S_OK)
+        break;
+      
+      /* make sure server is actually listening on the interface before
+       * returning */
+      RPCRT4_sync_with_server_thread(cps);
+    }
+    LeaveCriticalSection(&server_cs);
+  }
+
+  return status;
+}
+
+static RPC_STATUS RPCRT4_stop_listen(BOOL auto_listen)
+{
+  BOOL stop_listen = FALSE;
+  RPC_STATUS status = RPC_S_OK;
+
+  EnterCriticalSection(&listen_cs);
+  if (!std_listen && (auto_listen || !listen_done_event))
+  {
+    status = RPC_S_NOT_LISTENING;
+  }
+  else
+  {
+    stop_listen = listen_count != 0 && --listen_count == 0;
+    assert(listen_count >= 0);
+    if (stop_listen)
+      std_listen = FALSE;
+  }
+  LeaveCriticalSection(&listen_cs);
+
+  if (status) return status;
+
+  if (stop_listen) {
+    RpcServerProtseq *cps;
+    EnterCriticalSection(&server_cs);
+    LIST_FOR_EACH_ENTRY(cps, &protseqs, RpcServerProtseq, entry)
+      RPCRT4_sync_with_server_thread(cps);
+    LeaveCriticalSection(&server_cs);
+  }
+
+  if (!auto_listen)
+  {
+      EnterCriticalSection(&listen_cs);
+      SetEvent( listen_done_event );
+      LeaveCriticalSection(&listen_cs);
+  }
+  return RPC_S_OK;
+}
+
+static BOOL RPCRT4_protseq_is_endpoint_registered(RpcServerProtseq *protseq, const char *endpoint)
+{
+  RpcConnection *conn;
+  BOOL registered = FALSE;
+  EnterCriticalSection(&protseq->cs);
+  LIST_FOR_EACH_ENTRY(conn, &protseq->listeners, RpcConnection, protseq_entry) {
+    if (!endpoint || !strcmp(endpoint, conn->Endpoint)) {
+      registered = TRUE;
+      break;
+    }
+  }
+  LeaveCriticalSection(&protseq->cs);
+  return registered;
+}
+
+static RPC_STATUS RPCRT4_use_protseq(RpcServerProtseq* ps, const char *endpoint)
+{
+  RPC_STATUS status;
+
+  EnterCriticalSection(&ps->cs);
+
+  if (RPCRT4_protseq_is_endpoint_registered(ps, endpoint))
+    status = RPC_S_OK;
+  else
+    status = ps->ops->open_endpoint(ps, endpoint);
+
+  LeaveCriticalSection(&ps->cs);
+
+  if (status != RPC_S_OK)
+    return status;
+
+  if (std_listen)
+  {
+    status = RPCRT4_start_listen_protseq(ps, FALSE);
+    if (status == RPC_S_OK)
+      RPCRT4_sync_with_server_thread(ps);
+  }
+
+  return status;
+}
+
+/***********************************************************************
+ *             RpcServerInqBindings (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcServerInqBindings( RPC_BINDING_VECTOR** BindingVector )
+{
+  RPC_STATUS status;
+  DWORD count;
+  RpcServerProtseq* ps;
+  RpcConnection* conn;
+
+  if (BindingVector)
+    TRACE("(*BindingVector == ^%p)\n", *BindingVector);
+  else
+    ERR("(BindingVector == NULL!!?)\n");
+
+  EnterCriticalSection(&server_cs);
+  /* count connections */
+  count = 0;
+  LIST_FOR_EACH_ENTRY(ps, &protseqs, RpcServerProtseq, entry) {
+    EnterCriticalSection(&ps->cs);
+    LIST_FOR_EACH_ENTRY(conn, &ps->listeners, RpcConnection, protseq_entry)
+      count++;
+    LeaveCriticalSection(&ps->cs);
+  }
+  if (count) {
+    /* export bindings */
+    *BindingVector = malloc(sizeof(RPC_BINDING_VECTOR) + sizeof(RPC_BINDING_HANDLE) * (count - 1));
+    (*BindingVector)->Count = count;
+    count = 0;
+    LIST_FOR_EACH_ENTRY(ps, &protseqs, RpcServerProtseq, entry) {
+      EnterCriticalSection(&ps->cs);
+      LIST_FOR_EACH_ENTRY(conn, &ps->listeners, RpcConnection, protseq_entry) {
+       RPCRT4_MakeBinding((RpcBinding**)&(*BindingVector)->BindingH[count],
+                          conn);
+       count++;
+      }
+      LeaveCriticalSection(&ps->cs);
+    }
+    status = RPC_S_OK;
+  } else {
+    *BindingVector = NULL;
+    status = RPC_S_NO_BINDINGS;
+  }
+  LeaveCriticalSection(&server_cs);
+  return status;
+}
+
+/***********************************************************************
+ *             RpcServerUseProtseqEpA (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcServerUseProtseqEpA( RPC_CSTR Protseq, UINT MaxCalls, RPC_CSTR Endpoint, LPVOID SecurityDescriptor )
+{
+  RPC_POLICY policy;
+  
+  TRACE( "(%s,%u,%s,%p)\n", Protseq, MaxCalls, Endpoint, SecurityDescriptor );
+  
+  /* This should provide the default behaviour */
+  policy.Length        = sizeof( policy );
+  policy.EndpointFlags = 0;
+  policy.NICFlags      = 0;
+  
+  return RpcServerUseProtseqEpExA( Protseq, MaxCalls, Endpoint, SecurityDescriptor, &policy );
+}
+
+/***********************************************************************
+ *             RpcServerUseProtseqEpW (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcServerUseProtseqEpW( RPC_WSTR Protseq, UINT MaxCalls, RPC_WSTR Endpoint, LPVOID SecurityDescriptor )
+{
+  RPC_POLICY policy;
+  
+  TRACE( "(%s,%u,%s,%p)\n", debugstr_w( Protseq ), MaxCalls, debugstr_w( Endpoint ), SecurityDescriptor );
+  
+  /* This should provide the default behaviour */
+  policy.Length        = sizeof( policy );
+  policy.EndpointFlags = 0;
+  policy.NICFlags      = 0;
+  
+  return RpcServerUseProtseqEpExW( Protseq, MaxCalls, Endpoint, SecurityDescriptor, &policy );
+}
+
+/***********************************************************************
+ *             alloc_serverprotoseq (internal)
+ *
+ * Must be called with server_cs held.
+ */
+static RPC_STATUS alloc_serverprotoseq(UINT MaxCalls, const char *Protseq, RpcServerProtseq **ps)
+{
+  const struct protseq_ops *ops = rpcrt4_get_protseq_ops(Protseq);
+
+  if (!ops)
+  {
+    FIXME("protseq %s not supported\n", debugstr_a(Protseq));
+    return RPC_S_PROTSEQ_NOT_SUPPORTED;
+  }
+
+  *ps = ops->alloc();
+  if (!*ps)
+    return RPC_S_OUT_OF_RESOURCES;
+  (*ps)->MaxCalls = MaxCalls;
+  (*ps)->Protseq = strdup(Protseq);
+  (*ps)->ops = ops;
+  list_init(&(*ps)->listeners);
+  list_init(&(*ps)->connections);
+  InitializeCriticalSectionEx(&(*ps)->cs, 0, RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO);
+  (*ps)->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": RpcServerProtseq.cs");
+
+  list_add_head(&protseqs, &(*ps)->entry);
+
+  TRACE("new protseq %p created for %s\n", *ps, Protseq);
+
+  return RPC_S_OK;
+}
+
+/* must be called with server_cs held */
+static void destroy_serverprotoseq(RpcServerProtseq *ps)
+{
+    free(ps->Protseq);
+    ps->cs.DebugInfo->Spare[0] = 0;
+    DeleteCriticalSection(&ps->cs);
+    CloseHandle(ps->mgr_mutex);
+    CloseHandle(ps->server_ready_event);
+    list_remove(&ps->entry);
+    free(ps);
+}
+
+/* Finds a given protseq or creates a new one if one doesn't already exist */
+static RPC_STATUS RPCRT4_get_or_create_serverprotseq(UINT MaxCalls, const char *Protseq, RpcServerProtseq **ps)
+{
+    RPC_STATUS status;
+    RpcServerProtseq *cps;
+
+    EnterCriticalSection(&server_cs);
+
+    LIST_FOR_EACH_ENTRY(cps, &protseqs, RpcServerProtseq, entry)
+        if (!strcmp(cps->Protseq, Protseq))
+        {
+            TRACE("found existing protseq object for %s\n", Protseq);
+            *ps = cps;
+            LeaveCriticalSection(&server_cs);
+            return S_OK;
+        }
+
+    status = alloc_serverprotoseq(MaxCalls, Protseq, ps);
+
+    LeaveCriticalSection(&server_cs);
+
+    return status;
+}
+
+/***********************************************************************
+ *             RpcServerUseProtseqEpExA (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcServerUseProtseqEpExA( RPC_CSTR Protseq, UINT MaxCalls, RPC_CSTR Endpoint, LPVOID SecurityDescriptor,
+                                            PRPC_POLICY lpPolicy )
+{
+  RpcServerProtseq* ps;
+  RPC_STATUS status;
+
+  TRACE("(%s,%u,%s,%p,{%u,%lu,%lu})\n", debugstr_a((const char *)Protseq),
+       MaxCalls, debugstr_a((const char *)Endpoint), SecurityDescriptor,
+       lpPolicy->Length, lpPolicy->EndpointFlags, lpPolicy->NICFlags );
+
+  status = RPCRT4_get_or_create_serverprotseq(MaxCalls, (const char *)Protseq, &ps);
+  if (status != RPC_S_OK)
+    return status;
+
+  return RPCRT4_use_protseq(ps, (const char *)Endpoint);
+}
+
+/***********************************************************************
+ *             RpcServerUseProtseqEpExW (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcServerUseProtseqEpExW( RPC_WSTR Protseq, UINT MaxCalls, RPC_WSTR Endpoint, LPVOID SecurityDescriptor,
+                                            PRPC_POLICY lpPolicy )
+{
+  RpcServerProtseq* ps;
+  RPC_STATUS status;
+  LPSTR ProtseqA;
+  LPSTR EndpointA;
+
+  TRACE("(%s,%u,%s,%p,{%u,%lu,%lu})\n", debugstr_w( Protseq ), MaxCalls,
+       debugstr_w( Endpoint ), SecurityDescriptor,
+       lpPolicy->Length, lpPolicy->EndpointFlags, lpPolicy->NICFlags );
+
+  ProtseqA = RPCRT4_strdupWtoA(Protseq);
+  status = RPCRT4_get_or_create_serverprotseq(MaxCalls, ProtseqA, &ps);
+  free(ProtseqA);
+  if (status != RPC_S_OK)
+    return status;
+
+  EndpointA = RPCRT4_strdupWtoA(Endpoint);
+  status = RPCRT4_use_protseq(ps, EndpointA);
+  free(EndpointA);
+  return status;
+}
+
+/***********************************************************************
+ *             RpcServerUseProtseqA (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcServerUseProtseqA(RPC_CSTR Protseq, unsigned int MaxCalls, void *SecurityDescriptor)
+{
+  RPC_STATUS status;
+  RpcServerProtseq* ps;
+
+  TRACE("(Protseq == %s, MaxCalls == %d, SecurityDescriptor == ^%p)\n", debugstr_a((char*)Protseq), MaxCalls, SecurityDescriptor);
+
+  status = RPCRT4_get_or_create_serverprotseq(MaxCalls, (const char *)Protseq, &ps);
+  if (status != RPC_S_OK)
+    return status;
+
+  return RPCRT4_use_protseq(ps, NULL);
+}
+
+/***********************************************************************
+ *             RpcServerUseProtseqW (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcServerUseProtseqW(RPC_WSTR Protseq, unsigned int MaxCalls, void *SecurityDescriptor)
+{
+  RPC_STATUS status;
+  RpcServerProtseq* ps;
+  LPSTR ProtseqA;
+
+  TRACE("Protseq == %s, MaxCalls == %d, SecurityDescriptor == ^%p)\n", debugstr_w(Protseq), MaxCalls, SecurityDescriptor);
+
+  ProtseqA = RPCRT4_strdupWtoA(Protseq);
+  status = RPCRT4_get_or_create_serverprotseq(MaxCalls, ProtseqA, &ps);
+  free(ProtseqA);
+  if (status != RPC_S_OK)
+    return status;
+
+  return RPCRT4_use_protseq(ps, NULL);
+}
+
+void RPCRT4_destroy_all_protseqs(void)
+{
+    RpcServerProtseq *cps, *cursor2;
+
+    if (listen_count != 0)
+        std_listen = FALSE;
+
+    EnterCriticalSection(&server_cs);
+    LIST_FOR_EACH_ENTRY_SAFE(cps, cursor2, &protseqs, RpcServerProtseq, entry)
+    {
+        if (listen_count != 0)
+            RPCRT4_sync_with_server_thread(cps);
+        destroy_serverprotoseq(cps);
+    }
+    LeaveCriticalSection(&server_cs);
+    DeleteCriticalSection(&server_cs);
+    DeleteCriticalSection(&listen_cs);
+}
+
+/***********************************************************************
+ *             RpcServerRegisterIf (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcServerRegisterIf( RPC_IF_HANDLE IfSpec, UUID* MgrTypeUuid, RPC_MGR_EPV* MgrEpv )
+{
+  TRACE("(%p,%s,%p)\n", IfSpec, debugstr_guid(MgrTypeUuid), MgrEpv);
+  return RpcServerRegisterIf3( IfSpec, MgrTypeUuid, MgrEpv, 0, RPC_C_LISTEN_MAX_CALLS_DEFAULT, (UINT)-1, NULL, NULL );
+}
+
+/***********************************************************************
+ *             RpcServerRegisterIfEx (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcServerRegisterIfEx( RPC_IF_HANDLE IfSpec, UUID* MgrTypeUuid, RPC_MGR_EPV* MgrEpv,
+                       UINT Flags, UINT MaxCalls, RPC_IF_CALLBACK_FN* IfCallbackFn )
+{
+  TRACE("(%p,%s,%p,%u,%u,%p)\n", IfSpec, debugstr_guid(MgrTypeUuid), MgrEpv, Flags, MaxCalls, IfCallbackFn);
+  return RpcServerRegisterIf3( IfSpec, MgrTypeUuid, MgrEpv, Flags, MaxCalls, (UINT)-1, IfCallbackFn, NULL );
+}
+
+/***********************************************************************
+ *             RpcServerRegisterIf2 (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcServerRegisterIf2( RPC_IF_HANDLE IfSpec, UUID* MgrTypeUuid, RPC_MGR_EPV* MgrEpv,
+                      UINT Flags, UINT MaxCalls, UINT MaxRpcSize, RPC_IF_CALLBACK_FN* IfCallbackFn )
+{
+  return RpcServerRegisterIf3( IfSpec, MgrTypeUuid, MgrEpv, Flags, MaxCalls, MaxRpcSize, IfCallbackFn, NULL );
+}
+
+/***********************************************************************
+ *             RpcServerRegisterIf3 (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcServerRegisterIf3( RPC_IF_HANDLE IfSpec, UUID* MgrTypeUuid, RPC_MGR_EPV* MgrEpv,
+    UINT Flags, UINT MaxCalls, UINT MaxRpcSize, RPC_IF_CALLBACK_FN* IfCallbackFn, void* SecurityDescriptor)
+{
+  PRPC_SERVER_INTERFACE If = IfSpec;
+  RpcServerInterface* sif;
+  unsigned int i;
+
+  TRACE("(%p,%s,%p,%u,%u,%u,%p,%p)\n", IfSpec, debugstr_guid(MgrTypeUuid), MgrEpv, Flags, MaxCalls,
+        MaxRpcSize, IfCallbackFn, SecurityDescriptor);
+
+  if (SecurityDescriptor)
+      FIXME("Unsupported SecurityDescriptor argument.\n");
+
+  TRACE(" interface id: %s %d.%d\n", debugstr_guid(&If->InterfaceId.SyntaxGUID),
+                                     If->InterfaceId.SyntaxVersion.MajorVersion,
+                                     If->InterfaceId.SyntaxVersion.MinorVersion);
+  TRACE(" transfer syntax: %s %d.%d\n", debugstr_guid(&If->TransferSyntax.SyntaxGUID),
+                                        If->TransferSyntax.SyntaxVersion.MajorVersion,
+                                        If->TransferSyntax.SyntaxVersion.MinorVersion);
+  TRACE(" dispatch table: %p\n", If->DispatchTable);
+  if (If->DispatchTable) {
+    TRACE("  dispatch table count: %d\n", If->DispatchTable->DispatchTableCount);
+    for (i=0; i<If->DispatchTable->DispatchTableCount; i++) {
+      TRACE("   entry %d: %p\n", i, If->DispatchTable->DispatchTable[i]);
+    }
+    TRACE("  reserved: %Id\n", If->DispatchTable->Reserved);
+  }
+  TRACE(" protseq endpoint count: %d\n", If->RpcProtseqEndpointCount);
+  TRACE(" default manager epv: %p\n", If->DefaultManagerEpv);
+  TRACE(" interpreter info: %p\n", If->InterpreterInfo);
+
+  sif = calloc(1, sizeof(RpcServerInterface));
+  sif->If           = If;
+  if (MgrTypeUuid) {
+    sif->MgrTypeUuid = *MgrTypeUuid;
+    sif->MgrEpv       = MgrEpv;
+  } else {
+    memset(&sif->MgrTypeUuid, 0, sizeof(UUID));
+    sif->MgrEpv       = If->DefaultManagerEpv;
+  }
+  sif->Flags        = Flags;
+  sif->MaxCalls     = MaxCalls;
+  sif->MaxRpcSize   = MaxRpcSize;
+  sif->IfCallbackFn = IfCallbackFn;
+
+  EnterCriticalSection(&server_cs);
+  list_add_head(&server_interfaces, &sif->entry);
+  LeaveCriticalSection(&server_cs);
+
+  if (sif->Flags & RPC_IF_AUTOLISTEN)
+      RPCRT4_start_listen(TRUE);
+
+  return RPC_S_OK;
+}
+
+/***********************************************************************
+ *             RpcServerUnregisterIf (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcServerUnregisterIf( RPC_IF_HANDLE IfSpec, UUID* MgrTypeUuid, UINT WaitForCallsToComplete )
+{
+  PRPC_SERVER_INTERFACE If = IfSpec;
+  HANDLE event = NULL;
+  BOOL found = FALSE;
+  BOOL completed = TRUE;
+  RpcServerInterface *cif;
+  RPC_STATUS status;
+
+  TRACE("(IfSpec == (RPC_IF_HANDLE)^%p (%s), MgrTypeUuid == %s, WaitForCallsToComplete == %u)\n",
+    IfSpec, debugstr_guid(&If->InterfaceId.SyntaxGUID), debugstr_guid(MgrTypeUuid), WaitForCallsToComplete);
+
+  EnterCriticalSection(&server_cs);
+  LIST_FOR_EACH_ENTRY(cif, &server_interfaces, RpcServerInterface, entry) {
+    if (((!IfSpec && !(cif->Flags & RPC_IF_AUTOLISTEN)) ||
+        (IfSpec && !memcmp(&If->InterfaceId, &cif->If->InterfaceId, sizeof(RPC_SYNTAX_IDENTIFIER)))) &&
+        UuidEqual(MgrTypeUuid, &cif->MgrTypeUuid, &status)) {
+      list_remove(&cif->entry);
+      TRACE("unregistering cif %p\n", cif);
+      if (cif->CurrentCalls) {
+        completed = FALSE;
+        cif->Delete = TRUE;
+        if (WaitForCallsToComplete)
+          cif->CallsCompletedEvent = event = CreateEventW(NULL, FALSE, FALSE, NULL);
+      }
+      found = TRUE;
+      break;
+    }
+  }
+  LeaveCriticalSection(&server_cs);
+
+  if (!found) {
+    ERR("not found for object %s\n", debugstr_guid(MgrTypeUuid));
+    return RPC_S_UNKNOWN_IF;
+  }
+
+  if (completed)
+    free(cif);
+  else if (event) {
+    /* sif will be freed when the last call is completed, so be careful not to
+     * touch that memory here as that could happen before we get here */
+    WaitForSingleObject(event, INFINITE);
+    CloseHandle(event);
+  }
+
+  return RPC_S_OK;
+}
+
+/***********************************************************************
+ *             RpcServerUnregisterIfEx (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcServerUnregisterIfEx( RPC_IF_HANDLE IfSpec, UUID* MgrTypeUuid, int RundownContextHandles )
+{
+  FIXME("(IfSpec == (RPC_IF_HANDLE)^%p, MgrTypeUuid == %s, RundownContextHandles == %d): stub\n",
+    IfSpec, debugstr_guid(MgrTypeUuid), RundownContextHandles);
+
+  return RPC_S_OK;
+}
+
+/***********************************************************************
+ *             RpcObjectSetType (RPCRT4.@)
+ *
+ * PARAMS
+ *   ObjUuid  [I] "Object" UUID
+ *   TypeUuid [I] "Type" UUID
+ *
+ * RETURNS
+ *   RPC_S_OK                 The call succeeded
+ *   RPC_S_INVALID_OBJECT     The provided object (nil) is not valid
+ *   RPC_S_ALREADY_REGISTERED The provided object is already registered
+ *
+ * Maps "Object" UUIDs to "Type" UUIDs.  Passing the nil UUID as the type
+ * resets the mapping for the specified object UUID to nil (the default).
+ * The nil object is always associated with the nil type and cannot be
+ * reassigned.  Servers can support multiple implementations on the same
+ * interface by registering different end-point vectors for the different
+ * types.  There's no need to call this if a server only supports the nil
+ * type, as is typical.
+ */
+RPC_STATUS WINAPI RpcObjectSetType( UUID* ObjUuid, UUID* TypeUuid )
+{
+  RpcObjTypeMap *map = RpcObjTypeMaps, *prev = NULL;
+  RPC_STATUS dummy;
+
+  TRACE("(ObjUUID == %s, TypeUuid == %s).\n", debugstr_guid(ObjUuid), debugstr_guid(TypeUuid));
+  if ((! ObjUuid) || UuidIsNil(ObjUuid, &dummy)) {
+    /* nil uuid cannot be remapped */
+    return RPC_S_INVALID_OBJECT;
+  }
+
+  /* find the mapping for this object if there is one ... */
+  while (map) {
+    if (! UuidCompare(ObjUuid, &map->Object, &dummy)) break;
+    prev = map;
+    map = map->next;
+  }
+  if ((! TypeUuid) || UuidIsNil(TypeUuid, &dummy)) {
+    /* ... and drop it from the list */
+    if (map) {
+      if (prev) 
+        prev->next = map->next;
+      else
+        RpcObjTypeMaps = map->next;
+      free(map);
+    }
+  } else {
+    /* ... , fail if we found it ... */
+    if (map)
+      return RPC_S_ALREADY_REGISTERED;
+    /* ... otherwise create a new one and add it in. */
+    map = malloc(sizeof(RpcObjTypeMap));
+    map->Object = *ObjUuid;
+    map->Type = *TypeUuid;
+    map->next = NULL;
+    if (prev)
+      prev->next = map; /* prev is the last map in the linklist */
+    else
+      RpcObjTypeMaps = map;
+  }
+
+  return RPC_S_OK;
+}
+
+struct rpc_server_registered_auth_info
+{
+    struct list entry;
+    USHORT auth_type;
+    WCHAR *package_name;
+    WCHAR *principal;
+    ULONG max_token;
+};
+
+static RPC_STATUS find_security_package(ULONG auth_type, SecPkgInfoW **packages_buf, SecPkgInfoW **ret)
+{
+    SECURITY_STATUS sec_status;
+    SecPkgInfoW *packages;
+    ULONG package_count;
+    ULONG i;
+
+    sec_status = EnumerateSecurityPackagesW(&package_count, &packages);
+    if (sec_status != SEC_E_OK)
+    {
+        ERR("EnumerateSecurityPackagesW failed with error 0x%08lx\n", sec_status);
+        return RPC_S_SEC_PKG_ERROR;
+    }
+
+    for (i = 0; i < package_count; i++)
+        if (packages[i].wRPCID == auth_type)
+            break;
+
+    if (i == package_count)
+    {
+        WARN("unsupported AuthnSvc %lu\n", auth_type);
+        FreeContextBuffer(packages);
+        return RPC_S_UNKNOWN_AUTHN_SERVICE;
+    }
+
+    TRACE("found package %s for service %lu\n", debugstr_w(packages[i].Name), auth_type);
+    *packages_buf = packages;
+    *ret = packages + i;
+    return RPC_S_OK;
+}
+
+RPC_STATUS RPCRT4_ServerGetRegisteredAuthInfo(
+    USHORT auth_type, CredHandle *cred, TimeStamp *exp, ULONG *max_token)
+{
+    RPC_STATUS status = RPC_S_UNKNOWN_AUTHN_SERVICE;
+    struct rpc_server_registered_auth_info *auth_info;
+    SECURITY_STATUS sec_status;
+
+    EnterCriticalSection(&server_auth_info_cs);
+    LIST_FOR_EACH_ENTRY(auth_info, &server_registered_auth_info, struct rpc_server_registered_auth_info, entry)
+    {
+        if (auth_info->auth_type == auth_type)
+        {
+            sec_status = AcquireCredentialsHandleW((SEC_WCHAR *)auth_info->principal, auth_info->package_name,
+                                                   SECPKG_CRED_INBOUND, NULL, NULL, NULL, NULL,
+                                                   cred, exp);
+            if (sec_status != SEC_E_OK)
+            {
+                status = RPC_S_SEC_PKG_ERROR;
+                break;
+            }
+
+            *max_token = auth_info->max_token;
+            status = RPC_S_OK;
+            break;
+        }
+    }
+    LeaveCriticalSection(&server_auth_info_cs);
+
+    return status;
+}
+
+void RPCRT4_ServerFreeAllRegisteredAuthInfo(void)
+{
+    struct rpc_server_registered_auth_info *auth_info, *cursor2;
+
+    EnterCriticalSection(&server_auth_info_cs);
+    LIST_FOR_EACH_ENTRY_SAFE(auth_info, cursor2, &server_registered_auth_info, struct rpc_server_registered_auth_info, entry)
+    {
+        free(auth_info->package_name);
+        free(auth_info->principal);
+        free(auth_info);
+    }
+    LeaveCriticalSection(&server_auth_info_cs);
+    DeleteCriticalSection(&server_auth_info_cs);
+}
+
+/***********************************************************************
+ *             RpcServerRegisterAuthInfoA (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcServerRegisterAuthInfoA( RPC_CSTR ServerPrincName, ULONG AuthnSvc, RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn,
+                            LPVOID Arg )
+{
+    WCHAR *principal_name = NULL;
+    RPC_STATUS status;
+
+    TRACE("(%s,%lu,%p,%p)\n", ServerPrincName, AuthnSvc, GetKeyFn, Arg);
+
+    if(ServerPrincName && !(principal_name = RPCRT4_strdupAtoW((const char*)ServerPrincName)))
+        return RPC_S_OUT_OF_RESOURCES;
+
+    status = RpcServerRegisterAuthInfoW(principal_name, AuthnSvc, GetKeyFn, Arg);
+
+    free(principal_name);
+    return status;
+}
+
+/***********************************************************************
+ *             RpcServerRegisterAuthInfoW (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcServerRegisterAuthInfoW( RPC_WSTR ServerPrincName, ULONG AuthnSvc, RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn,
+                            LPVOID Arg )
+{
+    struct rpc_server_registered_auth_info *auth_info;
+    SecPkgInfoW *packages, *package;
+    WCHAR *package_name;
+    ULONG max_token;
+    RPC_STATUS status;
+
+    TRACE("(%s,%lu,%p,%p)\n", debugstr_w(ServerPrincName), AuthnSvc, GetKeyFn, Arg);
+
+    status = find_security_package(AuthnSvc, &packages, &package);
+    if (status != RPC_S_OK)
+        return status;
+
+    package_name = wcsdup(package->Name);
+    max_token = package->cbMaxToken;
+    FreeContextBuffer(packages);
+    if (!package_name)
+        return RPC_S_OUT_OF_RESOURCES;
+
+    auth_info = calloc(1, sizeof(*auth_info));
+    if (!auth_info) {
+        free(package_name);
+        return RPC_S_OUT_OF_RESOURCES;
+    }
+
+    if (ServerPrincName && !(auth_info->principal = wcsdup(ServerPrincName))) {
+        free(package_name);
+        free(auth_info);
+        return RPC_S_OUT_OF_RESOURCES;
+    }
+
+    auth_info->auth_type = AuthnSvc;
+    auth_info->package_name = package_name;
+    auth_info->max_token = max_token;
+
+    EnterCriticalSection(&server_auth_info_cs);
+    list_add_tail(&server_registered_auth_info, &auth_info->entry);
+    LeaveCriticalSection(&server_auth_info_cs);
+
+    return RPC_S_OK;
+}
+
+/******************************************************************************
+ * RpcServerInqDefaultPrincNameA   (rpcrt4.@)
+ */
+RPC_STATUS RPC_ENTRY RpcServerInqDefaultPrincNameA(ULONG AuthnSvc, RPC_CSTR *PrincName)
+{
+    RPC_STATUS ret;
+    RPC_WSTR principalW;
+
+    TRACE("%lu, %p\n", AuthnSvc, PrincName);
+
+    if ((ret = RpcServerInqDefaultPrincNameW( AuthnSvc, &principalW )) == RPC_S_OK)
+    {
+        if (!(*PrincName = (RPC_CSTR)RPCRT4_strdupWtoA( principalW ))) return RPC_S_OUT_OF_MEMORY;
+        RpcStringFreeW( &principalW );
+    }
+    return ret;
+}
+
+/******************************************************************************
+ * RpcServerInqDefaultPrincNameW   (rpcrt4.@)
+ */
+RPC_STATUS RPC_ENTRY RpcServerInqDefaultPrincNameW(ULONG AuthnSvc, RPC_WSTR *PrincName)
+{
+    ULONG len = 0;
+
+    FIXME("%lu, %p\n", AuthnSvc, PrincName);
+
+    if (AuthnSvc != RPC_C_AUTHN_WINNT) return RPC_S_UNKNOWN_AUTHN_SERVICE;
+
+    GetUserNameExW( NameSamCompatible, NULL, &len );
+    if (GetLastError() != ERROR_MORE_DATA) return RPC_S_INTERNAL_ERROR;
+
+    if (!(*PrincName = malloc(len * sizeof(WCHAR))))
+        return RPC_S_OUT_OF_MEMORY;
+
+    GetUserNameExW( NameSamCompatible, *PrincName, &len );
+    return RPC_S_OK;
+}
+
+/***********************************************************************
+ *             RpcServerListen (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcServerListen( UINT MinimumCallThreads, UINT MaxCalls, UINT DontWait )
+{
+  RPC_STATUS status = RPC_S_OK;
+
+  TRACE("(%u,%u,%u)\n", MinimumCallThreads, MaxCalls, DontWait);
+
+  if (list_empty(&protseqs))
+    return RPC_S_NO_PROTSEQS_REGISTERED;
+
+  status = RPCRT4_start_listen(FALSE);
+
+  if (DontWait || (status != RPC_S_OK)) return status;
+
+  return RpcMgmtWaitServerListen();
+}
+
+/***********************************************************************
+ *             RpcMgmtServerWaitListen (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcMgmtWaitServerListen( void )
+{
+  RpcServerProtseq *protseq;
+  HANDLE event, wait_thread;
+
+  TRACE("()\n");
+
+  EnterCriticalSection(&listen_cs);
+  event = listen_done_event;
+  LeaveCriticalSection(&listen_cs);
+
+  if (!event)
+      return RPC_S_NOT_LISTENING;
+
+  TRACE( "waiting for server calls to finish\n" );
+  WaitForSingleObject( event, INFINITE );
+  TRACE( "done waiting\n" );
+
+  EnterCriticalSection(&listen_cs);
+  /* wait for server threads to finish */
+  while(1)
+  {
+      if (listen_count)
+          break;
+
+      wait_thread = NULL;
+      EnterCriticalSection(&server_cs);
+      LIST_FOR_EACH_ENTRY(protseq, &protseqs, RpcServerProtseq, entry)
+      {
+          if ((wait_thread = protseq->server_thread))
+              break;
+      }
+      LeaveCriticalSection(&server_cs);
+      if (!wait_thread)
+          break;
+
+      TRACE("waiting for thread %lu\n", GetThreadId(wait_thread));
+      LeaveCriticalSection(&listen_cs);
+      WaitForSingleObject(wait_thread, INFINITE);
+      EnterCriticalSection(&listen_cs);
+  }
+  if (listen_done_event == event)
+  {
+      listen_done_event = NULL;
+      CloseHandle( event );
+  }
+  LeaveCriticalSection(&listen_cs);
+  return RPC_S_OK;
+}
+
+/***********************************************************************
+ *             RpcMgmtStopServerListening (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcMgmtStopServerListening ( RPC_BINDING_HANDLE Binding )
+{
+  TRACE("(Binding == (RPC_BINDING_HANDLE)^%p)\n", Binding);
+
+  if (Binding) {
+    FIXME("client-side invocation not implemented.\n");
+    return RPC_S_WRONG_KIND_OF_BINDING;
+  }
+  
+  return RPCRT4_stop_listen(FALSE);
+}
+
+/***********************************************************************
+ *             RpcMgmtEnableIdleCleanup (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcMgmtEnableIdleCleanup(void)
+{
+    FIXME("(): stub\n");
+    return RPC_S_OK;
+}
+
+/***********************************************************************
+ *             I_RpcServerStartListening (RPCRT4.@)
+ */
+RPC_STATUS WINAPI I_RpcServerStartListening( HWND hWnd )
+{
+  FIXME( "(%p): stub\n", hWnd );
+
+  return RPC_S_OK;
+}
+
+/***********************************************************************
+ *             I_RpcServerStopListening (RPCRT4.@)
+ */
+RPC_STATUS WINAPI I_RpcServerStopListening( void )
+{
+  FIXME( "(): stub\n" );
+
+  return RPC_S_OK;
+}
+
+/***********************************************************************
+ *             I_RpcWindowProc (RPCRT4.@)
+ */
+UINT WINAPI I_RpcWindowProc( void *hWnd, UINT Message, UINT wParam, ULONG lParam )
+{
+  FIXME( "(%p,%08x,%08x,%08lx): stub\n", hWnd, Message, wParam, lParam );
+
+  return 0;
+}
+
+/***********************************************************************
+ *             RpcMgmtInqIfIds (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcMgmtInqIfIds(RPC_BINDING_HANDLE Binding, RPC_IF_ID_VECTOR **IfIdVector)
+{
+  FIXME("(%p,%p): stub\n", Binding, IfIdVector);
+  return RPC_S_INVALID_BINDING;
+}
+
+/***********************************************************************
+ *             RpcMgmtInqStats (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcMgmtInqStats(RPC_BINDING_HANDLE Binding, RPC_STATS_VECTOR **Statistics)
+{
+  RPC_STATS_VECTOR *stats;
+
+  FIXME("(%p,%p)\n", Binding, Statistics);
+
+  if ((stats = malloc(sizeof(RPC_STATS_VECTOR))))
+  {
+    stats->Count = 1;
+    stats->Stats[0] = 0;
+    *Statistics = stats;
+    return RPC_S_OK;
+  }
+  return RPC_S_OUT_OF_RESOURCES;
+}
+
+/***********************************************************************
+ *             RpcMgmtStatsVectorFree (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcMgmtStatsVectorFree(RPC_STATS_VECTOR **StatsVector)
+{
+  FIXME("(%p)\n", StatsVector);
+
+  if (StatsVector)
+  {
+    free(*StatsVector);
+    *StatsVector = NULL;
+  }
+  return RPC_S_OK;
+}
+
+/***********************************************************************
+ *             RpcMgmtEpEltInqBegin (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcMgmtEpEltInqBegin(RPC_BINDING_HANDLE Binding, ULONG InquiryType,
+    RPC_IF_ID *IfId, ULONG VersOption, UUID *ObjectUuid, RPC_EP_INQ_HANDLE* InquiryContext)
+{
+  FIXME("(%p,%lu,%p,%lu,%p,%p): stub\n",
+        Binding, InquiryType, IfId, VersOption, ObjectUuid, InquiryContext);
+  return RPC_S_INVALID_BINDING;
+}
+
+/***********************************************************************
+ *             RpcMgmtIsServerListening (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcMgmtIsServerListening(RPC_BINDING_HANDLE Binding)
+{
+  RPC_STATUS status = RPC_S_NOT_LISTENING;
+
+  TRACE("(%p)\n", Binding);
+
+  if (Binding) {
+    RpcBinding *rpc_binding = (RpcBinding*)Binding;
+    status = RPCRT4_IsServerListening(rpc_binding->Protseq, rpc_binding->Endpoint);
+  }else {
+    EnterCriticalSection(&listen_cs);
+    if (listen_done_event && std_listen) status = RPC_S_OK;
+    LeaveCriticalSection(&listen_cs);
+  }
+
+  return status;
+}
+
+/***********************************************************************
+ *             RpcMgmtSetAuthorizationFn (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcMgmtSetAuthorizationFn(RPC_MGMT_AUTHORIZATION_FN fn)
+{
+  FIXME("(%p): stub\n", fn);
+  return RPC_S_OK;
+}
+
+/***********************************************************************
+ *             RpcMgmtSetServerStackSize (RPCRT4.@)
+ */
+RPC_STATUS WINAPI RpcMgmtSetServerStackSize(ULONG ThreadStackSize)
+{
+  FIXME("(0x%lx): stub\n", ThreadStackSize);
+  return RPC_S_OK;
+}
+
+/***********************************************************************
+ *             I_RpcGetCurrentCallHandle (RPCRT4.@)
+ */
+RPC_BINDING_HANDLE WINAPI I_RpcGetCurrentCallHandle(void)
+{
+    TRACE("\n");
+    return RPCRT4_GetThreadCurrentCallHandle();
+}
diff -ruN --show-c-function dlls/user32/tests/input.c dlls/user32/tests/input.c
--- dlls/user32/tests/input.c	2025-10-10 10:17:47.475751728 -0700
+++ dlls/user32/tests/input.c	2025-10-10 10:22:17.114365572 -0700
@@ -4316,8 +4316,8 @@ static void test_SendInput_mouse_message
 
     mouse_event( MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0 );
     wait_messages( 5, FALSE );
-    button_down_hwnd[1].message.hwnd = hwnd;
-    ok_seq( button_down_hwnd );
+    button_down_hwnd_todo[1].message.hwnd = hwnd;
+    ok_seq( button_down_hwnd_todo );
     mouse_event( MOUSEEVENTF_LEFTUP, 0, 0, 0, 0 );
     wait_messages( 5, FALSE );
     button_up_hwnd[1].message.hwnd = hwnd;
diff -ruN --show-c-function dlls/win32u/dce.c dlls/win32u/dce.c
--- dlls/win32u/dce.c	2025-10-10 10:17:47.494534953 -0700
+++ dlls/win32u/dce.c	2025-10-10 10:22:17.118829585 -0700
@@ -1803,7 +1803,7 @@ BOOL WINAPI NtUserRedrawWindow( HWND hwn
     }
 
     /* process pending expose events before painting */
-    if (flags & RDW_UPDATENOW) process_driver_events( QS_PAINT );
+    if (flags & RDW_UPDATENOW) user_driver->pProcessEvents( QS_PAINT );
 
     if (rect && !hrgn)
     {
diff -ruN --show-c-function dlls/win32u/hook.c dlls/win32u/hook.c
--- dlls/win32u/hook.c	2025-10-10 10:17:47.495752156 -0700
+++ dlls/win32u/hook.c	2025-10-10 10:22:17.123167901 -0700
@@ -31,7 +31,9 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(hook);
 
-static const char * const hook_names[NB_HOOKS] =
+#define WH_WINEVENT (WH_MAXHOOK+1)
+
+static const char * const hook_names[WH_WINEVENT - WH_MINHOOK + 1] =
 {
     "WH_MSGFILTER",
     "WH_JOURNALRECORD",
diff -ruN --show-c-function dlls/win32u/input.c dlls/win32u/input.c
--- dlls/win32u/input.c	2025-10-10 10:17:47.495752156 -0700
+++ dlls/win32u/input.c	2025-10-10 10:22:17.119006992 -0700
@@ -787,6 +787,21 @@ BOOL WINAPI NtUserGetCursorInfo( CURSORI
     return TRUE;
 }
 
+static void check_for_events( UINT flags )
+{
+    struct peek_message_filter filter =
+    {
+        .internal = TRUE,
+        .flags = PM_REMOVE,
+    };
+    MSG msg;
+
+    if (!user_driver->pProcessEvents( flags ))
+        flush_window_surfaces( TRUE );
+
+    peek_message( &msg, &filter );
+}
+
 /**********************************************************************
  *           GetAsyncKeyState (win32u.@)
  */
diff -ruN --show-c-function dlls/win32u/message.c dlls/win32u/message.c
--- dlls/win32u/message.c	2025-10-10 10:17:47.496752177 -0700
+++ dlls/win32u/message.c	2025-10-10 10:22:17.125365795 -0700
@@ -27,8 +27,6 @@
 #include <assert.h>
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
-#include "winternl.h"
-#include "ddk/wdm.h"
 #include "win32u_private.h"
 #include "ntuser_private.h"
 #include "winnls.h"
@@ -42,44 +40,6 @@ WINE_DEFAULT_DEBUG_CHANNEL(msg);
 WINE_DECLARE_DEBUG_CHANNEL(key);
 WINE_DECLARE_DEBUG_CHANNEL(relay);
 
-#define QS_DRIVER       0x80000000
-#define QS_HARDWARE     0x40000000
-#define QS_INTERNAL     (QS_DRIVER | QS_HARDWARE)
-
-static const struct _KUSER_SHARED_DATA *user_shared_data = (struct _KUSER_SHARED_DATA *)0x7ffe0000;
-
-static LONG atomic_load_long( const volatile LONG *ptr )
-{
-#if defined(__i386__) || defined(__x86_64__)
-    return *ptr;
-#else
-    return __atomic_load_n( ptr, __ATOMIC_SEQ_CST );
-#endif
-}
-
-static ULONG atomic_load_ulong( const volatile ULONG *ptr )
-{
-#if defined(__i386__) || defined(__x86_64__)
-    return *ptr;
-#else
-    return __atomic_load_n( ptr, __ATOMIC_SEQ_CST );
-#endif
-}
-
-static UINT64 get_tick_count(void)
-{
-    ULONG high, low;
-
-    do
-    {
-        high = atomic_load_long( &user_shared_data->TickCount.High1Time );
-        low = atomic_load_ulong( &user_shared_data->TickCount.LowPart );
-    }
-    while (high != atomic_load_long( &user_shared_data->TickCount.High2Time ));
-    /* note: we ignore TickCountMultiplier */
-    return (UINT64)high << 32 | low;
-}
-
 #define MAX_WINPROC_RECURSION  64
 
 #define WM_NCMOUSEFIRST WM_NCMOUSEMOVE
@@ -87,16 +47,6 @@ static UINT64 get_tick_count(void)
 
 #define MAX_PACK_COUNT 4
 
-struct peek_message_filter
-{
-    HWND hwnd;
-    UINT first;
-    UINT last;
-    UINT mask;
-    UINT flags;
-    BOOL internal;
-};
-
 /* info about the message currently being received by the current thread */
 struct received_message_info
 {
@@ -2828,7 +2778,7 @@ static BOOL check_queue_bits( UINT wake_
         {
             *wake_bits = queue_shm->wake_bits;
             *changed_bits = queue_shm->changed_bits;
-            skip = get_tick_count() - (UINT64)queue_shm->access_time / 10000 < 3000; /* avoid hung queue */
+            skip = TRUE;
         }
     }
 
@@ -2843,7 +2793,7 @@ static BOOL check_queue_bits( UINT wake_
  * available; -1 on error.
  * All pending sent messages are processed before returning.
  */
-static int peek_message( MSG *msg, const struct peek_message_filter *filter )
+int peek_message( MSG *msg, const struct peek_message_filter *filter )
 {
     LRESULT result;
     HWND hwnd = filter->hwnd;
@@ -2883,7 +2833,8 @@ static int peek_message( MSG *msg, const
         thread_info->client_info.msg_source = prev_source;
         wake_mask = filter->mask & (QS_SENDMESSAGE | QS_SMRESULT);
 
-        if (check_queue_bits( wake_mask, filter->mask, wake_mask | signal_bits, filter->mask | clear_bits,
+        if (NtGetTickCount() - thread_info->last_getmsg_time < 3000 && /* avoid hung queue */
+            check_queue_bits( wake_mask, filter->mask, wake_mask | signal_bits, filter->mask | clear_bits,
                               &wake_bits, &changed_bits ))
             res = STATUS_PENDING;
         else SERVER_START_REQ( get_message )
@@ -2897,6 +2848,7 @@ static int peek_message( MSG *msg, const
             req->wake_mask = wake_mask;
             req->changed_mask = filter->mask;
             wine_server_set_reply( req, buffer, buffer_size );
+            thread_info->last_getmsg_time = NtGetTickCount();
             if (!(res = wine_server_call( req )))
             {
                 size = wine_server_reply_size( reply );
@@ -3179,44 +3131,6 @@ static HANDLE get_server_queue_handle(vo
     return ret;
 }
 
-static BOOL has_hardware_messages(void)
-{
-    struct object_lock lock = OBJECT_LOCK_INIT;
-    const queue_shm_t *queue_shm;
-    BOOL signaled = FALSE;
-    UINT status;
-
-    while ((status = get_shared_queue( &lock, &queue_shm )) == STATUS_PENDING)
-        signaled = queue_shm->internal_bits & QS_HARDWARE;
-    if (status) return FALSE;
-
-    return signaled;
-}
-
-BOOL process_driver_events( UINT mask )
-{
-    if (user_driver->pProcessEvents( mask ))
-    {
-        SERVER_START_REQ( set_queue_mask )
-        {
-            req->poll_events = 1;
-            wine_server_call( req );
-        }
-        SERVER_END_REQ;
-    }
-
-    return has_hardware_messages();
-}
-
-void check_for_events( UINT flags )
-{
-    struct peek_message_filter filter = {.internal = TRUE, .flags = PM_REMOVE};
-    MSG msg;
-
-    if (!process_driver_events( flags )) flush_window_surfaces( TRUE );
-    peek_message( &msg, &filter );
-}
-
 /* monotonic timer tick for throttling driver event checks */
 static inline LONGLONG get_driver_check_time(void)
 {
@@ -3231,7 +3145,7 @@ static inline void check_for_driver_even
     if (get_user_thread_info()->last_driver_time != get_driver_check_time())
     {
         flush_window_surfaces( FALSE );
-        process_driver_events( QS_ALLINPUT );
+        user_driver->pProcessEvents( QS_ALLINPUT );
         get_user_thread_info()->last_driver_time = get_driver_check_time();
     }
 }
@@ -3260,12 +3174,12 @@ static DWORD wait_message( DWORD count,
         params.restore = TRUE;
     }
 
-    if (process_driver_events( QS_ALLINPUT )) ret = count - 1;
+    if (user_driver->pProcessEvents( mask )) ret = count - 1;
     else
     {
         ret = NtWaitForMultipleObjects( count, handles, !(flags & MWMO_WAITALL),
                                         !!(flags & MWMO_ALERTABLE), get_nt_timeout( &time, timeout ));
-        if (ret == count - 1) process_driver_events( QS_ALLINPUT );
+        if (ret == count - 1) user_driver->pProcessEvents( mask );
         else if (HIWORD(ret)) /* is it an error code? */
         {
             RtlSetLastWin32Error( RtlNtStatusToDosError(ret) );
@@ -3292,10 +3206,7 @@ static BOOL check_queue_masks( UINT wake
     UINT status;
 
     while ((status = get_shared_queue( &lock, &queue_shm )) == STATUS_PENDING)
-    {
-        if (queue_shm->wake_mask != wake_mask || queue_shm->changed_mask != changed_mask) skip = FALSE;
-        else skip = get_tick_count() - (UINT64)queue_shm->access_time / 10000 < 3000; /* avoid hung queue */
-    }
+        skip = queue_shm->wake_mask == wake_mask && queue_shm->changed_mask == changed_mask;
 
     if (status) return FALSE;
     return skip;
@@ -3319,6 +3230,7 @@ static DWORD wait_objects( DWORD count,
         {
             req->wake_mask    = wake_mask;
             req->changed_mask = changed_mask;
+            req->skip_wait    = 0;
             wine_server_call( req );
         }
         SERVER_END_REQ;
@@ -3639,6 +3551,7 @@ static void wait_message_reply( UINT fla
         {
             req->wake_mask    = wake_mask;
             req->changed_mask = wake_mask;
+            req->skip_wait    = 1;
             wine_server_call( req );
             wake_bits = reply->wake_bits & wake_mask;
         }
diff -ruN --show-c-function dlls/win32u/ntuser_private.h dlls/win32u/ntuser_private.h
--- dlls/win32u/ntuser_private.h	2025-10-10 10:17:47.496752177 -0700
+++ dlls/win32u/ntuser_private.h	2025-10-10 10:22:17.123729095 -0700
@@ -111,6 +111,7 @@ struct user_thread_info
 {
     struct ntuser_thread_info     client_info;            /* Data shared with client */
     HANDLE                        server_queue;           /* Handle to server-side queue */
+    DWORD                         last_getmsg_time;       /* Get/PeekMessage last request time */
     LONGLONG                      last_driver_time;       /* Get/PeekMessage driver event time */
     WORD                          hook_call_depth;        /* Number of recursively called hook procs */
     WORD                          hook_unicode;           /* Is current hook unicode? */
@@ -211,8 +212,17 @@ extern void free_dce( struct dce *dce, H
 extern void invalidate_dce( WND *win, const RECT *old_rect );
 
 /* message.c */
-extern BOOL process_driver_events( UINT mask );
-extern void check_for_events( UINT flags );
+struct peek_message_filter
+{
+    HWND hwnd;
+    UINT first;
+    UINT last;
+    UINT mask;
+    UINT flags;
+    BOOL internal;
+};
+
+extern int peek_message( MSG *msg, const struct peek_message_filter *filter );
 
 /* systray.c */
 extern LRESULT system_tray_call( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam, void *data );
diff -ruN --show-c-function dlls/win32u/ntuser_private.h.orig dlls/win32u/ntuser_private.h.orig
--- dlls/win32u/ntuser_private.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ dlls/win32u/ntuser_private.h.orig	2025-10-10 10:22:12.407269764 -0700
@@ -0,0 +1,244 @@
+/*
+ * User definitions
+ *
+ * Copyright 1993 Alexandre Julliard
+ * Copyright 2022 Jacek Caban
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_NTUSER_PRIVATE_H
+#define __WINE_NTUSER_PRIVATE_H
+
+#include "ntuser.h"
+#include "shellapi.h"
+#include "shlobj.h"
+#include "wine/list.h"
+#include "wine/vulkan.h"
+#include "wine/vulkan_driver.h"
+
+
+#define WM_POPUPSYSTEMMENU  0x0313
+
+enum system_timer_id
+{
+    SYSTEM_TIMER_TRACK_MOUSE = 0xfffa,
+    SYSTEM_TIMER_CARET = 0xffff,
+};
+
+#define OBJ_OTHER_PROCESS ((void *)1)  /* returned by get_user_handle_ptr on unknown handles */
+
+typedef struct tagWND
+{
+    HWND               handle;        /* window full handle */
+    HWND               parent;        /* Window parent */
+    HWND               owner;         /* Window owner */
+    struct tagCLASS   *class;         /* Window class */
+    struct dce        *dce;           /* DCE pointer */
+    WNDPROC            winproc;       /* Window procedure */
+    HINSTANCE          hInstance;     /* Window hInstance (from CreateWindow) */
+    struct window_rects rects;        /* window rects in window DPI, relative to the parent client area */
+    RECT               normal_rect;   /* Normal window rect saved when maximized/minimized */
+    POINT              min_pos;       /* Position for minimized window */
+    POINT              max_pos;       /* Position for maximized window */
+    WCHAR             *text;          /* Window text */
+    struct win_scroll_bar_info *pScroll; /* Scroll-bar info */
+    UINT               dwStyle;       /* Window style (from CreateWindow) */
+    UINT               dwExStyle;     /* Extended style (from CreateWindowEx) */
+    UINT_PTR           wIDmenu;       /* ID or hmenu (from CreateWindow) */
+    UINT               helpContext;   /* Help context ID */
+    UINT               flags;         /* Misc. flags (see below) */
+    HMENU              hSysMenu;      /* window's copy of System Menu */
+    HICON              hIcon;         /* window's icon */
+    HICON              hIconSmall;    /* window's small icon */
+    HICON              hIconSmall2;   /* window's secondary small icon, derived from hIcon */
+    HIMC               imc;           /* window's input context */
+    struct window_surface *surface;   /* Window surface if any */
+    struct opengl_drawable *current_drawable; /* current GL client surface for this window */
+    struct opengl_drawable *unused_drawable; /* unused GL client surface for this window */
+    struct tagDIALOGINFO *dlgInfo;    /* Dialog additional info (dialogs only) */
+    int                swap_interval; /* OpenGL surface swap interval */
+    int                pixel_format;  /* Pixel format set by the graphics driver */
+    int                internal_pixel_format; /* Internal pixel format set via WGL_WINE_pixel_format_passthrough */
+    int                cbWndExtra;    /* class cbWndExtra at window creation */
+    DWORD_PTR          userdata;      /* User private data */
+    DWORD              wExtra[1];     /* Window extra bytes */
+} WND;
+
+/* WND flags values */
+#define WIN_RESTORE_MAX           0x0001 /* Maximize when restoring */
+#define WIN_NEED_SIZE             0x0002 /* Internal WM_SIZE is needed */
+#define WIN_NCACTIVATED           0x0004 /* last WM_NCACTIVATE was positive */
+#define WIN_ISMDICLIENT           0x0008 /* Window is an MDIClient */
+#define WIN_ISUNICODE             0x0010 /* Window is Unicode */
+#define WIN_NEEDS_SHOW_OWNEDPOPUP 0x0020 /* WM_SHOWWINDOW:SC_SHOW must be sent in the next ShowOwnedPopup call */
+#define WIN_CHILDREN_MOVED        0x0040 /* children may have moved, ignore stored positions */
+#define WIN_HAS_IME_WIN           0x0080 /* the window has been registered with imm32 */
+
+#define WND_OTHER_PROCESS ((WND *)1)  /* returned by get_win_ptr on unknown window handles */
+#define WND_DESKTOP       ((WND *)2)  /* returned by get_win_ptr on the desktop window */
+
+/* check if hwnd is a broadcast magic handle */
+static inline BOOL is_broadcast( HWND hwnd )
+{
+    return hwnd == HWND_BROADCAST || hwnd == HWND_TOPMOST;
+}
+
+struct mouse_tracking_info
+{
+    TRACKMOUSEEVENT info;
+    POINT pos; /* center of hover rectangle */
+    HWND last_mouse_message_hwnd;
+    int last_mouse_message_hittest;
+    POINT last_mouse_message_pos;
+};
+
+/* this is the structure stored in TEB->Win32ClientInfo */
+/* no attempt is made to keep the layout compatible with the Windows one */
+struct user_thread_info
+{
+    struct ntuser_thread_info     client_info;            /* Data shared with client */
+    HANDLE                        server_queue;           /* Handle to server-side queue */
+    LONGLONG                      last_driver_time;       /* Get/PeekMessage driver event time */
+    WORD                          hook_call_depth;        /* Number of recursively called hook procs */
+    WORD                          hook_unicode;           /* Is current hook unicode? */
+    HHOOK                         hook;                   /* Current hook */
+    struct received_message_info *receive_info;           /* Message being currently received */
+    struct imm_thread_data       *imm_thread_data;        /* IMM thread data */
+    HKL                           kbd_layout;             /* Current keyboard layout */
+    UINT                          kbd_layout_id;          /* Current keyboard layout ID */
+    struct hardware_msg_data     *rawinput;               /* Current rawinput message data */
+    UINT                          spy_indent;             /* Current spy indent */
+    BOOL                          clipping_cursor;        /* thread is currently clipping */
+    DWORD                         clipping_reset;         /* time when clipping was last reset */
+    struct session_thread_data   *session_data;           /* shared session thread data */
+    struct mouse_tracking_info   *mouse_tracking_info;    /* NtUserTrackMouseEvent handling */
+};
+
+C_ASSERT( sizeof(struct user_thread_info) <= sizeof(((TEB *)0)->Win32ClientInfo) );
+
+static inline struct user_thread_info *get_user_thread_info(void)
+{
+    return CONTAINING_RECORD( NtUserGetThreadInfo(), struct user_thread_info, client_info );
+}
+
+struct hook_extra_info
+{
+    HHOOK handle;
+    LPARAM lparam;
+};
+
+/* FIXME: make it private to scroll.c */
+
+/* data for a single scroll bar */
+struct scroll_info
+{
+    INT   curVal;   /* Current scroll-bar value */
+    INT   minVal;   /* Minimum scroll-bar value */
+    INT   maxVal;   /* Maximum scroll-bar value */
+    INT   page;     /* Page size of scroll bar (Win32) */
+    UINT  flags;    /* EnableScrollBar flags */
+    BOOL  painted;  /* Whether the scroll bar is painted by DefWinProc() */
+};
+
+struct scroll_bar_win_data
+{
+    DWORD magic;
+    struct scroll_info info;
+};
+
+#define WINPROC_HANDLE (~0u >> 16)
+#define BUILTIN_WINPROC(index) ((WNDPROC)(ULONG_PTR)((index) | (WINPROC_HANDLE << 16)))
+
+#define MAX_ATOM_LEN 255
+
+/* Built-in class names (see _Undocumented_Windows_ p.418) */
+#define POPUPMENU_CLASS_ATOM MAKEINTATOM(32768)  /* PopupMenu */
+#define DESKTOP_CLASS_ATOM   MAKEINTATOM(32769)  /* Desktop */
+#define DIALOG_CLASS_ATOM    MAKEINTATOM(32770)  /* Dialog */
+#define WINSWITCH_CLASS_ATOM MAKEINTATOM(32771)  /* WinSwitch */
+#define ICONTITLE_CLASS_ATOM MAKEINTATOM(32772)  /* IconTitle */
+
+extern const char *debugstr_msg_name( UINT msg, HWND hwnd );
+extern const char *debugstr_vkey_name( WPARAM wParam );
+extern void spy_enter_message( INT flag, HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam );
+extern void spy_exit_message( INT flag, HWND hwnd, UINT msg,
+                              LRESULT lreturn, WPARAM wparam, LPARAM lparam );
+
+/* class.c */
+extern HINSTANCE user32_module;
+WNDPROC alloc_winproc( WNDPROC func, BOOL ansi );
+BOOL is_winproc_unicode( WNDPROC proc, BOOL def_val );
+DWORD get_class_long( HWND hwnd, INT offset, BOOL ansi );
+WNDPROC get_class_winproc( struct tagCLASS *class );
+ULONG_PTR get_class_long_ptr( HWND hwnd, INT offset, BOOL ansi );
+WORD get_class_word( HWND hwnd, INT offset );
+DLGPROC get_dialog_proc( DLGPROC proc, BOOL ansi );
+WNDPROC get_winproc( WNDPROC proc, BOOL ansi );
+void get_winproc_params( struct win_proc_params *params, BOOL fixup_ansi_dst );
+struct dce *get_class_dce( struct tagCLASS *class );
+struct dce *set_class_dce( struct tagCLASS *class, struct dce *dce );
+extern atom_t wine_server_add_atom( void *req, UNICODE_STRING *str );
+extern BOOL is_desktop_class( UNICODE_STRING *name );
+extern BOOL is_message_class( UNICODE_STRING *name );
+extern void register_builtin_classes(void);
+extern void register_desktop_class(void);
+
+/* imm.c */
+extern LRESULT ime_driver_call( HWND hwnd, enum wine_ime_call call, WPARAM wparam, LPARAM lparam,
+                                struct ime_driver_call_params *params );
+
+/* clipboard.c */
+extern LRESULT drag_drop_call( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam, void *data );
+
+/* cursoricon.c */
+HICON alloc_cursoricon_handle( BOOL is_icon );
+
+/* dce.c */
+extern void free_dce( struct dce *dce, HWND hwnd );
+extern void invalidate_dce( WND *win, const RECT *old_rect );
+
+/* message.c */
+extern BOOL process_driver_events( UINT mask );
+extern void check_for_events( UINT flags );
+
+/* systray.c */
+extern LRESULT system_tray_call( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam, void *data );
+
+/* vulkan.c */
+extern PFN_vkGetDeviceProcAddr p_vkGetDeviceProcAddr;
+extern PFN_vkGetInstanceProcAddr p_vkGetInstanceProcAddr;
+
+extern BOOL vulkan_init(void);
+
+/* window.c */
+HANDLE alloc_user_handle( void *ptr, unsigned short type );
+void *free_user_handle( HANDLE handle, unsigned short type );
+void *get_user_handle_ptr( HANDLE handle, unsigned short type );
+void release_user_handle_ptr( void *ptr );
+void *next_thread_user_object( UINT tid, HANDLE *handle, unsigned short type );
+UINT win_set_flags( HWND hwnd, UINT set_mask, UINT clear_mask );
+
+static inline UINT win_get_flags( HWND hwnd )
+{
+    return win_set_flags( hwnd, 0, 0 );
+}
+
+struct obj_locator get_window_class_locator( HWND hwnd );
+WND *get_win_ptr( HWND hwnd );
+BOOL is_child( HWND parent, HWND child );
+BOOL is_window( HWND hwnd );
+
+#endif /* __WINE_NTUSER_PRIVATE_H */
diff -ruN --show-c-function dlls/wineandroid.drv/window.c dlls/wineandroid.drv/window.c
--- dlls/wineandroid.drv/window.c	2025-10-10 10:17:47.515663798 -0700
+++ dlls/wineandroid.drv/window.c	2025-10-10 10:22:17.114870679 -0700
@@ -391,19 +391,13 @@ static void pull_events(void)
 }
 
 
-static int check_fd_events( int fd, int events )
-{
-    struct pollfd pfd = {.fd = fd, .events = events};
-    if (poll( &pfd, 1, 0 ) <= 0) return 0;
-    return pfd.revents;
-}
-
 /***********************************************************************
  *           process_events
  */
 static int process_events( DWORD mask )
 {
     struct java_event *event, *next, *previous;
+    unsigned int count = 0;
 
     assert( GetCurrentThreadId() == desktop_tid );
 
@@ -511,11 +505,12 @@ static int process_events( DWORD mask )
             FIXME( "got event %u\n", event->data.type );
         }
         free( event );
+        count++;
         /* next may have been removed by a recursive call, so reset it to the beginning of the list */
         next = LIST_ENTRY( event_queue.next, struct java_event, entry );
     }
     current_event = previous;
-    return !check_fd_events( event_pipe[0], POLLIN );
+    return count;
 }
 
 
diff -ruN --show-c-function dlls/winemac.drv/event.c dlls/winemac.drv/event.c
--- dlls/winemac.drv/event.c	2025-10-10 10:17:47.528752861 -0700
+++ dlls/winemac.drv/event.c	2025-10-10 10:22:17.114975738 -0700
@@ -26,8 +26,6 @@
 
 #include "config.h"
 
-#include <poll.h>
-
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "macdrv.h"
@@ -528,13 +526,25 @@ void macdrv_handle_event(const macdrv_ev
 }
 
 
-static int check_fd_events( int fd, int events )
+/***********************************************************************
+ *              process_events
+ */
+static int process_events(macdrv_event_queue queue, macdrv_event_mask mask)
 {
-    struct pollfd pfd = {.fd = fd, .events = events};
-    if (poll( &pfd, 1, 0 ) <= 0) return 0;
-    return pfd.revents;
+    macdrv_event *event;
+    int count = 0;
+
+    while (macdrv_copy_event_from_queue(queue, mask, &event))
+    {
+        count++;
+        macdrv_handle_event(event);
+        macdrv_release_event(event);
+    }
+    if (count) TRACE("processed %d events\n", count);
+    return count;
 }
 
+
 /***********************************************************************
  *              ProcessEvents   (MACDRV.@)
  */
@@ -542,8 +552,6 @@ BOOL macdrv_ProcessEvents(DWORD mask)
 {
     struct macdrv_thread_data *data = macdrv_thread_data();
     macdrv_event_mask event_mask = get_event_mask(mask);
-    macdrv_event *event;
-    int count = 0;
 
     TRACE("mask %x\n", mask);
 
@@ -555,13 +563,5 @@ BOOL macdrv_ProcessEvents(DWORD mask)
         data->current_event->type != WINDOW_DRAG_BEGIN)
         event_mask = 0;  /* don't process nested events */
 
-    while (macdrv_copy_event_from_queue(data->queue, event_mask, &event))
-    {
-        count++;
-        macdrv_handle_event(event);
-        macdrv_release_event(event);
-    }
-
-    if (count) TRACE("processed %d events\n", count);
-    return !check_fd_events(macdrv_get_event_queue_fd(data->queue), POLLIN);
+    return process_events(data->queue, event_mask);
 }
diff -ruN --show-c-function dlls/winex11.drv/event.c dlls/winex11.drv/event.c
--- dlls/winex11.drv/event.c	2025-10-10 10:17:47.540131919 -0700
+++ dlls/winex11.drv/event.c	2025-10-10 10:22:17.115080056 -0700
@@ -464,28 +464,19 @@ static inline BOOL call_event_handler( D
     return ret;
 }
 
-static int check_fd_events( int fd, int events )
-{
-    struct pollfd pfd = {.fd = fd, .events = events};
-    if (poll( &pfd, 1, 0 ) <= 0) return 0;
-    return pfd.revents;
-}
 
 /***********************************************************************
- *           ProcessEvents   (X11DRV.@)
+ *           process_events
  */
-BOOL X11DRV_ProcessEvents( DWORD mask )
+static BOOL process_events( Display *display, Bool (*filter)(Display*, XEvent*,XPointer), ULONG_PTR arg )
 {
-    struct x11drv_thread_data *data = x11drv_thread_data();
     XEvent event, prev_event;
     int count = 0;
+    BOOL queued = FALSE;
     enum event_merge_action action = MERGE_DISCARD;
 
-    if (!data) return FALSE;
-    if (data->current_event) mask = 0;  /* don't process nested events */
-
     prev_event.type = 0;
-    while (XCheckIfEvent( data->display, &event, filter_event, (XPointer)(UINT_PTR)mask ))
+    while (XCheckIfEvent( display, &event, filter, (char *)arg ))
     {
         count++;
         if (XFilterEvent( &event, None ))
@@ -526,29 +517,42 @@ BOOL X11DRV_ProcessEvents( DWORD mask )
         switch( action )
         {
         case MERGE_HANDLE:  /* handle prev, keep new */
-            call_event_handler( data->display, &prev_event );
+            queued |= call_event_handler( display, &prev_event );
             /* fall through */
         case MERGE_DISCARD:  /* discard prev, keep new */
             free_event_data( &prev_event );
             prev_event = event;
             break;
         case MERGE_KEEP:  /* handle new, keep prev for future merging */
-            call_event_handler( data->display, &event );
+            queued |= call_event_handler( display, &event );
             /* fall through */
         case MERGE_IGNORE: /* ignore new, keep prev for future merging */
             free_event_data( &event );
             break;
         }
     }
-    if (prev_event.type) call_event_handler( data->display, &prev_event );
+    if (prev_event.type) queued |= call_event_handler( display, &prev_event );
     free_event_data( &prev_event );
     XFlush( gdi_display );
-    if (count) TRACE( "processed %d events\n", count );
-    return !check_fd_events( ConnectionNumber( data->display ), POLLIN );
+    if (count) TRACE( "processed %d events, returning %d\n", count, queued );
+    return queued;
 }
 
 
 /***********************************************************************
+ *           ProcessEvents   (X11DRV.@)
+ */
+BOOL X11DRV_ProcessEvents( DWORD mask )
+{
+    struct x11drv_thread_data *data = x11drv_thread_data();
+
+    if (!data) return FALSE;
+    if (data->current_event) mask = 0;  /* don't process nested events */
+
+    return process_events( data->display, filter_event, mask );
+}
+
+/***********************************************************************
  *           EVENT_x11_time_to_win32_time
  *
  * Make our timer and the X timer line up as best we can
Binary files .git/index and .git/index differ
diff -ruN --show-c-function .git/logs/HEAD .git/logs/HEAD
--- .git/logs/HEAD	2025-10-10 10:17:49.477579329 -0700
+++ .git/logs/HEAD	2025-10-10 10:22:14.339309096 -0700
@@ -1,3 +1,3 @@
-0000000000000000000000000000000000000000 2827471c57299793d8e0868679184f8d762a5309 Vincent <vincent@ryzendesktop.(none)> 1760116667 -0700	clone: from /home/vincent/Downloads/wine-tkg-git/wine-tkg-git/wine-git
-2827471c57299793d8e0868679184f8d762a5309 01269452e0fbb1f081d506bd64996590a553e2b9 Vincent <vincent@ryzendesktop.(none)> 1760116669 -0700	checkout: moving from master to makepkg
-01269452e0fbb1f081d506bd64996590a553e2b9 01269452e0fbb1f081d506bd64996590a553e2b9 Vincent <vincent@ryzendesktop.(none)> 1760116669 -0700	reset: moving to HEAD
+0000000000000000000000000000000000000000 2827471c57299793d8e0868679184f8d762a5309 Vincent <vincent@ryzendesktop.(none)> 1760116931 -0700	clone: from /home/vincent/Downloads/wine-tkg-git/wine-tkg-git/wine-git
+2827471c57299793d8e0868679184f8d762a5309 01269452e0fbb1f081d506bd64996590a553e2b9 Vincent <vincent@ryzendesktop.(none)> 1760116934 -0700	checkout: moving from master to makepkg
+01269452e0fbb1f081d506bd64996590a553e2b9 01269452e0fbb1f081d506bd64996590a553e2b9 Vincent <vincent@ryzendesktop.(none)> 1760116934 -0700	reset: moving to HEAD
diff -ruN --show-c-function .git/logs/refs/heads/makepkg .git/logs/refs/heads/makepkg
--- .git/logs/refs/heads/makepkg	2025-10-10 10:17:49.311790981 -0700
+++ .git/logs/refs/heads/makepkg	2025-10-10 10:22:14.175305758 -0700
@@ -1 +1 @@
-0000000000000000000000000000000000000000 01269452e0fbb1f081d506bd64996590a553e2b9 Vincent <vincent@ryzendesktop.(none)> 1760116669 -0700	branch: Created from wine-10.16
+0000000000000000000000000000000000000000 01269452e0fbb1f081d506bd64996590a553e2b9 Vincent <vincent@ryzendesktop.(none)> 1760116934 -0700	branch: Created from wine-10.16
diff -ruN --show-c-function .git/logs/refs/heads/master .git/logs/refs/heads/master
--- .git/logs/refs/heads/master	2025-10-10 10:17:47.046005634 -0700
+++ .git/logs/refs/heads/master	2025-10-10 10:22:11.957367010 -0700
@@ -1 +1 @@
-0000000000000000000000000000000000000000 2827471c57299793d8e0868679184f8d762a5309 Vincent <vincent@ryzendesktop.(none)> 1760116667 -0700	clone: from /home/vincent/Downloads/wine-tkg-git/wine-tkg-git/wine-git
+0000000000000000000000000000000000000000 2827471c57299793d8e0868679184f8d762a5309 Vincent <vincent@ryzendesktop.(none)> 1760116931 -0700	clone: from /home/vincent/Downloads/wine-tkg-git/wine-tkg-git/wine-git
diff -ruN --show-c-function .git/logs/refs/remotes/origin/HEAD .git/logs/refs/remotes/origin/HEAD
--- .git/logs/refs/remotes/origin/HEAD	2025-10-10 10:17:47.045233770 -0700
+++ .git/logs/refs/remotes/origin/HEAD	2025-10-10 10:22:11.956607891 -0700
@@ -1 +1 @@
-0000000000000000000000000000000000000000 2827471c57299793d8e0868679184f8d762a5309 Vincent <vincent@ryzendesktop.(none)> 1760116667 -0700	clone: from /home/vincent/Downloads/wine-tkg-git/wine-tkg-git/wine-git
+0000000000000000000000000000000000000000 2827471c57299793d8e0868679184f8d762a5309 Vincent <vincent@ryzendesktop.(none)> 1760116931 -0700	clone: from /home/vincent/Downloads/wine-tkg-git/wine-tkg-git/wine-git
Binary files .git/objects/00/9751b399da97a53e6bdce49786c6a11d075d27 and .git/objects/00/9751b399da97a53e6bdce49786c6a11d075d27 differ
Binary files .git/objects/02/193b862ba671bbc397d6b5558b62c8cafcc750 and .git/objects/02/193b862ba671bbc397d6b5558b62c8cafcc750 differ
Binary files .git/objects/05/235a912462753754bf62b64582d0561d047f9e and .git/objects/05/235a912462753754bf62b64582d0561d047f9e differ
Binary files .git/objects/0c/01ec1c0d3a616407f587561bdbcf0ea3b244f3 and .git/objects/0c/01ec1c0d3a616407f587561bdbcf0ea3b244f3 differ
Binary files .git/objects/0d/49a996c2a826fb87108fac8fc8f16124bf215a and .git/objects/0d/49a996c2a826fb87108fac8fc8f16124bf215a differ
Binary files .git/objects/0d/f7fd2f18e7280e039aca79c1c14091e0a3e79e and .git/objects/0d/f7fd2f18e7280e039aca79c1c14091e0a3e79e differ
Binary files .git/objects/10/c971322acdb44ed32ca8f11b8c40e60040e3c3 and .git/objects/10/c971322acdb44ed32ca8f11b8c40e60040e3c3 differ
Binary files .git/objects/11/d86563a1052b5927dad6a22344b5432d5c2cbc and .git/objects/11/d86563a1052b5927dad6a22344b5432d5c2cbc differ
Binary files .git/objects/1a/850b66b44233fd3f8abb97b89169af1a26ed28 and .git/objects/1a/850b66b44233fd3f8abb97b89169af1a26ed28 differ
Binary files .git/objects/1f/7ae6c182dad7517377396a865fa7ceb1ef79c5 and .git/objects/1f/7ae6c182dad7517377396a865fa7ceb1ef79c5 differ
Binary files .git/objects/23/22b042ec2df7ee31b91ce1bb243a21a4808d6d and .git/objects/23/22b042ec2df7ee31b91ce1bb243a21a4808d6d differ
Binary files .git/objects/24/a53104f8b37da36affa08915293ec21e15ec5c and .git/objects/24/a53104f8b37da36affa08915293ec21e15ec5c differ
Binary files .git/objects/26/ad168542fb2b8bcd73c6523166da7edc8b4964 and .git/objects/26/ad168542fb2b8bcd73c6523166da7edc8b4964 differ
Binary files .git/objects/28/a5620268fb4e24e3255062be9969990f5db335 and .git/objects/28/a5620268fb4e24e3255062be9969990f5db335 differ
Binary files .git/objects/31/12934f1573d71526bd101570e17134e1495f82 and .git/objects/31/12934f1573d71526bd101570e17134e1495f82 differ
Binary files .git/objects/35/7a7e1fbcb2aa7f522acba623813c8065f46c16 and .git/objects/35/7a7e1fbcb2aa7f522acba623813c8065f46c16 differ
Binary files .git/objects/38/843f2789b7db3b6c4439300e6f63192ba460e6 and .git/objects/38/843f2789b7db3b6c4439300e6f63192ba460e6 differ
Binary files .git/objects/3d/5f41eeb38a12537da025bf716b24f5fac76a58 and .git/objects/3d/5f41eeb38a12537da025bf716b24f5fac76a58 differ
Binary files .git/objects/3d/750154d1ba7774f9929f09ec63e9cb4422b246 and .git/objects/3d/750154d1ba7774f9929f09ec63e9cb4422b246 differ
Binary files .git/objects/3e/f214557c3b8031d0b7a82214f0dc29f4db01c5 and .git/objects/3e/f214557c3b8031d0b7a82214f0dc29f4db01c5 differ
Binary files .git/objects/44/4bd29e84b47fbd15e6c1e4ea760c2ab77b8940 and .git/objects/44/4bd29e84b47fbd15e6c1e4ea760c2ab77b8940 differ
Binary files .git/objects/55/cd6aa037ea6b1e9558f1a42f77c2f7adc9c84d and .git/objects/55/cd6aa037ea6b1e9558f1a42f77c2f7adc9c84d differ
Binary files .git/objects/57/542aff5e10179df114f697d0abd3c319e03018 and .git/objects/57/542aff5e10179df114f697d0abd3c319e03018 differ
Binary files .git/objects/62/eba262a11396dc3832dccbb9f2e807501ff906 and .git/objects/62/eba262a11396dc3832dccbb9f2e807501ff906 differ
Binary files .git/objects/66/f17bf73f295528c950d382ae904e5552726ed7 and .git/objects/66/f17bf73f295528c950d382ae904e5552726ed7 differ
Binary files .git/objects/6b/fccb4cbcdda0ad6428898e2cf40ee9b90f5b94 and .git/objects/6b/fccb4cbcdda0ad6428898e2cf40ee9b90f5b94 differ
Binary files .git/objects/72/9b10d1cd435a10696b12b7901e7d3c25e74f71 and .git/objects/72/9b10d1cd435a10696b12b7901e7d3c25e74f71 differ
Binary files .git/objects/74/c507ef663b1511bdd056351df0e65a70915236 and .git/objects/74/c507ef663b1511bdd056351df0e65a70915236 differ
Binary files .git/objects/75/5b80e1b3bb38a4f24da5e116e222ead7c49000 and .git/objects/75/5b80e1b3bb38a4f24da5e116e222ead7c49000 differ
Binary files .git/objects/78/42e56a2910806a8975fc531322b64543c24f0b and .git/objects/78/42e56a2910806a8975fc531322b64543c24f0b differ
Binary files .git/objects/7d/87b6493fa9041c9b8b0403a5d0fa748d5ff42a and .git/objects/7d/87b6493fa9041c9b8b0403a5d0fa748d5ff42a differ
Binary files .git/objects/83/8c07ea57058ed1e2989dca4f409fd2dce8925e and .git/objects/83/8c07ea57058ed1e2989dca4f409fd2dce8925e differ
Binary files .git/objects/86/809b610c70dbae376656f57d6f7075436c2057 and .git/objects/86/809b610c70dbae376656f57d6f7075436c2057 differ
Binary files .git/objects/86/8d52f9cba37c754da3240f4a12c0190d714f51 and .git/objects/86/8d52f9cba37c754da3240f4a12c0190d714f51 differ
Binary files .git/objects/8a/9f8b1ef277938d67245dd7db246ac795ad5aa9 and .git/objects/8a/9f8b1ef277938d67245dd7db246ac795ad5aa9 differ
Binary files .git/objects/8d/dfa9dcf4edc96acd06a7e6ff9ea7ff195e3c92 and .git/objects/8d/dfa9dcf4edc96acd06a7e6ff9ea7ff195e3c92 differ
Binary files .git/objects/8e/141eae5b92fe8064cfa7bc9b1c2f1918c2c215 and .git/objects/8e/141eae5b92fe8064cfa7bc9b1c2f1918c2c215 differ
Binary files .git/objects/91/02cf911aa1c1b4ed0709c0d4766f197398f3f3 and .git/objects/91/02cf911aa1c1b4ed0709c0d4766f197398f3f3 differ
Binary files .git/objects/97/7ad4242e238dbd20e2ba40476ced3fc14dea98 and .git/objects/97/7ad4242e238dbd20e2ba40476ced3fc14dea98 differ
Binary files .git/objects/9b/aec508d4a530586aa7ccc42e1614a919497f28 and .git/objects/9b/aec508d4a530586aa7ccc42e1614a919497f28 differ
Binary files .git/objects/9c/12eefa5652b7a8789b18a073f881af7638011b and .git/objects/9c/12eefa5652b7a8789b18a073f881af7638011b differ
Binary files .git/objects/9c/35d84a44f93edd126c92758a41cfa57f02e268 and .git/objects/9c/35d84a44f93edd126c92758a41cfa57f02e268 differ
Binary files .git/objects/a4/92760ac4efa9e545c13de5508aae52f7de2d28 and .git/objects/a4/92760ac4efa9e545c13de5508aae52f7de2d28 differ
Binary files .git/objects/ac/8c76860da17a65fcdb841fea68d7ed16667070 and .git/objects/ac/8c76860da17a65fcdb841fea68d7ed16667070 differ
Binary files .git/objects/af/a05b0d2098aba6a574b9f7ead3e0149a3c07d2 and .git/objects/af/a05b0d2098aba6a574b9f7ead3e0149a3c07d2 differ
Binary files .git/objects/af/a34006a69e3b0429ca344351d68cf79a11ec1e and .git/objects/af/a34006a69e3b0429ca344351d68cf79a11ec1e differ
Binary files .git/objects/b5/adb833af15e261706c97ad9f6b1433bd4141c3 and .git/objects/b5/adb833af15e261706c97ad9f6b1433bd4141c3 differ
Binary files .git/objects/b6/80f50914c29bc7214eca55f943929586bf81d2 and .git/objects/b6/80f50914c29bc7214eca55f943929586bf81d2 differ
Binary files .git/objects/c3/6f5e29827a1fea984a38395c78f8eb34b1a324 and .git/objects/c3/6f5e29827a1fea984a38395c78f8eb34b1a324 differ
Binary files .git/objects/c4/4894690ec47859d9d8e3d8da8805ccd2318224 and .git/objects/c4/4894690ec47859d9d8e3d8da8805ccd2318224 differ
Binary files .git/objects/c9/8bf97d4052417853a52c90a8a3438bb70af428 and .git/objects/c9/8bf97d4052417853a52c90a8a3438bb70af428 differ
Binary files .git/objects/d2/f1e045016fc821ed91ce6625284a389358b6b4 and .git/objects/d2/f1e045016fc821ed91ce6625284a389358b6b4 differ
Binary files .git/objects/d3/9f4efa3ecf85c9099e7a8ff858b4f1d402a7da and .git/objects/d3/9f4efa3ecf85c9099e7a8ff858b4f1d402a7da differ
Binary files .git/objects/d4/f8cf5e964e6b65fceda60e54bb5d6eea3a95fe and .git/objects/d4/f8cf5e964e6b65fceda60e54bb5d6eea3a95fe differ
Binary files .git/objects/de/759c23c36144fa287a1982fb2e255b4f435157 and .git/objects/de/759c23c36144fa287a1982fb2e255b4f435157 differ
Binary files .git/objects/e0/8835c9b8ce2051b8aa52151247246522bb5b9f and .git/objects/e0/8835c9b8ce2051b8aa52151247246522bb5b9f differ
Binary files .git/objects/e1/93f61b3a7672d04a81a9f8b79826cd3481a82b and .git/objects/e1/93f61b3a7672d04a81a9f8b79826cd3481a82b differ
Binary files .git/objects/e3/889f24601be29697cacfb57bbf3b88b75b3648 and .git/objects/e3/889f24601be29697cacfb57bbf3b88b75b3648 differ
Binary files .git/objects/ec/c3b776bb3a835d91797e935a509ffb3076c9b8 and .git/objects/ec/c3b776bb3a835d91797e935a509ffb3076c9b8 differ
Binary files .git/objects/ef/b9b0c62559b5fda24ddd9ea0e69e7865a13b25 and .git/objects/ef/b9b0c62559b5fda24ddd9ea0e69e7865a13b25 differ
Binary files .git/objects/f4/f5e713935d51a6d050409eb230268fc2b9fe45 and .git/objects/f4/f5e713935d51a6d050409eb230268fc2b9fe45 differ
Binary files .git/objects/fa/c3509dfbacd972e9880c050a8502072f3f7242 and .git/objects/fa/c3509dfbacd972e9880c050a8502072f3f7242 differ
diff -ruN --show-c-function include/config.h.in include/config.h.in
--- include/config.h.in	2025-10-10 10:17:58.880995274 -0700
+++ include/config.h.in	2025-10-10 10:22:24.480560064 -0700
@@ -198,9 +198,6 @@
 /* Define to 1 if you have the <linux/major.h> header file. */
 #undef HAVE_LINUX_MAJOR_H
 
-/* Define to 1 if you have the <linux/ntsync.h> header file. */
-#undef HAVE_LINUX_NTSYNC_H
-
 /* Define to 1 if you have the <linux/param.h> header file. */
 #undef HAVE_LINUX_PARAM_H
 
@@ -336,6 +333,9 @@
 /* Define to 1 if you have the 'posix_fallocate' function. */
 #undef HAVE_POSIX_FALLOCATE
 
+/* Define to 1 if you have the 'ppoll' function. */
+#undef HAVE_PPOLL
+
 /* Define to 1 if you have the 'prctl' function. */
 #undef HAVE_PRCTL
 
@@ -396,6 +396,9 @@
 /* Define to 1 if 'interface_id' is a member of 'sg_io_hdr_t'. */
 #undef HAVE_SG_IO_HDR_T_INTERFACE_ID
 
+/* Define to 1 if you have the `shm_open' function. */
+#undef HAVE_SHM_OPEN
+
 /* Define to 1 if 'si_fd' is a member of 'siginfo_t'. */
 #undef HAVE_SIGINFO_T_SI_FD
 
@@ -525,6 +528,9 @@
 /* Define to 1 if you have the <sys/epoll.h> header file. */
 #undef HAVE_SYS_EPOLL_H
 
+/* Define to 1 if you have the <sys/eventfd.h> header file. */
+#undef HAVE_SYS_EVENTFD_H
+
 /* Define to 1 if you have the <sys/event.h> header file. */
 #undef HAVE_SYS_EVENT_H
 
diff -ruN --show-c-function include/config.h.in~ include/config.h.in~
--- include/config.h.in~	2025-10-10 10:17:48.596775696 -0700
+++ include/config.h.in~	2025-10-10 10:22:17.144246720 -0700
@@ -198,9 +198,6 @@
 /* Define to 1 if you have the <linux/major.h> header file. */
 #undef HAVE_LINUX_MAJOR_H
 
-/* Define to 1 if you have the <linux/ntsync.h> header file. */
-#undef HAVE_LINUX_NTSYNC_H
-
 /* Define to 1 if you have the <linux/param.h> header file. */
 #undef HAVE_LINUX_PARAM_H
 
@@ -336,6 +333,9 @@
 /* Define to 1 if you have the 'posix_fallocate' function. */
 #undef HAVE_POSIX_FALLOCATE
 
+/* Define to 1 if you have the `ppoll' function. */
+#undef HAVE_PPOLL
+
 /* Define to 1 if you have the 'prctl' function. */
 #undef HAVE_PRCTL
 
@@ -396,7 +396,10 @@
 /* Define to 1 if 'interface_id' is a member of 'sg_io_hdr_t'. */
 #undef HAVE_SG_IO_HDR_T_INTERFACE_ID
 
-/* Define to 1 if 'si_fd' is a member of 'siginfo_t'. */
+/* Define to 1 if you have the `shm_open' function. */
+#undef HAVE_SHM_OPEN
+
+/* Define to 1 if `si_fd' is a member of `siginfo_t'. */
 #undef HAVE_SIGINFO_T_SI_FD
 
 /* Define to 1 if you have the 'sigprocmask' function. */
@@ -525,6 +528,9 @@
 /* Define to 1 if you have the <sys/epoll.h> header file. */
 #undef HAVE_SYS_EPOLL_H
 
+/* Define to 1 if you have the <sys/eventfd.h> header file. */
+#undef HAVE_SYS_EVENTFD_H
+
 /* Define to 1 if you have the <sys/event.h> header file. */
 #undef HAVE_SYS_EVENT_H
 
diff -ruN --show-c-function include/wine/server_protocol.h include/wine/server_protocol.h
--- include/wine/server_protocol.h	2025-10-10 10:17:48.596775696 -0700
+++ include/wine/server_protocol.h	2025-10-10 10:22:22.403082879 -0700
@@ -974,8 +974,6 @@ struct obj_locator
 };
 
 #define MAX_ATOM_LEN     255
-#define WH_WINEVENT      (WH_MAXHOOK + 1)
-#define NB_HOOKS         (WH_WINEVENT - WH_MINHOOK + 1)
 
 struct shared_cursor
 {
@@ -996,13 +994,11 @@ typedef volatile struct
 
 typedef volatile struct
 {
-    timeout_t            access_time;
+    int                  hooks_count[WH_MAX - WH_MIN + 2];
     unsigned int         wake_mask;
     unsigned int         wake_bits;
     unsigned int         changed_mask;
     unsigned int         changed_bits;
-    unsigned int         internal_bits;
-    int                  hooks_count[NB_HOOKS];
 } queue_shm_t;
 
 typedef volatile struct
@@ -1174,10 +1170,8 @@ struct init_first_thread_reply
     thread_id_t  tid;
     timeout_t    server_start;
     unsigned int session_id;
-    obj_handle_t inproc_device;
     data_size_t  info_size;
     /* VARARG(machines,ushorts); */
-    char __pad_36[4];
 };
 
 
@@ -3010,7 +3004,7 @@ struct set_queue_mask_request
     struct request_header __header;
     unsigned int wake_mask;
     unsigned int changed_mask;
-    int          poll_events;
+    int          skip_wait;
 };
 struct set_queue_mask_reply
 {
@@ -5948,56 +5942,91 @@ struct get_next_thread_reply
     char __pad_12[4];
 };
 
+enum esync_type
+{
+    ESYNC_SEMAPHORE = 1,
+    ESYNC_AUTO_EVENT,
+    ESYNC_MANUAL_EVENT,
+    ESYNC_MUTEX,
+    ESYNC_AUTO_SERVER,
+    ESYNC_MANUAL_SERVER,
+    ESYNC_QUEUE,
+};
 
 
-struct set_keyboard_repeat_request
+struct create_esync_request
 {
     struct request_header __header;
-    int enable;
-    int delay;
-    int period;
+    unsigned int access;
+    int          initval;
+    int          type;
+    int          max;
+    /* VARARG(objattr,object_attributes); */
+    char __pad_28[4];
 };
-struct set_keyboard_repeat_reply
+struct create_esync_reply
 {
     struct reply_header __header;
-    int enable;
-    char __pad_12[4];
+    obj_handle_t handle;
+    int          type;
+    unsigned int shm_idx;
+    char __pad_20[4];
 };
 
-
-enum inproc_sync_type
+struct open_esync_request
+{
+    struct request_header __header;
+    unsigned int access;
+    unsigned int attributes;
+    obj_handle_t rootdir;
+    int          type;
+    /* VARARG(name,unicode_str); */
+    char __pad_28[4];
+};
+struct open_esync_reply
 {
-    INPROC_SYNC_UNKNOWN   = 0,
-    INPROC_SYNC_INTERNAL  = 1,
-    INPROC_SYNC_EVENT     = 2,
-    INPROC_SYNC_MUTEX     = 3,
-    INPROC_SYNC_SEMAPHORE = 4,
+    struct reply_header __header;
+    obj_handle_t handle;
+    int          type;
+    unsigned int shm_idx;
+    char __pad_20[4];
 };
 
 
-struct get_inproc_sync_fd_request
+struct get_esync_fd_request
 {
     struct request_header __header;
     obj_handle_t handle;
 };
-struct get_inproc_sync_fd_reply
+struct get_esync_fd_reply
 {
     struct reply_header __header;
-    int           type;
-    unsigned int access;
+    int          type;
+    unsigned int shm_idx;
 };
 
+struct esync_msgwait_request
+{
+    struct request_header __header;
+    int          in_msgwait;
+};
+struct esync_msgwait_reply
+{
+    struct reply_header __header;
+};
 
 
-struct get_inproc_alert_fd_request
+struct set_keyboard_repeat_request
 {
     struct request_header __header;
-    char __pad_12[4];
+    int enable;
+    int delay;
+    int period;
 };
-struct get_inproc_alert_fd_reply
+struct set_keyboard_repeat_reply
 {
     struct reply_header __header;
-    obj_handle_t handle;
+    int enable;
     char __pad_12[4];
 };
 
@@ -6090,6 +6119,17 @@ struct d3dkmt_object_open_name_reply
 };
 
 
+struct get_esync_apc_fd_request
+{
+    struct request_header __header;
+    char __pad_12[4];
+};
+struct get_esync_apc_fd_reply
+{
+    struct reply_header __header;
+};
+
+
 enum request
 {
     REQ_new_process,
@@ -6387,14 +6427,17 @@ enum request
     REQ_resume_process,
     REQ_get_next_process,
     REQ_get_next_thread,
+    REQ_create_esync,
+    REQ_open_esync,
+    REQ_get_esync_fd,
+    REQ_esync_msgwait,
     REQ_set_keyboard_repeat,
-    REQ_get_inproc_sync_fd,
-    REQ_get_inproc_alert_fd,
     REQ_d3dkmt_object_create,
     REQ_d3dkmt_object_query,
     REQ_d3dkmt_object_open,
     REQ_d3dkmt_share_objects,
     REQ_d3dkmt_object_open_name,
+    REQ_get_esync_apc_fd,
     REQ_NB_REQUESTS
 };
 
@@ -6697,14 +6740,17 @@ union generic_request
     struct resume_process_request resume_process_request;
     struct get_next_process_request get_next_process_request;
     struct get_next_thread_request get_next_thread_request;
+    struct create_esync_request create_esync_request;
+    struct open_esync_request open_esync_request;
+    struct get_esync_fd_request get_esync_fd_request;
+    struct esync_msgwait_request esync_msgwait_request;
     struct set_keyboard_repeat_request set_keyboard_repeat_request;
-    struct get_inproc_sync_fd_request get_inproc_sync_fd_request;
-    struct get_inproc_alert_fd_request get_inproc_alert_fd_request;
     struct d3dkmt_object_create_request d3dkmt_object_create_request;
     struct d3dkmt_object_query_request d3dkmt_object_query_request;
     struct d3dkmt_object_open_request d3dkmt_object_open_request;
     struct d3dkmt_share_objects_request d3dkmt_share_objects_request;
     struct d3dkmt_object_open_name_request d3dkmt_object_open_name_request;
+    struct get_esync_apc_fd_request get_esync_apc_fd_request;
 };
 union generic_reply
 {
@@ -7005,16 +7051,19 @@ union generic_reply
     struct resume_process_reply resume_process_reply;
     struct get_next_process_reply get_next_process_reply;
     struct get_next_thread_reply get_next_thread_reply;
+    struct create_esync_reply create_esync_reply;
+    struct open_esync_reply open_esync_reply;
+    struct get_esync_fd_reply get_esync_fd_reply;
+    struct esync_msgwait_reply esync_msgwait_reply;
     struct set_keyboard_repeat_reply set_keyboard_repeat_reply;
-    struct get_inproc_sync_fd_reply get_inproc_sync_fd_reply;
-    struct get_inproc_alert_fd_reply get_inproc_alert_fd_reply;
     struct d3dkmt_object_create_reply d3dkmt_object_create_reply;
     struct d3dkmt_object_query_reply d3dkmt_object_query_reply;
     struct d3dkmt_object_open_reply d3dkmt_object_open_reply;
     struct d3dkmt_share_objects_reply d3dkmt_share_objects_reply;
     struct d3dkmt_object_open_name_reply d3dkmt_object_open_name_reply;
+    struct get_esync_apc_fd_reply get_esync_apc_fd_reply;
 };
 
-#define SERVER_PROTOCOL_VERSION 917
+#define SERVER_PROTOCOL_VERSION 911
 
 #endif /* __WINE_WINE_SERVER_PROTOCOL_H */
diff -ruN --show-c-function README.esync README.esync
--- README.esync	1969-12-31 16:00:00.000000000 -0800
+++ README.esync	2025-10-10 10:22:17.172498779 -0700
@@ -0,0 +1,196 @@
+This is eventfd-based synchronization, or 'esync' for short. Turn it on with
+WINEESYNC=1; debug it with +esync.
+
+== BUGS AND LIMITATIONS ==
+
+Please let me know if you find any bugs. If you can, also attach a log with
++seh,+pid,+esync,+server,+timestamp.
+
+If you get something like "eventfd: Too many open files" and then things start
+crashing, you've probably run out of file descriptors. esync creates one
+eventfd descriptor for each synchronization object, and some games may use a
+large number of these.  Linux by default limits a process to 4096 file
+descriptors, which probably was reasonable back in the nineties but isn't
+really anymore. (Fortunately Debian and derivatives [Ubuntu, Mint] already
+have a reasonable limit.) To raise the limit you'll want to edit
+/etc/security/limits.conf and add a line like
+
+* hard nofile 1048576
+
+then restart your session.
+
+On distributions using systemd, the settings in `/etc/security/limits.conf`
+will be overridden by systemd's own settings. If you run `ulimit -Hn` and it
+returns a lower number than the one you've previously set, then you can set
+
+DefaultLimitNOFILE=1048576
+
+in both `/etc/systemd/system.conf` and `/etc/systemd/user.conf`. You can then
+execute `sudo systemctl daemon-reexec` and restart your session. Check again
+with `ulimit -Hn` that the limit is correct.
+
+Also note that if the wineserver has esync active, all clients also must, and
+vice versa. Otherwise things will probably crash quite badly.
+
+== EXPLANATION ==
+
+The aim is to execute all synchronization operations in "user-space", that is,
+without going through wineserver. We do this using Linux's eventfd
+facility. The main impetus to using eventfd is so that we can poll multiple
+objects at once; in particular we can't do this with futexes, or pthread
+semaphores, or the like. The only way I know of to wait on any of multiple
+objects is to use select/poll/epoll to wait on multiple fds, and eventfd gives
+us those fds in a quite usable way.
+
+Whenever a semaphore, event, or mutex is created, we have the server, instead
+of creating a traditional server-side event/semaphore/mutex, instead create an
+'esync' primitive. These live in esync.c and are very slim objects; in fact,
+they don't even know what type of primitive they are. The server is involved
+at all because we still need a way of creating named objects, passing handles
+to another process, etc.
+
+The server creates an eventfd file descriptor with the requested parameters
+and passes it back to ntdll. ntdll creates an object of the appropriate type,
+then caches it in a table. This table is copied almost wholesale from the fd
+cache code in server.c.
+
+Specific operations follow quite straightforwardly from eventfd:
+
+* To release an object, or set an event, we simply write() to it.
+* An object is signalled if read() succeeds on it. Notably, we create all
+  eventfd descriptors with O_NONBLOCK, so that we can atomically check if an
+  object is signalled and grab it if it is. This also lets us reset events.
+* For objects whose state should not be reset upon waiting—e.g. manual-reset
+  events—we simply check for the POLLIN flag instead of reading.
+* Semaphores are handled by the EFD_SEMAPHORE flag. This matches up quite well
+  (although with some difficulties; see below).
+* Mutexes store their owner thread locally. This isn't reliable information if
+  a different process's thread owns the mutex, but this doesn't matter—a
+  thread should only care whether it owns the mutex, so it knows whether to
+  try waiting on it or simply to increase the recursion count.
+
+The interesting part about esync is that (almost) all waits happen in ntdll,
+including those on server-bound objects. The idea here is that on the server
+side, for any waitable object, we create an eventfd file descriptor (not an
+esync primitive), and then pass it to ntdll if the program tries to wait on
+it. These are cached too, so only the first wait will require a round trip to
+the server. Then the server signals the file descriptor as appropriate, and
+thereby wakes up the client. So far this is implemented for processes,
+threads, message queues (difficult; see below), and device managers (necessary
+for drivers to work). All of these are necessarily server-bound, so we
+wouldn't really gain anything by signalling on the client side instead. Of
+course, except possibly for message queues, it's not likely that any program
+(cutting-edge D3D game or not) is going to be causing a great wineserver load
+by waiting on any of these objects; the motivation was rather to provide a way
+to wait on ntdll-bound and server-bound objects at the same time.
+
+Some cases are still passed to the server, and there's probably no reason not
+to keep them that way. Those that I noticed while testing include: async
+objects, which are internal to the file APIs and never exposed to userspace,
+startup_info objects, which are internal to the loader and signalled when a
+process starts, and keyed events, which are exposed through an ntdll API
+(although not through kernel32) but can't be mixed with other objects (you
+have to use NtWaitForKeyedEvent()). Other cases include: named pipes, debug
+events, sockets, and timers. It's unlikely we'll want to optimize debug events
+or sockets (or any of the other, rather rare, objects), but it is possible
+we'll want to optimize named pipes or timers.
+
+There were two sort of complications when working out the above. The first one
+was events. The trouble is that (1) the server actually creates some events by
+itself and (2) the server sometimes manipulates events passed by the
+client. Resolving the first case was easy enough, and merely entailed creating
+eventfd descriptors for the events the same way as for processes and threads
+(note that we don't really lose anything this way; the events include
+"LowMemoryCondition" and the event that signals system processes to shut
+down). For the second case I basically had to hook the server-side event
+functions to redirect to esync versions if the event was actually an esync
+primitive.
+
+The second complication was message queues. The difficulty here is that X11
+signals events by writing into a pipe (at least I think it's a pipe?), and so
+as a result wineserver has to poll on that descriptor. In theory we could just
+let wineserver do so and then signal us as appropriate, except that wineserver
+only polls on the pipe when the thread is waiting for events (otherwise we'd
+get e.g. keyboard input while the thread is doing something else, and spin
+forever trying to wake up a thread that doesn't care). The obvious solution is
+just to poll on that fd ourselves, and that's what I did—it's just that
+getting the fd from wineserver was kind of ugly, and the code for waiting was
+also kind of ugly basically because we have to wait on both X11's fd and the
+"normal" process/thread-style wineserver fd that we use to signal sent
+messages. The upshot about the whole thing was that races are basically
+impossible, since a thread can only wait on its own queue.
+
+System APCs already work, since the server will forcibly suspend a thread if
+it's not already waiting, and so we just need to check for EINTR from
+poll(). User APCs and alertable waits are implemented in a similar style to
+message queues (well, sort of): whenever someone executes an alertable wait,
+we add an additional eventfd to the list, which the server signals when an APC
+arrives. If that eventfd gets signaled, we hand it off to the server to take
+care of, and return STATUS_USER_APC.
+
+Originally I kept the volatile state of semaphores and mutexes inside a
+variable local to the handle, with the knowledge that this would break if
+someone tried to open the handle elsewhere or duplicate it. It did, and so now
+this state is stored inside shared memory. This is of the POSIX variety, is
+allocated by the server (but never mapped there) and lives under the path
+"/wine-esync".
+
+There are a couple things that this infrastructure can't handle, although
+surprisingly there aren't that many. In particular:
+* Implementing wait-all, i.e. WaitForMultipleObjects(..., TRUE, ...), is not
+  exactly possible the way we'd like it to be possible. In theory that
+  function should wait until it knows all objects are available, then grab
+  them all at once atomically. The server (like the kernel) can do this
+  because the server is single-threaded and can't race with itself. We can't
+  do this in ntdll, though. The approach I've taken I've laid out in great
+  detail in the relevant patch, but for a quick summary we poll on each object
+  until it's signaled (but don't grab it), check them all again, and if
+  they're all signaled we try to grab them all at once in a tight loop, and if
+  we fail on any of them we reset the count on whatever we shouldn't have
+  consumed. Such a blip would necessarily be very quick.
+* The whole patchset only works on Linux, where eventfd is available. However,
+  it should be possible to make it work on a Mac, since eventfd is just a
+  quicker, easier way to use pipes (i.e. instead of writing 1 to the fd you'd
+  write 1 byte; instead of reading a 64-bit value from the fd you'd read as
+  many bytes as you can carry, which is admittedly less than 2**64 but
+  can probably be something reasonable.) It's also possible, although I
+  haven't yet looked, to use some different kind of synchronization
+  primitives, but pipes would be easiest to tack onto this framework.
+* PulseEvent() can't work the way it's supposed to work. Fortunately it's rare
+  and deprecated. It's also explicitly mentioned on MSDN that a thread can
+  miss the notification for a kernel APC, so in a sense we're not necessarily
+  doing anything wrong.
+
+There are some things that are perfectly implementable but that I just haven't
+done yet:
+* Other synchronizable server primitives. It's unlikely we'll need any of
+  these, except perhaps named pipes (which would honestly be rather difficult)
+  and (maybe) timers.
+* Access masks. We'd need to store these inside ntdll, and validate them when
+  someone tries to execute esync operations.
+
+This patchset was inspired by Daniel Santos' "hybrid synchronization"
+patchset. My idea was to create a framework whereby even contended waits could
+be executed in userspace, eliminating a lot of the complexity that his
+synchronization primitives used. I do however owe some significant gratitude
+toward him for setting me on the right path.
+
+I've tried to maximize code separation, both to make any potential rebases
+easier and to ensure that esync is only active when configured. All code in
+existing source files is guarded with "if (do_esync())", and generally that
+condition is followed by "return esync_version_of_this_method(...);", where
+the latter lives in esync.c and is declared in esync.h. I've also tried to
+make the patchset very clear and readable—to write it as if I were going to
+submit it upstream. (Some intermediate patches do break things, which Wine is
+generally against, but I think it's for the better in this case.) I have cut
+some corners, though; there is some error checking missing, or implicit
+assumptions that the program is behaving correctly.
+
+I've tried to be careful about races. There are a lot of comments whose
+purpose are basically to assure me that races are impossible. In most cases we
+don't have to worry about races since all of the low-level synchronization is
+done by the kernel.
+
+Anyway, yeah, this is esync. Use it if you like.
+
+--Zebediah Figura
diff -ruN --show-c-function server/async.c server/async.c
--- server/async.c	2025-10-10 10:17:47.802634392 -0700
+++ server/async.c	2025-10-10 10:22:17.149366284 -0700
@@ -78,10 +78,10 @@ static const struct object_ops async_ops
     add_queue,                 /* add_queue */
     remove_queue,              /* remove_queue */
     async_signaled,            /* signaled */
+    NULL,                      /* get_esync_fd */
     async_satisfied,           /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
-    default_get_sync,          /* get_sync */
     default_map_access,        /* map_access */
     default_get_sd,            /* get_sd */
     default_set_sd,            /* set_sd */
@@ -700,10 +700,10 @@ static const struct object_ops iosb_ops
     no_add_queue,             /* add_queue */
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
+    NULL,                     /* get_esync_fd */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
-    default_get_sync,         /* get_sync */
     default_map_access,       /* map_access */
     default_get_sd,           /* get_sd */
     default_set_sd,           /* set_sd */
diff -ruN --show-c-function server/async.c.orig server/async.c.orig
--- server/async.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ server/async.c.orig	2025-10-10 10:22:12.712275974 -0700
@@ -0,0 +1,909 @@
+/*
+ * Server-side async I/O support
+ *
+ * Copyright (C) 2007 Alexandre Julliard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winternl.h"
+
+#include "object.h"
+#include "file.h"
+#include "request.h"
+#include "process.h"
+#include "handle.h"
+
+struct async
+{
+    struct object        obj;             /* object header */
+    struct thread       *thread;          /* owning thread */
+    struct list          queue_entry;     /* entry in async queue list */
+    struct list          process_entry;   /* entry in process list */
+    struct async_queue  *queue;           /* queue containing this async */
+    struct fd           *fd;              /* fd associated with an unqueued async */
+    struct timeout_user *timeout;
+    unsigned int         timeout_status;  /* status to report upon timeout */
+    struct event        *event;
+    struct async_data    data;            /* data for async I/O call */
+    struct iosb         *iosb;            /* I/O status block */
+    obj_handle_t         wait_handle;     /* pre-allocated wait handle */
+    unsigned int         initial_status;  /* status returned from initial request */
+    unsigned int         signaled :1;
+    unsigned int         pending :1;      /* request successfully queued, but pending */
+    unsigned int         direct_result :1;/* a flag if we're passing result directly from request instead of APC  */
+    unsigned int         alerted :1;      /* fd is signaled, but we are waiting for client-side I/O */
+    unsigned int         terminated :1;   /* async has been terminated */
+    unsigned int         canceled :1;     /* have we already queued cancellation for this async? */
+    unsigned int         unknown_status :1; /* initial status is not known yet */
+    unsigned int         blocking :1;     /* async is blocking */
+    unsigned int         is_system :1;    /* background system operation not affecting userspace visible state. */
+    struct completion   *completion;      /* completion associated with fd */
+    apc_param_t          comp_key;        /* completion key associated with fd */
+    unsigned int         comp_flags;      /* completion flags */
+    async_completion_callback completion_callback; /* callback to be called on completion */
+    void                *completion_callback_private; /* argument to completion_callback */
+};
+
+static void async_dump( struct object *obj, int verbose );
+static int async_signaled( struct object *obj, struct wait_queue_entry *entry );
+static void async_satisfied( struct object * obj, struct wait_queue_entry *entry );
+static void async_destroy( struct object *obj );
+
+static const struct object_ops async_ops =
+{
+    sizeof(struct async),      /* size */
+    &no_type,                  /* type */
+    async_dump,                /* dump */
+    add_queue,                 /* add_queue */
+    remove_queue,              /* remove_queue */
+    async_signaled,            /* signaled */
+    async_satisfied,           /* satisfied */
+    no_signal,                 /* signal */
+    no_get_fd,                 /* get_fd */
+    default_get_sync,          /* get_sync */
+    default_map_access,        /* map_access */
+    default_get_sd,            /* get_sd */
+    default_set_sd,            /* set_sd */
+    no_get_full_name,          /* get_full_name */
+    no_lookup_name,            /* lookup_name */
+    no_link_name,              /* link_name */
+    NULL,                      /* unlink_name */
+    no_open_file,              /* open_file */
+    no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_close_handle,           /* close_handle */
+    async_destroy              /* destroy */
+};
+
+static inline void async_reselect( struct async *async )
+{
+    if (async->queue && async->fd) fd_reselect_async( async->fd, async->queue );
+}
+
+static void async_dump( struct object *obj, int verbose )
+{
+    struct async *async = (struct async *)obj;
+    assert( obj->ops == &async_ops );
+    fprintf( stderr, "Async thread=%p\n", async->thread );
+}
+
+static int async_signaled( struct object *obj, struct wait_queue_entry *entry )
+{
+    struct async *async = (struct async *)obj;
+    assert( obj->ops == &async_ops );
+    return async->signaled;
+}
+
+static void async_satisfied( struct object *obj, struct wait_queue_entry *entry )
+{
+    struct async *async = (struct async *)obj;
+    assert( obj->ops == &async_ops );
+
+    /* we only return an async handle for asyncs created via create_request_async() */
+    assert( async->iosb );
+
+    if (async->direct_result)
+    {
+        async_set_result( &async->obj, async->iosb->status, async->iosb->result );
+        async->direct_result = 0;
+    }
+
+    if (async->initial_status == STATUS_PENDING && async->blocking)
+        set_wait_status( entry, async->iosb->status );
+    else
+        set_wait_status( entry, async->initial_status );
+
+    /* close wait handle here to avoid extra server round trip */
+    if (async->wait_handle)
+    {
+        close_handle( async->thread->process, async->wait_handle );
+        async->wait_handle = 0;
+    }
+}
+
+static void async_destroy( struct object *obj )
+{
+    struct async *async = (struct async *)obj;
+    assert( obj->ops == &async_ops );
+
+    list_remove( &async->process_entry );
+
+    if (async->queue)
+    {
+        list_remove( &async->queue_entry );
+        async_reselect( async );
+    }
+    else if (async->fd) release_object( async->fd );
+
+    if (async->timeout) remove_timeout_user( async->timeout );
+    if (async->completion) release_object( async->completion );
+    if (async->event) release_object( async->event );
+    if (async->iosb) release_object( async->iosb );
+    release_object( async->thread );
+}
+
+/* notifies client thread of new status of its async request */
+void async_terminate( struct async *async, unsigned int status )
+{
+    struct iosb *iosb = async->iosb;
+
+    if (async->terminated) return;
+
+    async->terminated = 1;
+    if (async->iosb && async->iosb->status == STATUS_PENDING) async->iosb->status = status;
+    if (status == STATUS_ALERTED)
+        async->alerted = 1;
+
+    /* if no APC could be queued (e.g. the process is terminated),
+     * thread_queue_apc() may trigger async_set_result(), which may drop the
+     * last reference to the async, so grab a temporary reference here */
+    grab_object( async );
+
+    if (!async->direct_result)
+    {
+        union apc_call data;
+
+        memset( &data, 0, sizeof(data) );
+        data.type            = APC_ASYNC_IO;
+        data.async_io.user   = async->data.user;
+        data.async_io.result = iosb ? iosb->result : 0;
+
+        /* this can happen if the initial status was unknown (i.e. for device
+         * files). the client should not fill the IOSB in this case; pass it as
+         * NULL to communicate that.
+         * note that we check the IOSB status and not the initial status */
+        if (NT_ERROR( status ) && (!is_fd_overlapped( async->fd ) || !async->pending))
+            data.async_io.sb = 0;
+        else
+            data.async_io.sb = async->data.iosb;
+
+        /* if there is output data, the client needs to make an extra request
+         * to retrieve it; use STATUS_ALERTED to signal this case */
+        if (iosb && iosb->out_data)
+            data.async_io.status = STATUS_ALERTED;
+        else
+            data.async_io.status = status;
+
+        thread_queue_apc( async->thread->process, async->thread, &async->obj, &data );
+    }
+
+    async_reselect( async );
+
+    release_object( async );
+}
+
+/* callback for timeout on an async request */
+static void async_timeout( void *private )
+{
+    struct async *async = private;
+
+    async->timeout = NULL;
+    async_terminate( async, async->timeout_status );
+}
+
+/* free an async queue, cancelling all async operations */
+void free_async_queue( struct async_queue *queue )
+{
+    struct async *async, *next;
+
+    LIST_FOR_EACH_ENTRY_SAFE( async, next, &queue->queue, struct async, queue_entry )
+    {
+        if (!async->completion) async->completion = fd_get_completion( async->fd, &async->comp_key );
+        async->fd = NULL;
+        async_terminate( async, STATUS_HANDLES_CLOSED );
+        async->queue = NULL;
+        release_object( &async->obj );
+    }
+}
+
+void queue_async( struct async_queue *queue, struct async *async )
+{
+    /* fd will be set to NULL in free_async_queue when fd is destroyed */
+    release_object( async->fd );
+
+    async->queue = queue;
+    grab_object( async );
+    list_add_tail( &queue->queue, &async->queue_entry );
+
+    if (!async->is_system) set_fd_signaled( async->fd, 0 );
+}
+
+/* create an async on a given queue of a fd */
+struct async *create_async( struct fd *fd, struct thread *thread, const struct async_data *data, struct iosb *iosb )
+{
+    struct event *event = NULL;
+    struct async *async;
+
+    if (data->event && !(event = get_event_obj( thread->process, data->event, EVENT_MODIFY_STATE )))
+        return NULL;
+
+    if (!(async = alloc_object( &async_ops )))
+    {
+        if (event) release_object( event );
+        return NULL;
+    }
+
+    async->thread        = (struct thread *)grab_object( thread );
+    async->event         = event;
+    async->data          = *data;
+    async->timeout       = NULL;
+    async->queue         = NULL;
+    async->fd            = (struct fd *)grab_object( fd );
+    async->initial_status = STATUS_PENDING;
+    async->signaled      = 0;
+    async->pending       = 1;
+    async->wait_handle   = 0;
+    async->direct_result = 0;
+    async->alerted       = 0;
+    async->terminated    = 0;
+    async->canceled      = 0;
+    async->unknown_status = 0;
+    async->blocking      = !is_fd_overlapped( fd );
+    async->is_system     = 0;
+    async->completion    = fd_get_completion( fd, &async->comp_key );
+    async->comp_flags    = 0;
+    async->completion_callback = NULL;
+    async->completion_callback_private = NULL;
+
+    if (iosb) async->iosb = (struct iosb *)grab_object( iosb );
+    else async->iosb = NULL;
+
+    list_add_head( &thread->process->asyncs, &async->process_entry );
+    if (event) reset_event( event );
+
+    if (async->completion && data->apc)
+    {
+        release_object( async );
+        set_error( STATUS_INVALID_PARAMETER );
+        return NULL;
+    }
+
+    return async;
+}
+
+/* set the initial status of an async whose status was previously unknown
+ * the initial status may be STATUS_PENDING */
+void async_set_initial_status( struct async *async, unsigned int status )
+{
+    async->initial_status = status;
+    async->unknown_status = 0;
+}
+
+void set_async_pending( struct async *async )
+{
+    if (!async->terminated)
+        async->pending = 1;
+}
+
+void async_wake_obj( struct async *async )
+{
+    assert( !async->unknown_status );
+    if (!async->blocking)
+    {
+        async->signaled = 1;
+        wake_up( &async->obj, 0 );
+    }
+}
+
+static void async_call_completion_callback( struct async *async )
+{
+    if (async->completion_callback)
+        async->completion_callback( async->completion_callback_private );
+    async->completion_callback = NULL;
+}
+
+/* return async object status and wait handle to client */
+obj_handle_t async_handoff( struct async *async, data_size_t *result, int force_blocking )
+{
+    async->blocking = force_blocking || async->blocking;
+
+    if (async->unknown_status)
+    {
+        /* even the initial status is not known yet */
+        set_error( STATUS_PENDING );
+        return async->wait_handle;
+    }
+
+    if (get_error() == STATUS_ALERTED)
+    {
+        /* give the client opportunity to complete synchronously.  after the
+         * client performs the I/O, it reports the result back to the server
+         * via the set_async_direct_result request.  if it turns out that the
+         * I/O request is not actually immediately satiable, the client may
+         * then choose to re-queue the async by reporting STATUS_PENDING
+         * instead.
+         *
+         * since we're deferring the initial I/O (to the client), we mark the
+         * async as having unknown initial status (unknown_status = 1).  note
+         * that we don't reuse async_set_unknown_status() here.  this is because
+         * the one responsible for performing the I/O is not the device driver,
+         * but instead the client that requested the I/O in the first place.
+         *
+         * also, async_set_unknown_status() would set direct_result to zero
+         * forcing APC_ASYNC_IO to fire in async_terminate(), which is not
+         * useful due to subtle semantic differences between synchronous and
+         * asynchronous completion.
+         */
+        async->unknown_status = 1;
+        async_terminate( async, STATUS_ALERTED );
+        return async->wait_handle;
+    }
+
+    async->initial_status = get_error();
+
+    if (get_error() != STATUS_PENDING)
+    {
+        /* status and data are already set and returned */
+        async_terminate( async, get_error() );
+    }
+    else if (async->iosb->status != STATUS_PENDING)
+    {
+        /* result is already available in iosb, return it */
+        if (async->iosb->out_data)
+        {
+            set_reply_data_ptr( async->iosb->out_data, async->iosb->out_size );
+            async->iosb->out_data = NULL;
+        }
+    }
+
+    if (!async->pending && NT_ERROR( async->iosb->status ))
+    {
+        async_call_completion_callback( async );
+
+        close_handle( async->thread->process, async->wait_handle );
+        async->wait_handle = 0;
+        set_error( async->iosb->status );
+        return 0;
+    }
+
+    if (async->iosb->status != STATUS_PENDING)
+    {
+        if (result) *result = async->iosb->result;
+        async->signaled = 1;
+    }
+    else
+    {
+        async->direct_result = 0;
+        async->pending = 1;
+        if (!async->blocking)
+        {
+            close_handle( async->thread->process, async->wait_handle);
+            async->wait_handle = 0;
+        }
+    }
+    async->initial_status = async->iosb->status;
+    set_error( async->iosb->status );
+    return async->wait_handle;
+}
+
+/* complete a request-based async with a pre-allocated buffer */
+void async_request_complete( struct async *async, unsigned int status, data_size_t result,
+                             data_size_t out_size, void *out_data )
+{
+    struct iosb *iosb = async_get_iosb( async );
+
+    /* the async may have already been canceled */
+    if (iosb->status != STATUS_PENDING)
+    {
+        release_object( iosb );
+        free( out_data );
+        return;
+    }
+
+    iosb->status = status;
+    iosb->result = result;
+    iosb->out_data = out_data;
+    iosb->out_size = out_size;
+
+    release_object( iosb );
+
+    async_terminate( async, status );
+}
+
+/* complete a request-based async */
+void async_request_complete_alloc( struct async *async, unsigned int status, data_size_t result,
+                                   data_size_t out_size, const void *out_data )
+{
+    void *out_data_copy = NULL;
+
+    if (out_size && !(out_data_copy = memdup( out_data, out_size )))
+    {
+        async_terminate( async, STATUS_NO_MEMORY );
+        return;
+    }
+
+    async_request_complete( async, status, result, out_size, out_data_copy );
+}
+
+/* mark an async as having unknown initial status */
+void async_set_unknown_status( struct async *async )
+{
+    async->unknown_status = 1;
+    async->direct_result = 0;
+}
+
+/* set the timeout of an async operation */
+void async_set_timeout( struct async *async, timeout_t timeout, unsigned int status )
+{
+    if (async->timeout) remove_timeout_user( async->timeout );
+    if (timeout != TIMEOUT_INFINITE) async->timeout = add_timeout_user( timeout, async_timeout, async );
+    else async->timeout = NULL;
+    async->timeout_status = status;
+}
+
+/* set a callback to be notified when the async is completed */
+void async_set_completion_callback( struct async *async, async_completion_callback func, void *private )
+{
+    async->completion_callback = func;
+    async->completion_callback_private = private;
+}
+
+static void add_async_completion( struct async *async, apc_param_t cvalue, unsigned int status,
+                                  apc_param_t information )
+{
+    if (async->fd && !async->completion) async->completion = fd_get_completion( async->fd, &async->comp_key );
+    if (async->completion) add_completion( async->completion, async->comp_key, cvalue, status, information );
+}
+
+/* store the result of the client-side async callback */
+void async_set_result( struct object *obj, unsigned int status, apc_param_t total )
+{
+    struct async *async = (struct async *)obj;
+
+    if (obj->ops != &async_ops) return;  /* in case the client messed up the APC results */
+
+    assert( async->terminated );  /* it must have been woken up if we get a result */
+
+    if (async->unknown_status) async_set_initial_status( async, status );
+
+    if (async->alerted && status == STATUS_PENDING)  /* restart it */
+    {
+        async->terminated = 0;
+        async->alerted = 0;
+        async_reselect( async );
+    }
+    else
+    {
+        if (async->timeout) remove_timeout_user( async->timeout );
+        async->timeout = NULL;
+        async->terminated = 1;
+        if (async->iosb) async->iosb->status = status;
+
+        /* don't signal completion if the async failed synchronously
+         * this can happen if the initial status was unknown (i.e. for device files)
+         * note that we check the IOSB status here, not the initial status */
+        if (async->pending || !NT_ERROR( status ))
+        {
+            if (async->data.apc)
+            {
+                union apc_call data;
+                memset( &data, 0, sizeof(data) );
+                data.type         = APC_USER;
+                data.user.flags   = 0;
+                data.user.func    = async->data.apc;
+                data.user.args[0] = async->data.apc_context;
+                data.user.args[1] = async->data.iosb;
+                data.user.args[2] = 0;
+                thread_queue_apc( NULL, async->thread, NULL, &data );
+            }
+            else if (async->data.apc_context && (async->pending ||
+                     !(async->comp_flags & FILE_SKIP_COMPLETION_PORT_ON_SUCCESS)))
+            {
+                add_async_completion( async, async->data.apc_context, status, total );
+            }
+
+            if (async->event) set_event( async->event );
+            else if (async->fd && !async->is_system) set_fd_signaled( async->fd, 1 );
+        }
+
+        if (!async->signaled)
+        {
+            async->signaled = 1;
+            wake_up( &async->obj, 0 );
+        }
+
+        async_call_completion_callback( async );
+
+        if (async->queue)
+        {
+            list_remove( &async->queue_entry );
+            async_reselect( async );
+            async->fd = NULL;
+            async->queue = NULL;
+            release_object( async );
+        }
+    }
+}
+
+int async_queue_has_waiting_asyncs( struct async_queue *queue )
+{
+    struct async *async;
+
+    LIST_FOR_EACH_ENTRY( async, &queue->queue, struct async, queue_entry )
+        if (!async->unknown_status) return 1;
+
+    return 0;
+}
+
+/* check if an async operation is waiting to be alerted */
+int async_waiting( struct async_queue *queue )
+{
+    struct list *ptr;
+    struct async *async;
+
+    if (!(ptr = list_head( &queue->queue ))) return 0;
+    async = LIST_ENTRY( ptr, struct async, queue_entry );
+    return !async->terminated;
+}
+
+static int cancel_async( struct process *process, struct object *obj, struct thread *thread, client_ptr_t iosb )
+{
+    struct async *async;
+    int woken = 0;
+
+    /* FIXME: it would probably be nice to replace the "canceled" flag with a
+     * single LIST_FOR_EACH_ENTRY_SAFE, but currently cancelling an async can
+     * cause other asyncs to be removed via async_reselect() */
+
+restart:
+    LIST_FOR_EACH_ENTRY( async, &process->asyncs, struct async, process_entry )
+    {
+        if (async->terminated || async->canceled || async->is_system) continue;
+        if ((!obj || (get_fd_user( async->fd ) == obj)) &&
+            (!thread || async->thread == thread) &&
+            (!iosb || async->data.iosb == iosb))
+        {
+            async->canceled = 1;
+            fd_cancel_async( async->fd, async );
+            woken++;
+            goto restart;
+        }
+    }
+    return woken;
+}
+
+static int cancel_blocking( struct process *process, struct thread *thread, client_ptr_t iosb )
+{
+    struct async *async;
+    int woken = 0;
+
+restart:
+    LIST_FOR_EACH_ENTRY( async, &process->asyncs, struct async, process_entry )
+    {
+        if (async->terminated || async->canceled) continue;
+        if (async->blocking && async->thread == thread &&
+            (!iosb || async->data.iosb == iosb))
+        {
+            async->canceled = 1;
+            fd_cancel_async( async->fd, async );
+            woken++;
+            goto restart;
+        }
+    }
+    return woken;
+}
+
+void cancel_process_asyncs( struct process *process )
+{
+    struct async *async;
+
+restart:
+    LIST_FOR_EACH_ENTRY( async, &process->asyncs, struct async, process_entry )
+    {
+        if (async->terminated || async->canceled) continue;
+        async->canceled = 1;
+        fd_cancel_async( async->fd, async );
+        goto restart;
+    }
+}
+
+int async_close_obj_handle( struct object *obj, struct process *process, obj_handle_t handle )
+{
+    /* Handle a special case when the last object handle in the given process is closed.
+     * If this is the last object handle overall that is handled in object's close_handle and
+     * destruction. */
+    struct async *async;
+
+    if (obj->handle_count == 1 || get_obj_handle_count( process, obj ) != 1) return 1;
+
+restart:
+    LIST_FOR_EACH_ENTRY( async, &process->asyncs, struct async, process_entry )
+    {
+        if (async->terminated || async->canceled || get_fd_user( async->fd ) != obj) continue;
+        if (!async->completion || !async->data.apc_context || async->event) continue;
+
+        async->canceled = 1;
+        fd_cancel_async( async->fd, async );
+        goto restart;
+    }
+    return 1;
+}
+
+void cancel_terminating_thread_asyncs( struct thread *thread )
+{
+    struct async *async;
+
+restart:
+    LIST_FOR_EACH_ENTRY( async, &thread->process->asyncs, struct async, process_entry )
+    {
+        if (async->thread != thread || async->terminated || async->canceled) continue;
+        if (async->completion && async->data.apc_context && !async->event) continue;
+        if (async->is_system) continue;
+
+        async->canceled = 1;
+        fd_cancel_async( async->fd, async );
+        goto restart;
+    }
+}
+
+/* wake up async operations on the queue */
+void async_wake_up( struct async_queue *queue, unsigned int status )
+{
+    struct list *ptr, *next;
+
+    LIST_FOR_EACH_SAFE( ptr, next, &queue->queue )
+    {
+        struct async *async = LIST_ENTRY( ptr, struct async, queue_entry );
+        async_terminate( async, status );
+        if (status == STATUS_ALERTED) break;  /* only wake up the first one */
+    }
+}
+
+static void iosb_dump( struct object *obj, int verbose );
+static void iosb_destroy( struct object *obj );
+
+static const struct object_ops iosb_ops =
+{
+    sizeof(struct iosb),      /* size */
+    &no_type,                 /* type */
+    iosb_dump,                /* dump */
+    no_add_queue,             /* add_queue */
+    NULL,                     /* remove_queue */
+    NULL,                     /* signaled */
+    NULL,                     /* satisfied */
+    no_signal,                /* signal */
+    no_get_fd,                /* get_fd */
+    default_get_sync,         /* get_sync */
+    default_map_access,       /* map_access */
+    default_get_sd,           /* get_sd */
+    default_set_sd,           /* set_sd */
+    no_get_full_name,         /* get_full_name */
+    no_lookup_name,           /* lookup_name */
+    no_link_name,             /* link_name */
+    NULL,                     /* unlink_name */
+    no_open_file,             /* open_file */
+    no_kernel_obj_list,       /* get_kernel_obj_list */
+    no_close_handle,          /* close_handle */
+    iosb_destroy              /* destroy */
+};
+
+static void iosb_dump( struct object *obj, int verbose )
+{
+    assert( obj->ops == &iosb_ops );
+    fprintf( stderr, "I/O status block\n" );
+}
+
+static void iosb_destroy( struct object *obj )
+{
+    struct iosb *iosb = (struct iosb *)obj;
+
+    free( iosb->in_data );
+    free( iosb->out_data );
+}
+
+/* allocate iosb struct */
+static struct iosb *create_iosb( const void *in_data, data_size_t in_size, data_size_t out_size )
+{
+    struct iosb *iosb;
+
+    if (!(iosb = alloc_object( &iosb_ops ))) return NULL;
+
+    iosb->status = STATUS_PENDING;
+    iosb->result = 0;
+    iosb->in_size = in_size;
+    iosb->in_data = NULL;
+    iosb->out_size = out_size;
+    iosb->out_data = NULL;
+
+    if (in_size && !(iosb->in_data = memdup( in_data, in_size )))
+    {
+        release_object( iosb );
+        iosb = NULL;
+    }
+
+    return iosb;
+}
+
+/* create an async associated with iosb for async-based requests
+ * returned async must be passed to async_handoff */
+struct async *create_request_async( struct fd *fd, unsigned int comp_flags, const struct async_data *data, int is_system )
+{
+    struct async *async;
+    struct iosb *iosb;
+
+    if (!(iosb = create_iosb( get_req_data(), get_req_data_size(), get_reply_max_size() )))
+        return NULL;
+
+    async = create_async( fd, current, data, iosb );
+    release_object( iosb );
+    if (async)
+    {
+        if (!(async->wait_handle = alloc_handle( current->process, async, SYNCHRONIZE, 0 )))
+        {
+            release_object( async );
+            return NULL;
+        }
+        async->pending       = 0;
+        async->direct_result = 1;
+        async->is_system     = !!is_system;
+        async->comp_flags    = comp_flags;
+    }
+    return async;
+}
+
+struct iosb *async_get_iosb( struct async *async )
+{
+    return async->iosb ? (struct iosb *)grab_object( async->iosb ) : NULL;
+}
+
+struct thread *async_get_thread( struct async *async )
+{
+    return async->thread;
+}
+
+/* find the first pending async in queue */
+struct async *find_pending_async( struct async_queue *queue )
+{
+    struct async *async;
+    LIST_FOR_EACH_ENTRY( async, &queue->queue, struct async, queue_entry )
+        if (!async->terminated) return (struct async *)grab_object( async );
+    return NULL;
+}
+
+/* cancels sync I/O on a thread */
+DECL_HANDLER(cancel_sync)
+{
+    struct thread *thread = get_thread_from_handle( req->handle, THREAD_TERMINATE );
+
+    if (thread)
+    {
+        if (!cancel_blocking( current->process, thread, req->iosb ))
+            set_error( STATUS_NOT_FOUND );
+        release_object( thread );
+    }
+}
+
+/* cancels all async I/O */
+DECL_HANDLER(cancel_async)
+{
+    struct object *obj = get_handle_obj( current->process, req->handle, 0, NULL );
+    struct thread *thread = req->only_thread ? current : NULL;
+
+    if (obj)
+    {
+        int count = cancel_async( current->process, obj, thread, req->iosb );
+        if (!count && !thread) set_error( STATUS_NOT_FOUND );
+        release_object( obj );
+    }
+}
+
+/* get async result from associated iosb */
+DECL_HANDLER(get_async_result)
+{
+    struct iosb *iosb = NULL;
+    struct async *async;
+
+    LIST_FOR_EACH_ENTRY( async, &current->process->asyncs, struct async, process_entry )
+        if (async->data.user == req->user_arg)
+        {
+            iosb = async->iosb;
+            break;
+        }
+
+    if (!iosb)
+    {
+        set_error( STATUS_INVALID_PARAMETER );
+        return;
+    }
+
+    if (iosb->out_data)
+    {
+        data_size_t size = min( iosb->out_size, get_reply_max_size() );
+        if (size)
+        {
+            set_reply_data_ptr( iosb->out_data, size );
+            iosb->out_data = NULL;
+        }
+    }
+    set_error( iosb->status );
+}
+
+/* notify direct completion of async and close the wait handle if not blocking */
+DECL_HANDLER(set_async_direct_result)
+{
+    struct async *async = (struct async *)get_handle_obj( current->process, req->handle, 0, &async_ops );
+    unsigned int status = req->status;
+
+    if (!async) return;
+
+    if (!async->unknown_status || !async->terminated || !async->alerted)
+    {
+        set_error( STATUS_INVALID_PARAMETER );
+        release_object( &async->obj );
+        return;
+    }
+
+    if (status == STATUS_PENDING)
+    {
+        async->direct_result = 0;
+        async->pending = 1;
+    }
+    else if (req->mark_pending)
+    {
+        async->pending = 1;
+    }
+
+    /* if the I/O has completed successfully (or unsuccessfully, and
+     * async->pending is set), the client would have already set the IOSB.
+     * therefore, we can do async_set_result() directly and let the client skip
+     * waiting on wait_handle.
+     */
+    async_set_result( &async->obj, status, req->information );
+
+    /* close wait handle here to avoid extra server round trip, if the I/O
+     * either has completed, or is pending and not blocking.
+     */
+    if (status != STATUS_PENDING || !async->blocking)
+    {
+        close_handle( async->thread->process, async->wait_handle );
+        async->wait_handle = 0;
+    }
+
+    /* report back to the client whether the wait handle has been closed.
+     * handle will be 0 if closed by us; otherwise the original value is
+     * retained
+     */
+    reply->handle = async->wait_handle;
+
+    release_object( &async->obj );
+}
diff -ruN --show-c-function server/atom.c server/atom.c
--- server/atom.c	2025-10-10 10:17:47.802634392 -0700
+++ server/atom.c	2025-10-10 10:22:17.149607304 -0700
@@ -77,10 +77,10 @@ static const struct object_ops atom_tabl
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
-    default_get_sync,             /* get_sync */
     default_map_access,           /* map_access */
     default_get_sd,               /* get_sd */
     default_set_sd,               /* set_sd */
diff -ruN --show-c-function server/atom.c.orig server/atom.c.orig
--- server/atom.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ server/atom.c.orig	2025-10-10 10:22:12.712275974 -0700
@@ -0,0 +1,440 @@
+/*
+ * Server-side atom management
+ *
+ * Copyright (C) 1999, 2000 Alexandre Julliard
+ * Copyright (C) 2000 Turchanov Sergei
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include <assert.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+
+#include "unicode.h"
+#include "request.h"
+#include "object.h"
+#include "process.h"
+#include "handle.h"
+#include "user.h"
+#include "winuser.h"
+#include "winternl.h"
+
+#define HASH_SIZE     37
+#define MIN_HASH_SIZE 4
+#define MAX_HASH_SIZE 0x200
+
+#define MIN_STR_ATOM  0xc000
+#define MAX_ATOMS     0x4000
+
+struct atom_entry
+{
+    struct atom_entry *next;   /* hash table list */
+    struct atom_entry *prev;   /* hash table list */
+    int                count;  /* reference count */
+    atom_t             atom;   /* atom handle */
+    unsigned short     hash;   /* string hash */
+    unsigned short     len;    /* string len */
+    WCHAR              str[1]; /* atom string */
+};
+
+struct atom_table
+{
+    struct object       obj;                 /* object header */
+    int                 count;               /* number of used atoms */
+    struct atom_entry  *atoms[MAX_ATOMS];    /* atom entries */
+    struct atom_entry  *entries[HASH_SIZE];  /* hash table entries */
+};
+
+C_ASSERT( sizeof(struct atom_table) <= 256 * 1024 );
+
+static void atom_table_dump( struct object *obj, int verbose );
+static void atom_table_destroy( struct object *obj );
+
+static const struct object_ops atom_table_ops =
+{
+    sizeof(struct atom_table),    /* size */
+    &no_type,                     /* type */
+    atom_table_dump,              /* dump */
+    no_add_queue,                 /* add_queue */
+    NULL,                         /* remove_queue */
+    NULL,                         /* signaled */
+    NULL,                         /* satisfied */
+    no_signal,                    /* signal */
+    no_get_fd,                    /* get_fd */
+    default_get_sync,             /* get_sync */
+    default_map_access,           /* map_access */
+    default_get_sd,               /* get_sd */
+    default_set_sd,               /* set_sd */
+    no_get_full_name,             /* get_full_name */
+    no_lookup_name,               /* lookup_name */
+    no_link_name,                 /* link_name */
+    NULL,                         /* unlink_name */
+    no_open_file,                 /* open_file */
+    no_kernel_obj_list,           /* get_kernel_obj_list */
+    no_close_handle,              /* close_handle */
+    atom_table_destroy            /* destroy */
+};
+
+static struct atom_table *global_table;
+static struct atom_table *user_table;
+
+static void add_atom_asciiz( struct atom_table *table, const char *name )
+{
+    WCHAR buffer[MAX_ATOM_LEN + 1];
+    struct unicode_str str = { buffer, strlen( name ) * sizeof(WCHAR) };
+    for (int i = 0; i < str.len / sizeof(WCHAR); i++) buffer[i] = name[i];
+    add_atom( table, &str );
+}
+
+struct object *create_atom_table(void)
+{
+    struct atom_table *table;
+
+    if (!(table = alloc_object( &atom_table_ops ))) return NULL;
+    memset( table->atoms, 0, sizeof(*table->atoms) * ARRAY_SIZE(table->atoms) );
+    memset( table->entries, 0, sizeof(*table->entries) * ARRAY_SIZE(table->entries) );
+    table->count = 1; /* atom 0xc000 is reserved */
+
+    return &table->obj;
+}
+
+void set_global_atom_table( struct object *obj )
+{
+    assert( obj->ops == &atom_table_ops );
+    global_table = (struct atom_table *)obj;
+    make_object_permanent( obj );
+    grab_object( obj );
+
+    add_atom_asciiz( global_table, "StdExit" );
+    add_atom_asciiz( global_table, "StdNewDocument" );
+    add_atom_asciiz( global_table, "StdOpenDocument" );
+    add_atom_asciiz( global_table, "StdEditDocument" );
+    add_atom_asciiz( global_table, "StdNewfromTemplate" );
+    add_atom_asciiz( global_table, "StdCloseDocument" );
+    add_atom_asciiz( global_table, "StdShowItem" );
+    add_atom_asciiz( global_table, "StdDoVerbItem" );
+    add_atom_asciiz( global_table, "System" );
+    add_atom_asciiz( global_table, "OLEsystem" );
+    add_atom_asciiz( global_table, "StdDocumentName" );
+    add_atom_asciiz( global_table, "Protocols" );
+    add_atom_asciiz( global_table, "Topics" );
+    add_atom_asciiz( global_table, "Formats" );
+    add_atom_asciiz( global_table, "Status" );
+    add_atom_asciiz( global_table, "EditEnvItems" );
+    add_atom_asciiz( global_table, "True" );
+    add_atom_asciiz( global_table, "False" );
+    add_atom_asciiz( global_table, "Change" );
+    add_atom_asciiz( global_table, "Save" );
+    add_atom_asciiz( global_table, "Close" );
+    add_atom_asciiz( global_table, "MSDraw" );
+    add_atom_asciiz( global_table, "CC32SubclassInfo" );
+}
+
+struct atom_table *get_global_atom_table(void)
+{
+    return global_table;
+}
+
+void set_user_atom_table( struct object *obj )
+{
+    assert( obj->ops == &atom_table_ops );
+    user_table = (struct atom_table *)obj;
+    make_object_permanent( obj );
+    grab_object( obj );
+
+    add_atom_asciiz( user_table, "USER32" );
+    add_atom_asciiz( user_table, "ObjectLink" );
+    add_atom_asciiz( user_table, "OwnerLink" );
+    add_atom_asciiz( user_table, "Native" );
+    add_atom_asciiz( user_table, "Binary" );
+    add_atom_asciiz( user_table, "FileName" );
+    add_atom_asciiz( user_table, "FileNameW" );
+    add_atom_asciiz( user_table, "NetworkName" );
+    add_atom_asciiz( user_table, "DataObject" );
+    add_atom_asciiz( user_table, "Embedded Object" );
+    add_atom_asciiz( user_table, "Embed Source" );
+    add_atom_asciiz( user_table, "Custom Link Source" );
+    add_atom_asciiz( user_table, "Link Source" );
+    add_atom_asciiz( user_table, "Object Descriptor" );
+    add_atom_asciiz( user_table, "Link Source Descriptor" );
+    add_atom_asciiz( user_table, "OleDraw" );
+    add_atom_asciiz( user_table, "PBrush" );
+    add_atom_asciiz( user_table, "MSDraw" );
+    add_atom_asciiz( user_table, "Ole Private Data" );
+    add_atom_asciiz( user_table, "Screen Picture" );
+    add_atom_asciiz( user_table, "OleClipboardPersistOnFlush" );
+    add_atom_asciiz( user_table, "MoreOlePrivateData" );
+    add_atom_asciiz( user_table, "Button" );
+    add_atom_asciiz( user_table, "Edit" );
+    add_atom_asciiz( user_table, "Static" );
+    add_atom_asciiz( user_table, "ListBox" );
+    add_atom_asciiz( user_table, "ScrollBar" );
+    add_atom_asciiz( user_table, "ComboBox" );
+}
+
+struct atom_table *get_user_atom_table(void)
+{
+    return user_table;
+}
+
+/* retrieve an entry pointer from its atom */
+static struct atom_entry *get_atom_entry( struct atom_table *table, atom_t atom )
+{
+    struct atom_entry *entry = NULL;
+    if (table && (atom >= MIN_STR_ATOM) && (atom < MIN_STR_ATOM + table->count))
+        entry = table->atoms[atom - MIN_STR_ATOM];
+    if (!entry) set_error( STATUS_INVALID_HANDLE );
+    return entry;
+}
+
+/* add an atom entry in the table and return its handle */
+static atom_t add_atom_entry( struct atom_table *table, struct atom_entry *entry )
+{
+    int i;
+    for (i = 1 /* atom 0xc000 is reserved */; i < table->count; i++) if (!table->atoms[i]) break;
+    if (i == ARRAY_SIZE(table->atoms)) return 0;
+    if (i == table->count) table->count++;
+    table->atoms[i] = entry;
+    entry->atom = i + MIN_STR_ATOM;
+    return entry->atom;
+}
+
+/* dump an atom table */
+static void atom_table_dump( struct object *obj, int verbose )
+{
+    int i;
+    struct atom_table *table = (struct atom_table *)obj;
+    assert( obj->ops == &atom_table_ops );
+
+    fprintf( stderr, "Atom table size=%d\n", table->count );
+    if (!verbose) return;
+    for (i = 0; i < table->count; i++)
+    {
+        struct atom_entry *entry = table->atoms[i];
+        if (!entry) continue;
+        fprintf( stderr, "  %04x: ref=%d hash=%d \"",
+                 entry->atom, entry->count, entry->hash );
+        dump_strW( entry->str, entry->len, stderr, "\"\"");
+        fprintf( stderr, "\"\n" );
+    }
+}
+
+/* destroy the atom table */
+static void atom_table_destroy( struct object *obj )
+{
+    int i;
+    struct atom_table *table = (struct atom_table *)obj;
+    assert( obj->ops == &atom_table_ops );
+    for (i = 0; i < table->count; i++) free( table->atoms[i] );
+}
+
+static atom_t get_int_atom_value( const struct unicode_str *name )
+{
+    const WCHAR *ptr = name->str;
+    const WCHAR *end = ptr + name->len / sizeof(WCHAR);
+    unsigned int ret = 0;
+
+    if (*ptr++ != '#') return 0;
+    while (ptr < end)
+    {
+        if (*ptr < '0' || *ptr > '9') return 0;
+        ret = ret * 10 + *ptr++ - '0';
+        if (ret >= MAXINTATOM) return 0;
+    }
+    return ret;
+}
+
+/* find an atom entry in its hash list */
+static struct atom_entry *find_atom_entry( struct atom_table *table, const struct unicode_str *str,
+                                           unsigned short hash )
+{
+    struct atom_entry *entry = table->entries[hash];
+    while (entry)
+    {
+        if (entry->len == str->len && !memicmp_strW( entry->str, str->str, str->len )) break;
+        entry = entry->next;
+    }
+    return entry;
+}
+
+/* add an atom to the table */
+atom_t add_atom( struct atom_table *table, const struct unicode_str *str )
+{
+    struct atom_entry *entry;
+    unsigned short hash;
+    atom_t atom = 0;
+
+    if (!str->len)
+    {
+        set_error( STATUS_OBJECT_NAME_INVALID );
+        return 0;
+    }
+    if (str->len > MAX_ATOM_LEN * sizeof(WCHAR))
+    {
+        set_error( STATUS_INVALID_PARAMETER );
+        return 0;
+    }
+    if ((atom = get_int_atom_value( str ))) return atom;
+
+    hash = hash_strW( str->str, str->len, ARRAY_SIZE(table->entries) );
+    if ((entry = find_atom_entry( table, str, hash )))  /* exists already */
+    {
+        entry->count++;
+        return entry->atom;
+    }
+
+    if ((entry = mem_alloc( FIELD_OFFSET( struct atom_entry, str[str->len / sizeof(WCHAR)] ) )))
+    {
+        if ((atom = add_atom_entry( table, entry )))
+        {
+            entry->prev  = NULL;
+            if ((entry->next = table->entries[hash])) entry->next->prev = entry;
+            table->entries[hash] = entry;
+            entry->count  = 1;
+            entry->hash   = hash;
+            entry->len    = str->len;
+            memcpy( entry->str, str->str, str->len );
+        }
+        else
+        {
+            set_error( STATUS_NO_MEMORY );
+            free( entry );
+        }
+    }
+
+    return atom;
+}
+
+/* delete an atom from the table */
+static void delete_atom( struct atom_table *table, atom_t atom, int if_pinned )
+{
+    struct atom_entry *entry = get_atom_entry( table, atom );
+    if (!entry) return;
+    if (!--entry->count)
+    {
+        if (entry->next) entry->next->prev = entry->prev;
+        if (entry->prev) entry->prev->next = entry->next;
+        else table->entries[entry->hash] = entry->next;
+        table->atoms[atom - MIN_STR_ATOM] = NULL;
+        free( entry );
+    }
+}
+
+/* find an atom in the table */
+atom_t find_atom( struct atom_table *table, const struct unicode_str *str )
+{
+    struct atom_entry *entry;
+    unsigned short hash;
+    atom_t atom;
+
+    if (!str->len)
+    {
+        set_error( STATUS_OBJECT_NAME_INVALID );
+        return 0;
+    }
+    if (str->len > MAX_ATOM_LEN * sizeof(WCHAR))
+    {
+        set_error( STATUS_INVALID_PARAMETER );
+        return 0;
+    }
+    if ((atom = get_int_atom_value( str ))) return atom;
+
+    hash = hash_strW( str->str, str->len, ARRAY_SIZE(table->entries) );
+    if (!(entry = find_atom_entry( table, str, hash )))
+    {
+        set_error( STATUS_OBJECT_NAME_NOT_FOUND );
+        return 0;
+    }
+    return entry->atom;
+}
+
+/* increment the ref count of a global atom; used for window properties */
+atom_t grab_atom( struct atom_table *table, atom_t atom )
+{
+    if (atom >= MIN_STR_ATOM)
+    {
+        struct atom_entry *entry = get_atom_entry( table, atom );
+        if (!entry) return 0;
+        entry->count++;
+    }
+    return atom;
+}
+
+/* decrement the ref count of a global atom; used for window properties */
+void release_atom( struct atom_table *table, atom_t atom )
+{
+    if (atom >= MIN_STR_ATOM) delete_atom( table, atom, 1 );
+}
+
+/* add a global atom */
+DECL_HANDLER(add_atom)
+{
+    struct unicode_str name = get_req_unicode_str();
+    reply->atom = add_atom( global_table, &name );
+}
+
+/* delete a global atom */
+DECL_HANDLER(delete_atom)
+{
+    delete_atom( global_table, req->atom, 0 );
+}
+
+/* find a global atom */
+DECL_HANDLER(find_atom)
+{
+    struct unicode_str name = get_req_unicode_str();
+    reply->atom = find_atom( global_table, &name );
+}
+
+/* get global atom name */
+DECL_HANDLER(get_atom_information)
+{
+    struct atom_entry *entry;
+
+    if ((entry = get_atom_entry( global_table, req->atom )))
+    {
+        set_reply_data( entry->str, min( entry->len, get_reply_max_size() ));
+        reply->count = entry->count;
+        reply->pinned = 0;
+        reply->total = entry->len;
+    }
+    else reply->count = -1;
+}
+
+/* add a user atom */
+DECL_HANDLER(add_user_atom)
+{
+    struct unicode_str name = get_req_unicode_str();
+    reply->atom = add_atom( user_table, &name );
+}
+
+/* get a user atom name */
+DECL_HANDLER(get_user_atom_name)
+{
+    struct atom_entry *entry;
+
+    if ((entry = get_atom_entry( user_table, req->atom )))
+    {
+        set_reply_data( (void *)entry->str, min( entry->len, get_reply_max_size() ));
+        reply->total = entry->len;
+    }
+}
diff -ruN --show-c-function server/change.c server/change.c
--- server/change.c	2025-10-10 10:17:47.802634392 -0700
+++ server/change.c	2025-10-10 10:22:17.172620550 -0700
@@ -109,13 +109,13 @@ static const struct object_ops dir_ops =
     sizeof(struct dir),       /* size */
     &file_type,               /* type */
     dir_dump,                 /* dump */
-    NULL,                     /* add_queue */
-    NULL,                     /* remove_queue */
-    NULL,                     /* signaled */
-    NULL,                     /* satisfied */
+    add_queue,                /* add_queue */
+    remove_queue,             /* remove_queue */
+    default_fd_signaled,      /* signaled */
+    default_fd_get_esync_fd,  /* get_esync_fd */
+    no_satisfied,             /* satisfied */
     no_signal,                /* signal */
     dir_get_fd,               /* get_fd */
-    default_fd_get_sync,      /* get_sync */
     default_map_access,       /* map_access */
     dir_get_sd,               /* get_sd */
     dir_set_sd,               /* set_sd */
diff -ruN --show-c-function server/clipboard.c server/clipboard.c
--- server/clipboard.c	2025-10-10 10:17:47.802634392 -0700
+++ server/clipboard.c	2025-10-10 10:22:17.149868810 -0700
@@ -76,10 +76,10 @@ static const struct object_ops clipboard
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
-    default_get_sync,             /* get_sync */
     default_map_access,           /* map_access */
     default_get_sd,               /* get_sd */
     default_set_sd,               /* set_sd */
diff -ruN --show-c-function server/completion.c server/completion.c
--- server/completion.c	2025-10-10 10:17:47.802634392 -0700
+++ server/completion.c	2025-10-10 10:22:17.149986112 -0700
@@ -72,11 +72,11 @@ struct completion_wait
 
 struct completion
 {
-    struct object       obj;
-    struct object      *sync;
-    struct list         queue;
-    struct list         wait_queue;
-    unsigned int        depth;
+    struct object  obj;
+    struct list    queue;
+    struct list    wait_queue;
+    unsigned int   depth;
+    int            closed;
 };
 
 static void completion_wait_dump( struct object*, int );
@@ -92,10 +92,10 @@ static const struct object_ops completio
     add_queue,                      /* add_queue */
     remove_queue,                   /* remove_queue */
     completion_wait_signaled,       /* signaled */
+    NULL,                           /* get_esync_fd */
     completion_wait_satisfied,      /* satisfied */
     no_signal,                      /* signal */
     no_get_fd,                      /* get_fd */
-    default_get_sync,               /* get_sync */
     default_map_access,             /* map_access */
     default_get_sd,                 /* get_sd */
     default_set_sd,                 /* set_sd */
@@ -155,7 +155,7 @@ static void completion_wait_satisfied( s
 }
 
 static void completion_dump( struct object*, int );
-static struct object *completion_get_sync( struct object * );
+static int completion_signaled( struct object *obj, struct wait_queue_entry *entry );
 static int completion_close_handle( struct object *obj, struct process *process, obj_handle_t handle );
 static void completion_destroy( struct object * );
 
@@ -164,13 +164,13 @@ static const struct object_ops completio
     sizeof(struct completion), /* size */
     &completion_type,          /* type */
     completion_dump,           /* dump */
-    NULL,                      /* add_queue */
-    NULL,                      /* remove_queue */
-    NULL,                      /* signaled */
-    NULL,                      /* satisfied */
+    add_queue,                 /* add_queue */
+    remove_queue,              /* remove_queue */
+    completion_signaled,       /* signaled */
+    NULL,                      /* get_esync_fd */
+    no_satisfied,              /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
-    completion_get_sync,       /* get_sync */
     default_map_access,        /* map_access */
     default_get_sd,            /* get_sd */
     default_set_sd,            /* set_sd */
@@ -193,8 +193,6 @@ static void completion_destroy( struct o
     {
         free( tmp );
     }
-
-    if (completion->sync) release_object( completion->sync );
 }
 
 static void completion_dump( struct object *obj, int verbose )
@@ -205,11 +203,11 @@ static void completion_dump( struct obje
     fprintf( stderr, "Completion depth=%u\n", completion->depth );
 }
 
-static struct object *completion_get_sync( struct object *obj )
+static int completion_signaled( struct object *obj, struct wait_queue_entry *entry )
 {
     struct completion *completion = (struct completion *)obj;
-    assert( obj->ops == &completion_ops );
-    return grab_object( completion->sync );
+
+    return !list_empty( &completion->queue ) || completion->closed;
 }
 
 static int completion_close_handle( struct object *obj, struct process *process, obj_handle_t handle )
@@ -230,7 +228,8 @@ static int completion_close_handle( stru
             cleanup_thread_completion( wait->thread );
         }
     }
-    signal_sync( completion->sync );
+    completion->closed = 1;
+    wake_up( obj, 0 );
     return 1;
 }
 
@@ -274,16 +273,10 @@ static struct completion *create_complet
     {
         if (get_error() != STATUS_OBJECT_NAME_EXISTS)
         {
-            completion->sync = NULL;
             list_init( &completion->queue );
             list_init( &completion->wait_queue );
             completion->depth = 0;
-
-            if (!(completion->sync = create_internal_sync( 1, 0 )))
-            {
-                release_object( completion );
-                return NULL;
-            }
+            completion->closed = 0;
         }
     }
 
@@ -316,7 +309,7 @@ void add_completion( struct completion *
         wake_up( &wait->obj, 1 );
         if (list_empty( &completion->queue )) return;
     }
-    if (!list_empty( &completion->queue )) signal_sync( completion->sync );
+    if (!list_empty( &completion->queue )) wake_up( &completion->obj, 0 );
 }
 
 /* create a completion */
@@ -417,7 +410,6 @@ DECL_HANDLER(remove_completion)
         reply->information = msg->information;
         free( msg );
         reply->wait_handle = 0;
-        if (list_empty( &completion->queue )) reset_sync( completion->sync );
     }
 
     release_object( completion );
diff -ruN --show-c-function server/console.c server/console.c
--- server/console.c	2025-10-10 10:17:47.802634392 -0700
+++ server/console.c	2025-10-10 10:22:17.173873787 -0700
@@ -41,6 +41,7 @@
 #include "wincon.h"
 #include "winternl.h"
 #include "wine/condrv.h"
+#include "esync.h"
 
 struct screen_buffer;
 
@@ -53,7 +54,7 @@ struct history_line
 struct console
 {
     struct object                obj;           /* object header */
-    struct object               *sync;          /* sync object for wait/signal */
+    int                          signaled;      /* is console signaled */
     struct thread               *renderer;      /* console renderer thread */
     struct screen_buffer        *active;        /* active screen buffer */
     struct console_server       *server;        /* console server object */
@@ -68,25 +69,26 @@ struct console
 
 static void console_dump( struct object *obj, int verbose );
 static void console_destroy( struct object *obj );
+static int console_signaled( struct object *obj, struct wait_queue_entry *entry );
 static struct fd *console_get_fd( struct object *obj );
-static struct object *console_get_sync( struct object *obj );
 static struct object *console_lookup_name( struct object *obj, struct unicode_str *name,
                                            unsigned int attr, struct object *root );
 static struct object *console_open_file( struct object *obj, unsigned int access,
                                          unsigned int sharing, unsigned int options );
+static int console_add_queue( struct object *obj, struct wait_queue_entry *entry );
 
 static const struct object_ops console_ops =
 {
     sizeof(struct console),           /* size */
     &file_type,                       /* type */
     console_dump,                     /* dump */
-    NULL,                             /* add_queue */
-    NULL,                             /* remove_queue */
-    NULL,                             /* signaled */
-    NULL,                             /* satisfied */
+    console_add_queue,                /* add_queue */
+    remove_queue,                     /* remove_queue */
+    console_signaled,                 /* signaled */
+    NULL,                             /* get_esync_fd */
+    no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     console_get_fd,                   /* get_fd */
-    console_get_sync,                 /* get_sync */
     default_map_access,               /* map_access */
     default_get_sd,                   /* get_sd */
     default_set_sd,                   /* set_sd */
@@ -133,22 +135,23 @@ struct console_host_ioctl
 
 struct console_server
 {
-    struct object         obj;            /* object header */
-    struct object        *sync;           /* sync object for wait/signal */
-    struct fd            *fd;             /* pseudo-fd for ioctls */
-    struct console       *console;        /* attached console */
-    struct list           queue;          /* ioctl queue */
-    struct list           read_queue;     /* blocking read queue */
+    struct object         obj;         /* object header */
+    struct fd            *fd;          /* pseudo-fd for ioctls */
+    struct console       *console;     /* attached console */
+    struct list           queue;       /* ioctl queue */
+    struct list           read_queue;  /* blocking read queue */
     unsigned int          busy : 1;       /* flag if server processing an ioctl */
     unsigned int          once_input : 1; /* flag if input thread has already been requested */
-    int                   term_fd;        /* UNIX terminal fd */
-    struct termios        termios;        /* original termios */
+    int                   term_fd;     /* UNIX terminal fd */
+    struct termios        termios;     /* original termios */
+    int                   esync_fd;
 };
 
 static void console_server_dump( struct object *obj, int verbose );
 static void console_server_destroy( struct object *obj );
+static int console_server_signaled( struct object *obj, struct wait_queue_entry *entry );
+static int console_server_get_esync_fd( struct object *obj, enum esync_type *type );
 static struct fd *console_server_get_fd( struct object *obj );
-static struct object *console_server_get_sync( struct object *obj );
 static struct object *console_server_lookup_name( struct object *obj, struct unicode_str *name,
                                                 unsigned int attr, struct object *root );
 static struct object *console_server_open_file( struct object *obj, unsigned int access,
@@ -159,13 +162,13 @@ static const struct object_ops console_s
     sizeof(struct console_server),    /* size */
     &file_type,                       /* type */
     console_server_dump,              /* dump */
-    NULL,                             /* add_queue */
-    NULL,                             /* remove_queue */
-    NULL,                             /* signaled */
-    NULL,                             /* satisfied */
+    add_queue,                        /* add_queue */
+    remove_queue,                     /* remove_queue */
+    console_server_signaled,          /* signaled */
+    console_server_get_esync_fd,      /* get_esync_fd */
+    no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     console_server_get_fd,            /* get_fd */
-    console_server_get_sync,          /* get_sync */
     default_map_access,               /* map_access */
     default_get_sd,                   /* get_sd */
     default_set_sd,                   /* set_sd */
@@ -210,7 +213,6 @@ struct font_info
 struct screen_buffer
 {
     struct object         obj;           /* object header */
-    struct object        *sync;          /* sync object for wait/signal */
     struct list           entry;         /* entry in list of all screen buffers */
     struct console       *input;         /* associated console input */
     unsigned int          id;            /* buffer id */
@@ -220,8 +222,8 @@ struct screen_buffer
 
 static void screen_buffer_dump( struct object *obj, int verbose );
 static void screen_buffer_destroy( struct object *obj );
+static int screen_buffer_signaled( struct object *obj, struct wait_queue_entry *entry );
 static struct fd *screen_buffer_get_fd( struct object *obj );
-static struct object *screen_buffer_get_sync( struct object *obj );
 static struct object *screen_buffer_open_file( struct object *obj, unsigned int access,
                                                unsigned int sharing, unsigned int options );
 
@@ -230,13 +232,13 @@ static const struct object_ops screen_bu
     sizeof(struct screen_buffer),     /* size */
     &file_type,                       /* type */
     screen_buffer_dump,               /* dump */
-    NULL,                             /* add_queue */
-    NULL,                             /* remove_queue */
-    NULL,                             /* signaled */
-    NULL,                             /* satisfied */
+    add_queue,                        /* add_queue */
+    remove_queue,                     /* remove_queue */
+    screen_buffer_signaled,           /* signaled */
+    NULL,                             /* get_esync_fd */
+    no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     screen_buffer_get_fd,             /* get_fd */
-    screen_buffer_get_sync,           /* get_sync */
     default_map_access,               /* map_access */
     default_get_sd,                   /* get_sd */
     default_set_sd,                   /* set_sd */
@@ -283,10 +285,10 @@ static const struct object_ops console_d
     no_add_queue,                     /* add_queue */
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
+    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
-    default_get_sync,                 /* get_sync */
     default_map_access,               /* map_access */
     default_get_sd,                   /* get_sd */
     default_set_sd,                   /* set_sd */
@@ -303,17 +305,16 @@ static const struct object_ops console_d
 struct console_input
 {
     struct object         obj;         /* object header */
-    struct object        *sync;        /* sync object for wait/signal */
     struct fd            *fd;          /* pseudo-fd */
     struct list           entry;       /* entry in console->inputs */
     struct console       *console;     /* associated console at creation time */
 };
 
 static void console_input_dump( struct object *obj, int verbose );
+static int console_input_signaled( struct object *obj, struct wait_queue_entry *entry );
 static struct object *console_input_open_file( struct object *obj, unsigned int access,
                                                unsigned int sharing, unsigned int options );
 static struct fd *console_input_get_fd( struct object *obj );
-static struct object *console_input_get_sync( struct object *obj );
 static void console_input_destroy( struct object *obj );
 
 static const struct object_ops console_input_ops =
@@ -321,13 +322,13 @@ static const struct object_ops console_i
     sizeof(struct console_input),     /* size */
     &device_type,                     /* type */
     console_input_dump,               /* dump */
-    NULL,                             /* add_queue */
-    NULL,                             /* remove_queue */
-    NULL,                             /* signaled */
-    NULL,                             /* satisfied */
+    add_queue,                        /* add_queue */
+    remove_queue,                     /* remove_queue */
+    console_input_signaled,           /* signaled */
+    NULL,                             /* get_esync_fd */
+    no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     console_input_get_fd,             /* get_fd */
-    console_input_get_sync,           /* get_sync */
     default_map_access,               /* map_access */
     default_get_sd,                   /* get_sd */
     default_set_sd,                   /* set_sd */
@@ -364,15 +365,14 @@ static const struct fd_ops console_input
 struct console_output
 {
     struct object         obj;         /* object header */
-    struct object        *sync;        /* sync object for wait/signal */
     struct fd            *fd;          /* pseudo-fd */
     struct list           entry;       /* entry in console->outputs */
     struct console       *console;     /* associated console at creation time */
 };
 
 static void console_output_dump( struct object *obj, int verbose );
+static int console_output_signaled( struct object *obj, struct wait_queue_entry *entry );
 static struct fd *console_output_get_fd( struct object *obj );
-static struct object *console_output_get_sync( struct object *obj );
 static struct object *console_output_open_file( struct object *obj, unsigned int access,
                                                 unsigned int sharing, unsigned int options );
 static void console_output_destroy( struct object *obj );
@@ -382,13 +382,13 @@ static const struct object_ops console_o
     sizeof(struct console_output),    /* size */
     &device_type,                     /* type */
     console_output_dump,              /* dump */
-    NULL,                             /* add_queue */
-    NULL,                             /* remove_queue */
-    NULL,                             /* signaled */
-    NULL,                             /* satisfied */
+    add_queue,                        /* add_queue */
+    remove_queue,                     /* remove_queue */
+    console_output_signaled,          /* signaled */
+    NULL,                             /* get_esync_fd */
+    no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     console_output_get_fd,            /* get_fd */
-    console_output_get_sync,          /* get_sync */
     default_map_access,               /* map_access */
     default_get_sd,                   /* get_sd */
     default_set_sd,                   /* set_sd */
@@ -444,10 +444,10 @@ static const struct object_ops console_c
     no_add_queue,                     /* add_queue */
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
+    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     console_connection_get_fd,        /* get_fd */
-    default_get_sync,                 /* get_sync */
     default_map_access,               /* map_access */
     default_get_sd,                   /* get_sd */
     default_set_sd,                   /* set_sd */
@@ -482,18 +482,10 @@ static const struct fd_ops console_conne
 static int queue_host_ioctl( struct console_server *server, unsigned int code, unsigned int output,
                              struct async *async, struct async_queue *queue );
 
-static struct fd *console_get_fd( struct object *obj )
-{
-    struct console *console = (struct console *)obj;
-    assert( obj->ops == &console_ops );
-    return (struct fd *)grab_object( console->fd );
-}
-
-static struct object *console_get_sync( struct object *obj )
+static int console_add_queue( struct object *obj, struct wait_queue_entry *entry )
 {
-    struct console *console = (struct console *)obj;
+    struct console *console = (struct console*)obj;
     assert( obj->ops == &console_ops );
-
     /* before waiting, ensure conhost's input thread has been started */
     if (console->server && !console->server->once_input)
     {
@@ -501,8 +493,20 @@ static struct object *console_get_sync(
         if (console->server->term_fd == -1)
             queue_host_ioctl( console->server, IOCTL_CONDRV_PEEK, 0, NULL, NULL );
     }
+    return add_queue( &console->obj, entry );
+}
+
+static int console_signaled( struct object *obj, struct wait_queue_entry *entry )
+{
+    struct console *console = (struct console*)obj;
+    return console->signaled;
+}
 
-    return grab_object( console->sync );
+static struct fd *console_get_fd( struct object *obj )
+{
+    struct console *console = (struct console *)obj;
+    assert( obj->ops == &console_ops );
+    return (struct fd *)grab_object( console->fd );
 }
 
 static enum server_fd_type console_get_fd_type( struct fd *fd )
@@ -541,9 +545,11 @@ static struct object *create_console(voi
 {
     struct console *console;
 
-    if (!(console = alloc_object( &console_ops ))) return NULL;
-    console->sync          = NULL;
+    if (!(console = alloc_object( &console_ops )))
+        return NULL;
+
     console->renderer      = NULL;
+    console->signaled      = 0;
     console->active        = NULL;
     console->server        = NULL;
     console->fd            = NULL;
@@ -554,14 +560,14 @@ static struct object *create_console(voi
     init_async_queue( &console->ioctl_q );
     init_async_queue( &console->read_q );
 
-    if (!(console->sync = create_internal_sync( 1, 0 ))) goto error;
-    if (!(console->fd = alloc_pseudo_fd( &console_fd_ops, &console->obj, FILE_SYNCHRONOUS_IO_NONALERT ))) goto error;
+    console->fd = alloc_pseudo_fd( &console_fd_ops, &console->obj, FILE_SYNCHRONOUS_IO_NONALERT );
+    if (!console->fd)
+    {
+        release_object( console );
+        return NULL;
+    }
     allow_fd_caching( console->fd );
     return &console->obj;
-
-error:
-    release_object( console );
-    return NULL;
 }
 
 static void console_host_ioctl_terminate( struct console_host_ioctl *call, unsigned int status )
@@ -589,7 +595,7 @@ static int queue_host_ioctl( struct cons
         queue_async( queue, async );
     }
     list_add_tail( &server->queue, &ioctl->entry );
-    signal_sync( server->sync );
+    wake_up( &server->obj, 0 );
     if (async) set_error( STATUS_PENDING );
     return 1;
 }
@@ -602,6 +608,8 @@ static void disconnect_console_server( s
         list_remove( &call->entry );
         console_host_ioctl_terminate( call, STATUS_CANCELLED );
     }
+    if (do_esync())
+        esync_clear( server->esync_fd );
     while (!list_empty( &server->read_queue ))
     {
         struct console_host_ioctl *call = LIST_ENTRY( list_head( &server->read_queue ), struct console_host_ioctl, entry );
@@ -621,7 +629,7 @@ static void disconnect_console_server( s
         assert( server->console->server == server );
         server->console->server = NULL;
         server->console = NULL;
-        signal_sync( server->sync );
+        wake_up( &server->obj, 0 );
     }
 }
 
@@ -645,8 +653,9 @@ static struct object *create_screen_buff
         return NULL;
     }
 
-    if (!(screen_buffer = alloc_object( &screen_buffer_ops ))) return NULL;
-    screen_buffer->sync  = grab_object( console->sync );
+    if (!(screen_buffer = alloc_object( &screen_buffer_ops )))
+        return NULL;
+
     screen_buffer->id    = ++console->last_id;
     screen_buffer->input = console;
     init_async_queue( &screen_buffer->ioctl_q );
@@ -777,12 +786,6 @@ static void console_destroy( struct obje
     LIST_FOR_EACH_ENTRY( output, &console->outputs, struct console_output, entry )
         output->console = NULL;
 
-    if (console->sync)
-    {
-        reset_sync( console->sync );
-        release_object( console->sync );
-    }
-
     free_async_queue( &console->ioctl_q );
     free_async_queue( &console->read_q );
     if (console->fd)
@@ -862,10 +865,17 @@ static void screen_buffer_destroy( struc
                               screen_buffer->id, NULL, NULL );
     }
     free_async_queue( &screen_buffer->ioctl_q );
-    if (screen_buffer->sync) release_object( screen_buffer->sync );
     if (screen_buffer->fd) release_object( screen_buffer->fd );
 }
 
+static int screen_buffer_signaled( struct object *obj, struct wait_queue_entry *entry )
+{
+    struct screen_buffer *screen_buffer = (struct screen_buffer *)obj;
+    assert( obj->ops == &screen_buffer_ops );
+    if (!screen_buffer->input) return 0;
+    return screen_buffer->input->signaled;
+}
+
 static struct object *screen_buffer_open_file( struct object *obj, unsigned int access,
                                                unsigned int sharing, unsigned int options )
 {
@@ -882,13 +892,6 @@ static struct fd *screen_buffer_get_fd(
     return NULL;
 }
 
-static struct object *screen_buffer_get_sync( struct object *obj )
-{
-    struct screen_buffer *screen_buffer = (struct screen_buffer *)obj;
-    assert( obj->ops == &screen_buffer_ops );
-    return grab_object( screen_buffer->sync );
-}
-
 static void console_server_dump( struct object *obj, int verbose )
 {
     assert( obj->ops == &console_server_ops );
@@ -900,8 +903,8 @@ static void console_server_destroy( stru
     struct console_server *server = (struct console_server *)obj;
     assert( obj->ops == &console_server_ops );
     disconnect_console_server( server );
-    if (server->sync) release_object( server->sync );
     if (server->fd) release_object( server->fd );
+    if (do_esync()) close( server->esync_fd );
 }
 
 static struct object *console_server_lookup_name( struct object *obj, struct unicode_str *name,
@@ -936,25 +939,31 @@ static struct object *console_server_loo
         release_object( screen_buffer );
         server->console->server = server;
 
-        if (list_empty( &server->queue )) reset_sync( server->sync );
         return &server->console->obj;
     }
 
     return NULL;
 }
 
-static struct fd *console_server_get_fd( struct object* obj )
+static int console_server_signaled( struct object *obj, struct wait_queue_entry *entry )
 {
     struct console_server *server = (struct console_server*)obj;
     assert( obj->ops == &console_server_ops );
-    return (struct fd *)grab_object( server->fd );
+    return !server->console || !list_empty( &server->queue );
 }
 
-static struct object *console_server_get_sync( struct object *obj )
+static int console_server_get_esync_fd( struct object *obj, enum esync_type *type )
 {
-    struct console_server *server = (struct console_server *)obj;
+    struct console_server *server = (struct console_server*)obj;
+    *type = ESYNC_MANUAL_SERVER;
+    return server->esync_fd;
+}
+
+static struct fd *console_server_get_fd( struct object* obj )
+{
+    struct console_server *server = (struct console_server*)obj;
     assert( obj->ops == &console_server_ops );
-    return grab_object( server->sync );
+    return (struct fd *)grab_object( server->fd );
 }
 
 static struct object *console_server_open_file( struct object *obj, unsigned int access,
@@ -968,23 +977,25 @@ static struct object *create_console_ser
     struct console_server *server;
 
     if (!(server = alloc_object( &console_server_ops ))) return NULL;
-    server->sync       = NULL;
-    server->fd         = NULL;
     server->console    = NULL;
     server->busy       = 0;
     server->once_input = 0;
     server->term_fd    = -1;
     list_init( &server->queue );
     list_init( &server->read_queue );
-
-    if (!(server->sync = create_internal_sync( 1, 1 ))) goto error;
-    if (!(server->fd = alloc_pseudo_fd( &console_server_fd_ops, &server->obj, FILE_SYNCHRONOUS_IO_NONALERT ))) goto error;
+    server->fd = alloc_pseudo_fd( &console_server_fd_ops, &server->obj, FILE_SYNCHRONOUS_IO_NONALERT );
+    if (!server->fd)
+    {
+        release_object( server );
+        return NULL;
+    }
     allow_fd_caching(server->fd);
-    return &server->obj;
+    server->esync_fd = -1;
 
-error:
-    release_object( server );
-    return NULL;
+    if (do_esync())
+        server->esync_fd = esync_create_fd( 0, 0 );
+
+    return &server->obj;
 }
 
 static int is_blocking_read_ioctl( unsigned int code )
@@ -1350,7 +1361,6 @@ static struct object *console_device_loo
 
         name->len = 0;
         if (!(console_input = alloc_object( &console_input_ops ))) return NULL;
-        console_input->sync = grab_object( current->process->console->sync );
         console_input->fd = alloc_pseudo_fd( &console_input_fd_ops, &console_input->obj,
                                              FILE_SYNCHRONOUS_IO_NONALERT );
         if (!console_input->fd)
@@ -1375,7 +1385,6 @@ static struct object *console_device_loo
 
         name->len = 0;
         if (!(console_output = alloc_object( &console_output_ops ))) return NULL;
-        console_output->sync = grab_object( current->process->console->sync );
         console_output->fd = alloc_pseudo_fd( &console_output_fd_ops, &console_output->obj,
                                              FILE_SYNCHRONOUS_IO_NONALERT );
         if (!console_output->fd)
@@ -1438,18 +1447,19 @@ static void console_input_dump( struct o
     fputs( "console Input device\n", stderr );
 }
 
-static struct fd *console_input_get_fd( struct object *obj )
+static int console_input_signaled( struct object *obj, struct wait_queue_entry *entry )
 {
     struct console_input *console_input = (struct console_input *)obj;
     assert( obj->ops == &console_input_ops );
-    return (struct fd *)grab_object( console_input->fd );
+    if (!console_input->console) return 0;
+    return console_input->console->signaled;
 }
 
-static struct object *console_input_get_sync( struct object *obj )
+static struct fd *console_input_get_fd( struct object *obj )
 {
     struct console_input *console_input = (struct console_input *)obj;
     assert( obj->ops == &console_input_ops );
-    return grab_object( console_input->sync );
+    return (struct fd *)grab_object( console_input->fd );
 }
 
 static struct object *console_input_open_file( struct object *obj, unsigned int access,
@@ -1465,7 +1475,6 @@ static void console_input_destroy( struc
     assert( obj->ops == &console_input_ops );
     if (console_input->fd) release_object( console_input->fd );
     if (console_input->console) list_remove( &console_input->entry );
-    if (console_input->sync) release_object( console_input->sync );
 }
 
 static void console_input_ioctl( struct fd *fd, ioctl_code_t code, struct async *async )
@@ -1509,18 +1518,19 @@ static void console_output_dump( struct
     fputs( "console Output device\n", stderr );
 }
 
-static struct fd *console_output_get_fd( struct object *obj )
+static int console_output_signaled( struct object *obj, struct wait_queue_entry *entry )
 {
     struct console_output *console_output = (struct console_output *)obj;
     assert( obj->ops == &console_output_ops );
-    return (struct fd *)grab_object( console_output->fd );
+    if (!console_output->console) return 0;
+    return console_output->console->signaled;
 }
 
-static struct object *console_output_get_sync( struct object *obj )
+static struct fd *console_output_get_fd( struct object *obj )
 {
     struct console_output *console_output = (struct console_output *)obj;
     assert( obj->ops == &console_output_ops );
-    return grab_object( console_output->sync );
+    return (struct fd *)grab_object( console_output->fd );
 }
 
 static struct object *console_output_open_file( struct object *obj, unsigned int access,
@@ -1536,7 +1546,6 @@ static void console_output_destroy( stru
     assert( obj->ops == &console_output_ops );
     if (console_output->fd) release_object( console_output->fd );
     if (console_output->console) list_remove( &console_output->entry );
-    if (console_output->sync) release_object( console_output->sync );
 }
 
 static void console_output_ioctl( struct fd *fd, ioctl_code_t code, struct async *async )
@@ -1573,7 +1582,10 @@ struct object *create_console_device( st
 DECL_HANDLER(get_next_console_request)
 {
     struct console_host_ioctl *ioctl = NULL, *next;
+    struct screen_buffer *screen_buffer;
     struct console_server *server;
+    struct console_output *output;
+    struct console_input *input;
     struct iosb *iosb = NULL;
 
     server = (struct console_server *)get_handle_obj( current->process, req->handle, 0, &console_server_ops );
@@ -1588,8 +1600,18 @@ DECL_HANDLER(get_next_console_request)
 
     if (!server->console->renderer) server->console->renderer = current;
 
-    if (!req->signal) reset_sync( server->console->sync );
-    else signal_sync( server->console->sync );
+    if (!req->signal) server->console->signaled = 0;
+    else if (!server->console->signaled)
+    {
+        server->console->signaled = 1;
+        wake_up( &server->console->obj, 0 );
+        LIST_FOR_EACH_ENTRY( screen_buffer, &server->console->screen_buffers, struct screen_buffer, entry )
+            wake_up( &screen_buffer->obj, 0 );
+        LIST_FOR_EACH_ENTRY( input, &server->console->inputs, struct console_input, entry )
+            wake_up( &input->obj, 0 );
+        LIST_FOR_EACH_ENTRY( output, &server->console->outputs, struct console_output, entry )
+            wake_up( &output->obj, 0 );
+    }
 
     if (req->read)
     {
@@ -1610,6 +1632,8 @@ DECL_HANDLER(get_next_console_request)
         /* set result of previous ioctl */
         ioctl = LIST_ENTRY( list_head( &server->queue ), struct console_host_ioctl, entry );
         list_remove( &ioctl->entry );
+        if (do_esync() && list_empty( &server->queue ))
+            esync_clear( server->esync_fd );
     }
 
     if (ioctl)
@@ -1633,7 +1657,11 @@ DECL_HANDLER(get_next_console_request)
         free( ioctl );
         if (iosb) release_object( iosb );
 
-        if (req->read) goto done;
+        if (req->read)
+        {
+            release_object( server );
+            return;
+        }
         server->busy = 0;
     }
 
@@ -1691,8 +1719,8 @@ DECL_HANDLER(get_next_console_request)
     {
         set_error( STATUS_PENDING );
     }
+    if (do_esync() && list_empty( &server->queue ))
+        esync_clear( server->esync_fd );
 
-done:
-    if (list_empty( &server->queue )) reset_sync( server->sync );
     release_object( server );
 }
diff -ruN --show-c-function server/d3dkmt.c server/d3dkmt.c
--- server/d3dkmt.c	2025-10-10 10:17:47.802634392 -0700
+++ server/d3dkmt.c	2025-10-10 10:22:17.123045740 -0700
@@ -55,10 +55,10 @@ static const struct object_ops d3dkmt_ob
     no_add_queue,                   /* add_queue */
     NULL,                           /* remove_queue */
     NULL,                           /* signaled */
+    NULL,                           /* get_esync_fd */
     NULL,                           /* satisfied */
     no_signal,                      /* signal */
     no_get_fd,                      /* get_fd */
-    default_get_sync,               /* get_sync */
     default_map_access,             /* map_access */
     default_get_sd,                 /* get_sd */
     default_set_sd,                 /* set_sd */
@@ -108,9 +108,9 @@ static const struct object_ops dxgk_shar
     NULL,                               /* remove_queue */
     NULL,                               /* signaled */
     NULL,                               /* satisfied */
+    NULL,                               /* get_esync_fd */
     no_signal,                          /* signal */
     no_get_fd,                          /* get_fd */
-    default_get_sync,                   /* get_sync */
     default_map_access,                 /* map_access */
     default_get_sd,                     /* get_sd */
     default_set_sd,                     /* set_sd */
@@ -174,10 +174,10 @@ static const struct object_ops dxgk_shar
     no_add_queue,                           /* add_queue */
     NULL,                                   /* remove_queue */
     NULL,                                   /* signaled */
+    NULL,                                   /* get_esync_fd */
     NULL,                                   /* satisfied */
     no_signal,                              /* signal */
     no_get_fd,                              /* get_fd */
-    default_get_sync,                       /* get_sync */
     default_map_access,                     /* map_access */
     default_get_sd,                         /* get_sd */
     default_set_sd,                         /* set_sd */
diff -ruN --show-c-function server/debugger.c server/debugger.c
--- server/debugger.c	2025-10-10 10:17:47.802634392 -0700
+++ server/debugger.c	2025-10-10 10:22:17.150308203 -0700
@@ -43,7 +43,6 @@ enum debug_event_state { EVENT_QUEUED, E
 struct debug_event
 {
     struct object          obj;       /* object header */
-    struct event_sync     *sync;      /* sync object for wait/signal */
     struct list            entry;     /* entry in event queue */
     struct thread         *sender;    /* thread which sent this event */
     struct file           *file;      /* file object for events that need one */
@@ -70,14 +69,13 @@ struct type_descr debug_obj_type =
 struct debug_obj
 {
     struct object        obj;         /* object header */
-    struct object       *sync;       /* sync object for wait/signal */
     struct list          event_queue; /* pending events queue */
     unsigned int         flags;       /* debug flags */
 };
 
 
 static void debug_event_dump( struct object *obj, int verbose );
-static struct object *debug_event_get_sync( struct object *obj );
+static int debug_event_signaled( struct object *obj, struct wait_queue_entry *entry );
 static void debug_event_destroy( struct object *obj );
 
 static const struct object_ops debug_event_ops =
@@ -85,13 +83,13 @@ static const struct object_ops debug_eve
     sizeof(struct debug_event),    /* size */
     &no_type,                      /* type */
     debug_event_dump,              /* dump */
-    NULL,                          /* add_queue */
-    NULL,                          /* remove_queue */
-    NULL,                          /* signaled */
-    NULL,                          /* satisfied */
+    add_queue,                     /* add_queue */
+    remove_queue,                  /* remove_queue */
+    debug_event_signaled,          /* signaled */
+    NULL,                          /* get_esync_fd */
+    no_satisfied,                  /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
-    debug_event_get_sync,          /* get_sync */
     default_map_access,            /* map_access */
     default_get_sd,                /* get_sd */
     default_set_sd,                /* set_sd */
@@ -106,7 +104,7 @@ static const struct object_ops debug_eve
 };
 
 static void debug_obj_dump( struct object *obj, int verbose );
-static struct object *debug_obj_get_sync( struct object *obj );
+static int debug_obj_signaled( struct object *obj, struct wait_queue_entry *entry );
 static void debug_obj_destroy( struct object *obj );
 
 static const struct object_ops debug_obj_ops =
@@ -114,13 +112,13 @@ static const struct object_ops debug_obj
     sizeof(struct debug_obj),      /* size */
     &debug_obj_type,               /* type */
     debug_obj_dump,                /* dump */
-    NULL,                          /* add_queue */
-    NULL,                          /* remove_queue */
-    NULL,                          /* signaled */
-    NULL,                          /* satisfied */
+    add_queue,                     /* add_queue */
+    remove_queue,                  /* remove_queue */
+    debug_obj_signaled,            /* signaled */
+    NULL,                          /* get_esync_fd */
+    no_satisfied,                  /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
-    debug_obj_get_sync,            /* get_sync */
     default_map_access,            /* map_access */
     default_get_sd,                /* get_sd */
     default_set_sd,                /* set_sd */
@@ -256,7 +254,7 @@ static void link_event( struct debug_obj
     {
         /* grab reference since debugger could be killed while trying to wake up */
         grab_object( debug_obj );
-        signal_sync( debug_obj->sync );
+        wake_up( &debug_obj->obj, 0 );
         release_object( debug_obj );
     }
 }
@@ -265,11 +263,10 @@ static void link_event( struct debug_obj
 static void resume_event( struct debug_obj *debug_obj, struct debug_event *event )
 {
     event->state = EVENT_QUEUED;
-    reset_sync( (struct object *)event->sync );
     if (!event->sender->process->debug_event)
     {
         grab_object( debug_obj );
-        signal_sync( debug_obj->sync );
+        wake_up( &debug_obj->obj, 0 );
         release_object( debug_obj );
     }
 }
@@ -278,7 +275,6 @@ static void resume_event( struct debug_o
 static void delay_event( struct debug_obj *debug_obj, struct debug_event *event )
 {
     event->state = EVENT_DELAYED;
-    reset_sync( (struct object *)event->sync );
     if (event->sender->process->debug_event == event) event->sender->process->debug_event = NULL;
 }
 
@@ -305,11 +301,11 @@ static void debug_event_dump( struct obj
              debug_event->sender, debug_event->data.code, debug_event->state );
 }
 
-static struct object *debug_event_get_sync( struct object *obj )
+static int debug_event_signaled( struct object *obj, struct wait_queue_entry *entry )
 {
     struct debug_event *debug_event = (struct debug_event *)obj;
     assert( obj->ops == &debug_event_ops );
-    return grab_object( debug_event->sync );
+    return debug_event->state == EVENT_CONTINUED;
 }
 
 static void debug_event_destroy( struct object *obj )
@@ -317,7 +313,6 @@ static void debug_event_destroy( struct
     struct debug_event *event = (struct debug_event *)obj;
     assert( obj->ops == &debug_event_ops );
 
-    if (event->sync) release_object( event->sync );
     if (event->file) release_object( event->file );
     release_object( event->sender );
 }
@@ -330,11 +325,11 @@ static void debug_obj_dump( struct objec
              debug_obj->event_queue.next, debug_obj->event_queue.prev );
 }
 
-static struct object *debug_obj_get_sync( struct object *obj )
+static int debug_obj_signaled( struct object *obj, struct wait_queue_entry *entry )
 {
     struct debug_obj *debug_obj = (struct debug_obj *)obj;
     assert( obj->ops == &debug_obj_ops );
-    return grab_object( debug_obj->sync );
+    return find_event_to_send( debug_obj ) != NULL;
 }
 
 static void debug_obj_destroy( struct object *obj )
@@ -349,8 +344,6 @@ static void debug_obj_destroy( struct ob
     /* free all pending events */
     while ((ptr = list_head( &debug_obj->event_queue )))
         unlink_event( debug_obj, LIST_ENTRY( ptr, struct debug_event, entry ));
-
-    if (debug_obj->sync) release_object( debug_obj->sync );
 }
 
 struct debug_obj *get_debug_obj( struct process *process, obj_handle_t handle, unsigned int access )
@@ -368,15 +361,8 @@ static struct debug_obj *create_debug_ob
     {
         if (get_error() != STATUS_OBJECT_NAME_EXISTS)
         {
-            debug_obj->sync  = NULL;
             debug_obj->flags = flags;
             list_init( &debug_obj->event_queue );
-
-            if (!(debug_obj->sync = create_internal_sync( 1, 0 )))
-            {
-                release_object( debug_obj );
-                return NULL;
-            }
         }
     }
     return debug_obj;
@@ -422,7 +408,7 @@ static int continue_debug_event( struct
                 assert( event->sender->process->debug_event == event );
                 event->status = status;
                 event->state  = EVENT_CONTINUED;
-                signal_sync( (struct object *)event->sync );
+                wake_up( &event->obj, 0 );
                 unlink_event( debug_obj, event );
                 resume_process( process );
                 return 1;
@@ -443,21 +429,12 @@ static struct debug_event *alloc_debug_e
 
     /* build the event */
     if (!(event = alloc_object( &debug_event_ops ))) return NULL;
-    event->sync      = NULL;
     event->state     = EVENT_QUEUED;
     event->sender    = (struct thread *)grab_object( thread );
     event->file      = NULL;
     memset( &event->data, 0, sizeof(event->data) );
     fill_debug_event[code - DbgCreateThreadStateChange]( event, arg );
     event->data.code = code;
-
-    /* create a server-side sync here, as send_debug_event still uses server_select to pass contexts around */
-    if (!(event->sync = create_server_internal_sync( 1, 0 )))
-    {
-        release_object( event );
-        return NULL;
-    }
-
     return event;
 }
 
@@ -543,7 +520,7 @@ void debugger_detach( struct process *pr
         assert( event->state != EVENT_CONTINUED );
         event->status = DBG_CONTINUE;
         event->state  = EVENT_CONTINUED;
-        signal_sync( (struct object *)event->sync );
+        wake_up( &event->obj, 0 );
         unlink_event( debug_obj, event );
         /* from queued debug event */
         resume_process( process );
@@ -589,13 +566,11 @@ DECL_HANDLER(wait_debug_event)
     if ((event = find_event_to_send( debug_obj )))
     {
         event->state = EVENT_SENT;
-        reset_sync( (struct object *)event->sync );
         event->sender->process->debug_event = event;
         reply->pid = get_process_id( event->sender->process );
         reply->tid = get_thread_id( event->sender );
         alloc_event_handles( event, current->process );
         set_reply_data( &event->data, min( get_reply_max_size(), sizeof(event->data) ));
-        if (!find_event_to_send( debug_obj )) reset_sync( debug_obj->sync );
     }
     else
     {
diff -ruN --show-c-function server/device.c server/device.c
--- server/device.c	2025-10-10 10:17:47.802634392 -0700
+++ server/device.c	2025-10-10 10:22:17.160181955 -0700
@@ -38,6 +38,7 @@
 #include "handle.h"
 #include "request.h"
 #include "process.h"
+#include "esync.h"
 
 /* IRP object */
 
@@ -66,10 +67,10 @@ static const struct object_ops irp_call_
     no_add_queue,                     /* add_queue */
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
+    NULL,                             /* get_esync_fd */
     NULL,                             /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
-    default_get_sync,                 /* get_sync */
     default_map_access,               /* map_access */
     default_get_sd,                   /* get_sd */
     default_set_sd,                   /* set_sd */
@@ -89,15 +90,16 @@ static const struct object_ops irp_call_
 struct device_manager
 {
     struct object          obj;            /* object header */
-    struct object         *sync;           /* sync object for wait/signal */
     struct list            devices;        /* list of devices */
     struct list            requests;       /* list of pending irps across all devices */
     struct irp_call       *current_call;   /* call currently executed on client side */
     struct wine_rb_tree    kernel_objects; /* map of objects that have client side pointer associated */
+    int                    esync_fd;       /* esync file descriptor */
 };
 
 static void device_manager_dump( struct object *obj, int verbose );
-static struct object *device_manager_get_sync( struct object *obj );
+static int device_manager_signaled( struct object *obj, struct wait_queue_entry *entry );
+static int device_manager_get_esync_fd( struct object *obj, enum esync_type *type );
 static void device_manager_destroy( struct object *obj );
 
 static const struct object_ops device_manager_ops =
@@ -105,13 +107,13 @@ static const struct object_ops device_ma
     sizeof(struct device_manager),    /* size */
     &no_type,                         /* type */
     device_manager_dump,              /* dump */
-    NULL,                             /* add_queue */
-    NULL,                             /* remove_queue */
-    NULL,                             /* signaled */
-    NULL,                             /* satisfied */
+    add_queue,                        /* add_queue */
+    remove_queue,                     /* remove_queue */
+    device_manager_signaled,          /* signaled */
+    device_manager_get_esync_fd,      /* get_esync_fd */
+    no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
-    device_manager_get_sync,          /* get_sync */
     default_map_access,               /* map_access */
     default_get_sd,                   /* get_sd */
     default_set_sd,                   /* set_sd */
@@ -166,10 +168,10 @@ static const struct object_ops device_op
     no_add_queue,                     /* add_queue */
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
+    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
-    default_get_sync,                 /* get_sync */
     default_map_access,               /* map_access */
     default_get_sd,                   /* get_sd */
     default_set_sd,                   /* set_sd */
@@ -216,13 +218,13 @@ static const struct object_ops device_fi
     sizeof(struct device_file),       /* size */
     &file_type,                       /* type */
     device_file_dump,                 /* dump */
-    NULL,                             /* add_queue */
-    NULL,                             /* remove_queue */
-    NULL,                             /* signaled */
-    NULL,                             /* satisfied */
+    add_queue,                        /* add_queue */
+    remove_queue,                     /* remove_queue */
+    default_fd_signaled,              /* signaled */
+    NULL,                             /* get_esync_fd */
+    no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     device_file_get_fd,               /* get_fd */
-    default_fd_get_sync,              /* get_sync */
     default_map_access,               /* map_access */
     default_get_sd,                   /* get_sd */
     default_set_sd,                   /* set_sd */
@@ -423,7 +425,7 @@ static void add_irp_to_queue( struct dev
     irp->thread = thread ? (struct thread *)grab_object( thread ) : NULL;
     if (irp->file) list_add_tail( &irp->file->requests, &irp->dev_entry );
     list_add_tail( &manager->requests, &irp->mgr_entry );
-    if (list_head( &manager->requests ) == &irp->mgr_entry) signal_sync( manager->sync );
+    if (list_head( &manager->requests ) == &irp->mgr_entry) wake_up( &manager->obj, 0 );  /* first one */
 }
 
 static struct object *device_open_file( struct object *obj, unsigned int access,
@@ -753,7 +755,6 @@ struct object *create_unix_device( struc
 /* terminate requests when the underlying device is deleted */
 static void delete_file( struct device_file *file )
 {
-    struct device_manager *manager = file->device->manager;
     struct irp_call *irp, *next;
 
     /* the pending requests may be the only thing holding a reference to the file */
@@ -762,11 +763,13 @@ static void delete_file( struct device_f
     /* terminate all pending requests */
     LIST_FOR_EACH_ENTRY_SAFE( irp, next, &file->requests, struct irp_call, dev_entry )
     {
+        if (do_esync() && file->device->manager && list_empty( &file->device->manager->requests ))
+            esync_clear( file->device->manager->esync_fd );
+
         list_remove( &irp->mgr_entry );
         set_irp_result( irp, STATUS_FILE_DELETED, NULL, 0, 0 );
     }
 
-    if (list_empty( &manager->requests )) reset_sync( manager->sync );
     release_object( file );
 }
 
@@ -791,11 +794,18 @@ static void device_manager_dump( struct
     fprintf( stderr, "Device manager\n" );
 }
 
-static struct object *device_manager_get_sync( struct object *obj )
+static int device_manager_signaled( struct object *obj, struct wait_queue_entry *entry )
 {
     struct device_manager *manager = (struct device_manager *)obj;
-    assert( obj->ops == &device_manager_ops );
-    return grab_object( manager->sync );
+
+    return !list_empty( &manager->requests );
+}
+
+static int device_manager_get_esync_fd( struct object *obj, enum esync_type *type )
+{
+    struct device_manager *manager = (struct device_manager *)obj;
+    *type = ESYNC_MANUAL_SERVER;
+    return manager->esync_fd;
 }
 
 static void device_manager_destroy( struct object *obj )
@@ -833,7 +843,8 @@ static void device_manager_destroy( stru
         release_object( irp );
     }
 
-    if (manager->sync) release_object( manager->sync );
+    if (do_esync())
+        close( manager->esync_fd );
 }
 
 static struct device_manager *create_device_manager(void)
@@ -842,17 +853,13 @@ static struct device_manager *create_dev
 
     if ((manager = alloc_object( &device_manager_ops )))
     {
-        manager->sync         = NULL;
         manager->current_call = NULL;
         list_init( &manager->devices );
         list_init( &manager->requests );
         wine_rb_init( &manager->kernel_objects, compare_kernel_object );
 
-        if (!(manager->sync = create_internal_sync( 1, 0 )))
-        {
-            release_object( manager );
-            return NULL;
-        }
+        if (do_esync())
+            manager->esync_fd = esync_create_fd( 0, 0 );
     }
     return manager;
 }
@@ -1039,11 +1046,12 @@ DECL_HANDLER(get_next_device_request)
                 }
                 list_remove( &irp->mgr_entry );
                 list_init( &irp->mgr_entry );
-                if (list_empty( &manager->requests )) reset_sync( manager->sync );
-
                 /* we already own the object if it's only on manager queue */
                 if (irp->file) grab_object( irp );
                 manager->current_call = irp;
+
+                if (do_esync() && list_empty( &manager->requests ))
+                    esync_clear( manager->esync_fd );
             }
             else close_handle( current->process, reply->next );
         }
diff -ruN --show-c-function server/directory.c server/directory.c
--- server/directory.c	2025-10-10 10:17:47.802634392 -0700
+++ server/directory.c	2025-10-10 10:22:17.150607911 -0700
@@ -69,10 +69,10 @@ static const struct object_ops object_ty
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
-    default_get_sync,             /* get_sync */
     default_map_access,           /* map_access */
     default_get_sd,               /* get_sd */
     default_set_sd,               /* set_sd */
@@ -120,10 +120,10 @@ static const struct object_ops directory
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
-    default_get_sync,             /* get_sync */
     default_map_access,           /* map_access */
     default_get_sd,               /* get_sd */
     default_set_sd,               /* set_sd */
diff -ruN --show-c-function server/esync.c server/esync.c
--- server/esync.c	1969-12-31 16:00:00.000000000 -0800
+++ server/esync.c	2025-10-10 10:22:17.173292935 -0700
@@ -0,0 +1,588 @@
+/*
+ * eventfd-based synchronization objects
+ *
+ * Copyright (C) 2018 Zebediah Figura
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdarg.h>
+#ifdef HAVE_SYS_EVENTFD_H
+# include <sys/eventfd.h>
+#endif
+#include <sys/mman.h>
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#include <unistd.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winternl.h"
+
+#include "handle.h"
+#include "request.h"
+#include "file.h"
+#include "esync.h"
+
+int do_esync(void)
+{
+#ifdef HAVE_SYS_EVENTFD_H
+    static int do_esync_cached = -1;
+
+    if (do_esync_cached == -1)
+        do_esync_cached = getenv("WINEESYNC") && atoi(getenv("WINEESYNC"));
+
+    return do_esync_cached;
+#else
+    return 0;
+#endif
+}
+
+static char shm_name[29];
+static int shm_fd;
+static off_t shm_size;
+static void **shm_addrs;
+static int shm_addrs_size;  /* length of the allocated shm_addrs array */
+static long pagesize;
+
+static void shm_cleanup(void)
+{
+    close( shm_fd );
+    if (shm_unlink( shm_name ) == -1)
+        perror( "shm_unlink" );
+}
+
+void esync_init(void)
+{
+    struct stat st;
+
+    if (fstat( config_dir_fd, &st ) == -1)
+        fatal_error( "cannot stat config dir\n" );
+
+    if (st.st_ino != (unsigned long)st.st_ino)
+        sprintf( shm_name, "/wine-%lx%08lx-esync", (unsigned long)((unsigned long long)st.st_ino >> 32), (unsigned long)st.st_ino );
+    else
+        sprintf( shm_name, "/wine-%lx-esync", (unsigned long)st.st_ino );
+
+    shm_unlink( shm_name );
+
+    shm_fd = shm_open( shm_name, O_RDWR | O_CREAT | O_EXCL, 0644 );
+    if (shm_fd == -1)
+        perror( "shm_open" );
+
+    pagesize = sysconf( _SC_PAGESIZE );
+
+    shm_addrs = calloc( 128, sizeof(shm_addrs[0]) );
+    shm_addrs_size = 128;
+
+    shm_size = pagesize;
+    if (ftruncate( shm_fd, shm_size ) == -1)
+        perror( "ftruncate" );
+
+    fprintf( stderr, "esync: up and running.\n" );
+
+    atexit( shm_cleanup );
+}
+
+static struct list mutex_list = LIST_INIT(mutex_list);
+
+struct esync
+{
+    struct object   obj;            /* object header */
+    int             fd;             /* eventfd file descriptor */
+    enum esync_type type;
+    unsigned int    shm_idx;        /* index into the shared memory section */
+    struct list     mutex_entry;    /* entry in the mutex list (if applicable) */
+};
+
+static void esync_dump( struct object *obj, int verbose );
+static int esync_get_esync_fd( struct object *obj, enum esync_type *type );
+static unsigned int esync_map_access( struct object *obj, unsigned int access );
+static void esync_destroy( struct object *obj );
+
+const struct object_ops esync_ops =
+{
+    sizeof(struct esync),      /* size */
+    &no_type,                  /* type */
+    esync_dump,                /* dump */
+    no_add_queue,              /* add_queue */
+    NULL,                      /* remove_queue */
+    NULL,                      /* signaled */
+    esync_get_esync_fd,        /* get_esync_fd */
+    NULL,                      /* satisfied */
+    no_signal,                 /* signal */
+    no_get_fd,                 /* get_fd */
+    esync_map_access,          /* map_access */
+    default_get_sd,            /* get_sd */
+    default_set_sd,            /* set_sd */
+    default_get_full_name,     /* get_full_name */
+    no_lookup_name,            /* lookup_name */
+    directory_link_name,       /* link_name */
+    default_unlink_name,       /* unlink_name */
+    no_open_file,              /* open_file */
+    no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_close_handle,           /* close_handle */
+    esync_destroy              /* destroy */
+};
+
+static void esync_dump( struct object *obj, int verbose )
+{
+    struct esync *esync = (struct esync *)obj;
+    assert( obj->ops == &esync_ops );
+    fprintf( stderr, "esync fd=%d\n", esync->fd );
+}
+
+static int esync_get_esync_fd( struct object *obj, enum esync_type *type )
+{
+    struct esync *esync = (struct esync *)obj;
+    *type = esync->type;
+    return esync->fd;
+}
+
+static unsigned int esync_map_access( struct object *obj, unsigned int access )
+{
+    /* Sync objects have the same flags. */
+    if (access & GENERIC_READ)    access |= STANDARD_RIGHTS_READ | EVENT_QUERY_STATE;
+    if (access & GENERIC_WRITE)   access |= STANDARD_RIGHTS_WRITE | EVENT_MODIFY_STATE;
+    if (access & GENERIC_EXECUTE) access |= STANDARD_RIGHTS_EXECUTE | SYNCHRONIZE;
+    if (access & GENERIC_ALL)     access |= STANDARD_RIGHTS_ALL | EVENT_QUERY_STATE | EVENT_MODIFY_STATE;
+    return access & ~(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL);
+}
+
+static void esync_destroy( struct object *obj )
+{
+    struct esync *esync = (struct esync *)obj;
+    if (esync->type == ESYNC_MUTEX)
+        list_remove( &esync->mutex_entry );
+    close( esync->fd );
+}
+
+static int type_matches( enum esync_type type1, enum esync_type type2 )
+{
+    return (type1 == type2) ||
+           ((type1 == ESYNC_AUTO_EVENT || type1 == ESYNC_MANUAL_EVENT) &&
+            (type2 == ESYNC_AUTO_EVENT || type2 == ESYNC_MANUAL_EVENT));
+}
+
+static void *get_shm( unsigned int idx )
+{
+    int entry  = (idx * 8) / pagesize;
+    int offset = (idx * 8) % pagesize;
+
+    if (entry >= shm_addrs_size)
+    {
+        int new_size = max(shm_addrs_size * 2, entry + 1);
+
+        if (!(shm_addrs = realloc( shm_addrs, new_size * sizeof(shm_addrs[0]) )))
+            fprintf( stderr, "esync: couldn't expand shm_addrs array to size %d\n", entry + 1 );
+
+        memset( shm_addrs + shm_addrs_size, 0, (new_size - shm_addrs_size) * sizeof(shm_addrs[0]) );
+
+        shm_addrs_size = new_size;
+    }
+
+    if (!shm_addrs[entry])
+    {
+        void *addr = mmap( NULL, pagesize, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, entry * pagesize );
+        if (addr == (void *)-1)
+        {
+            fprintf( stderr, "esync: failed to map page %d (offset %#lx): ", entry, entry * pagesize );
+            perror( "mmap" );
+        }
+
+        if (debug_level)
+            fprintf( stderr, "esync: Mapping page %d at %p.\n", entry, addr );
+
+        if (__sync_val_compare_and_swap( &shm_addrs[entry], 0, addr ))
+            munmap( addr, pagesize ); /* someone beat us to it */
+    }
+
+    return (void *)((unsigned long)shm_addrs[entry] + offset);
+}
+
+struct semaphore
+{
+    int max;
+    int count;
+};
+C_ASSERT(sizeof(struct semaphore) == 8);
+
+struct mutex
+{
+    DWORD tid;
+    int count;    /* recursion count */
+};
+C_ASSERT(sizeof(struct mutex) == 8);
+
+struct event
+{
+    int signaled;
+    int locked;
+};
+C_ASSERT(sizeof(struct event) == 8);
+
+struct esync *create_esync( struct object *root, const struct unicode_str *name,
+                            unsigned int attr, int initval, int max, enum esync_type type,
+                            const struct security_descriptor *sd )
+{
+#ifdef HAVE_SYS_EVENTFD_H
+    struct esync *esync;
+
+    if ((esync = create_named_object( root, &esync_ops, name, attr, sd )))
+    {
+        if (get_error() != STATUS_OBJECT_NAME_EXISTS)
+        {
+            int flags = EFD_CLOEXEC | EFD_NONBLOCK;
+
+            if (type == ESYNC_SEMAPHORE)
+                flags |= EFD_SEMAPHORE;
+
+            /* initialize it if it didn't already exist */
+            esync->fd = eventfd( initval, flags );
+            if (esync->fd == -1)
+            {
+                perror( "eventfd" );
+                file_set_error();
+                release_object( esync );
+                return NULL;
+            }
+            esync->type = type;
+
+            /* Use the fd as index, since that'll be unique across all
+             * processes, but should hopefully end up also allowing reuse. */
+            esync->shm_idx = esync->fd + 1; /* we keep index 0 reserved */
+            while (esync->shm_idx * 8 >= shm_size)
+            {
+                /* Better expand the shm section. */
+                shm_size += pagesize;
+                if (ftruncate( shm_fd, shm_size ) == -1)
+                {
+                    fprintf( stderr, "esync: couldn't expand %s to size %ld: ",
+                             shm_name, (long)shm_size );
+                    perror( "ftruncate" );
+                }
+            }
+
+            /* Initialize the shared memory portion. We want to do this on the
+             * server side to avoid a potential though unlikely race whereby
+             * the same object is opened and used between the time it's created
+             * and the time its shared memory portion is initialized. */
+            switch (type)
+            {
+            case ESYNC_SEMAPHORE:
+            {
+                struct semaphore *semaphore = get_shm( esync->shm_idx );
+                semaphore->max = max;
+                semaphore->count = initval;
+                break;
+            }
+            case ESYNC_AUTO_EVENT:
+            case ESYNC_MANUAL_EVENT:
+            {
+                struct event *event = get_shm( esync->shm_idx );
+                event->signaled = initval ? 1 : 0;
+                event->locked = 0;
+                break;
+            }
+            case ESYNC_MUTEX:
+            {
+                struct mutex *mutex = get_shm( esync->shm_idx );
+                mutex->tid = initval ? 0 : current->id;
+                mutex->count = initval ? 0 : 1;
+                list_add_tail( &mutex_list, &esync->mutex_entry );
+                break;
+            }
+            default:
+                assert( 0 );
+            }
+        }
+        else
+        {
+            /* validate the type */
+            if (!type_matches( type, esync->type ))
+            {
+                release_object( &esync->obj );
+                set_error( STATUS_OBJECT_TYPE_MISMATCH );
+                return NULL;
+            }
+        }
+    }
+    return esync;
+#else
+    /* FIXME: Provide a fallback implementation using pipe(). */
+    set_error( STATUS_NOT_IMPLEMENTED );
+    return NULL;
+#endif
+}
+
+/* Create a file descriptor for an existing handle.
+ * Caller must close the handle when it's done; it's not linked to an esync
+ * server object in any way. */
+int esync_create_fd( int initval, int flags )
+{
+#ifdef HAVE_SYS_EVENTFD_H
+    int fd;
+
+    fd = eventfd( initval, flags | EFD_CLOEXEC | EFD_NONBLOCK );
+    if (fd == -1)
+        perror( "eventfd" );
+
+    return fd;
+#else
+    return -1;
+#endif
+}
+
+/* Wake up a specific fd. */
+void esync_wake_fd( int fd )
+{
+    static const uint64_t value = 1;
+
+    if (write( fd, &value, sizeof(value) ) == -1)
+        perror( "esync: write" );
+}
+
+/* Wake up a server-side esync object. */
+void esync_wake_up( struct object *obj )
+{
+    enum esync_type dummy;
+    int fd;
+
+    if (obj->ops->get_esync_fd)
+    {
+        fd = obj->ops->get_esync_fd( obj, &dummy );
+        esync_wake_fd( fd );
+    }
+}
+
+void esync_clear( int fd )
+{
+    uint64_t value;
+
+    /* we don't care about the return value */
+    read( fd, &value, sizeof(value) );
+}
+
+static inline void small_pause(void)
+{
+#ifdef __i386__
+    __asm__ __volatile__( "rep;nop" : : : "memory" );
+#else
+    __asm__ __volatile__( "" : : : "memory" );
+#endif
+}
+
+/* Server-side event support. */
+void esync_set_event( struct esync *esync )
+{
+    static const uint64_t value = 1;
+    struct event *event = get_shm( esync->shm_idx );
+
+    assert( esync->obj.ops == &esync_ops );
+    assert( event != NULL );
+
+    if (debug_level)
+        fprintf( stderr, "esync_set_event() fd=%d\n", esync->fd );
+
+    if (esync->type == ESYNC_MANUAL_EVENT)
+    {
+        /* Acquire the spinlock. */
+        while (__sync_val_compare_and_swap( &event->locked, 0, 1 ))
+            small_pause();
+    }
+
+    if (!__atomic_exchange_n( &event->signaled, 1, __ATOMIC_SEQ_CST ))
+    {
+        if (write( esync->fd, &value, sizeof(value) ) == -1)
+            perror( "esync: write" );
+    }
+
+    if (esync->type == ESYNC_MANUAL_EVENT)
+    {
+        /* Release the spinlock. */
+        event->locked = 0;
+    }
+}
+
+void esync_reset_event( struct esync *esync )
+{
+    static uint64_t value = 1;
+    struct event *event = get_shm( esync->shm_idx );
+
+    assert( esync->obj.ops == &esync_ops );
+    assert( event != NULL );
+
+    if (debug_level)
+        fprintf( stderr, "esync_reset_event() fd=%d\n", esync->fd );
+
+    if (esync->type == ESYNC_MANUAL_EVENT)
+    {
+        /* Acquire the spinlock. */
+        while (__sync_val_compare_and_swap( &event->locked, 0, 1 ))
+            small_pause();
+    }
+
+    /* Only bother signaling the fd if we weren't already signaled. */
+    if (__atomic_exchange_n( &event->signaled, 0, __ATOMIC_SEQ_CST ))
+    {
+        /* we don't care about the return value */
+        read( esync->fd, &value, sizeof(value) );
+    }
+
+    if (esync->type == ESYNC_MANUAL_EVENT)
+    {
+        /* Release the spinlock. */
+        event->locked = 0;
+    }
+}
+
+void esync_abandon_mutexes( struct thread *thread )
+{
+    struct esync *esync;
+
+    LIST_FOR_EACH_ENTRY( esync, &mutex_list, struct esync, mutex_entry )
+    {
+        struct mutex *mutex = get_shm( esync->shm_idx );
+
+        if (mutex->tid == thread->id)
+        {
+            if (debug_level)
+                fprintf( stderr, "esync_abandon_mutexes() fd=%d\n", esync->fd );
+            mutex->tid = ~0;
+            mutex->count = 0;
+            esync_wake_fd( esync->fd );
+        }
+    }
+}
+
+DECL_HANDLER(create_esync)
+{
+    struct esync *esync;
+    struct unicode_str name;
+    struct object *root;
+    const struct security_descriptor *sd;
+    const struct object_attributes *objattr = get_req_object_attributes( &sd, &name, &root );
+
+    if (!do_esync())
+    {
+        set_error( STATUS_NOT_IMPLEMENTED );
+        return;
+    }
+
+    if (!req->type)
+    {
+        set_error( STATUS_INVALID_PARAMETER );
+        return;
+    }
+
+    if (!objattr) return;
+
+    if ((esync = create_esync( root, &name, objattr->attributes, req->initval, req->max, req->type, sd )))
+    {
+        if (get_error() == STATUS_OBJECT_NAME_EXISTS)
+            reply->handle = alloc_handle( current->process, esync, req->access, objattr->attributes );
+        else
+            reply->handle = alloc_handle_no_access_check( current->process, esync,
+                                                          req->access, objattr->attributes );
+
+        reply->type = esync->type;
+        reply->shm_idx = esync->shm_idx;
+        send_client_fd( current->process, esync->fd, reply->handle );
+        release_object( esync );
+    }
+
+    if (root) release_object( root );
+}
+
+DECL_HANDLER(open_esync)
+{
+    struct unicode_str name = get_req_unicode_str();
+
+    reply->handle = open_object( current->process, req->rootdir, req->access,
+                                 &esync_ops, &name, req->attributes );
+
+    /* send over the fd */
+    if (reply->handle)
+    {
+        struct esync *esync;
+
+        if (!(esync = (struct esync *)get_handle_obj( current->process, reply->handle,
+                                                      0, &esync_ops )))
+            return;
+
+        if (!type_matches( req->type, esync->type ))
+        {
+            set_error( STATUS_OBJECT_TYPE_MISMATCH );
+            release_object( esync );
+            return;
+        }
+
+        reply->type = esync->type;
+        reply->shm_idx = esync->shm_idx;
+
+        send_client_fd( current->process, esync->fd, reply->handle );
+        release_object( esync );
+    }
+}
+
+/* Retrieve a file descriptor for an esync object which will be signaled by the
+ * server. The client should only read from (i.e. wait on) this object. */
+DECL_HANDLER(get_esync_fd)
+{
+    struct object *obj;
+    enum esync_type type;
+    int fd;
+
+    if (!(obj = get_handle_obj( current->process, req->handle, SYNCHRONIZE, NULL )))
+        return;
+
+    if (obj->ops->get_esync_fd)
+    {
+        fd = obj->ops->get_esync_fd( obj, &type );
+        reply->type = type;
+        if (obj->ops == &esync_ops)
+        {
+            struct esync *esync = (struct esync *)obj;
+            reply->shm_idx = esync->shm_idx;
+        }
+        else
+            reply->shm_idx = 0;
+        send_client_fd( current->process, fd, req->handle );
+    }
+    else
+    {
+        if (debug_level)
+        {
+            fprintf( stderr, "%04x: esync: can't wait on object: ", current->id );
+            obj->ops->dump( obj, 0 );
+        }
+        set_error( STATUS_NOT_IMPLEMENTED );
+    }
+
+    release_object( obj );
+}
+
+/* Return the fd used for waiting on user APCs. */
+DECL_HANDLER(get_esync_apc_fd)
+{
+    send_client_fd( current->process, current->esync_apc_fd, current->id );
+}
diff -ruN --show-c-function server/esync.h server/esync.h
--- server/esync.h	1969-12-31 16:00:00.000000000 -0800
+++ server/esync.h	2025-10-10 10:22:17.173418323 -0700
@@ -0,0 +1,35 @@
+/*
+ * eventfd-based synchronization objects
+ *
+ * Copyright (C) 2018 Zebediah Figura
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <unistd.h>
+
+extern int do_esync(void);
+void esync_init(void);
+int esync_create_fd( int initval, int flags );
+void esync_wake_fd( int fd );
+void esync_wake_up( struct object *obj );
+void esync_clear( int fd );
+
+struct esync;
+
+extern const struct object_ops esync_ops;
+void esync_set_event( struct esync *esync );
+void esync_reset_event( struct esync *esync );
+void esync_abandon_mutexes( struct thread *thread );
diff -ruN --show-c-function server/event.c server/event.c
--- server/event.c	2025-10-10 10:17:47.802634392 -0700
+++ server/event.c	2025-10-10 10:22:17.157949712 -0700
@@ -35,6 +35,7 @@
 #include "thread.h"
 #include "request.h"
 #include "security.h"
+#include "esync.h"
 
 static const WCHAR event_name[] = {'E','v','e','n','t'};
 
@@ -50,116 +51,20 @@ struct type_descr event_type =
     },
 };
 
-struct event_sync
-{
-    struct object  obj;             /* object header */
-    unsigned int   manual : 1;      /* is it a manual reset event? */
-    unsigned int   signaled : 1;    /* event has been signaled */
-};
-
-static void event_sync_dump( struct object *obj, int verbose );
-static int event_sync_signaled( struct object *obj, struct wait_queue_entry *entry );
-static void event_sync_satisfied( struct object *obj, struct wait_queue_entry *entry );
-static int event_sync_signal( struct object *obj, unsigned int access, int signal );
-
-static const struct object_ops event_sync_ops =
-{
-    sizeof(struct event_sync), /* size */
-    &no_type,                  /* type */
-    event_sync_dump,           /* dump */
-    add_queue,                 /* add_queue */
-    remove_queue,              /* remove_queue */
-    event_sync_signaled,       /* signaled */
-    event_sync_satisfied,      /* satisfied */
-    event_sync_signal,         /* signal */
-    no_get_fd,                 /* get_fd */
-    default_get_sync,          /* get_sync */
-    default_map_access,        /* map_access */
-    default_get_sd,            /* get_sd */
-    default_set_sd,            /* set_sd */
-    default_get_full_name,     /* get_full_name */
-    no_lookup_name,            /* lookup_name */
-    directory_link_name,       /* link_name */
-    default_unlink_name,       /* unlink_name */
-    no_open_file,              /* open_file */
-    no_kernel_obj_list,        /* get_kernel_obj_list */
-    no_close_handle,           /* close_handle */
-    no_destroy                 /* destroy */
-};
-
-static struct object *create_event_sync( int manual, int signaled )
-{
-    struct event_sync *event;
-
-    if (get_inproc_device_fd() >= 0) return (struct object *)create_inproc_event_sync( manual, signaled );
-
-    if (!(event = alloc_object( &event_sync_ops ))) return NULL;
-    event->manual   = manual;
-    event->signaled = signaled;
-
-    return &event->obj;
-}
-
-struct event_sync *create_server_internal_sync( int manual, int signaled )
-{
-    struct event_sync *event;
-
-    if (!(event = alloc_object( &event_sync_ops ))) return NULL;
-    event->manual   = manual;
-    event->signaled = signaled;
-
-    return event;
-}
-
-struct object *create_internal_sync( int manual, int signaled )
-{
-    if (get_inproc_device_fd() >= 0) return (struct object *)create_inproc_internal_sync( manual, signaled );
-    return (struct object *)create_server_internal_sync( manual, signaled );
-}
-
-static void event_sync_dump( struct object *obj, int verbose )
-{
-    struct event_sync *event = (struct event_sync *)obj;
-    assert( obj->ops == &event_sync_ops );
-    fprintf( stderr, "Event manual=%d signaled=%d\n",
-             event->manual, event->signaled );
-}
-
-static int event_sync_signaled( struct object *obj, struct wait_queue_entry *entry )
-{
-    struct event_sync *event = (struct event_sync *)obj;
-    assert( obj->ops == &event_sync_ops );
-    return event->signaled;
-}
-
-static void event_sync_satisfied( struct object *obj, struct wait_queue_entry *entry )
-{
-    struct event_sync *event = (struct event_sync *)obj;
-    assert( obj->ops == &event_sync_ops );
-    /* Reset if it's an auto-reset event */
-    if (!event->manual) event->signaled = 0;
-}
-
-static int event_sync_signal( struct object *obj, unsigned int access, int signal )
-{
-    struct event_sync *event = (struct event_sync *)obj;
-    assert( obj->ops == &event_sync_ops );
-
-    /* wake up all waiters if manual reset, a single one otherwise */
-    if ((event->signaled = !!signal)) wake_up( &event->obj, !event->manual );
-    return 1;
-}
-
 struct event
 {
-    struct object      obj;             /* object header */
-    struct object     *sync;            /* event sync object */
-    struct list        kernel_object;   /* list of kernel object pointers */
+    struct object  obj;             /* object header */
+    struct list    kernel_object;   /* list of kernel object pointers */
+    int            manual_reset;    /* is it a manual reset event? */
+    int            signaled;        /* event has been signaled */
+    int            esync_fd;        /* esync file descriptor */
 };
 
 static void event_dump( struct object *obj, int verbose );
-static struct object *event_get_sync( struct object *obj );
-static int event_signal( struct object *obj, unsigned int access, int signal );
+static int event_signaled( struct object *obj, struct wait_queue_entry *entry );
+static void event_satisfied( struct object *obj, struct wait_queue_entry *entry );
+static int event_get_esync_fd( struct object *obj, enum esync_type *type );
+static int event_signal( struct object *obj, unsigned int access);
 static struct list *event_get_kernel_obj_list( struct object *obj );
 static void event_destroy( struct object *obj );
 
@@ -168,13 +73,13 @@ static const struct object_ops event_ops
     sizeof(struct event),      /* size */
     &event_type,               /* type */
     event_dump,                /* dump */
-    NULL,                      /* add_queue */
-    NULL,                      /* remove_queue */
-    NULL,                      /* signaled */
-    NULL,                      /* satisfied */
+    add_queue,                 /* add_queue */
+    remove_queue,              /* remove_queue */
+    event_signaled,            /* signaled */
+    event_get_esync_fd,        /* get_esync_fd */
+    event_satisfied,           /* satisfied */
     event_signal,              /* signal */
     no_get_fd,                 /* get_fd */
-    event_get_sync,            /* get_sync */
     default_map_access,        /* map_access */
     default_get_sd,            /* get_sd */
     default_set_sd,            /* set_sd */
@@ -185,7 +90,7 @@ static const struct object_ops event_ops
     no_open_file,              /* open_file */
     event_get_kernel_obj_list, /* get_kernel_obj_list */
     no_close_handle,           /* close_handle */
-    event_destroy,             /* destroy */
+    event_destroy              /* destroy */
 };
 
 
@@ -219,10 +124,10 @@ static const struct object_ops keyed_eve
     add_queue,                   /* add_queue */
     remove_queue,                /* remove_queue */
     keyed_event_signaled,        /* signaled */
+    NULL,                        /* get_esync_fd */
     no_satisfied,                /* satisfied */
     no_signal,                   /* signal */
     no_get_fd,                   /* get_fd */
-    default_get_sync,            /* get_sync */
     default_map_access,          /* map_access */
     default_get_sd,              /* get_sd */
     default_set_sd,              /* set_sd */
@@ -248,14 +153,12 @@ struct event *create_event( struct objec
         if (get_error() != STATUS_OBJECT_NAME_EXISTS)
         {
             /* initialize it if it didn't already exist */
-            event->sync = NULL;
             list_init( &event->kernel_object );
+            event->manual_reset = manual_reset;
+            event->signaled     = initial_state;
 
-            if (!(event->sync = create_event_sync( manual_reset, initial_state )))
-            {
-                release_object( event );
-                return NULL;
-            }
+            if (do_esync())
+                event->esync_fd = esync_create_fd( initial_state, 0 );
         }
     }
     return event;
@@ -263,48 +166,89 @@ struct event *create_event( struct objec
 
 struct event *get_event_obj( struct process *process, obj_handle_t handle, unsigned int access )
 {
+    struct object *obj;
+    if (do_esync() && (obj = get_handle_obj( process, handle, access, &esync_ops)))
+        return (struct event *)obj; /* even though it's not an event */
+
     return (struct event *)get_handle_obj( process, handle, access, &event_ops );
 }
 
+static void pulse_event( struct event *event )
+{
+    event->signaled = 1;
+    /* wake up all waiters if manual reset, a single one otherwise */
+    wake_up( &event->obj, !event->manual_reset );
+    event->signaled = 0;
+}
+
 void set_event( struct event *event )
 {
-    signal_sync( event->sync );
+    if (do_esync() && event->obj.ops == &esync_ops)
+    {
+        esync_set_event( (struct esync *)event );
+        return;
+    }
+
+    event->signaled = 1;
+    /* wake up all waiters if manual reset, a single one otherwise */
+    wake_up( &event->obj, !event->manual_reset );
 }
 
 void reset_event( struct event *event )
 {
-    reset_sync( event->sync );
+    if (do_esync() && event->obj.ops == &esync_ops)
+    {
+        esync_reset_event( (struct esync *)event );
+        return;
+    }
+    event->signaled = 0;
+
+    if (do_esync())
+        esync_clear( event->esync_fd );
 }
 
 static void event_dump( struct object *obj, int verbose )
 {
     struct event *event = (struct event *)obj;
     assert( obj->ops == &event_ops );
-    event->sync->ops->dump( event->sync, verbose );
+    fprintf( stderr, "Event manual=%d signaled=%d\n",
+             event->manual_reset, event->signaled );
 }
 
-static struct object *event_get_sync( struct object *obj )
+static int event_signaled( struct object *obj, struct wait_queue_entry *entry )
 {
     struct event *event = (struct event *)obj;
     assert( obj->ops == &event_ops );
-    return grab_object( event->sync );
+    return event->signaled;
 }
 
-static int event_signal( struct object *obj, unsigned int access, int signal )
+static int event_get_esync_fd( struct object *obj, enum esync_type *type )
+{
+    struct event *event = (struct event *)obj;
+    *type = event->manual_reset ? ESYNC_MANUAL_SERVER : ESYNC_AUTO_SERVER;
+    return event->esync_fd;
+}
+
+static void event_satisfied( struct object *obj, struct wait_queue_entry *entry )
 {
     struct event *event = (struct event *)obj;
     assert( obj->ops == &event_ops );
+    /* Reset if it's an auto-reset event */
+    if (!event->manual_reset) event->signaled = 0;
+}
 
-    assert( event->sync->ops == &event_sync_ops ); /* never called with inproc syncs */
-    assert( signal == -1 ); /* always called from signal_object */
+static int event_signal( struct object *obj, unsigned int access )
+{
+    struct event *event = (struct event *)obj;
+    assert( obj->ops == &event_ops );
 
     if (!(access & EVENT_MODIFY_STATE))
     {
         set_error( STATUS_ACCESS_DENIED );
         return 0;
     }
-
-    return event_sync_signal( event->sync, 0, 1 );
+    set_event( event );
+    return 1;
 }
 
 static struct list *event_get_kernel_obj_list( struct object *obj )
@@ -316,9 +260,9 @@ static struct list *event_get_kernel_obj
 static void event_destroy( struct object *obj )
 {
     struct event *event = (struct event *)obj;
-    assert( obj->ops == &event_ops );
 
-    if (event->sync) release_object( event->sync );
+    if (do_esync())
+        close( event->esync_fd );
 }
 
 struct keyed_event *create_keyed_event( struct object *root, const struct unicode_str *name,
@@ -411,19 +355,14 @@ DECL_HANDLER(open_event)
 /* do an event operation */
 DECL_HANDLER(event_op)
 {
-    struct event_sync *sync;
     struct event *event;
 
     if (!(event = get_event_obj( current->process, req->handle, EVENT_MODIFY_STATE ))) return;
-    assert( event->sync->ops == &event_sync_ops ); /* never called with inproc syncs */
-    sync = (struct event_sync *)event->sync;
-
-    reply->state = sync->signaled;
+    reply->state = event->signaled;
     switch(req->op)
     {
     case PULSE_EVENT:
-        set_event( event );
-        reset_event( event );
+        pulse_event( event );
         break;
     case SET_EVENT:
         set_event( event );
@@ -441,15 +380,12 @@ DECL_HANDLER(event_op)
 /* return details about the event */
 DECL_HANDLER(query_event)
 {
-    struct event_sync *sync;
     struct event *event;
 
     if (!(event = get_event_obj( current->process, req->handle, EVENT_QUERY_STATE ))) return;
-    assert( event->sync->ops == &event_sync_ops ); /* never called with inproc syncs */
-    sync = (struct event_sync *)event->sync;
 
-    reply->manual_reset = sync->manual;
-    reply->state = sync->signaled;
+    reply->manual_reset = event->manual_reset;
+    reply->state = event->signaled;
 
     release_object( event );
 }
diff -ruN --show-c-function server/fd.c server/fd.c
--- server/fd.c	2025-10-10 10:17:47.802758721 -0700
+++ server/fd.c	2025-10-10 10:22:17.172811923 -0700
@@ -94,6 +94,7 @@
 #include "handle.h"
 #include "process.h"
 #include "request.h"
+#include "esync.h"
 
 #include "winternl.h"
 #include "winioctl.h"
@@ -129,7 +130,6 @@ struct fd
 {
     struct object        obj;         /* object header */
     const struct fd_ops *fd_ops;      /* file descriptor operations */
-    struct object       *sync;        /* sync object for wait/signal */
     struct inode        *inode;       /* inode that this fd belongs to */
     struct list          inode_entry; /* entry in inode fd list */
     struct closed_fd    *closed;      /* structure to store the unix fd at destroy time */
@@ -146,6 +146,7 @@ struct fd
     int                  unix_fd;     /* unix file descriptor */
     unsigned int         no_fd_status;/* status to return when unix_fd is -1 */
     unsigned int         cacheable :1;/* can the fd be cached on the client side? */
+    unsigned int         signaled :1; /* is the fd signaled? */
     unsigned int         fs_locks :1; /* can we use filesystem locks for this fd? */
     int                  poll_index;  /* index of fd in poll array */
     struct async_queue   read_q;      /* async readers of this fd */
@@ -154,10 +155,10 @@ struct fd
     struct completion   *completion;  /* completion object attached to this fd */
     apc_param_t          comp_key;    /* completion key to set in completion events */
     unsigned int         comp_flags;  /* completion flags */
+    int                  esync_fd;    /* esync file descriptor */
 };
 
 static void fd_dump( struct object *obj, int verbose );
-static struct object *fd_get_sync( struct object *obj );
 static void fd_destroy( struct object *obj );
 
 static const struct object_ops fd_ops =
@@ -165,13 +166,13 @@ static const struct object_ops fd_ops =
     sizeof(struct fd),        /* size */
     &no_type,                 /* type */
     fd_dump,                  /* dump */
-    NULL,                     /* add_queue */
+    no_add_queue,             /* add_queue */
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
+    NULL,                     /* get_esync_fd */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
-    fd_get_sync,              /* get_sync */
     default_map_access,       /* map_access */
     default_get_sd,           /* get_sd */
     default_set_sd,           /* set_sd */
@@ -210,10 +211,10 @@ static const struct object_ops device_op
     no_add_queue,             /* add_queue */
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
+    NULL,                     /* get_esync_fd */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
-    default_get_sync,         /* get_sync */
     default_map_access,       /* map_access */
     default_get_sd,           /* get_sd */
     default_set_sd,           /* set_sd */
@@ -251,10 +252,10 @@ static const struct object_ops inode_ops
     no_add_queue,             /* add_queue */
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
+    NULL,                     /* get_esync_fd */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
-    default_get_sync,         /* get_sync */
     default_map_access,       /* map_access */
     default_get_sd,           /* get_sd */
     default_set_sd,           /* set_sd */
@@ -273,7 +274,6 @@ static const struct object_ops inode_ops
 struct file_lock
 {
     struct object       obj;         /* object header */
-    struct object      *sync;        /* sync object for wait/signal */
     struct fd          *fd;          /* fd owning this lock */
     struct list         fd_entry;    /* entry in list of locks on a given fd */
     struct list         inode_entry; /* entry in inode list of locks */
@@ -285,21 +285,20 @@ struct file_lock
 };
 
 static void file_lock_dump( struct object *obj, int verbose );
-static struct object *file_lock_get_sync( struct object *obj );
-static void file_lock_destroy( struct object *obj );
+static int file_lock_signaled( struct object *obj, struct wait_queue_entry *entry );
 
 static const struct object_ops file_lock_ops =
 {
     sizeof(struct file_lock),   /* size */
     &no_type,                   /* type */
     file_lock_dump,             /* dump */
-    NULL,                       /* add_queue */
-    NULL,                       /* remove_queue */
-    NULL,                       /* signaled */
-    NULL,                       /* satisfied */
+    add_queue,                  /* add_queue */
+    remove_queue,               /* remove_queue */
+    file_lock_signaled,         /* signaled */
+    NULL,                       /* get_esync_fd */
+    no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
-    file_lock_get_sync,         /* get_sync */
     default_map_access,         /* map_access */
     default_get_sd,             /* get_sd */
     default_set_sd,             /* set_sd */
@@ -310,7 +309,7 @@ static const struct object_ops file_lock
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
     no_close_handle,            /* close_handle */
-    file_lock_destroy,          /* destroy */
+    no_destroy                  /* destroy */
 };
 
 
@@ -1243,18 +1242,11 @@ static void file_lock_dump( struct objec
     fprintf( stderr, "\n" );
 }
 
-static struct object *file_lock_get_sync( struct object *obj )
-{
-    struct file_lock *lock = (struct file_lock *)obj;
-    assert( obj->ops == &file_lock_ops );
-    return grab_object( lock->sync );
-}
-
-static void file_lock_destroy( struct object *obj )
+static int file_lock_signaled( struct object *obj, struct wait_queue_entry *entry )
 {
     struct file_lock *lock = (struct file_lock *)obj;
-    assert( obj->ops == &file_lock_ops );
-    if (lock->sync) release_object( lock->sync );
+    /* lock is signaled if it has lost its owner */
+    return !lock->process;
 }
 
 /* set (or remove) a Unix lock if possible for the given range */
@@ -1434,24 +1426,22 @@ static struct file_lock *add_lock( struc
     struct file_lock *lock;
 
     if (!(lock = alloc_object( &file_lock_ops ))) return NULL;
-    lock->sync    = NULL;
     lock->shared  = shared;
     lock->start   = start;
     lock->end     = end;
     lock->fd      = fd;
     lock->process = current->process;
 
-    if (!(lock->sync = create_internal_sync( 1, 0 ))) goto error;
     /* now try to set a Unix lock */
-    if (!set_unix_lock( lock->fd, lock->start, lock->end, lock->shared ? F_RDLCK : F_WRLCK )) goto error;
+    if (!set_unix_lock( lock->fd, lock->start, lock->end, lock->shared ? F_RDLCK : F_WRLCK ))
+    {
+        release_object( lock );
+        return NULL;
+    }
     list_add_tail( &fd->locks, &lock->fd_entry );
     list_add_tail( &fd->inode->locks, &lock->inode_entry );
     list_add_tail( &lock->process->locks, &lock->proc_entry );
     return lock;
-
-error:
-    release_object( lock );
-    return NULL;
 }
 
 /* remove an existing lock */
@@ -1465,7 +1455,7 @@ static void remove_lock( struct file_loc
     if (remove_unix) remove_unix_locks( lock->fd, lock->start, lock->end );
     if (list_empty( &inode->locks )) inode_close_pending( inode, 1 );
     lock->process = NULL;
-    signal_sync( lock->sync );
+    wake_up( &lock->obj, 0 );
     release_object( lock );
 }
 
@@ -1572,12 +1562,6 @@ static void fd_dump( struct object *obj,
     fprintf( stderr, "\n" );
 }
 
-static struct object *fd_get_sync( struct object *obj )
-{
-    struct fd *fd = (struct fd *)obj;
-    return grab_object( fd->sync );
-}
-
 static void fd_destroy( struct object *obj )
 {
     struct fd *fd = (struct fd *)obj;
@@ -1602,7 +1586,9 @@ static void fd_destroy( struct object *o
         if (fd->unix_fd != -1) close( fd->unix_fd );
         free( fd->unix_name );
     }
-    if (fd->sync) release_object( fd->sync );
+
+    if (do_esync())
+        close( fd->esync_fd );
 }
 
 /* check if the desired access is possible without violating */
@@ -1700,7 +1686,6 @@ static struct fd *alloc_fd_object(void)
     if (!fd) return NULL;
 
     fd->fd_ops     = NULL;
-    fd->sync       = NULL;
     fd->user       = NULL;
     fd->inode      = NULL;
     fd->closed     = NULL;
@@ -1714,24 +1699,27 @@ static struct fd *alloc_fd_object(void)
     fd->nt_name    = NULL;
     fd->nt_namelen = 0;
     fd->cacheable  = 0;
+    fd->signaled   = 1;
     fd->fs_locks   = 1;
     fd->poll_index = -1;
     fd->completion = NULL;
     fd->comp_flags = 0;
+    fd->esync_fd   = -1;
     init_async_queue( &fd->read_q );
     init_async_queue( &fd->write_q );
     init_async_queue( &fd->wait_q );
     list_init( &fd->inode_entry );
     list_init( &fd->locks );
 
-    if (!(fd->sync = create_internal_sync( 1, 1 ))) goto error;
-    if ((fd->poll_index = add_poll_user( fd )) == -1) goto error;
+    if (do_esync())
+        fd->esync_fd = esync_create_fd( 1, 0 );
 
+    if ((fd->poll_index = add_poll_user( fd )) == -1)
+    {
+        release_object( fd );
+        return NULL;
+    }
     return fd;
-
-error:
-    release_object( fd );
-    return NULL;
 }
 
 /* allocate a pseudo fd object, for objects that need to behave like files but don't have a unix fd */
@@ -1742,7 +1730,6 @@ struct fd *alloc_pseudo_fd( const struct
     if (!fd) return NULL;
 
     fd->fd_ops     = fd_user_ops;
-    fd->sync       = NULL;
     fd->user       = user;
     fd->inode      = NULL;
     fd->closed     = NULL;
@@ -1756,22 +1743,21 @@ struct fd *alloc_pseudo_fd( const struct
     fd->nt_namelen = 0;
     fd->unix_fd    = -1;
     fd->cacheable  = 0;
+    fd->signaled   = 1;
     fd->fs_locks   = 0;
     fd->poll_index = -1;
     fd->completion = NULL;
     fd->comp_flags = 0;
     fd->no_fd_status = STATUS_BAD_DEVICE_TYPE;
+    fd->esync_fd   = -1;
     init_async_queue( &fd->read_q );
     init_async_queue( &fd->write_q );
     init_async_queue( &fd->wait_q );
     list_init( &fd->inode_entry );
     list_init( &fd->locks );
 
-    if (!(fd->sync = create_internal_sync( 1, 1 )))
-    {
-        release_object( fd );
-        return NULL;
-    }
+    if (do_esync())
+        fd->esync_fd = esync_create_fd( 0, 0 );
     return fd;
 }
 
@@ -2175,8 +2161,11 @@ int is_fd_removable( struct fd *fd )
 void set_fd_signaled( struct fd *fd, int signaled )
 {
     if (fd->comp_flags & FILE_SKIP_SET_EVENT_ON_HANDLE) return;
-    if (signaled) signal_sync( fd->sync );
-    else reset_sync( fd->sync );
+    fd->signaled = signaled;
+    if (signaled) wake_up( fd->user, 0 );
+
+    if (do_esync() && !signaled)
+        esync_clear( fd->esync_fd );
 }
 
 /* check if events are pending and if yes return which one(s) */
@@ -2193,13 +2182,13 @@ int check_fd_events( struct fd *fd, int
     return pfd.revents;
 }
 
-/* default get_sync() routine for objects that poll() on an fd */
-struct object *default_fd_get_sync( struct object *obj )
+/* default signaled() routine for objects that poll() on an fd */
+int default_fd_signaled( struct object *obj, struct wait_queue_entry *entry )
 {
     struct fd *fd = get_obj_fd( obj );
-    struct object *sync = get_obj_sync( &fd->obj );
+    int ret = fd->signaled;
     release_object( fd );
-    return sync;
+    return ret;
 }
 
 /* default get_full_name() routine for objects with an fd */
@@ -2218,6 +2207,15 @@ WCHAR *default_fd_get_full_name( struct
     return ret;
 }
 
+int default_fd_get_esync_fd( struct object *obj, enum esync_type *type )
+{
+    struct fd *fd = get_obj_fd( obj );
+    int ret = fd->esync_fd;
+    *type = ESYNC_MANUAL_SERVER;
+    release_object( fd );
+    return ret;
+}
+
 int default_fd_get_poll_events( struct fd *fd )
 {
     int events = 0;
diff -ruN --show-c-function server/file.c server/file.c
--- server/file.c	2025-10-10 10:17:47.802758721 -0700
+++ server/file.c	2025-10-10 10:22:17.151279785 -0700
@@ -91,13 +91,13 @@ static const struct object_ops file_ops
     sizeof(struct file),          /* size */
     &file_type,                   /* type */
     file_dump,                    /* dump */
-    NULL,                         /* add_queue */
-    NULL,                         /* remove_queue */
-    NULL,                         /* signaled */
-    NULL,                         /* satisfied */
+    add_queue,                    /* add_queue */
+    remove_queue,                 /* remove_queue */
+    default_fd_signaled,          /* signaled */
+    NULL,                         /* get_esync_fd */
+    no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     file_get_fd,                  /* get_fd */
-    default_fd_get_sync,          /* get_sync */
     default_map_access,           /* map_access */
     file_get_sd,                  /* get_sd */
     file_set_sd,                  /* set_sd */
diff -ruN --show-c-function server/file.h server/file.h
--- server/file.h	2025-10-10 10:17:48.598775739 -0700
+++ server/file.h	2025-10-10 10:22:17.170829344 -0700
@@ -108,7 +108,8 @@ extern void set_fd_signaled( struct fd *
 extern char *dup_fd_name( struct fd *root, const char *name ) __WINE_DEALLOC(free) __WINE_MALLOC;
 extern void get_nt_name( struct fd *fd, struct unicode_str *name );
 
-extern struct object *default_fd_get_sync( struct object *obj );
+extern int default_fd_signaled( struct object *obj, struct wait_queue_entry *entry );
+extern int default_fd_get_esync_fd( struct object *obj, enum esync_type *type );
 extern WCHAR *default_fd_get_full_name( struct object *obj, data_size_t max, data_size_t *ret_len );
 extern int default_fd_get_poll_events( struct fd *fd );
 extern void default_poll_event( struct fd *fd, int event );
diff -ruN --show-c-function server/handle.c server/handle.c
--- server/handle.c	2025-10-10 10:17:47.802758721 -0700
+++ server/handle.c	2025-10-10 10:22:17.151411706 -0700
@@ -126,10 +126,10 @@ static const struct object_ops handle_ta
     no_add_queue,                    /* add_queue */
     NULL,                            /* remove_queue */
     NULL,                            /* signaled */
+    NULL,                            /* get_esync_fd */
     NULL,                            /* satisfied */
     no_signal,                       /* signal */
     no_get_fd,                       /* get_fd */
-    default_get_sync,                /* get_sync */
     default_map_access,              /* map_access */
     default_get_sd,                  /* get_sd */
     default_set_sd,                  /* set_sd */
diff -ruN --show-c-function server/hook.c server/hook.c
--- server/hook.c	2025-10-10 10:17:47.802758721 -0700
+++ server/hook.c	2025-10-10 10:22:17.151555779 -0700
@@ -58,6 +58,10 @@ struct hook
     data_size_t         module_size;
 };
 
+#define WH_WINEVENT (WH_MAXHOOK+1)
+
+#define NB_HOOKS (WH_WINEVENT-WH_MINHOOK+1)
+
 struct hook_table
 {
     struct object obj;              /* object header */
@@ -76,10 +80,10 @@ static const struct object_ops hook_tabl
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
-    default_get_sync,             /* get_sync */
     default_map_access,           /* map_access */
     default_get_sd,               /* get_sd */
     default_set_sd,               /* set_sd */
diff -ruN --show-c-function server/inproc_sync.c server/inproc_sync.c
--- server/inproc_sync.c	2025-10-10 10:17:48.598775739 -0700
+++ server/inproc_sync.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,307 +0,0 @@
-/*
- * In-process synchronization primitives
- *
- * Copyright (C) 2021-2022 Elizabeth Figura for CodeWeavers
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#include "config.h"
-
-#include <assert.h>
-#include <stdint.h>
-#include <stdio.h>
-
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#include "winternl.h"
-
-#include "file.h"
-#include "handle.h"
-#include "request.h"
-#include "thread.h"
-#include "user.h"
-
-#ifdef HAVE_LINUX_NTSYNC_H
-# include <linux/ntsync.h>
-#endif
-
-#ifdef NTSYNC_IOC_EVENT_READ
-
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/stat.h>
-#include <unistd.h>
-
-int get_inproc_device_fd(void)
-{
-    static int fd = -2;
-    if (fd == -2) fd = open( "/dev/ntsync", O_CLOEXEC | O_RDONLY );
-    return fd;
-}
-
-struct inproc_sync
-{
-    struct object          obj;  /* object header */
-    enum inproc_sync_type  type;
-    int                    fd;
-    struct list            entry;
-};
-
-static struct list inproc_mutexes = LIST_INIT( inproc_mutexes );
-
-static void inproc_sync_dump( struct object *obj, int verbose );
-static int inproc_sync_signal( struct object *obj, unsigned int access, int signal );
-static void inproc_sync_destroy( struct object *obj );
-
-static const struct object_ops inproc_sync_ops =
-{
-    sizeof(struct inproc_sync), /* size */
-    &no_type,                   /* type */
-    inproc_sync_dump,           /* dump */
-    no_add_queue,               /* add_queue */
-    NULL,                       /* remove_queue */
-    NULL,                       /* signaled */
-    NULL,                       /* satisfied */
-    inproc_sync_signal,         /* signal */
-    no_get_fd,                  /* get_fd */
-    default_get_sync,           /* get_sync */
-    default_map_access,         /* map_access */
-    default_get_sd,             /* get_sd */
-    default_set_sd,             /* set_sd */
-    default_get_full_name,      /* get_full_name */
-    no_lookup_name,             /* lookup_name */
-    directory_link_name,        /* link_name */
-    default_unlink_name,        /* unlink_name */
-    no_open_file,               /* open_file */
-    no_kernel_obj_list,         /* get_kernel_obj_list */
-    no_close_handle,            /* close_handle */
-    inproc_sync_destroy,        /* destroy */
-};
-
-int get_inproc_sync_fd( struct inproc_sync *sync )
-{
-    if (!sync) return -1;
-    return sync->fd;
-}
-
-struct inproc_sync *create_inproc_internal_sync( int manual, int signaled )
-{
-    struct ntsync_event_args args = {.signaled = signaled, .manual = manual};
-    struct inproc_sync *event;
-
-    if (!(event = alloc_object( &inproc_sync_ops ))) return NULL;
-    event->type = INPROC_SYNC_INTERNAL;
-    event->fd   = ioctl( get_inproc_device_fd(), NTSYNC_IOC_CREATE_EVENT, &args );
-    list_init( &event->entry );
-
-    if (event->fd == -1)
-    {
-        set_error( STATUS_TOO_MANY_OPENED_FILES );
-        release_object( event );
-        return NULL;
-    }
-    return event;
-}
-
-struct inproc_sync *create_inproc_event_sync( int manual, int signaled )
-{
-    struct ntsync_event_args args = {.signaled = signaled, .manual = manual};
-    struct inproc_sync *event;
-
-    if (!(event = alloc_object( &inproc_sync_ops ))) return NULL;
-    event->type = INPROC_SYNC_EVENT;
-    event->fd   = ioctl( get_inproc_device_fd(), NTSYNC_IOC_CREATE_EVENT, &args );
-    list_init( &event->entry );
-
-    if (event->fd == -1)
-    {
-        set_error( STATUS_NO_MORE_FILES );
-        release_object( event );
-        return NULL;
-    }
-    return event;
-}
-
-struct inproc_sync *create_inproc_mutex_sync( thread_id_t owner, unsigned int count )
-{
-    struct ntsync_mutex_args args = {.owner = owner, .count = count};
-    struct inproc_sync *mutex;
-
-    if (!(mutex = alloc_object( &inproc_sync_ops ))) return NULL;
-    mutex->type = INPROC_SYNC_MUTEX;
-    mutex->fd   = ioctl( get_inproc_device_fd(), NTSYNC_IOC_CREATE_MUTEX, &args );
-    list_add_tail( &inproc_mutexes, &mutex->entry );
-
-    if (mutex->fd == -1)
-    {
-        set_error( STATUS_NO_MORE_FILES );
-        release_object( mutex );
-        return NULL;
-    }
-    return mutex;
-}
-
-struct inproc_sync *create_inproc_semaphore_sync( unsigned int initial, unsigned int max )
-{
-    struct ntsync_sem_args args = {.count = initial, .max = max};
-    struct inproc_sync *sem;
-
-    if (!(sem = alloc_object( &inproc_sync_ops ))) return NULL;
-    sem->type = INPROC_SYNC_SEMAPHORE;
-    sem->fd   = ioctl( get_inproc_device_fd(), NTSYNC_IOC_CREATE_SEM, &args );
-    list_init( &sem->entry );
-
-    if (sem->fd == -1)
-    {
-        set_error( STATUS_NO_MORE_FILES );
-        release_object( sem );
-        return NULL;
-    }
-    return sem;
-}
-
-static void inproc_sync_dump( struct object *obj, int verbose )
-{
-    struct inproc_sync *sync = (struct inproc_sync *)obj;
-    assert( obj->ops == &inproc_sync_ops );
-    fprintf( stderr, "Inproc sync type=%d, fd=%d\n", sync->type, sync->fd );
-}
-
-void signal_inproc_sync( struct inproc_sync *sync )
-{
-    __u32 count;
-    if (debug_level) fprintf( stderr, "set_inproc_event %d\n", sync->fd );
-    ioctl( sync->fd, NTSYNC_IOC_EVENT_SET, &count );
-}
-
-void reset_inproc_sync( struct inproc_sync *sync )
-{
-    __u32 count;
-    if (debug_level) fprintf( stderr, "reset_inproc_event %d\n", sync->fd );
-    ioctl( sync->fd, NTSYNC_IOC_EVENT_RESET, &count );
-}
-
-static int inproc_sync_signal( struct object *obj, unsigned int access, int signal )
-{
-    struct inproc_sync *sync = (struct inproc_sync *)obj;
-    assert( obj->ops == &inproc_sync_ops );
-
-    assert( sync->type == INPROC_SYNC_INTERNAL || sync->type == INPROC_SYNC_EVENT ); /* never called for mutex / semaphore */
-    assert( signal == 0 || signal == 1 ); /* never called from signal_object */
-
-    if (signal) signal_inproc_sync( sync );
-    else reset_inproc_sync( sync );
-    return 1;
-}
-
-static void inproc_sync_destroy( struct object *obj )
-{
-    struct inproc_sync *sync = (struct inproc_sync *)obj;
-    assert( obj->ops == &inproc_sync_ops );
-    list_remove( &sync->entry );
-    close( sync->fd );
-}
-
-void abandon_inproc_mutexes( thread_id_t tid )
-{
-    struct inproc_sync *mutex;
-
-    LIST_FOR_EACH_ENTRY( mutex, &inproc_mutexes, struct inproc_sync, entry )
-        ioctl( mutex->fd, NTSYNC_IOC_MUTEX_KILL, &tid );
-}
-
-static int get_obj_inproc_sync( struct object *obj, int *type )
-{
-    struct object *sync;
-    int fd = -1;
-
-    if (!(sync = get_obj_sync( obj ))) return -1;
-    if (sync->ops == &inproc_sync_ops)
-    {
-        struct inproc_sync *inproc = (struct inproc_sync *)sync;
-        *type = inproc->type;
-        fd = inproc->fd;
-    }
-
-    release_object( sync );
-    return fd;
-}
-
-#else /* NTSYNC_IOC_EVENT_READ */
-
-int get_inproc_device_fd(void)
-{
-    return -1;
-}
-
-int get_inproc_sync_fd( struct inproc_sync *sync )
-{
-    return -1;
-}
-
-struct inproc_sync *create_inproc_internal_sync( int manual, int signaled )
-{
-    return NULL;
-}
-
-struct inproc_sync *create_inproc_event_sync( int manual, int signaled )
-{
-    return NULL;
-}
-
-struct inproc_sync *create_inproc_mutex_sync( thread_id_t owner, unsigned int count )
-{
-    return NULL;
-}
-
-struct inproc_sync *create_inproc_semaphore_sync( unsigned int initial, unsigned int max )
-{
-    return NULL;
-}
-
-void signal_inproc_sync( struct inproc_sync *sync )
-{
-}
-
-void reset_inproc_sync( struct inproc_sync *sync )
-{
-}
-
-void abandon_inproc_mutexes( thread_id_t tid )
-{
-}
-
-static int get_obj_inproc_sync( struct object *obj, int *type )
-{
-    return -1;
-}
-
-#endif /* NTSYNC_IOC_EVENT_READ */
-
-DECL_HANDLER(get_inproc_sync_fd)
-{
-    struct object *obj;
-    int fd;
-
-    if (!(obj = get_handle_obj( current->process, req->handle, 0, NULL ))) return;
-
-    reply->access = get_handle_access( current->process, req->handle );
-
-    if ((fd = get_obj_inproc_sync( obj, &reply->type )) < 0) set_error( STATUS_NOT_IMPLEMENTED );
-    else send_client_fd( current->process, fd, req->handle );
-
-    release_object( obj );
-}
diff -ruN --show-c-function server/mailslot.c server/mailslot.c
--- server/mailslot.c	2025-10-10 10:17:47.802758721 -0700
+++ server/mailslot.c	2025-10-10 10:22:17.151679333 -0700
@@ -79,13 +79,13 @@ static const struct object_ops mailslot_
     sizeof(struct mailslot),   /* size */
     &file_type,                /* type */
     mailslot_dump,             /* dump */
-    NULL,                      /* add_queue */
-    NULL,                      /* remove_queue */
-    NULL,                      /* signaled */
-    NULL,                      /* satisfied */
+    add_queue,                 /* add_queue */
+    remove_queue,              /* remove_queue */
+    default_fd_signaled,       /* signaled */
+    NULL,                      /* get_esync_fd */
+    no_satisfied,              /* satisfied */
     no_signal,                 /* signal */
     mailslot_get_fd,           /* get_fd */
-    default_fd_get_sync,       /* get_sync */
     mailslot_map_access,       /* map_access */
     default_get_sd,            /* get_sd */
     default_set_sd,            /* set_sd */
@@ -144,10 +144,10 @@ static const struct object_ops mail_writ
     no_add_queue,               /* add_queue */
     NULL,                       /* remove_queue */
     NULL,                       /* signaled */
+    NULL,                       /* get_esync_fd */
     NULL,                       /* satisfied */
     no_signal,                  /* signal */
     mail_writer_get_fd,         /* get_fd */
-    default_get_sync,           /* get_sync */
     mail_writer_map_access,     /* map_access */
     default_get_sd,             /* get_sd */
     default_set_sd,             /* set_sd */
@@ -210,10 +210,10 @@ static const struct object_ops mailslot_
     no_add_queue,                   /* add_queue */
     NULL,                           /* remove_queue */
     NULL,                           /* signaled */
+    NULL,                           /* get_esync_fd */
     no_satisfied,                   /* satisfied */
     no_signal,                      /* signal */
     no_get_fd,                      /* get_fd */
-    default_get_sync,               /* get_sync */
     default_map_access,             /* map_access */
     default_get_sd,                 /* get_sd */
     default_set_sd,                 /* set_sd */
@@ -238,13 +238,13 @@ static const struct object_ops mailslot_
     sizeof(struct mailslot_device_file),    /* size */
     &file_type,                             /* type */
     mailslot_device_file_dump,              /* dump */
-    NULL,                                   /* add_queue */
-    NULL,                                   /* remove_queue */
-    NULL,                                   /* signaled */
-    NULL,                                   /* satisfied */
+    add_queue,                              /* add_queue */
+    remove_queue,                           /* remove_queue */
+    default_fd_signaled,                    /* signaled */
+    NULL,                                   /* get_esync_fd */
+    no_satisfied,                           /* satisfied */
     no_signal,                              /* signal */
     mailslot_device_file_get_fd,            /* get_fd */
-    default_fd_get_sync,                    /* get_sync */
     default_map_access,                     /* map_access */
     default_get_sd,                         /* get_sd */
     default_set_sd,                         /* set_sd */
diff -ruN --show-c-function server/main.c server/main.c
--- server/main.c	2025-10-10 10:17:47.802758721 -0700
+++ server/main.c	2025-10-10 10:22:17.144599178 -0700
@@ -40,6 +40,7 @@
 #include "thread.h"
 #include "request.h"
 #include "unicode.h"
+#include "esync.h"
 
 /* command-line options */
 int debug_level = 0;
@@ -259,6 +260,9 @@ int main( int argc, char *argv[] )
     sock_init();
     open_master_socket();
 
+    if (do_esync())
+        esync_init();
+
     if (debug_level) fprintf( stderr, "wineserver: starting (pid=%ld)\n", (long) getpid() );
     set_current_time();
     init_signals();
diff -ruN --show-c-function server/main.c.orig server/main.c.orig
--- server/main.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ server/main.c.orig	2025-10-10 10:22:12.713275995 -0700
@@ -0,0 +1,271 @@
+/*
+ * Server main function
+ *
+ * Copyright (C) 1998 Alexandre Julliard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include <assert.h>
+#include <ctype.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <unistd.h>
+#ifdef HAVE_SYS_RESOURCE_H
+# include <sys/resource.h>
+#endif
+#ifdef HAVE_SYS_SYSCTL_H
+# include <sys/sysctl.h>
+#endif
+
+#include "object.h"
+#include "file.h"
+#include "thread.h"
+#include "request.h"
+#include "unicode.h"
+
+/* command-line options */
+int debug_level = 0;
+int foreground = 0;
+timeout_t master_socket_timeout = 3 * -TICKS_PER_SEC;  /* master socket timeout, default is 3 seconds */
+const char *server_argv0;
+
+/* parse-line args */
+
+static void usage( FILE *fh )
+{
+    fprintf(fh, "Usage: %s [options]\n\n", server_argv0);
+    fprintf(fh, "Options:\n");
+    fprintf(fh, "   -d[n], --debug[=n]       set debug level to n or +1 if n not specified\n");
+    fprintf(fh, "   -f,    --foreground      remain in the foreground for debugging\n");
+    fprintf(fh, "   -h,    --help            display this help message\n");
+    fprintf(fh, "   -k[n], --kill[=n]        kill the current wineserver, optionally with signal n\n");
+    fprintf(fh, "   -p[n], --persistent[=n]  make server persistent, optionally for n seconds\n");
+    fprintf(fh, "   -v,    --version         display version information and exit\n");
+    fprintf(fh, "   -w,    --wait            wait until the current wineserver terminates\n");
+    fprintf(fh, "\n");
+}
+
+static void option_callback( int optc, char *optarg )
+{
+    int ret;
+
+    switch (optc)
+    {
+    case 'd':
+        if (optarg && isdigit(*optarg))
+            debug_level = atoi( optarg );
+        else
+            debug_level++;
+        break;
+    case 'f':
+        foreground = 1;
+        break;
+    case 'h':
+        usage(stdout);
+        exit(0);
+        break;
+    case 'k':
+        if (optarg && isdigit(*optarg))
+            ret = kill_lock_owner( atoi( optarg ) );
+        else
+            ret = kill_lock_owner(-1);
+        exit( !ret );
+    case 'p':
+        if (optarg && isdigit(*optarg))
+            master_socket_timeout = (timeout_t)atoi( optarg ) * -TICKS_PER_SEC;
+        else
+            master_socket_timeout = TIMEOUT_INFINITE;
+        break;
+    case 'v':
+        fprintf( stderr, "%s\n", PACKAGE_STRING );
+        exit(0);
+    case 'w':
+        wait_for_lock();
+        exit(0);
+    }
+}
+
+/* command-line option parsing */
+/* partly based on the GLibc getopt() implementation */
+
+static struct long_option
+{
+    const char *name;
+    int has_arg;
+    int val;
+} long_options[] =
+{
+    {"debug",       2, 'd'},
+    {"foreground",  0, 'f'},
+    {"help",        0, 'h'},
+    {"kill",        2, 'k'},
+    {"persistent",  2, 'p'},
+    {"version",     0, 'v'},
+    {"wait",        0, 'w'},
+    { NULL }
+};
+
+static void parse_options( int argc, char **argv, const char *short_opts,
+                           const struct long_option *long_opts, void (*callback)( int, char* ) )
+{
+    const char *flag;
+    char *start, *end;
+    int i;
+
+    for (i = 1; i < argc; i++)
+    {
+        if (argv[i][0] != '-' || !argv[i][1])  /* not an option */
+            continue;
+        if (!strcmp( argv[i], "--" ))
+            break;
+        start = argv[i] + 1 + (argv[i][1] == '-');
+
+        if (argv[i][1] == '-')
+        {
+            /* handle long option */
+            const struct long_option *opt, *found = NULL;
+            int count = 0;
+
+            if (!(end = strchr( start, '=' ))) end = start + strlen(start);
+            for (opt = long_opts; opt && opt->name; opt++)
+            {
+                if (strncmp( opt->name, start, end - start )) continue;
+                if (!opt->name[end - start])  /* exact match */
+                {
+                    found = opt;
+                    count = 1;
+                    break;
+                }
+                if (!found)
+                {
+                    found = opt;
+                    count++;
+                }
+                else if (found->has_arg != opt->has_arg || found->val != opt->val)
+                {
+                    count++;
+                }
+            }
+
+            if (count > 1) goto error;
+
+            if (found)
+            {
+                if (*end)
+                {
+                    if (!found->has_arg) goto error;
+                    end++;  /* skip '=' */
+                }
+                else if (found->has_arg == 1)
+                {
+                    if (i == argc - 1) goto error;
+                    end = argv[++i];
+                }
+                else end = NULL;
+
+                callback( found->val, end );
+                continue;
+            }
+            goto error;
+        }
+
+        /* handle short option */
+        for ( ; *start; start++)
+        {
+            if (!(flag = strchr( short_opts, *start ))) goto error;
+            if (flag[1] == ':')
+            {
+                end = start + 1;
+                if (!*end) end = NULL;
+                if (flag[2] != ':' && !end)
+                {
+                    if (i == argc - 1) goto error;
+                    end = argv[++i];
+                }
+                callback( *start, end );
+                break;
+            }
+            callback( *start, NULL );
+        }
+    }
+    return;
+
+error:
+    usage( stderr );
+    exit(1);
+}
+
+static void sigterm_handler( int signum )
+{
+    exit(1);  /* make sure atexit functions get called */
+}
+
+static void init_limits(void)
+{
+#ifdef RLIMIT_NOFILE
+    struct rlimit rlimit;
+
+    if (!getrlimit( RLIMIT_NOFILE, &rlimit ))
+    {
+        rlimit.rlim_cur = rlimit.rlim_max;
+        if (!setrlimit( RLIMIT_NOFILE, &rlimit )) return;
+#ifdef __APPLE__
+        {
+            /* macOS before Big Sur fails if rlim_max is larger than maxfilesperproc */
+            unsigned int nlimit = 0;
+            size_t size = sizeof(nlimit);
+            sysctlbyname("kern.maxfilesperproc", &nlimit, &size, NULL, 0);
+            rlimit.rlim_cur = max( nlimit, OPEN_MAX );
+            setrlimit( RLIMIT_NOFILE, &rlimit );
+        }
+#endif
+    }
+#endif
+}
+
+int main( int argc, char *argv[] )
+{
+    setvbuf( stderr, NULL, _IOLBF, 0 );
+    server_argv0 = argv[0];
+    parse_options( argc, argv, "d::fhk::p::vw", long_options, option_callback );
+
+    /* setup temporary handlers before the real signal initialization is done */
+    signal( SIGPIPE, SIG_IGN );
+    signal( SIGHUP, sigterm_handler );
+    signal( SIGINT, sigterm_handler );
+    signal( SIGQUIT, sigterm_handler );
+    signal( SIGTERM, sigterm_handler );
+    signal( SIGABRT, sigterm_handler );
+    init_limits();
+
+    sock_init();
+    open_master_socket();
+
+    if (debug_level) fprintf( stderr, "wineserver: starting (pid=%ld)\n", (long) getpid() );
+    set_current_time();
+    init_signals();
+    init_memory();
+    init_directories( load_intl_file() );
+    init_threading();
+    init_registry();
+    main_loop();
+    return 0;
+}
diff -ruN --show-c-function server/Makefile.in server/Makefile.in
--- server/Makefile.in	2025-10-10 10:17:47.802394217 -0700
+++ server/Makefile.in	2025-10-10 10:22:17.144386324 -0700
@@ -12,12 +12,12 @@ SOURCES = \
 	debugger.c \
 	device.c \
 	directory.c \
+	esync.c \
 	event.c \
 	fd.c \
 	file.c \
 	handle.c \
 	hook.c \
-	inproc_sync.c \
 	mach.c \
 	mailslot.c \
 	main.c \
diff -ruN --show-c-function server/Makefile.in.orig server/Makefile.in.orig
--- server/Makefile.in.orig	1969-12-31 16:00:00.000000000 -0800
+++ server/Makefile.in.orig	2025-10-10 10:22:12.712194761 -0700
@@ -0,0 +1,55 @@
+PROGRAMS = wineserver
+
+SOURCES = \
+	async.c \
+	atom.c \
+	change.c \
+	class.c \
+	clipboard.c \
+	completion.c \
+	console.c \
+	d3dkmt.c \
+	debugger.c \
+	device.c \
+	directory.c \
+	event.c \
+	fd.c \
+	file.c \
+	handle.c \
+	hook.c \
+	inproc_sync.c \
+	mach.c \
+	mailslot.c \
+	main.c \
+	mapping.c \
+	mutex.c \
+	named_pipe.c \
+	object.c \
+	process.c \
+	procfs.c \
+	ptrace.c \
+	queue.c \
+	region.c \
+	registry.c \
+	request.c \
+	semaphore.c \
+	serial.c \
+	signal.c \
+	sock.c \
+	symlink.c \
+	thread.c \
+	timer.c \
+	token.c \
+	trace.c \
+	unicode.c \
+	user.c \
+	window.c \
+	wineserver.de.UTF-8.man.in \
+	wineserver.fr.UTF-8.man.in \
+	wineserver.man.in \
+	winstation.c
+
+UNIX_CFLAGS = $(INOTIFY_CFLAGS)
+UNIX_LIBS   = $(LDEXECFLAGS) $(RT_LIBS) $(INOTIFY_LIBS) $(PROCSTAT_LIBS)
+
+unicode_EXTRADEFS = -DBINDIR="\"${bindir}\"" -DDATADIR="\"${datadir}\""
diff -ruN --show-c-function server/mapping.c server/mapping.c
--- server/mapping.c	2025-10-10 10:17:48.598775739 -0700
+++ server/mapping.c	2025-10-10 10:22:17.151848384 -0700
@@ -67,10 +67,10 @@ static const struct object_ops ranges_op
     no_add_queue,              /* add_queue */
     NULL,                      /* remove_queue */
     NULL,                      /* signaled */
+    NULL,                      /* get_esync_fd */
     NULL,                      /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
-    default_get_sync,          /* get_sync */
     default_map_access,        /* map_access */
     default_get_sd,            /* get_sd */
     default_set_sd,            /* set_sd */
@@ -104,10 +104,10 @@ static const struct object_ops shared_ma
     no_add_queue,              /* add_queue */
     NULL,                      /* remove_queue */
     NULL,                      /* signaled */
+    NULL,                      /* get_esync_fd */
     NULL,                      /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
-    default_get_sync,          /* get_sync */
     default_map_access,        /* map_access */
     default_get_sd,            /* get_sd */
     default_set_sd,            /* set_sd */
@@ -178,10 +178,10 @@ static const struct object_ops mapping_o
     no_add_queue,                /* add_queue */
     NULL,                        /* remove_queue */
     NULL,                        /* signaled */
+    NULL,                        /* get_esync_fd */
     NULL,                        /* satisfied */
     no_signal,                   /* signal */
     mapping_get_fd,              /* get_fd */
-    default_get_sync,            /* get_sync */
     default_map_access,          /* map_access */
     default_get_sd,              /* get_sd */
     default_set_sd,              /* set_sd */
diff -ruN --show-c-function server/mutex.c server/mutex.c
--- server/mutex.c	2025-10-10 10:17:47.802758721 -0700
+++ server/mutex.c	2025-10-10 10:22:17.152019488 -0700
@@ -50,32 +50,33 @@ struct type_descr mutex_type =
     },
 };
 
-struct mutex_sync
+struct mutex
 {
-    struct object       obj;                /* object header */
-    struct thread      *owner;              /* mutex owner */
-    unsigned int        count;              /* recursion count */
-    int                 abandoned;          /* has it been abandoned? */
-    struct list         entry;              /* entry in owner thread mutex list */
+    struct object  obj;             /* object header */
+    struct thread *owner;           /* mutex owner */
+    unsigned int   count;           /* recursion count */
+    int            abandoned;       /* has it been abandoned? */
+    struct list    entry;           /* entry in owner thread mutex list */
 };
 
-static void mutex_sync_dump( struct object *obj, int verbose );
-static int mutex_sync_signaled( struct object *obj, struct wait_queue_entry *entry );
-static void mutex_sync_satisfied( struct object *obj, struct wait_queue_entry *entry );
-static void mutex_sync_destroy( struct object *obj );
-
-static const struct object_ops mutex_sync_ops =
-{
-    sizeof(struct mutex_sync), /* size */
-    &no_type,                  /* type */
-    mutex_sync_dump,           /* dump */
+static void mutex_dump( struct object *obj, int verbose );
+static int mutex_signaled( struct object *obj, struct wait_queue_entry *entry );
+static void mutex_satisfied( struct object *obj, struct wait_queue_entry *entry );
+static void mutex_destroy( struct object *obj );
+static int mutex_signal( struct object *obj, unsigned int access );
+
+static const struct object_ops mutex_ops =
+{
+    sizeof(struct mutex),      /* size */
+    &mutex_type,               /* type */
+    mutex_dump,                /* dump */
     add_queue,                 /* add_queue */
     remove_queue,              /* remove_queue */
-    mutex_sync_signaled,       /* signaled */
-    mutex_sync_satisfied,      /* satisfied */
-    no_signal,                 /* signal */
+    mutex_signaled,            /* signaled */
+    NULL,                      /* get_esync_fd */
+    mutex_satisfied,           /* satisfied */
+    mutex_signal,              /* signal */
     no_get_fd,                 /* get_fd */
-    default_get_sync,          /* get_sync */
     default_map_access,        /* map_access */
     default_get_sd,            /* get_sd */
     default_set_sd,            /* set_sd */
@@ -86,11 +87,12 @@ static const struct object_ops mutex_syn
     no_open_file,              /* open_file */
     no_kernel_obj_list,        /* get_kernel_obj_list */
     no_close_handle,           /* close_handle */
-    mutex_sync_destroy,        /* destroy */
+    mutex_destroy              /* destroy */
 };
 
+
 /* grab a mutex for a given thread */
-static void do_grab( struct mutex_sync *mutex, struct thread *thread )
+static void do_grab( struct mutex *mutex, struct thread *thread )
 {
     assert( !mutex->count || (mutex->owner == thread) );
 
@@ -104,106 +106,15 @@ static void do_grab( struct mutex_sync *
 }
 
 /* release a mutex once the recursion count is 0 */
-static int do_release( struct mutex_sync *mutex, struct thread *thread, int count )
-{
-    if (!mutex->count || (mutex->owner != thread))
-    {
-        set_error( STATUS_MUTANT_NOT_OWNED );
-        return 0;
-    }
-    if (!(mutex->count -= count))
-    {
-        /* remove the mutex from the thread list of owned mutexes */
-        list_remove( &mutex->entry );
-        mutex->owner = NULL;
-        wake_up( &mutex->obj, 0 );
-        release_object( mutex );
-    }
-    return 1;
-}
-
-static void mutex_sync_dump( struct object *obj, int verbose )
-{
-    struct mutex_sync *mutex = (struct mutex_sync *)obj;
-    assert( obj->ops == &mutex_sync_ops );
-    fprintf( stderr, "Mutex count=%u owner=%p\n", mutex->count, mutex->owner );
-}
-
-static void mutex_sync_destroy( struct object *obj )
+static void do_release( struct mutex *mutex )
 {
-    struct mutex_sync *mutex = (struct mutex_sync *)obj;
-    assert( obj->ops == &mutex_sync_ops );
     assert( !mutex->count );
-}
-
-static int mutex_sync_signaled( struct object *obj, struct wait_queue_entry *entry )
-{
-    struct mutex_sync *mutex = (struct mutex_sync *)obj;
-    assert( obj->ops == &mutex_sync_ops );
-    return (!mutex->count || (mutex->owner == get_wait_queue_thread( entry )));
-}
-
-static void mutex_sync_satisfied( struct object *obj, struct wait_queue_entry *entry )
-{
-    struct mutex_sync *mutex = (struct mutex_sync *)obj;
-    assert( obj->ops == &mutex_sync_ops );
-
-    do_grab( mutex, get_wait_queue_thread( entry ));
-    if (mutex->abandoned) make_wait_abandoned( entry );
-    mutex->abandoned = 0;
-}
-
-static struct object *create_mutex_sync( int owned )
-{
-    struct mutex_sync *mutex;
-
-    if (get_inproc_device_fd() >= 0) return (struct object *)create_inproc_mutex_sync( owned ? current->id : 0, owned ? 1 : 0 );
-
-    if (!(mutex = alloc_object( &mutex_sync_ops ))) return NULL;
-    mutex->count = 0;
+    /* remove the mutex from the thread list of owned mutexes */
+    list_remove( &mutex->entry );
     mutex->owner = NULL;
-    mutex->abandoned = 0;
-    if (owned) do_grab( mutex, current );
-
-    return &mutex->obj;
+    wake_up( &mutex->obj, 0 );
 }
 
-struct mutex
-{
-    struct object       obj;             /* object header */
-    struct object      *sync;            /* mutex sync object */
-};
-
-static void mutex_dump( struct object *obj, int verbose );
-static struct object *mutex_get_sync( struct object *obj );
-static int mutex_signal( struct object *obj, unsigned int access, int signal );
-static void mutex_destroy( struct object *obj );
-
-static const struct object_ops mutex_ops =
-{
-    sizeof(struct mutex),      /* size */
-    &mutex_type,               /* type */
-    mutex_dump,                /* dump */
-    NULL,                      /* add_queue */
-    NULL,                      /* remove_queue */
-    NULL,                      /* signaled */
-    NULL,                      /* satisfied */
-    mutex_signal,              /* signal */
-    no_get_fd,                 /* get_fd */
-    mutex_get_sync,            /* get_sync */
-    default_map_access,        /* map_access */
-    default_get_sd,            /* get_sd */
-    default_set_sd,            /* set_sd */
-    default_get_full_name,     /* get_full_name */
-    no_lookup_name,            /* lookup_name */
-    directory_link_name,       /* link_name */
-    default_unlink_name,       /* unlink_name */
-    no_open_file,              /* open_file */
-    no_kernel_obj_list,        /* get_kernel_obj_list */
-    no_close_handle,           /* close_handle */
-    mutex_destroy,             /* destroy */
-};
-
 static struct mutex *create_mutex( struct object *root, const struct unicode_str *name,
                                    unsigned int attr, int owned, const struct security_descriptor *sd )
 {
@@ -214,13 +125,10 @@ static struct mutex *create_mutex( struc
         if (get_error() != STATUS_OBJECT_NAME_EXISTS)
         {
             /* initialize it if it didn't already exist */
-            mutex->sync = NULL;
-
-            if (!(mutex->sync = create_mutex_sync( owned )))
-            {
-                release_object( mutex );
-                return NULL;
-            }
+            mutex->count = 0;
+            mutex->owner = NULL;
+            mutex->abandoned = 0;
+            if (owned) do_grab( mutex, current );
         }
     }
     return mutex;
@@ -232,50 +140,65 @@ void abandon_mutexes( struct thread *thr
 
     while ((ptr = list_head( &thread->mutex_list )) != NULL)
     {
-        struct mutex_sync *mutex = LIST_ENTRY( ptr, struct mutex_sync, entry );
+        struct mutex *mutex = LIST_ENTRY( ptr, struct mutex, entry );
         assert( mutex->owner == thread );
+        mutex->count = 0;
         mutex->abandoned = 1;
-        do_release( mutex, thread, mutex->count );
+        do_release( mutex );
     }
-
-    abandon_inproc_mutexes( thread->id );
 }
 
 static void mutex_dump( struct object *obj, int verbose )
 {
     struct mutex *mutex = (struct mutex *)obj;
     assert( obj->ops == &mutex_ops );
-    mutex->sync->ops->dump( mutex->sync, verbose );
+    fprintf( stderr, "Mutex count=%u owner=%p\n", mutex->count, mutex->owner );
 }
 
-static struct object *mutex_get_sync( struct object *obj )
+static int mutex_signaled( struct object *obj, struct wait_queue_entry *entry )
 {
     struct mutex *mutex = (struct mutex *)obj;
     assert( obj->ops == &mutex_ops );
-    return grab_object( mutex->sync );
+    return (!mutex->count || (mutex->owner == get_wait_queue_thread( entry )));
 }
 
-static int mutex_signal( struct object *obj, unsigned int access, int signal )
+static void mutex_satisfied( struct object *obj, struct wait_queue_entry *entry )
 {
     struct mutex *mutex = (struct mutex *)obj;
     assert( obj->ops == &mutex_ops );
 
-    assert( mutex->sync->ops == &mutex_sync_ops ); /* never called with inproc syncs */
-    assert( signal == -1 ); /* always called from signal_object */
+    do_grab( mutex, get_wait_queue_thread( entry ));
+    if (mutex->abandoned) make_wait_abandoned( entry );
+    mutex->abandoned = 0;
+}
+
+static int mutex_signal( struct object *obj, unsigned int access )
+{
+    struct mutex *mutex = (struct mutex *)obj;
+    assert( obj->ops == &mutex_ops );
 
     if (!(access & SYNCHRONIZE))
     {
         set_error( STATUS_ACCESS_DENIED );
         return 0;
     }
-    return do_release( (struct mutex_sync *)mutex->sync, current, 1 );
+    if (!mutex->count || (mutex->owner != current))
+    {
+        set_error( STATUS_MUTANT_NOT_OWNED );
+        return 0;
+    }
+    if (!--mutex->count) do_release( mutex );
+    return 1;
 }
 
 static void mutex_destroy( struct object *obj )
 {
     struct mutex *mutex = (struct mutex *)obj;
     assert( obj->ops == &mutex_ops );
-    if (mutex->sync) release_object( mutex->sync );
+
+    if (!mutex->count) return;
+    mutex->count = 0;
+    do_release( mutex );
 }
 
 /* create a mutex */
@@ -319,11 +242,12 @@ DECL_HANDLER(release_mutex)
     if ((mutex = (struct mutex *)get_handle_obj( current->process, req->handle,
                                                  0, &mutex_ops )))
     {
-        struct mutex_sync *sync = (struct mutex_sync *)mutex->sync;
-        assert( mutex->sync->ops == &mutex_sync_ops ); /* never called with inproc syncs */
-
-        reply->prev_count = sync->count;
-        do_release( sync, current, 1 );
+        if (!mutex->count || (mutex->owner != current)) set_error( STATUS_MUTANT_NOT_OWNED );
+        else
+        {
+            reply->prev_count = mutex->count;
+            if (!--mutex->count) do_release( mutex );
+        }
         release_object( mutex );
     }
 }
@@ -336,12 +260,9 @@ DECL_HANDLER(query_mutex)
     if ((mutex = (struct mutex *)get_handle_obj( current->process, req->handle,
                                                  MUTANT_QUERY_STATE, &mutex_ops )))
     {
-        struct mutex_sync *sync = (struct mutex_sync *)mutex->sync;
-        assert( mutex->sync->ops == &mutex_sync_ops ); /* never called with inproc syncs */
-
-        reply->count = sync->count;
-        reply->owned = (sync->owner == current);
-        reply->abandoned = sync->abandoned;
+        reply->count = mutex->count;
+        reply->owned = (mutex->owner == current);
+        reply->abandoned = mutex->abandoned;
 
         release_object( mutex );
     }
diff -ruN --show-c-function server/named_pipe.c server/named_pipe.c
--- server/named_pipe.c	2025-10-10 10:17:47.802758721 -0700
+++ server/named_pipe.c	2025-10-10 10:22:17.170967346 -0700
@@ -119,10 +119,10 @@ static const struct object_ops named_pip
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
-    default_get_sync,             /* get_sync */
     named_pipe_map_access,        /* map_access */
     default_get_sd,               /* get_sd */
     default_set_sd,               /* set_sd */
@@ -165,13 +165,13 @@ static const struct object_ops pipe_serv
     sizeof(struct pipe_server),   /* size */
     &file_type,                   /* type */
     pipe_server_dump,             /* dump */
-    NULL,                         /* add_queue */
-    NULL,                         /* remove_queue */
-    NULL,                         /* signaled */
-    NULL,                         /* satisfied */
+    add_queue,                    /* add_queue */
+    remove_queue,                 /* remove_queue */
+    default_fd_signaled,          /* signaled */
+    default_fd_get_esync_fd,      /* get_esync_fd */
+    no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     pipe_end_get_fd,              /* get_fd */
-    default_fd_get_sync,          /* get_sync */
     default_map_access,           /* map_access */
     pipe_end_get_sd,              /* get_sd */
     pipe_end_set_sd,              /* set_sd */
@@ -210,13 +210,13 @@ static const struct object_ops pipe_clie
     sizeof(struct pipe_end),      /* size */
     &file_type,                   /* type */
     pipe_client_dump,             /* dump */
-    NULL,                         /* add_queue */
-    NULL,                         /* remove_queue */
-    NULL,                         /* signaled */
-    NULL,                         /* satisfied */
+    add_queue,                    /* add_queue */
+    remove_queue,                 /* remove_queue */
+    default_fd_signaled,          /* signaled */
+    default_fd_get_esync_fd,      /* get_esync_fd */
+    no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     pipe_end_get_fd,              /* get_fd */
-    default_fd_get_sync,          /* get_sync */
     default_map_access,           /* map_access */
     pipe_end_get_sd,              /* get_sd */
     pipe_end_set_sd,              /* set_sd */
@@ -262,10 +262,10 @@ static const struct object_ops named_pip
     no_add_queue,                     /* add_queue */
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
+    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
-    default_get_sync,                 /* get_sync */
     default_map_access,               /* map_access */
     default_get_sd,                   /* get_sd */
     default_set_sd,                   /* set_sd */
@@ -291,13 +291,13 @@ static const struct object_ops named_pip
     sizeof(struct named_pipe_device_file),   /* size */
     &file_type,                              /* type */
     named_pipe_device_file_dump,             /* dump */
-    NULL,                                    /* add_queue */
-    NULL,                                    /* remove_queue */
-    NULL,                                    /* signaled */
-    NULL,                                    /* satisfied */
+    add_queue,                               /* add_queue */
+    remove_queue,                            /* remove_queue */
+    default_fd_signaled,                     /* signaled */
+    NULL,                                    /* get_esync_fd */
+    no_satisfied,                            /* satisfied */
     no_signal,                               /* signal */
     named_pipe_device_file_get_fd,           /* get_fd */
-    default_fd_get_sync,                     /* get_sync */
     default_map_access,                      /* map_access */
     default_get_sd,                          /* get_sd */
     default_set_sd,                          /* set_sd */
@@ -342,13 +342,13 @@ static const struct object_ops named_pip
     sizeof(struct named_pipe_device_file),   /* size */
     &file_type,                              /* type */
     named_pipe_dir_dump,                     /* dump */
-    NULL,                                    /* add_queue */
-    NULL,                                    /* remove_queue */
-    NULL,                                    /* signaled */
-    NULL,                                    /* satisfied */
+    add_queue,                               /* add_queue */
+    remove_queue,                            /* remove_queue */
+    default_fd_signaled,                     /* signaled */
+    NULL,                                    /* get_esync_fd */
+    no_satisfied,                            /* satisfied */
     no_signal,                               /* signal */
     named_pipe_dir_get_fd,                   /* get_fd */
-    default_fd_get_sync,                     /* get_sync */
     default_map_access,                      /* map_access */
     default_get_sd,                          /* get_sd */
     default_set_sd,                          /* set_sd */
diff -ruN --show-c-function server/object.c server/object.c
--- server/object.c	2025-10-10 10:17:47.802758721 -0700
+++ server/object.c	2025-10-10 10:22:17.152343833 -0700
@@ -109,10 +109,10 @@ static const struct object_ops apc_reser
     no_add_queue,               /* add_queue */
     NULL,                       /* remove_queue */
     NULL,                       /* signaled */
+    NULL,                       /* get_esync_fd */
     no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
-    default_get_sync,           /* get_sync */
     default_map_access,         /* map_access */
     default_get_sd,             /* get_sd */
     default_set_sd,             /* set_sd */
@@ -134,10 +134,10 @@ static const struct object_ops completio
     no_add_queue,              /* add_queue */
     NULL,                      /* remove_queue */
     NULL,                      /* signaled */
+    NULL,                      /* get_esync_fd */
     no_satisfied,              /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
-    default_get_sync,          /* get_sync */
     default_map_access,        /* map_access */
     default_get_sd,            /* get_sd */
     default_set_sd,            /* set_sd */
@@ -630,7 +630,7 @@ void no_satisfied( struct object *obj, s
 {
 }
 
-int no_signal( struct object *obj, unsigned int access, int signal )
+int no_signal( struct object *obj, unsigned int access )
 {
     set_error( STATUS_OBJECT_TYPE_MISMATCH );
     return 0;
@@ -642,11 +642,6 @@ struct fd *no_get_fd( struct object *obj
     return NULL;
 }
 
-struct object *default_get_sync( struct object *obj )
-{
-    return grab_object( obj );
-}
-
 unsigned int default_map_access( struct object *obj, unsigned int access )
 {
     return map_access( access, &obj->ops->type->mapping );
diff -ruN --show-c-function server/object.h server/object.h
--- server/object.h	2025-10-10 10:17:47.802758721 -0700
+++ server/object.h	2025-10-10 10:22:17.152489499 -0700
@@ -78,14 +78,14 @@ struct object_ops
     void (*remove_queue)(struct object *,struct wait_queue_entry *);
     /* is object signaled? */
     int  (*signaled)(struct object *,struct wait_queue_entry *);
+    /* return the esync fd for this object */
+    int (*get_esync_fd)(struct object *, enum esync_type *type);
     /* wait satisfied */
     void (*satisfied)(struct object *,struct wait_queue_entry *);
-    /* signal/reset an object */
-    int  (*signal)(struct object *,unsigned int,int);
+    /* signal an object */
+    int  (*signal)(struct object *, unsigned int);
     /* return an fd object that can be used to read/write from the object */
     struct fd *(*get_fd)(struct object *);
-    /* return a sync that can be used to wait/signal the object */
-    struct object *(*get_sync)(struct object *);
     /* map access rights to the specific rights for this object */
     unsigned int (*map_access)(struct object *, unsigned int);
     /* returns the security descriptor of the object */
@@ -170,10 +170,8 @@ extern struct object *find_object( const
 extern struct object *find_object_index( const struct namespace *namespace, unsigned int index );
 extern int no_add_queue( struct object *obj, struct wait_queue_entry *entry );
 extern void no_satisfied( struct object *obj, struct wait_queue_entry *entry );
-extern int no_signal( struct object *obj, unsigned int access, int signal );
+extern int no_signal( struct object *obj, unsigned int access );
 extern struct fd *no_get_fd( struct object *obj );
-extern struct object *default_get_sync( struct object *obj );
-static inline struct object *get_obj_sync( struct object *obj ) { return obj->ops->get_sync( obj ); }
 extern unsigned int default_map_access( struct object *obj, unsigned int access );
 extern struct security_descriptor *default_get_sd( struct object *obj );
 extern int default_set_sd( struct object *obj, const struct security_descriptor *sd, unsigned int set_info );
@@ -219,14 +217,8 @@ static inline void *mem_append( void *pt
 /* event functions */
 
 struct event;
-struct event_sync;
 struct keyed_event;
 
-extern struct event_sync *create_server_internal_sync( int manual, int signaled );
-extern struct object *create_internal_sync( int manual, int signaled );
-extern void signal_sync( struct object *sync );
-extern void reset_sync( struct object *sync );
-
 extern struct event *create_event( struct object *root, const struct unicode_str *name,
                                    unsigned int attr, int manual_reset, int initial_state,
                                    const struct security_descriptor *sd );
@@ -241,19 +233,6 @@ extern void reset_event( struct event *e
 
 extern void abandon_mutexes( struct thread *thread );
 
-/* in-process synchronization functions */
-
-struct inproc_sync;
-extern int get_inproc_device_fd(void);
-extern int get_inproc_sync_fd( struct inproc_sync *sync );
-extern struct inproc_sync *create_inproc_internal_sync( int manual, int signaled );
-extern struct inproc_sync *create_inproc_event_sync( int manual, int signaled );
-extern struct inproc_sync *create_inproc_semaphore_sync( unsigned int initial, unsigned int max );
-extern struct inproc_sync *create_inproc_mutex_sync( thread_id_t owner, unsigned int count );
-extern void abandon_inproc_mutexes( thread_id_t owner );
-extern void signal_inproc_sync( struct inproc_sync *sync );
-extern void reset_inproc_sync( struct inproc_sync *sync );
-
 /* serial functions */
 
 int get_serial_async_timeout(struct object *obj, int type, int count);
diff -ruN --show-c-function server/process.c server/process.c
--- server/process.c	2025-10-10 10:17:48.598775739 -0700
+++ server/process.c	2025-10-10 10:22:17.156227457 -0700
@@ -64,6 +64,7 @@
 #include "request.h"
 #include "user.h"
 #include "security.h"
+#include "esync.h"
 
 /* process object */
 
@@ -90,12 +91,13 @@ struct type_descr process_type =
 };
 
 static void process_dump( struct object *obj, int verbose );
-static struct object *process_get_sync( struct object *obj );
+static int process_signaled( struct object *obj, struct wait_queue_entry *entry );
 static unsigned int process_map_access( struct object *obj, unsigned int access );
 static struct security_descriptor *process_get_sd( struct object *obj );
 static void process_poll_event( struct fd *fd, int event );
 static struct list *process_get_kernel_obj_list( struct object *obj );
 static void process_destroy( struct object *obj );
+static int process_get_esync_fd( struct object *obj, enum esync_type *type );
 static void terminate_process( struct process *process, struct thread *skip, int exit_code );
 
 static const struct object_ops process_ops =
@@ -103,13 +105,13 @@ static const struct object_ops process_o
     sizeof(struct process),      /* size */
     &process_type,               /* type */
     process_dump,                /* dump */
-    NULL,                        /* add_queue */
-    NULL,                        /* remove_queue */
-    NULL,                        /* signaled */
-    NULL,                        /* satisfied */
+    add_queue,                   /* add_queue */
+    remove_queue,                /* remove_queue */
+    process_signaled,            /* signaled */
+    process_get_esync_fd,        /* get_esync_fd */
+    no_satisfied,                /* satisfied */
     no_signal,                   /* signal */
     no_get_fd,                   /* get_fd */
-    process_get_sync,            /* get_sync */
     process_map_access,          /* map_access */
     process_get_sd,              /* get_sd */
     default_set_sd,              /* set_sd */
@@ -139,16 +141,15 @@ static const struct fd_ops process_fd_op
 
 struct startup_info
 {
-    struct object               obj;            /* object header */
-    struct object              *sync;           /* sync object for wait/signal */
-    struct process             *process;        /* created process */
-    data_size_t                 info_size;      /* size of startup info */
-    data_size_t                 data_size;      /* size of whole startup data */
-    struct startup_info_data   *data;           /* data for startup info */
+    struct object       obj;          /* object header */
+    struct process     *process;      /* created process */
+    data_size_t         info_size;    /* size of startup info */
+    data_size_t         data_size;    /* size of whole startup data */
+    struct startup_info_data *data;   /* data for startup info */
 };
 
 static void startup_info_dump( struct object *obj, int verbose );
-static struct object *startup_info_get_sync( struct object *obj );
+static int startup_info_signaled( struct object *obj, struct wait_queue_entry *entry );
 static void startup_info_destroy( struct object *obj );
 
 static const struct object_ops startup_info_ops =
@@ -156,13 +157,13 @@ static const struct object_ops startup_i
     sizeof(struct startup_info),   /* size */
     &no_type,                      /* type */
     startup_info_dump,             /* dump */
-    NULL,                          /* add_queue */
-    NULL,                          /* remove_queue */
-    NULL,                          /* signaled */
-    NULL,                          /* satisfied */
+    add_queue,                     /* add_queue */
+    remove_queue,                  /* remove_queue */
+    startup_info_signaled,         /* signaled */
+    NULL,                          /* get_esync_fd */
+    no_satisfied,                  /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
-    startup_info_get_sync,         /* get_sync */
     default_map_access,            /* map_access */
     default_get_sd,                /* get_sd */
     default_set_sd,                /* set_sd */
@@ -193,24 +194,24 @@ struct type_descr job_type =
 };
 
 static void job_dump( struct object *obj, int verbose );
-static struct object *job_get_sync( struct object *obj );
+static int job_signaled( struct object *obj, struct wait_queue_entry *entry );
 static int job_close_handle( struct object *obj, struct process *process, obj_handle_t handle );
 static void job_destroy( struct object *obj );
 
 struct job
 {
-    struct object        obj;               /* object header */
-    struct object       *sync;              /* sync object for wait/signal */
-    struct list          process_list;      /* list of processes */
-    int                  num_processes;     /* count of running processes */
-    int                  total_processes;   /* count of processes which have been assigned */
-    unsigned int         limit_flags;       /* limit flags */
-    int                  terminating;       /* job is terminating */
-    struct completion   *completion_port;   /* associated completion port */
-    apc_param_t          completion_key;    /* key to send with completion messages */
-    struct job          *parent;
-    struct list          parent_job_entry;  /* list entry for parent job */
-    struct list          child_job_list;    /* list of child jobs */
+    struct object obj;             /* object header */
+    struct list process_list;      /* list of processes */
+    int num_processes;             /* count of running processes */
+    int total_processes;           /* count of processes which have been assigned */
+    unsigned int limit_flags;      /* limit flags */
+    int terminating;               /* job is terminating */
+    int signaled;                  /* job is signaled */
+    struct completion *completion_port; /* associated completion port */
+    apc_param_t completion_key;    /* key to send with completion messages */
+    struct job *parent;
+    struct list parent_job_entry;  /* list entry for parent job */
+    struct list child_job_list;    /* list of child jobs */
 };
 
 static const struct object_ops job_ops =
@@ -218,13 +219,13 @@ static const struct object_ops job_ops =
     sizeof(struct job),            /* size */
     &job_type,                     /* type */
     job_dump,                      /* dump */
-    NULL,                          /* add_queue */
-    NULL,                          /* remove_queue */
-    NULL,                          /* signaled */
-    NULL,                          /* satisfied */
+    add_queue,                     /* add_queue */
+    remove_queue,                  /* remove_queue */
+    job_signaled,                  /* signaled */
+    NULL,                          /* get_esync_fd */
+    no_satisfied,                  /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
-    job_get_sync,                  /* get_sync */
     default_map_access,            /* map_access */
     default_get_sd,                /* get_sd */
     default_set_sd,                /* set_sd */
@@ -248,22 +249,16 @@ static struct job *create_job_object( st
         if (get_error() != STATUS_OBJECT_NAME_EXISTS)
         {
             /* initialize it if it didn't already exist */
-            job->sync = NULL;
             list_init( &job->process_list );
             list_init( &job->child_job_list );
             job->num_processes = 0;
             job->total_processes = 0;
             job->limit_flags = 0;
             job->terminating = 0;
+            job->signaled = 0;
             job->completion_port = NULL;
             job->completion_key = 0;
             job->parent = NULL;
-
-            if (!(job->sync = create_internal_sync( 1, 0 )))
-            {
-                release_object( job );
-                return NULL;
-            }
         }
     }
     return job;
@@ -418,7 +413,8 @@ static void terminate_job( struct job *j
         if (process->running_threads) terminate_process( process, NULL, exit_code );
     }
     job->terminating = 0;
-    signal_sync( job->sync );
+    job->signaled = 1;
+    wake_up( &job->obj, 0 );
 }
 
 static int job_close_handle( struct object *obj, struct process *process, obj_handle_t handle )
@@ -449,8 +445,6 @@ static void job_destroy( struct object *
         list_remove( &job->parent_job_entry );
         release_object( job->parent );
     }
-
-    if (job->sync) release_object( job->sync );
 }
 
 static void job_dump( struct object *obj, int verbose )
@@ -461,11 +455,10 @@ static void job_dump( struct object *obj
              list_count(&job->process_list), list_count(&job->child_job_list), job->parent );
 }
 
-static struct object *job_get_sync( struct object *obj )
+static int job_signaled( struct object *obj, struct wait_queue_entry *entry )
 {
     struct job *job = (struct job *)obj;
-    assert( obj->ops == &job_ops );
-    return grab_object( job->sync );
+    return job->signaled;
 }
 
 struct ptid_entry
@@ -564,7 +557,7 @@ static void set_process_startup_state( s
     if (process->startup_state == STARTUP_IN_PROGRESS) process->startup_state = state;
     if (process->startup_info)
     {
-        signal_sync( process->startup_info->sync );
+        wake_up( &process->startup_info->obj, 0 );
         release_object( process->startup_info );
         process->startup_info = NULL;
     }
@@ -663,7 +656,6 @@ struct process *create_process( int fd,
         close( fd );
         goto error;
     }
-    process->sync            = NULL;
     process->parent_id       = 0;
     process->debug_obj       = NULL;
     process->debug_event     = NULL;
@@ -701,6 +693,7 @@ struct process *create_process( int fd,
     process->rawinput_kbd    = NULL;
     memset( &process->image_info, 0, sizeof(process->image_info) );
     list_init( &process->rawinput_entry );
+    process->esync_fd        = -1;
     list_init( &process->kernel_object );
     list_init( &process->thread_list );
     list_init( &process->locks );
@@ -722,7 +715,6 @@ struct process *create_process( int fd,
         goto error;
     }
     if (!(process->msg_fd = create_anonymous_fd( &process_fd_ops, fd, &process->obj, 0 ))) goto error;
-    if (!(process->sync = create_internal_sync( 1, 0 ))) goto error;
 
     /* create the handle table */
     if (!parent)
@@ -752,6 +744,9 @@ struct process *create_process( int fd,
     if (!process->handles || !process->token) goto error;
     process->session_id = token_get_session_id( process->token );
 
+    if (do_esync())
+        process->esync_fd = esync_create_fd( 0, 0 );
+
     set_fd_events( process->msg_fd, POLLIN );  /* start listening to events */
     return process;
 
@@ -796,11 +791,11 @@ static void process_destroy( struct obje
     if (process->idle_event) release_object( process->idle_event );
     if (process->id) free_ptid( process->id );
     if (process->token) release_object( process->token );
-    if (process->sync) release_object( process->sync );
     list_remove( &process->rawinput_entry );
     free( process->rawinput_devices );
     free( process->dir_cache );
     free( process->image );
+    if (do_esync()) close( process->esync_fd );
 }
 
 /* dump a process on stdout for debugging purposes */
@@ -812,11 +807,17 @@ static void process_dump( struct object
     fprintf( stderr, "Process id=%04x handles=%p\n", process->id, process->handles );
 }
 
-static struct object *process_get_sync( struct object *obj )
+static int process_signaled( struct object *obj, struct wait_queue_entry *entry )
 {
     struct process *process = (struct process *)obj;
-    assert( obj->ops == &process_ops );
-    return grab_object( process->sync );
+    return !process->running_threads;
+}
+
+static int process_get_esync_fd( struct object *obj, enum esync_type *type )
+{
+    struct process *process = (struct process *)obj;
+    *type = ESYNC_MANUAL_SERVER;
+    return process->esync_fd;
 }
 
 static unsigned int process_map_access( struct object *obj, unsigned int access )
@@ -889,7 +890,6 @@ static void startup_info_destroy( struct
     assert( obj->ops == &startup_info_ops );
     free( info->data );
     if (info->process) release_object( info->process );
-    if (info->sync) release_object( info->sync );
 }
 
 static void startup_info_dump( struct object *obj, int verbose )
@@ -904,11 +904,10 @@ static void startup_info_dump( struct ob
     fputc( '\n', stderr );
 }
 
-static struct object *startup_info_get_sync( struct object *obj )
+static int startup_info_signaled( struct object *obj, struct wait_queue_entry *entry )
 {
     struct startup_info *info = (struct startup_info *)obj;
-    assert( obj->ops == &startup_info_ops );
-    return grab_object( info->sync );
+    return info->process && info->process->startup_state != STARTUP_IN_PROGRESS;
 }
 
 /* get a process from an id (and increment the refcount) */
@@ -1000,7 +999,7 @@ static void process_killed( struct proce
     finish_process_tracing( process );
     release_job_process( process );
     start_sigkill_timer( process );
-    signal_sync( process->sync );
+    wake_up( &process->obj, 0 );
 }
 
 /* add a thread to a process running threads list */
@@ -1218,16 +1217,9 @@ DECL_HANDLER(new_process)
         release_object( parent );
         return;
     }
-    info->sync     = NULL;
     info->process  = NULL;
     info->data     = NULL;
 
-    if (!(info->sync = create_internal_sync( 1, 0 )))
-    {
-        close( socket_fd );
-        goto done;
-    }
-
     info_ptr = get_req_data_after_objattr( objattr, &info->data_size );
 
     if ((req->handles_size & 3) || req->handles_size > info->data_size)
diff -ruN --show-c-function server/process.h server/process.h
--- server/process.h	2025-10-10 10:17:47.802758721 -0700
+++ server/process.h	2025-10-10 10:22:17.156366426 -0700
@@ -36,7 +36,6 @@ enum startup_state { STARTUP_IN_PROGRESS
 struct process
 {
     struct object        obj;             /* object header */
-    struct object       *sync;            /* sync object for wait/signal */
     struct list          entry;           /* entry in system-wide process list */
     process_id_t         parent_id;       /* parent process id (at the time of creation) */
     struct list          thread_list;     /* thread list */
@@ -88,6 +87,7 @@ struct process
     struct list          rawinput_entry;  /* entry in the rawinput process list */
     struct list          kernel_object;   /* list of kernel object pointers */
     struct pe_image_info image_info;      /* main exe image info */
+    int                  esync_fd;        /* esync file descriptor (signaled on exit) */
 };
 
 /* process functions */
diff -ruN --show-c-function server/protocol.def server/protocol.def
--- server/protocol.def	2025-10-10 10:17:48.598775739 -0700
+++ server/protocol.def	2025-10-10 10:22:17.166222829 -0700
@@ -990,8 +990,6 @@ struct obj_locator
 };
 
 #define MAX_ATOM_LEN     255
-#define WH_WINEVENT      (WH_MAXHOOK + 1)
-#define NB_HOOKS         (WH_WINEVENT - WH_MINHOOK + 1)
 
 struct shared_cursor
 {
@@ -1012,13 +1010,11 @@ typedef volatile struct
 
 typedef volatile struct
 {
-    timeout_t            access_time;      /* last time the queue was accessed */
+    int                  hooks_count[WH_MAX - WH_MIN + 2]; /* active hooks count */
     unsigned int         wake_mask;        /* wakeup mask */
     unsigned int         wake_bits;        /* wakeup bits */
     unsigned int         changed_mask;     /* changed wakeup mask */
     unsigned int         changed_bits;     /* changed wakeup bits */
-    unsigned int         internal_bits;    /* internal queue bits */
-    int                  hooks_count[NB_HOOKS];  /* active hooks count */
 } queue_shm_t;
 
 typedef volatile struct
@@ -1152,7 +1148,6 @@ typedef volatile struct
     thread_id_t  tid;          /* thread id of the new thread */
     timeout_t    server_start; /* server start time */
     unsigned int session_id;   /* process session id */
-    obj_handle_t inproc_device;/* inproc device fd in flight with this handle */
     data_size_t  info_size;    /* total size of startup info */
     VARARG(machines,ushorts);  /* array of supported machines */
 @END
@@ -2302,7 +2297,7 @@ struct process_info
 @REQ(set_queue_mask)
     unsigned int wake_mask;    /* wakeup bits mask */
     unsigned int changed_mask; /* changed bits mask */
-    int          poll_events;  /* whether to poll queue fd */
+    int          skip_wait;    /* will we skip waiting if signaled? */
 @REPLY
     unsigned int wake_bits;    /* current wake bits */
     unsigned int changed_bits; /* current changed bits */
@@ -4108,7 +4103,7 @@ struct handle_info
     obj_handle_t handle;       /* process handle */
 @END
 
-/* Iterate processes using global process list */
+/* Itererate processes using global process list */
 @REQ(get_next_process)
     obj_handle_t last;         /* process handle to start with */
     unsigned int access;       /* desired access for returned handle */
@@ -4129,39 +4124,61 @@ struct handle_info
     obj_handle_t handle;       /* next thread handle */
 @END
 
+enum esync_type
+{
+    ESYNC_SEMAPHORE = 1,
+    ESYNC_AUTO_EVENT,
+    ESYNC_MANUAL_EVENT,
+    ESYNC_MUTEX,
+    ESYNC_AUTO_SERVER,
+    ESYNC_MANUAL_SERVER,
+    ESYNC_QUEUE,
+};
 
-/* Setup keyboard auto-repeat */
-@REQ(set_keyboard_repeat)
-    int enable;                /* whether to enable auto-repeat */
-    int delay;                 /* auto-repeat delay in ms */
-    int period;                /* auto-repeat period in ms */
+/* Create a new eventfd-based synchronization object */
+@REQ(create_esync)
+    unsigned int access;        /* wanted access rights */
+    int          initval;       /* initial value */
+    int          type;          /* type of esync object */
+    int          max;           /* maximum count on a semaphore */
+    VARARG(objattr,object_attributes); /* object attributes */
 @REPLY
-    int enable;                /* previous state of auto-repeat enable */
+    obj_handle_t handle;        /* handle to the object */
+    int          type;          /* actual type (may be different for events) */
+    unsigned int shm_idx;
 @END
 
+@REQ(open_esync)
+    unsigned int access;        /* wanted access rights */
+    unsigned int attributes;    /* object attributes */
+    obj_handle_t rootdir;       /* root directory */
+    int          type;          /* type of esync object (above) */
+    VARARG(name,unicode_str);   /* object name */
+@REPLY
+    obj_handle_t handle;        /* handle to the event */
+    int          type;          /* type of esync object (above) */
+    unsigned int shm_idx;       /* this object's index into the shm section */
+@END
 
-enum inproc_sync_type
-{
-    INPROC_SYNC_UNKNOWN   = 0,
-    INPROC_SYNC_INTERNAL  = 1,
-    INPROC_SYNC_EVENT     = 2,
-    INPROC_SYNC_MUTEX     = 3,
-    INPROC_SYNC_SEMAPHORE = 4,
-};
-
-/* Get the in-process synchronization fd associated with the waitable handle */
-@REQ(get_inproc_sync_fd)
+/* Retrieve the esync fd for an object. */
+@REQ(get_esync_fd)
     obj_handle_t handle;        /* handle to the object */
 @REPLY
-    int           type;         /* inproc sync type */
-    unsigned int access;        /* handle access rights */
+    int          type;
+    unsigned int shm_idx;
 @END
 
+@REQ(esync_msgwait)
+    int          in_msgwait;    /* are we in a message wait? */
+@END
 
-/* Get the in-process synchronization fd for the current thread user APC alerts */
-@REQ(get_inproc_alert_fd)
+/* Setup keyboard auto-repeat */
+@REQ(set_keyboard_repeat)
+    int enable;                /* whether to enable auto-repeat */
+    int delay;                 /* auto-repeat delay in ms */
+    int period;                /* auto-repeat period in ms */
 @REPLY
-    obj_handle_t handle;        /* alert fd is in flight with this handle */
+    int enable;                /* previous state of auto-repeat enable */
 @END
 
 
@@ -4220,3 +4237,7 @@ enum inproc_sync_type
 @REPLY
     obj_handle_t        handle;         /* shared object handle */
 @END
+
+/* Retrieve the fd to wait on for user APCs. */
+@REQ(get_esync_apc_fd)
+@END
diff -ruN --show-c-function server/queue.c server/queue.c
--- server/queue.c	2025-10-10 10:17:48.599775761 -0700
+++ server/queue.c	2025-10-10 10:22:17.159847221 -0700
@@ -45,10 +45,7 @@
 #include "process.h"
 #include "request.h"
 #include "user.h"
-
-#define QS_DRIVER       0x80000000
-#define QS_HARDWARE     0x40000000
-#define QS_INTERNAL     (QS_DRIVER | QS_HARDWARE)
+#include "esync.h"
 
 #define WM_NCMOUSEFIRST WM_NCMOUSEMOVE
 #define WM_NCMOUSELAST  (WM_NCMOUSEFIRST+(WM_MOUSELAST-WM_MOUSEFIRST))
@@ -120,7 +117,6 @@ struct msg_queue
 {
     struct object          obj;             /* object header */
     struct fd             *fd;              /* optional file descriptor to poll */
-    struct object         *sync;            /* sync object for wait/signal */
     int                    paint_count;     /* pending paint messages count */
     int                    hotkey_count;    /* pending hotkey messages count */
     int                    quit_message;    /* is there a pending quit message? */
@@ -136,8 +132,11 @@ struct msg_queue
     struct timeout_user   *timeout;         /* timeout for next timer to expire */
     struct thread_input   *input;           /* thread input descriptor */
     struct hook_table     *hooks;           /* hook table */
+    timeout_t              last_get_msg;    /* time of last get message call */
     int                    keystate_lock;   /* owns an input keystate lock */
     queue_shm_t           *shared;          /* queue in session shared memory */
+    int                    esync_fd;        /* esync file descriptor (signalled on message) */
+    int                    esync_in_msgwait; /* our thread is currently waiting on us */
 };
 
 struct hotkey
@@ -151,7 +150,11 @@ struct hotkey
 };
 
 static void msg_queue_dump( struct object *obj, int verbose );
-static struct object *msg_queue_get_sync( struct object *obj );
+static int msg_queue_add_queue( struct object *obj, struct wait_queue_entry *entry );
+static void msg_queue_remove_queue( struct object *obj, struct wait_queue_entry *entry );
+static int msg_queue_signaled( struct object *obj, struct wait_queue_entry *entry );
+static int msg_queue_get_esync_fd( struct object *obj, enum esync_type *type );
+static void msg_queue_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static void msg_queue_destroy( struct object *obj );
 static void msg_queue_poll_event( struct fd *fd, int event );
 static void thread_input_dump( struct object *obj, int verbose );
@@ -163,13 +166,13 @@ static const struct object_ops msg_queue
     sizeof(struct msg_queue),  /* size */
     &no_type,                  /* type */
     msg_queue_dump,            /* dump */
-    NULL,                      /* add_queue */
-    NULL,                      /* remove_queue */
-    NULL,                      /* signaled */
-    NULL,                      /* satisfied */
+    msg_queue_add_queue,       /* add_queue */
+    msg_queue_remove_queue,    /* remove_queue */
+    msg_queue_signaled,        /* signaled */
+    msg_queue_get_esync_fd,    /* get_esync_fd */
+    msg_queue_satisfied,       /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
-    msg_queue_get_sync,        /* get_sync */
     default_map_access,        /* map_access */
     default_get_sd,            /* get_sd */
     default_set_sd,            /* set_sd */
@@ -204,10 +207,10 @@ static const struct object_ops thread_in
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
-    default_get_sync,             /* get_sync */
     default_map_access,           /* map_access */
     default_get_sd,               /* get_sd */
     default_set_sd,               /* set_sd */
@@ -306,7 +309,6 @@ static struct msg_queue *create_msg_queu
     if ((queue = alloc_object( &msg_queue_ops )))
     {
         queue->fd              = NULL;
-        queue->sync            = NULL;
         queue->paint_count     = 0;
         queue->hotkey_count    = 0;
         queue->quit_message    = 0;
@@ -316,28 +318,35 @@ static struct msg_queue *create_msg_queu
         queue->timeout         = NULL;
         queue->input           = (struct thread_input *)grab_object( input );
         queue->hooks           = NULL;
+        queue->last_get_msg    = current_time;
         queue->keystate_lock   = 0;
+        queue->esync_fd        = -1;
+        queue->esync_in_msgwait = 0;
         list_init( &queue->send_result );
         list_init( &queue->callback_result );
         list_init( &queue->pending_timers );
         list_init( &queue->expired_timers );
         for (i = 0; i < NB_MSG_KINDS; i++) list_init( &queue->msg_list[i] );
 
-        if (!(queue->sync = create_internal_sync( 1, 0 ))) goto error;
-        if (!(queue->shared = alloc_shared_object())) goto error;
+        if (!(queue->shared = alloc_shared_object()))
+        {
+            release_object( queue );
+            return NULL;
+        }
 
         SHARED_WRITE_BEGIN( queue->shared, queue_shm_t )
         {
             memset( (void *)shared->hooks_count, 0, sizeof(shared->hooks_count) );
-            shared->access_time = monotonic_time;
             shared->wake_mask = 0;
             shared->wake_bits = 0;
             shared->changed_mask = 0;
             shared->changed_bits = 0;
-            shared->internal_bits = 0;
         }
         SHARED_WRITE_END;
 
+        if (do_esync())
+            queue->esync_fd = esync_create_fd( 0, 0 );
+
         thread->queue = queue;
 
         if ((desktop = get_thread_desktop( thread, 0 )))
@@ -348,10 +357,6 @@ static struct msg_queue *create_msg_queu
     }
     if (new_input) release_object( new_input );
     return queue;
-
-error:
-    release_object( queue );
-    return NULL;
 }
 
 /* free the message queue of a thread at thread exit */
@@ -712,22 +717,18 @@ void add_queue_hook_count( struct thread
 }
 
 /* check the queue status */
-static inline int get_queue_status( struct msg_queue *queue )
+static inline int is_signaled( struct msg_queue *queue )
 {
     queue_shm_t *queue_shm = queue->shared;
     return (queue_shm->wake_bits & queue_shm->wake_mask) ||
-           (queue_shm->changed_bits & queue_shm->changed_mask) ||
-            queue_shm->internal_bits;
+           (queue_shm->changed_bits & queue_shm->changed_mask);
 }
 
 /* set some queue bits */
 static inline void set_queue_bits( struct msg_queue *queue, unsigned int bits )
 {
     queue_shm_t *queue_shm = queue->shared;
-    unsigned int internal = bits & QS_INTERNAL;
-    bits &= ~QS_INTERNAL;
 
-    /* lock the key state on key press, including from hardware messages */
     if (bits & (QS_KEY | QS_MOUSEBUTTON))
     {
         if (!queue->keystate_lock) lock_input_keystate( queue->input );
@@ -738,36 +739,32 @@ static inline void set_queue_bits( struc
     {
         shared->wake_bits |= bits;
         shared->changed_bits |= bits;
-        shared->internal_bits |= internal;
     }
     SHARED_WRITE_END;
 
-    if (get_queue_status( queue )) signal_sync( queue->sync );
+    if (is_signaled( queue )) wake_up( &queue->obj, 0 );
 }
 
 /* clear some queue bits */
 static inline void clear_queue_bits( struct msg_queue *queue, unsigned int bits )
 {
     queue_shm_t *queue_shm = queue->shared;
-    unsigned int internal = bits & QS_INTERNAL;
-    bits &= ~QS_INTERNAL;
 
     SHARED_WRITE_BEGIN( queue_shm, queue_shm_t )
     {
         shared->wake_bits &= ~bits;
         shared->changed_bits &= ~bits;
-        shared->internal_bits &= ~internal;
-        bits = shared->wake_bits;
     }
     SHARED_WRITE_END;
 
-    /* release the keystate lock when last key message has been processed */
-    if (!internal && !(bits & (QS_KEY | QS_MOUSEBUTTON)))
+    if (!(queue_shm->wake_bits & (QS_KEY | QS_MOUSEBUTTON)))
     {
         if (queue->keystate_lock) unlock_input_keystate( queue->input );
         queue->keystate_lock = 0;
     }
-    if (!get_queue_status( queue )) reset_sync( queue->sync );
+
+    if (do_esync() && !is_signaled( queue ))
+        esync_clear( queue->esync_fd );
 }
 
 /* check if message is matched by the filter */
@@ -1277,15 +1274,47 @@ static void cleanup_results( struct msg_
 /* check if the thread owning the queue is hung (not checking for messages) */
 static int is_queue_hung( struct msg_queue *queue )
 {
-    /* queue is hung if it's signaled and thread didn't access it for more than 5 seconds */
-    return get_queue_status( queue ) && monotonic_time - queue->shared->access_time > 5 * TICKS_PER_SEC;
+    struct wait_queue_entry *entry;
+
+    if (current_time - queue->last_get_msg <= 5 * TICKS_PER_SEC)
+        return 0;  /* less than 5 seconds since last get message -> not hung */
+
+    LIST_FOR_EACH_ENTRY( entry, &queue->obj.wait_queue, struct wait_queue_entry, entry )
+    {
+        if (get_wait_queue_thread(entry)->queue == queue)
+            return 0;  /* thread is waiting on queue -> not hung */
+    }
+
+    if (do_esync() && queue->esync_in_msgwait)
+        return 0;   /* thread is waiting on queue in absentia -> not hung */
+
+    return 1;
+}
+
+static int msg_queue_add_queue( struct object *obj, struct wait_queue_entry *entry )
+{
+    struct msg_queue *queue = (struct msg_queue *)obj;
+
+    /* a thread can only wait on its own queue */
+    if (get_wait_queue_thread(entry)->queue != queue)
+    {
+        set_error( STATUS_ACCESS_DENIED );
+        return 0;
+    }
+
+    if (queue->fd && list_empty( &obj->wait_queue ))  /* first on the queue */
+        set_fd_events( queue->fd, POLLIN );
+    add_queue( obj, entry );
+    return 1;
 }
 
-static struct object *msg_queue_get_sync( struct object *obj )
+static void msg_queue_remove_queue(struct object *obj, struct wait_queue_entry *entry )
 {
     struct msg_queue *queue = (struct msg_queue *)obj;
-    assert( obj->ops == &msg_queue_ops );
-    return grab_object( queue->sync );
+
+    remove_queue( obj, entry );
+    if (queue->fd && list_empty( &obj->wait_queue ))  /* last on the queue is gone */
+        set_fd_events( queue->fd, 0 );
 }
 
 static void msg_queue_dump( struct object *obj, int verbose )
@@ -1296,6 +1325,43 @@ static void msg_queue_dump( struct objec
              queue_shm->wake_bits, queue_shm->wake_mask );
 }
 
+static int msg_queue_signaled( struct object *obj, struct wait_queue_entry *entry )
+{
+    struct msg_queue *queue = (struct msg_queue *)obj;
+    int ret = 0;
+
+    if (queue->fd)
+    {
+        if ((ret = check_fd_events( queue->fd, POLLIN )))
+            /* stop waiting on select() if we are signaled */
+            set_fd_events( queue->fd, 0 );
+        else if (!list_empty( &obj->wait_queue ))
+            /* restart waiting on poll() if we are no longer signaled */
+            set_fd_events( queue->fd, POLLIN );
+    }
+    return ret || is_signaled( queue );
+}
+
+static int msg_queue_get_esync_fd( struct object *obj, enum esync_type *type )
+{
+    struct msg_queue *queue = (struct msg_queue *)obj;
+    *type = ESYNC_QUEUE;
+    return queue->esync_fd;
+}
+
+static void msg_queue_satisfied( struct object *obj, struct wait_queue_entry *entry )
+{
+    struct msg_queue *queue = (struct msg_queue *)obj;
+    queue_shm_t *queue_shm = queue->shared;
+
+    SHARED_WRITE_BEGIN( queue_shm, queue_shm_t )
+    {
+        shared->wake_mask = 0;
+        shared->changed_mask = 0;
+    }
+    SHARED_WRITE_END;
+}
+
 static void msg_queue_destroy( struct object *obj )
 {
     struct msg_queue *queue = (struct msg_queue *)obj;
@@ -1339,7 +1405,7 @@ static void msg_queue_destroy( struct ob
     if (queue->hooks) release_object( queue->hooks );
     if (queue->fd) release_object( queue->fd );
     if (queue->shared) free_shared_object( queue->shared );
-    if (queue->sync) release_object( queue->sync );
+    if (do_esync()) close( queue->esync_fd );
 }
 
 static void msg_queue_poll_event( struct fd *fd, int event )
@@ -1349,7 +1415,7 @@ static void msg_queue_poll_event( struct
 
     if (event & (POLLERR | POLLHUP)) set_fd_events( fd, -1 );
     else set_fd_events( queue->fd, 0 );
-    set_queue_bits( queue, QS_DRIVER );
+    wake_up( &queue->obj, 0 );
 }
 
 static void thread_input_dump( struct object *obj, int verbose )
@@ -1765,7 +1831,6 @@ static void release_hardware_message( st
         }
     }
     if (clr_bit) clear_queue_bits( queue, clr_bit );
-    if (list_empty( &input->msg_list )) clear_queue_bits( queue, QS_HARDWARE );
 
     update_thread_input_key_state( input, msg->msg, msg->wparam );
     list_remove( &msg->entry );
@@ -1894,13 +1959,13 @@ static void queue_hardware_message( stru
     struct thread_input *input;
     struct hardware_msg_data *msg_data = msg->data;
     unsigned int msg_code;
-    int flags, msg_bit;
+    int flags;
 
     update_desktop_key_state( desktop, msg->msg, msg->wparam );
     last_input_time = get_tick_count();
     if (msg->msg != WM_MOUSEMOVE) always_queue = 1;
 
-    switch ((msg_bit = get_hardware_msg_bit( msg->msg )))
+    switch (get_hardware_msg_bit( msg->msg ))
     {
     case QS_KEY:
         if (queue_hotkey_message( desktop, msg )) return;
@@ -1950,7 +2015,7 @@ static void queue_hardware_message( stru
     {
         msg->unique_id = 0;  /* will be set once we return it to the app */
         list_add_tail( &input->msg_list, &msg->entry );
-        set_queue_bits( thread->queue, QS_HARDWARE | msg_bit );
+        set_queue_bits( thread->queue, get_hardware_msg_bit( msg->msg ) );
     }
     release_object( thread );
 }
@@ -2731,7 +2796,6 @@ static int get_hardware_message( struct
     while (ptr)
     {
         struct message *msg = LIST_ENTRY( ptr, struct message, entry );
-        int msg_bit = get_hardware_msg_bit( msg->msg );
         struct hardware_msg_data *data = msg->data;
 
         ptr = list_next( &input->msg_list, ptr );
@@ -2755,7 +2819,7 @@ static int get_hardware_message( struct
             if (win_thread->queue->input == input)
             {
                 /* wake the other thread */
-                set_queue_bits( win_thread->queue, QS_HARDWARE | msg_bit );
+                set_queue_bits( win_thread->queue, get_hardware_msg_bit( msg->msg ) );
                 got_one = 1;
             }
             else
@@ -2774,7 +2838,7 @@ static int get_hardware_message( struct
          * match the filter we skip it */
         if (got_one || !check_hw_message_filter( win, msg_code, filter_win, first, last ))
         {
-            clear_bits &= ~msg_bit;
+            clear_bits &= ~get_hardware_msg_bit( msg->msg );
             continue;
         }
 
@@ -2804,7 +2868,7 @@ static int get_hardware_message( struct
         return 1;
     }
     /* nothing found, clear the hardware queue bits */
-    clear_queue_bits( thread->queue, QS_HARDWARE | clear_bits );
+    clear_queue_bits( thread->queue, clear_bits );
     return 0;
 }
 
@@ -3084,10 +3148,7 @@ DECL_HANDLER(set_queue_fd)
     if ((unix_fd = get_file_unix_fd( file )) != -1)
     {
         if ((unix_fd = dup( unix_fd )) != -1)
-        {
             queue->fd = create_anonymous_fd( &msg_queue_fd_ops, unix_fd, &queue->obj, 0 );
-            set_fd_events( queue->fd, POLLIN );
-        }
         else
             file_set_error();
     }
@@ -3099,31 +3160,39 @@ DECL_HANDLER(set_queue_fd)
 DECL_HANDLER(set_queue_mask)
 {
     struct msg_queue *queue = get_current_queue();
-    queue_shm_t *queue_shm;
 
-    if (!queue) return;
-    queue_shm = queue->shared;
-
-    if (req->poll_events)
+    if (queue)
     {
-        if (!queue->fd) return;
-        clear_queue_bits( queue, QS_DRIVER );
-        set_fd_events( queue->fd, POLLIN );
-        return;
-    }
+        queue_shm_t *queue_shm = queue->shared;
 
-    SHARED_WRITE_BEGIN( queue_shm, queue_shm_t )
-    {
-        shared->access_time  = monotonic_time;
-        shared->wake_mask    = req->wake_mask;
-        shared->changed_mask = req->changed_mask;
-        reply->wake_bits     = shared->wake_bits;
-        reply->changed_bits  = shared->changed_bits;
-    }
-    SHARED_WRITE_END;
+        SHARED_WRITE_BEGIN( queue_shm, queue_shm_t )
+        {
+            shared->wake_mask = req->wake_mask;
+            shared->changed_mask = req->changed_mask;
+        }
+        SHARED_WRITE_END;
+
+        reply->wake_bits    = queue_shm->wake_bits;
+        reply->changed_bits = queue_shm->changed_bits;
+
+        if (is_signaled( queue ))
+        {
+            /* if skip wait is set, do what would have been done in the subsequent wait */
+            if (req->skip_wait)
+            {
+                SHARED_WRITE_BEGIN( queue_shm, queue_shm_t )
+                {
+                    shared->wake_mask = 0;
+                    shared->changed_mask = 0;
+                }
+                SHARED_WRITE_END;
+            }
+            else wake_up( &queue->obj, 0 );
+        }
 
-    if (!get_queue_status( queue )) reset_sync( queue->sync );
-    else signal_sync( queue->sync );
+        if (do_esync() && !is_signaled( queue ))
+            esync_clear( queue->esync_fd );
+    }
 }
 
 
@@ -3131,20 +3200,23 @@ DECL_HANDLER(set_queue_mask)
 DECL_HANDLER(get_queue_status)
 {
     struct msg_queue *queue = current->queue;
-    queue_shm_t *queue_shm;
+    if (queue)
+    {
+        queue_shm_t *queue_shm = queue->shared;
 
-    if (!queue) return;
-    queue_shm = queue->shared;
+        reply->wake_bits    = queue_shm->wake_bits;
+        reply->changed_bits = queue_shm->changed_bits;
 
-    SHARED_WRITE_BEGIN( queue_shm, queue_shm_t )
-    {
-        reply->wake_bits      = shared->wake_bits;
-        reply->changed_bits   = shared->changed_bits;
-        shared->changed_bits &= ~req->clear_bits;
-    }
-    SHARED_WRITE_END;
+        SHARED_WRITE_BEGIN( queue_shm, queue_shm_t )
+        {
+            shared->changed_bits &= ~req->clear_bits;
+        }
+        SHARED_WRITE_END;
 
-    if (!get_queue_status( queue )) reset_sync( queue->sync );
+        if (do_esync() && !is_signaled( queue ))
+            esync_clear( queue->esync_fd );
+    }
+    else reply->wake_bits = reply->changed_bits = 0;
 }
 
 
@@ -3314,11 +3386,7 @@ DECL_HANDLER(get_message)
         return;
     }
 
-    SHARED_WRITE_BEGIN( queue_shm, queue_shm_t )
-    {
-        shared->access_time = monotonic_time;
-    }
-    SHARED_WRITE_END;
+    queue->last_get_msg = current_time;
 
     /* first check for sent messages */
     if ((ptr = list_head( &queue->msg_list[SEND_MESSAGE] )))
@@ -3344,8 +3412,6 @@ DECL_HANDLER(get_message)
     }
     SHARED_WRITE_END;
 
-    if (!get_queue_status( queue )) reset_sync( queue->sync );
-
     /* then check for posted messages */
     if ((filter & QS_POSTMESSAGE) &&
         get_posted_message( queue, get_win, req->get_first, req->get_last, req->flags, reply ))
@@ -3405,9 +3471,11 @@ DECL_HANDLER(get_message)
     }
     SHARED_WRITE_END;
 
-    if (!get_queue_status( queue )) reset_sync( queue->sync );
-    else signal_sync( queue->sync );
     set_error( STATUS_PENDING );  /* FIXME */
+
+    if (do_esync() && !is_signaled( queue ))
+        esync_clear( queue->esync_fd );
+
 }
 
 
@@ -4184,6 +4252,23 @@ DECL_HANDLER(update_rawinput_devices)
     }
 }
 
+DECL_HANDLER(esync_msgwait)
+{
+    struct msg_queue *queue = get_current_queue();
+    const queue_shm_t *queue_shm;
+
+    if (!queue) return;
+    queue_shm = queue->shared;
+    queue->esync_in_msgwait = req->in_msgwait;
+
+    if (current->process->idle_event && !(queue_shm->wake_mask & QS_SMRESULT))
+        set_event( current->process->idle_event );
+
+    /* and start/stop waiting on the driver */
+    if (queue->fd)
+        set_fd_events( queue->fd, req->in_msgwait ? POLLIN : 0 );
+}
+
 DECL_HANDLER(set_keyboard_repeat)
 {
     struct desktop *desktop;
@@ -4202,3 +4287,4 @@ DECL_HANDLER(set_keyboard_repeat)
 
     release_object( desktop );
 }
+
diff -ruN --show-c-function server/registry.c server/registry.c
--- server/registry.c	2025-10-10 10:17:47.803758742 -0700
+++ server/registry.c	2025-10-10 10:22:17.153264909 -0700
@@ -180,10 +180,10 @@ static const struct object_ops key_ops =
     no_add_queue,            /* add_queue */
     NULL,                    /* remove_queue */
     NULL,                    /* signaled */
+    NULL,                    /* get_esync_fd */
     NULL,                    /* satisfied */
     no_signal,               /* signal */
     no_get_fd,               /* get_fd */
-    default_get_sync,        /* get_sync */
     key_map_access,          /* map_access */
     key_get_sd,              /* get_sd */
     default_set_sd,          /* set_sd */
diff -ruN --show-c-function server/request.c server/request.c
--- server/request.c	2025-10-10 10:17:48.599775761 -0700
+++ server/request.c	2025-10-10 10:22:17.153515755 -0700
@@ -89,10 +89,10 @@ static const struct object_ops master_so
     no_add_queue,                  /* add_queue */
     NULL,                          /* remove_queue */
     NULL,                          /* signaled */
+    NULL,                          /* get_esync_fd */
     NULL,                          /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
-    default_get_sync,              /* get_sync */
     default_map_access,            /* map_access */
     default_get_sd,                /* get_sd */
     default_set_sd,                /* set_sd */
diff -ruN --show-c-function server/request_handlers.h server/request_handlers.h
--- server/request_handlers.h	2025-10-10 10:17:48.599775761 -0700
+++ server/request_handlers.h	2025-10-10 10:22:22.409492703 -0700
@@ -302,14 +302,17 @@ DECL_HANDLER(suspend_process);
 DECL_HANDLER(resume_process);
 DECL_HANDLER(get_next_process);
 DECL_HANDLER(get_next_thread);
+DECL_HANDLER(create_esync);
+DECL_HANDLER(open_esync);
+DECL_HANDLER(get_esync_fd);
+DECL_HANDLER(esync_msgwait);
 DECL_HANDLER(set_keyboard_repeat);
-DECL_HANDLER(get_inproc_sync_fd);
-DECL_HANDLER(get_inproc_alert_fd);
 DECL_HANDLER(d3dkmt_object_create);
 DECL_HANDLER(d3dkmt_object_query);
 DECL_HANDLER(d3dkmt_object_open);
 DECL_HANDLER(d3dkmt_share_objects);
 DECL_HANDLER(d3dkmt_object_open_name);
+DECL_HANDLER(get_esync_apc_fd);
 
 typedef void (*req_handler)( const void *req, void *reply );
 static const req_handler req_handlers[REQ_NB_REQUESTS] =
@@ -609,14 +612,17 @@ static const req_handler req_handlers[RE
     (req_handler)req_resume_process,
     (req_handler)req_get_next_process,
     (req_handler)req_get_next_thread,
+    (req_handler)req_create_esync,
+    (req_handler)req_open_esync,
+    (req_handler)req_get_esync_fd,
+    (req_handler)req_esync_msgwait,
     (req_handler)req_set_keyboard_repeat,
-    (req_handler)req_get_inproc_sync_fd,
-    (req_handler)req_get_inproc_alert_fd,
     (req_handler)req_d3dkmt_object_create,
     (req_handler)req_d3dkmt_object_query,
     (req_handler)req_d3dkmt_object_open,
     (req_handler)req_d3dkmt_share_objects,
     (req_handler)req_d3dkmt_object_open_name,
+    (req_handler)req_get_esync_apc_fd,
 };
 
 C_ASSERT( sizeof(abstime_t) == 8 );
@@ -719,9 +725,8 @@ C_ASSERT( offsetof(struct init_first_thr
 C_ASSERT( offsetof(struct init_first_thread_reply, tid) == 12 );
 C_ASSERT( offsetof(struct init_first_thread_reply, server_start) == 16 );
 C_ASSERT( offsetof(struct init_first_thread_reply, session_id) == 24 );
-C_ASSERT( offsetof(struct init_first_thread_reply, inproc_device) == 28 );
-C_ASSERT( offsetof(struct init_first_thread_reply, info_size) == 32 );
-C_ASSERT( sizeof(struct init_first_thread_reply) == 40 );
+C_ASSERT( offsetof(struct init_first_thread_reply, info_size) == 28 );
+C_ASSERT( sizeof(struct init_first_thread_reply) == 32 );
 C_ASSERT( offsetof(struct init_thread_request, unix_tid) == 12 );
 C_ASSERT( offsetof(struct init_thread_request, reply_fd) == 16 );
 C_ASSERT( offsetof(struct init_thread_request, wait_fd) == 20 );
@@ -1313,7 +1318,7 @@ C_ASSERT( offsetof(struct set_queue_fd_r
 C_ASSERT( sizeof(struct set_queue_fd_request) == 16 );
 C_ASSERT( offsetof(struct set_queue_mask_request, wake_mask) == 12 );
 C_ASSERT( offsetof(struct set_queue_mask_request, changed_mask) == 16 );
-C_ASSERT( offsetof(struct set_queue_mask_request, poll_events) == 20 );
+C_ASSERT( offsetof(struct set_queue_mask_request, skip_wait) == 20 );
 C_ASSERT( sizeof(struct set_queue_mask_request) == 24 );
 C_ASSERT( offsetof(struct set_queue_mask_reply, wake_bits) == 8 );
 C_ASSERT( offsetof(struct set_queue_mask_reply, changed_bits) == 12 );
@@ -2292,20 +2297,37 @@ C_ASSERT( offsetof(struct get_next_threa
 C_ASSERT( sizeof(struct get_next_thread_request) == 32 );
 C_ASSERT( offsetof(struct get_next_thread_reply, handle) == 8 );
 C_ASSERT( sizeof(struct get_next_thread_reply) == 16 );
+C_ASSERT( offsetof(struct create_esync_request, access) == 12 );
+C_ASSERT( offsetof(struct create_esync_request, initval) == 16 );
+C_ASSERT( offsetof(struct create_esync_request, type) == 20 );
+C_ASSERT( offsetof(struct create_esync_request, max) == 24 );
+C_ASSERT( sizeof(struct create_esync_request) == 32 );
+C_ASSERT( offsetof(struct create_esync_reply, handle) == 8 );
+C_ASSERT( offsetof(struct create_esync_reply, type) == 12 );
+C_ASSERT( offsetof(struct create_esync_reply, shm_idx) == 16 );
+C_ASSERT( sizeof(struct create_esync_reply) == 24 );
+C_ASSERT( offsetof(struct open_esync_request, access) == 12 );
+C_ASSERT( offsetof(struct open_esync_request, attributes) == 16 );
+C_ASSERT( offsetof(struct open_esync_request, rootdir) == 20 );
+C_ASSERT( offsetof(struct open_esync_request, type) == 24 );
+C_ASSERT( sizeof(struct open_esync_request) == 32 );
+C_ASSERT( offsetof(struct open_esync_reply, handle) == 8 );
+C_ASSERT( offsetof(struct open_esync_reply, type) == 12 );
+C_ASSERT( offsetof(struct open_esync_reply, shm_idx) == 16 );
+C_ASSERT( sizeof(struct open_esync_reply) == 24 );
+C_ASSERT( offsetof(struct get_esync_fd_request, handle) == 12 );
+C_ASSERT( sizeof(struct get_esync_fd_request) == 16 );
+C_ASSERT( offsetof(struct get_esync_fd_reply, type) == 8 );
+C_ASSERT( offsetof(struct get_esync_fd_reply, shm_idx) == 12 );
+C_ASSERT( sizeof(struct get_esync_fd_reply) == 16 );
+C_ASSERT( offsetof(struct esync_msgwait_request, in_msgwait) == 12 );
+C_ASSERT( sizeof(struct esync_msgwait_request) == 16 );
 C_ASSERT( offsetof(struct set_keyboard_repeat_request, enable) == 12 );
 C_ASSERT( offsetof(struct set_keyboard_repeat_request, delay) == 16 );
 C_ASSERT( offsetof(struct set_keyboard_repeat_request, period) == 20 );
 C_ASSERT( sizeof(struct set_keyboard_repeat_request) == 24 );
 C_ASSERT( offsetof(struct set_keyboard_repeat_reply, enable) == 8 );
 C_ASSERT( sizeof(struct set_keyboard_repeat_reply) == 16 );
-C_ASSERT( offsetof(struct get_inproc_sync_fd_request, handle) == 12 );
-C_ASSERT( sizeof(struct get_inproc_sync_fd_request) == 16 );
-C_ASSERT( offsetof(struct get_inproc_sync_fd_reply, type) == 8 );
-C_ASSERT( offsetof(struct get_inproc_sync_fd_reply, access) == 12 );
-C_ASSERT( sizeof(struct get_inproc_sync_fd_reply) == 16 );
-C_ASSERT( sizeof(struct get_inproc_alert_fd_request) == 16 );
-C_ASSERT( offsetof(struct get_inproc_alert_fd_reply, handle) == 8 );
-C_ASSERT( sizeof(struct get_inproc_alert_fd_reply) == 16 );
 C_ASSERT( offsetof(struct d3dkmt_object_create_request, type) == 12 );
 C_ASSERT( sizeof(struct d3dkmt_object_create_request) == 16 );
 C_ASSERT( offsetof(struct d3dkmt_object_create_reply, global) == 8 );
@@ -2339,3 +2361,4 @@ C_ASSERT( offsetof(struct d3dkmt_object_
 C_ASSERT( sizeof(struct d3dkmt_object_open_name_request) == 32 );
 C_ASSERT( offsetof(struct d3dkmt_object_open_name_reply, handle) == 8 );
 C_ASSERT( sizeof(struct d3dkmt_object_open_name_reply) == 16 );
+C_ASSERT( sizeof(struct get_esync_apc_fd_request) == 16 );
diff -ruN --show-c-function server/request_trace.h server/request_trace.h
--- server/request_trace.h	2025-10-10 10:17:56.799195505 -0700
+++ server/request_trace.h	2025-10-10 10:22:22.406573919 -0700
@@ -147,7 +147,6 @@ static void dump_init_first_thread_reply
     fprintf( stderr, ", tid=%04x", req->tid );
     dump_timeout( ", server_start=", &req->server_start );
     fprintf( stderr, ", session_id=%08x", req->session_id );
-    fprintf( stderr, ", inproc_device=%04x", req->inproc_device );
     fprintf( stderr, ", info_size=%u", req->info_size );
     dump_varargs_ushorts( ", machines=", cur_size );
 }
@@ -1382,7 +1381,7 @@ static void dump_set_queue_mask_request(
 {
     fprintf( stderr, " wake_mask=%08x", req->wake_mask );
     fprintf( stderr, ", changed_mask=%08x", req->changed_mask );
-    fprintf( stderr, ", poll_events=%d", req->poll_events );
+    fprintf( stderr, ", skip_wait=%d", req->skip_wait );
 }
 
 static void dump_set_queue_mask_reply( const struct set_queue_mask_reply *req )
@@ -3359,36 +3358,64 @@ static void dump_get_next_thread_reply(
     fprintf( stderr, " handle=%04x", req->handle );
 }
 
-static void dump_set_keyboard_repeat_request( const struct set_keyboard_repeat_request *req )
+static void dump_create_esync_request( const struct create_esync_request *req )
 {
-    fprintf( stderr, " enable=%d", req->enable );
-    fprintf( stderr, ", delay=%d", req->delay );
-    fprintf( stderr, ", period=%d", req->period );
+    fprintf( stderr, " access=%08x", req->access );
+    fprintf( stderr, ", initval=%d", req->initval );
+    fprintf( stderr, ", type=%d", req->type );
+    fprintf( stderr, ", max=%d", req->max );
+    dump_varargs_object_attributes( ", objattr=", cur_size );
 }
 
-static void dump_set_keyboard_repeat_reply( const struct set_keyboard_repeat_reply *req )
+static void dump_create_esync_reply( const struct create_esync_reply *req )
 {
-    fprintf( stderr, " enable=%d", req->enable );
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", type=%d", req->type );
+    fprintf( stderr, ", shm_idx=%08x", req->shm_idx );
+}
+
+static void dump_open_esync_request( const struct open_esync_request *req )
+{
+    fprintf( stderr, " access=%08x", req->access );
+    fprintf( stderr, ", attributes=%08x", req->attributes );
+    fprintf( stderr, ", rootdir=%04x", req->rootdir );
+    fprintf( stderr, ", type=%d", req->type );
+    dump_varargs_unicode_str( ", name=", cur_size );
+}
+
+static void dump_open_esync_reply( const struct open_esync_reply *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", type=%d", req->type );
+    fprintf( stderr, ", shm_idx=%08x", req->shm_idx );
 }
 
-static void dump_get_inproc_sync_fd_request( const struct get_inproc_sync_fd_request *req )
+static void dump_get_esync_fd_request( const struct get_esync_fd_request *req )
 {
     fprintf( stderr, " handle=%04x", req->handle );
 }
 
-static void dump_get_inproc_sync_fd_reply( const struct get_inproc_sync_fd_reply *req )
+static void dump_get_esync_fd_reply( const struct get_esync_fd_reply *req )
 {
     fprintf( stderr, " type=%d", req->type );
-    fprintf( stderr, ", access=%08x", req->access );
+    fprintf( stderr, ", shm_idx=%08x", req->shm_idx );
 }
 
-static void dump_get_inproc_alert_fd_request( const struct get_inproc_alert_fd_request *req )
+static void dump_esync_msgwait_request( const struct esync_msgwait_request *req )
 {
+    fprintf( stderr, " in_msgwait=%d", req->in_msgwait );
 }
 
-static void dump_get_inproc_alert_fd_reply( const struct get_inproc_alert_fd_reply *req )
+static void dump_set_keyboard_repeat_request( const struct set_keyboard_repeat_request *req )
 {
-    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, " enable=%d", req->enable );
+    fprintf( stderr, ", delay=%d", req->delay );
+    fprintf( stderr, ", period=%d", req->period );
+}
+
+static void dump_set_keyboard_repeat_reply( const struct set_keyboard_repeat_reply *req )
+{
+    fprintf( stderr, " enable=%d", req->enable );
 }
 
 static void dump_d3dkmt_object_create_request( const struct d3dkmt_object_create_request *req )
@@ -3458,6 +3485,10 @@ static void dump_d3dkmt_object_open_name
     fprintf( stderr, " handle=%04x", req->handle );
 }
 
+static void dump_get_esync_apc_fd_request( const struct get_esync_apc_fd_request *req )
+{
+}
+
 typedef void (*dump_func)( const void *req );
 
 static const dump_func req_dumpers[REQ_NB_REQUESTS] =
@@ -3757,14 +3788,17 @@ static const dump_func req_dumpers[REQ_N
     (dump_func)dump_resume_process_request,
     (dump_func)dump_get_next_process_request,
     (dump_func)dump_get_next_thread_request,
+    (dump_func)dump_create_esync_request,
+    (dump_func)dump_open_esync_request,
+    (dump_func)dump_get_esync_fd_request,
+    (dump_func)dump_esync_msgwait_request,
     (dump_func)dump_set_keyboard_repeat_request,
-    (dump_func)dump_get_inproc_sync_fd_request,
-    (dump_func)dump_get_inproc_alert_fd_request,
     (dump_func)dump_d3dkmt_object_create_request,
     (dump_func)dump_d3dkmt_object_query_request,
     (dump_func)dump_d3dkmt_object_open_request,
     (dump_func)dump_d3dkmt_share_objects_request,
     (dump_func)dump_d3dkmt_object_open_name_request,
+    (dump_func)dump_get_esync_apc_fd_request,
 };
 
 static const dump_func reply_dumpers[REQ_NB_REQUESTS] =
@@ -4064,14 +4098,17 @@ static const dump_func reply_dumpers[REQ
     NULL,
     (dump_func)dump_get_next_process_reply,
     (dump_func)dump_get_next_thread_reply,
+    (dump_func)dump_create_esync_reply,
+    (dump_func)dump_open_esync_reply,
+    (dump_func)dump_get_esync_fd_reply,
+    NULL,
     (dump_func)dump_set_keyboard_repeat_reply,
-    (dump_func)dump_get_inproc_sync_fd_reply,
-    (dump_func)dump_get_inproc_alert_fd_reply,
     (dump_func)dump_d3dkmt_object_create_reply,
     (dump_func)dump_d3dkmt_object_query_reply,
     (dump_func)dump_d3dkmt_object_open_reply,
     (dump_func)dump_d3dkmt_share_objects_reply,
     (dump_func)dump_d3dkmt_object_open_name_reply,
+    NULL,
 };
 
 static const char * const req_names[REQ_NB_REQUESTS] =
@@ -4371,14 +4408,17 @@ static const char * const req_names[REQ_
     "resume_process",
     "get_next_process",
     "get_next_thread",
+    "create_esync",
+    "open_esync",
+    "get_esync_fd",
+    "esync_msgwait",
     "set_keyboard_repeat",
-    "get_inproc_sync_fd",
-    "get_inproc_alert_fd",
     "d3dkmt_object_create",
     "d3dkmt_object_query",
     "d3dkmt_object_open",
     "d3dkmt_share_objects",
     "d3dkmt_object_open_name",
+    "get_esync_apc_fd",
 };
 
 static const struct
@@ -4478,7 +4518,6 @@ static const struct
     { "NO_IMPERSONATION_TOKEN",      STATUS_NO_IMPERSONATION_TOKEN },
     { "NO_MEMORY",                   STATUS_NO_MEMORY },
     { "NO_MORE_ENTRIES",             STATUS_NO_MORE_ENTRIES },
-    { "NO_MORE_FILES",               STATUS_NO_MORE_FILES },
     { "NO_SUCH_DEVICE",              STATUS_NO_SUCH_DEVICE },
     { "NO_SUCH_FILE",                STATUS_NO_SUCH_FILE },
     { "NO_TOKEN",                    STATUS_NO_TOKEN },
diff -ruN --show-c-function server/semaphore.c server/semaphore.c
--- server/semaphore.c	2025-10-10 10:17:47.804758763 -0700
+++ server/semaphore.c	2025-10-10 10:22:17.153642976 -0700
@@ -50,121 +50,30 @@ struct type_descr semaphore_type =
     },
 };
 
-struct semaphore_sync
-{
-    struct object       obj;                /* object header */
-    unsigned int        count;              /* current count */
-    unsigned int        max;                /* maximum possible count */
-};
-
-static void semaphore_sync_dump( struct object *obj, int verbose );
-static int semaphore_sync_signaled( struct object *obj, struct wait_queue_entry *entry );
-static void semaphore_sync_satisfied( struct object *obj, struct wait_queue_entry *entry );
-
-static const struct object_ops semaphore_sync_ops =
-{
-    sizeof(struct semaphore_sync), /* size */
-    &no_type,                      /* type */
-    semaphore_sync_dump,           /* dump */
-    add_queue,                     /* add_queue */
-    remove_queue,                  /* remove_queue */
-    semaphore_sync_signaled,       /* signaled */
-    semaphore_sync_satisfied,      /* satisfied */
-    no_signal,                     /* signal */
-    no_get_fd,                     /* get_fd */
-    default_get_sync,              /* get_sync */
-    default_map_access,            /* map_access */
-    default_get_sd,                /* get_sd */
-    default_set_sd,                /* set_sd */
-    default_get_full_name,         /* get_full_name */
-    no_lookup_name,                /* lookup_name */
-    directory_link_name,           /* link_name */
-    default_unlink_name,           /* unlink_name */
-    no_open_file,                  /* open_file */
-    no_kernel_obj_list,            /* get_kernel_obj_list */
-    no_close_handle,               /* close_handle */
-    no_destroy                     /* destroy */
-};
-
-static int release_semaphore( struct semaphore_sync *sem, unsigned int count,
-                              unsigned int *prev )
-{
-    if (prev) *prev = sem->count;
-    if (sem->count + count < sem->count || sem->count + count > sem->max)
-    {
-        set_error( STATUS_SEMAPHORE_LIMIT_EXCEEDED );
-        return 0;
-    }
-    else if (sem->count)
-    {
-        /* there cannot be any thread to wake up if the count is != 0 */
-        sem->count += count;
-    }
-    else
-    {
-        sem->count = count;
-        wake_up( &sem->obj, count );
-    }
-    return 1;
-}
-
-static void semaphore_sync_dump( struct object *obj, int verbose )
-{
-    struct semaphore_sync *sem = (struct semaphore_sync *)obj;
-    assert( obj->ops == &semaphore_sync_ops );
-    fprintf( stderr, "Semaphore count=%d max=%d\n", sem->count, sem->max );
-}
-
-static int semaphore_sync_signaled( struct object *obj, struct wait_queue_entry *entry )
-{
-    struct semaphore_sync *sem = (struct semaphore_sync *)obj;
-    assert( obj->ops == &semaphore_sync_ops );
-    return (sem->count > 0);
-}
-
-static void semaphore_sync_satisfied( struct object *obj, struct wait_queue_entry *entry )
-{
-    struct semaphore_sync *sem = (struct semaphore_sync *)obj;
-    assert( obj->ops == &semaphore_sync_ops );
-    assert( sem->count );
-    sem->count--;
-}
-
-static struct object *create_semaphore_sync( unsigned int initial, unsigned int max )
-{
-    struct semaphore_sync *sem;
-
-    if (get_inproc_device_fd() >= 0) return (struct object *)create_inproc_semaphore_sync( initial, max );
-
-    if (!(sem = alloc_object( &semaphore_sync_ops ))) return NULL;
-    sem->count = initial;
-    sem->max   = max;
-    return &sem->obj;
-}
-
 struct semaphore
 {
-    struct object          obj;    /* object header */
-    struct object         *sync;   /* semaphore sync object */
+    struct object  obj;    /* object header */
+    unsigned int   count;  /* current count */
+    unsigned int   max;    /* maximum possible count */
 };
 
 static void semaphore_dump( struct object *obj, int verbose );
-static struct object *semaphore_get_sync( struct object *obj );
-static int semaphore_signal( struct object *obj, unsigned int access, int signal );
-static void semaphore_destroy( struct object *obj );
+static int semaphore_signaled( struct object *obj, struct wait_queue_entry *entry );
+static void semaphore_satisfied( struct object *obj, struct wait_queue_entry *entry );
+static int semaphore_signal( struct object *obj, unsigned int access );
 
 static const struct object_ops semaphore_ops =
 {
     sizeof(struct semaphore),      /* size */
     &semaphore_type,               /* type */
     semaphore_dump,                /* dump */
-    NULL,                          /* add_queue */
-    NULL,                          /* remove_queue */
-    NULL,                          /* signaled */
-    NULL,                          /* satisfied */
+    add_queue,                     /* add_queue */
+    remove_queue,                  /* remove_queue */
+    semaphore_signaled,            /* signaled */
+    NULL,                          /* get_esync_fd */
+    semaphore_satisfied,           /* satisfied */
     semaphore_signal,              /* signal */
     no_get_fd,                     /* get_fd */
-    semaphore_get_sync,            /* get_sync */
     default_map_access,            /* map_access */
     default_get_sd,                /* get_sd */
     default_set_sd,                /* set_sd */
@@ -175,9 +84,10 @@ static const struct object_ops semaphore
     no_open_file,                  /* open_file */
     no_kernel_obj_list,            /* get_kernel_obj_list */
     no_close_handle,               /* close_handle */
-    semaphore_destroy,             /* destroy */
+    no_destroy                     /* destroy */
 };
 
+
 static struct semaphore *create_semaphore( struct object *root, const struct unicode_str *name,
                                            unsigned int attr, unsigned int initial, unsigned int max,
                                            const struct security_descriptor *sd )
@@ -194,53 +104,68 @@ static struct semaphore *create_semaphor
         if (get_error() != STATUS_OBJECT_NAME_EXISTS)
         {
             /* initialize it if it didn't already exist */
-            sem->sync = NULL;
-
-            if (!(sem->sync = create_semaphore_sync( initial, max )))
-            {
-                release_object( sem );
-                return NULL;
-            }
+            sem->count = initial;
+            sem->max   = max;
         }
     }
     return sem;
 }
 
+static int release_semaphore( struct semaphore *sem, unsigned int count,
+                              unsigned int *prev )
+{
+    if (prev) *prev = sem->count;
+    if (sem->count + count < sem->count || sem->count + count > sem->max)
+    {
+        set_error( STATUS_SEMAPHORE_LIMIT_EXCEEDED );
+        return 0;
+    }
+    else if (sem->count)
+    {
+        /* there cannot be any thread to wake up if the count is != 0 */
+        sem->count += count;
+    }
+    else
+    {
+        sem->count = count;
+        wake_up( &sem->obj, count );
+    }
+    return 1;
+}
+
 static void semaphore_dump( struct object *obj, int verbose )
 {
     struct semaphore *sem = (struct semaphore *)obj;
     assert( obj->ops == &semaphore_ops );
-    sem->sync->ops->dump( sem->sync, verbose );
+    fprintf( stderr, "Semaphore count=%d max=%d\n", sem->count, sem->max );
 }
 
-static struct object *semaphore_get_sync( struct object *obj )
+static int semaphore_signaled( struct object *obj, struct wait_queue_entry *entry )
 {
     struct semaphore *sem = (struct semaphore *)obj;
     assert( obj->ops == &semaphore_ops );
-    return grab_object( sem->sync );
+    return (sem->count > 0);
 }
 
-static int semaphore_signal( struct object *obj, unsigned int access, int signal )
+static void semaphore_satisfied( struct object *obj, struct wait_queue_entry *entry )
 {
     struct semaphore *sem = (struct semaphore *)obj;
     assert( obj->ops == &semaphore_ops );
+    assert( sem->count );
+    sem->count--;
+}
 
-    assert( sem->sync->ops == &semaphore_sync_ops ); /* never called with inproc syncs */
-    assert( signal == -1 ); /* always called from signal_object */
+static int semaphore_signal( struct object *obj, unsigned int access )
+{
+    struct semaphore *sem = (struct semaphore *)obj;
+    assert( obj->ops == &semaphore_ops );
 
     if (!(access & SEMAPHORE_MODIFY_STATE))
     {
         set_error( STATUS_ACCESS_DENIED );
         return 0;
     }
-    return release_semaphore( (struct semaphore_sync *)sem->sync, 1, NULL );
-}
-
-static void semaphore_destroy( struct object *obj )
-{
-    struct semaphore *sem = (struct semaphore *)obj;
-    assert( obj->ops == &semaphore_ops );
-    if (sem->sync) release_object( sem->sync );
+    return release_semaphore( sem, 1, NULL );
 }
 
 /* create a semaphore */
@@ -284,10 +209,7 @@ DECL_HANDLER(release_semaphore)
     if ((sem = (struct semaphore *)get_handle_obj( current->process, req->handle,
                                                    SEMAPHORE_MODIFY_STATE, &semaphore_ops )))
     {
-        struct semaphore_sync *sync = (struct semaphore_sync *)sem->sync;
-        assert( sem->sync->ops == &semaphore_sync_ops ); /* never called with inproc syncs */
-
-        release_semaphore( sync, req->count, &reply->prev_count );
+        release_semaphore( sem, req->count, &reply->prev_count );
         release_object( sem );
     }
 }
@@ -300,11 +222,8 @@ DECL_HANDLER(query_semaphore)
     if ((sem = (struct semaphore *)get_handle_obj( current->process, req->handle,
                                                    SEMAPHORE_QUERY_STATE, &semaphore_ops )))
     {
-        struct semaphore_sync *sync = (struct semaphore_sync *)sem->sync;
-        assert( sem->sync->ops == &semaphore_sync_ops ); /* never called with inproc syncs */
-
-        reply->current = sync->count;
-        reply->max = sync->max;
+        reply->current = sem->count;
+        reply->max = sem->max;
         release_object( sem );
     }
 }
diff -ruN --show-c-function server/serial.c server/serial.c
--- server/serial.c	2025-10-10 10:17:47.804758763 -0700
+++ server/serial.c	2025-10-10 10:22:17.153737255 -0700
@@ -88,13 +88,13 @@ static const struct object_ops serial_op
     sizeof(struct serial),        /* size */
     &file_type,                   /* type */
     serial_dump,                  /* dump */
-    NULL,                         /* add_queue */
-    NULL,                         /* remove_queue */
-    NULL,                         /* signaled */
-    NULL,                         /* satisfied */
+    add_queue,                    /* add_queue */
+    remove_queue,                 /* remove_queue */
+    default_fd_signaled,          /* signaled */
+    NULL,                         /* get_esync_fd */
+    no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     serial_get_fd,                /* get_fd */
-    default_fd_get_sync,          /* get_sync */
     default_map_access,           /* map_access */
     default_get_sd,               /* get_sd */
     default_set_sd,               /* set_sd */
diff -ruN --show-c-function server/signal.c server/signal.c
--- server/signal.c	2025-10-10 10:17:47.804758763 -0700
+++ server/signal.c	2025-10-10 10:22:17.153836884 -0700
@@ -62,10 +62,10 @@ static const struct object_ops handler_o
     no_add_queue,             /* add_queue */
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
+    NULL,                     /* get_esync_fd */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
-    default_get_sync,         /* get_sync */
     default_map_access,       /* map_access */
     default_get_sd,           /* get_sd */
     default_set_sd,           /* set_sd */
diff -ruN --show-c-function server/sock.c server/sock.c
--- server/sock.c	2025-10-10 10:17:47.804758763 -0700
+++ server/sock.c	2025-10-10 10:22:17.154019941 -0700
@@ -483,13 +483,13 @@ static const struct object_ops sock_ops
     sizeof(struct sock),          /* size */
     &file_type,                   /* type */
     sock_dump,                    /* dump */
-    NULL,                         /* add_queue */
-    NULL,                         /* remove_queue */
-    NULL,                         /* signaled */
-    NULL,                         /* satisfied */
+    add_queue,                    /* add_queue */
+    remove_queue,                 /* remove_queue */
+    default_fd_signaled,          /* signaled */
+    NULL,                         /* get_esync_fd */
+    no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     sock_get_fd,                  /* get_fd */
-    default_fd_get_sync,          /* get_sync */
     default_map_access,           /* map_access */
     default_get_sd,               /* get_sd */
     default_set_sd,               /* set_sd */
@@ -3706,10 +3706,10 @@ static const struct object_ops ifchange_
     no_add_queue,            /* add_queue */
     NULL,                    /* remove_queue */
     NULL,                    /* signaled */
+    NULL,                    /* get_esync_fd */
     no_satisfied,            /* satisfied */
     no_signal,               /* signal */
     ifchange_get_fd,         /* get_fd */
-    default_get_sync,        /* get_sync */
     default_map_access,      /* map_access */
     default_get_sd,          /* get_sd */
     default_set_sd,          /* set_sd */
@@ -3928,10 +3928,10 @@ static const struct object_ops socket_de
     no_add_queue,               /* add_queue */
     NULL,                       /* remove_queue */
     NULL,                       /* signaled */
+    NULL,                       /* get_esync_fd */
     no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
-    default_get_sync,           /* get_sync */
     default_map_access,         /* map_access */
     default_get_sd,             /* get_sd */
     default_set_sd,             /* set_sd */
diff -ruN --show-c-function server/sock.c.orig server/sock.c.orig
--- server/sock.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ server/sock.c.orig	2025-10-10 10:22:12.715276035 -0700
@@ -0,0 +1,4449 @@
+/*
+ * Server-side socket management
+ *
+ * Copyright (C) 1999 Marcus Meissner, Ove Kåven
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ *
+ * FIXME: we use read|write access in all cases. Shouldn't we depend that
+ * on the access of the current handle?
+ */
+
+#include "config.h"
+
+#include <assert.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#ifdef HAVE_IFADDRS_H
+# include <ifaddrs.h>
+#endif
+#ifdef HAVE_NET_IF_H
+# include <net/if.h>
+#endif
+#ifdef HAVE_NETINET_IN_H
+# include <netinet/in.h>
+#endif
+#ifdef HAVE_NETINET_TCP_H
+# include <netinet/tcp.h>
+#endif
+#ifdef HAVE_NETINET_TCP_FSM_H
+#include <netinet/tcp_fsm.h>
+#endif
+#include <poll.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#ifdef HAVE_SYS_FILIO_H
+# include <sys/filio.h>
+#endif
+#include <time.h>
+#include <unistd.h>
+#include <limits.h>
+#ifdef HAVE_LINUX_FILTER_H
+# include <linux/filter.h>
+#endif
+#ifdef HAVE_LINUX_RTNETLINK_H
+# include <linux/rtnetlink.h>
+#endif
+
+#ifdef HAVE_NETIPX_IPX_H
+# include <netipx/ipx.h>
+# define HAS_IPX
+#elif defined(HAVE_LINUX_IPX_H)
+# ifdef HAVE_ASM_TYPES_H
+#  include <asm/types.h>
+# endif
+# ifdef HAVE_LINUX_TYPES_H
+#  include <linux/types.h>
+# endif
+# include <linux/ipx.h>
+# ifdef SOL_IPX
+#  define HAS_IPX
+# endif
+#endif
+
+#ifdef HAVE_LINUX_IRDA_H
+# ifdef HAVE_LINUX_TYPES_H
+#  include <linux/types.h>
+# endif
+# include <linux/irda.h>
+# define HAS_IRDA
+#endif
+
+#ifdef HAVE_BLUETOOTH_BLUETOOTH_H
+# include <bluetooth/bluetooth.h>
+# ifdef HAVE_BLUETOOTH_RFCOMM_H
+#  include <bluetooth/rfcomm.h>
+#  define HAS_BLUETOOTH
+# endif
+#endif
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winternl.h"
+#include "winerror.h"
+#define USE_WS_PREFIX
+#include "winsock2.h"
+#include "ws2tcpip.h"
+#include "tcpmib.h"
+#include "wsipx.h"
+#include "af_irda.h"
+#include "bthsdpdef.h"
+#include "bluetoothapis.h"
+#include "bthdef.h"
+#include "ws2bth.h"
+#include "wine/afd.h"
+#include "wine/rbtree.h"
+
+#include "process.h"
+#include "file.h"
+#include "handle.h"
+#include "thread.h"
+#include "request.h"
+#include "user.h"
+
+#if defined(linux) && !defined(IP_UNICAST_IF)
+#define IP_UNICAST_IF 50
+#endif
+
+#ifndef HAVE_NETINET_TCP_FSM_H
+#define TCPS_ESTABLISHED  1
+#define TCPS_SYN_SENT     2
+#define TCPS_SYN_RECEIVED 3
+#define TCPS_FIN_WAIT_1   4
+#define TCPS_FIN_WAIT_2   5
+#define TCPS_TIME_WAIT    6
+#define TCPS_CLOSED       7
+#define TCPS_CLOSE_WAIT   8
+#define TCPS_LAST_ACK     9
+#define TCPS_LISTEN      10
+#define TCPS_CLOSING     11
+#endif
+
+static const char magic_loopback_addr[] = {127, 12, 34, 56};
+
+union win_sockaddr
+{
+    struct WS_sockaddr addr;
+    struct WS_sockaddr_in in;
+    struct WS_sockaddr_in6 in6;
+    struct WS_sockaddr_ipx ipx;
+    SOCKADDR_IRDA irda;
+};
+
+union unix_sockaddr
+{
+    struct sockaddr addr;
+    struct sockaddr_in in;
+    struct sockaddr_in6 in6;
+#ifdef HAS_IPX
+    struct sockaddr_ipx ipx;
+#endif
+#ifdef HAS_IRDA
+    struct sockaddr_irda irda;
+#endif
+#ifdef HAS_BLUETOOTH
+    struct sockaddr_rc rfcomm;
+#endif
+};
+
+static struct list poll_list = LIST_INIT( poll_list );
+
+struct poll_req
+{
+    struct list entry;
+    struct async *async;
+    struct iosb *iosb;
+    struct timeout_user *timeout;
+    timeout_t orig_timeout;
+    int exclusive;
+    int pending;
+    unsigned int count;
+    struct
+    {
+        struct sock *sock;
+        int mask;
+        obj_handle_t handle;
+        int flags;
+        unsigned int status;
+    } sockets[1];
+};
+
+struct accept_req
+{
+    struct list entry;
+    struct async *async;
+    struct iosb *iosb;
+    struct sock *sock, *acceptsock;
+    int accepted;
+    unsigned int recv_len, local_len;
+};
+
+struct connect_req
+{
+    struct async *async;
+    struct iosb *iosb;
+    struct sock *sock;
+    unsigned int addr_len, send_len, send_cursor;
+};
+
+struct send_req
+{
+    struct iosb *iosb;
+    struct sock *sock;
+};
+
+enum connection_state
+{
+    SOCK_LISTENING,
+    SOCK_UNCONNECTED,
+    SOCK_CONNECTING,
+    SOCK_CONNECTED,
+    SOCK_CONNECTIONLESS,
+};
+
+struct bound_addr
+{
+    struct rb_entry entry;
+    union unix_sockaddr addr;
+    int match_any_addr;
+    int reuse_count;
+};
+
+#define MAX_ICMP_HISTORY_LENGTH 8
+
+#define MIN_RCVBUF 65536
+
+struct sock
+{
+    struct object       obj;         /* object header */
+    struct fd          *fd;          /* socket file descriptor */
+    enum connection_state state;     /* connection state */
+    unsigned int        mask;        /* event mask */
+    /* pending AFD_POLL_* events which have not yet been reported to the application */
+    unsigned int        pending_events;
+    /* AFD_POLL_* events which have already been reported and should not be
+     * selected for again until reset by a relevant call.
+     *
+     * For example, if AFD_POLL_READ is set here and not in pending_events, it
+     * has already been reported and consumed, and we should not report it
+     * again, even if POLLIN is signaled, until it is reset by e.g recv().
+     *
+     * If an event has been signaled and not consumed yet, it will be set in
+     * both pending_events and reported_events (as we should only ever report
+     * any event once until it is reset.) */
+    unsigned int        reported_events;
+    unsigned short      proto;       /* socket protocol */
+    unsigned short      type;        /* socket type */
+    unsigned short      family;      /* socket family */
+    struct event       *event;       /* event object */
+    user_handle_t       window;      /* window to send the message to */
+    unsigned int        message;     /* message to send */
+    obj_handle_t        wparam;      /* message wparam (socket handle) */
+    int                 errors[AFD_POLL_BIT_COUNT]; /* event errors */
+    timeout_t           connect_time;/* time the socket was connected */
+    struct sock        *deferred;    /* socket that waits for a deferred accept */
+    struct async_queue  read_q;      /* queue for asynchronous reads */
+    struct async_queue  write_q;     /* queue for asynchronous writes */
+    struct async_queue  ifchange_q;  /* queue for interface change notifications */
+    struct async_queue  accept_q;    /* queue for asynchronous accepts */
+    struct async_queue  connect_q;   /* queue for asynchronous connects */
+    struct async_queue  poll_q;      /* queue for asynchronous polls */
+    struct object      *ifchange_obj; /* the interface change notification object */
+    struct list         ifchange_entry; /* entry in ifchange notification list */
+    struct list         accept_list; /* list of pending accept requests */
+    struct accept_req  *accept_recv_req; /* pending accept-into request which will recv on this socket */
+    struct connect_req *connect_req; /* pending connection request */
+    struct poll_req    *main_poll;   /* main poll */
+    union win_sockaddr  addr;        /* socket name */
+    int                 addr_len;    /* socket name length */
+    union win_sockaddr  peer_addr;   /* peer name */
+    int                 peer_addr_len; /* peer name length */
+    unsigned int        rcvbuf;      /* advisory recv buffer size */
+    unsigned int        sndbuf;      /* advisory send buffer size */
+    unsigned int        rcvtimeo;    /* receive timeout in ms */
+    unsigned int        sndtimeo;    /* send timeout in ms */
+    struct
+    {
+        unsigned short icmp_id;
+        unsigned short icmp_seq;
+    }
+    icmp_fixup_data[MAX_ICMP_HISTORY_LENGTH]; /* Sent ICMP packets history used to fixup reply id. */
+    struct bound_addr  *bound_addr[2]; /* Links to the entries in bound addresses tree. */
+    unsigned int        icmp_fixup_data_len;  /* Sent ICMP packets history length. */
+    unsigned int        rd_shutdown : 1; /* is the read end shut down? */
+    unsigned int        wr_shutdown : 1; /* is the write end shut down? */
+    unsigned int        wr_shutdown_pending : 1; /* is a write shutdown pending? */
+    unsigned int        hangup : 1;  /* has the read end received a hangup? */
+    unsigned int        aborted : 1; /* did we get a POLLERR or irregular POLLHUP? */
+    unsigned int        nonblocking : 1; /* is the socket nonblocking? */
+    unsigned int        bound : 1;   /* is the socket bound? */
+    unsigned int        reset : 1;   /* did we get a TCP reset? */
+    unsigned int        reuseaddr : 1; /* winsock SO_REUSEADDR option value */
+    unsigned int        exclusiveaddruse : 1; /* winsock SO_EXCLUSIVEADDRUSE option value */
+};
+
+static int is_tcp_socket( struct sock *sock )
+{
+    return sock->type == WS_SOCK_STREAM && (sock->family == WS_AF_INET || sock->family == WS_AF_INET6);
+}
+
+static int addr_compare( const void *key, const struct wine_rb_entry *entry )
+{
+    const struct bound_addr *bound_addr = RB_ENTRY_VALUE(entry, struct bound_addr, entry);
+    const struct bound_addr *addr = key;
+
+    if (addr->addr.addr.sa_family != bound_addr->addr.addr.sa_family)
+        return addr->addr.addr.sa_family < bound_addr->addr.addr.sa_family ? -1 : 1;
+
+    if (addr->addr.addr.sa_family == AF_INET)
+    {
+        if (addr->addr.in.sin_port != bound_addr->addr.in.sin_port)
+            return addr->addr.in.sin_port < bound_addr->addr.in.sin_port ? -1 : 1;
+        if (bound_addr->match_any_addr || addr->match_any_addr
+            || addr->addr.in.sin_addr.s_addr == bound_addr->addr.in.sin_addr.s_addr)
+            return 0;
+        return addr->addr.in.sin_addr.s_addr < bound_addr->addr.in.sin_addr.s_addr ? -1 : 1;
+    }
+
+    assert( addr->addr.addr.sa_family == AF_INET6 );
+    if (addr->addr.in6.sin6_port != bound_addr->addr.in6.sin6_port)
+        return addr->addr.in6.sin6_port < bound_addr->addr.in6.sin6_port ? -1 : 1;
+    if (bound_addr->match_any_addr || addr->match_any_addr) return 0;
+    return memcmp( &addr->addr.in6.sin6_addr, &bound_addr->addr.in6.sin6_addr, sizeof(addr->addr.in6.sin6_addr) );
+}
+
+static int ipv4addr_from_v6( union unix_sockaddr *v4addr, const struct sockaddr_in6 *in6, int map_unspecified )
+{
+    v4addr->in.sin_family = AF_INET;
+    v4addr->in.sin_port = in6->sin6_port;
+
+    if (map_unspecified && IN6_IS_ADDR_UNSPECIFIED(&in6->sin6_addr))
+    {
+        v4addr->in.sin_addr.s_addr = htonl( INADDR_ANY );
+        return 1;
+    }
+    if (IN6_IS_ADDR_V4COMPAT(&in6->sin6_addr) || IN6_IS_ADDR_V4MAPPED(&in6->sin6_addr))
+    {
+        memcpy( &v4addr->in.sin_addr.s_addr, &in6->sin6_addr.s6_addr[12], sizeof(v4addr->in.sin_addr.s_addr) );
+        return 1;
+    }
+    return 0;
+}
+
+static struct rb_tree bound_addresses_tree = { addr_compare };
+
+static int should_track_conflicts_for_addr( struct sock *sock, const union unix_sockaddr *addr )
+{
+    if (!is_tcp_socket( sock )) return 0;
+
+    if (sock->family == WS_AF_INET && addr->addr.sa_family == AF_INET && addr->in.sin_port)
+        return 1;
+    else if (sock->family == WS_AF_INET6 && addr->addr.sa_family == AF_INET6 && addr->in6.sin6_port)
+        return 1;
+
+    return 0;
+}
+
+static int is_any_addr( const union unix_sockaddr *addr )
+{
+    if (addr->addr.sa_family == AF_INET && addr->in.sin_addr.s_addr == htonl( INADDR_ANY ))
+        return 1;
+    if (addr->addr.sa_family == AF_INET6 && IN6_IS_ADDR_UNSPECIFIED(&addr->in6.sin6_addr))
+        return 1;
+    return 0;
+}
+
+static int check_addr_usage( struct sock *sock, const union unix_sockaddr *addr, int v6only )
+{
+    struct bound_addr *bound_addr, search_addr;
+    struct rb_entry *entry;
+
+    if (!should_track_conflicts_for_addr( sock, addr )) return 0;
+
+    search_addr.addr = *addr;
+    search_addr.match_any_addr = sock->exclusiveaddruse && is_any_addr( addr );
+
+    if ((entry = rb_get( &bound_addresses_tree, &search_addr )))
+    {
+        bound_addr = WINE_RB_ENTRY_VALUE(entry, struct bound_addr, entry);
+        if (bound_addr->reuse_count == -1 || !sock->reuseaddr)
+        {
+            set_error( sock->reuseaddr || bound_addr->match_any_addr
+                       ? STATUS_ACCESS_DENIED : STATUS_SHARING_VIOLATION );
+            return 1;
+        }
+    }
+
+    if (sock->family != WS_AF_INET6 || v6only) return 0;
+    if (!ipv4addr_from_v6( &search_addr.addr, &addr->in6, sock->exclusiveaddruse )) return 0;
+
+    search_addr.match_any_addr = sock->exclusiveaddruse && is_any_addr( &search_addr.addr );
+    if ((entry = rb_get( &bound_addresses_tree, &search_addr )))
+    {
+        bound_addr = WINE_RB_ENTRY_VALUE(entry, struct bound_addr, entry);
+        if (bound_addr->reuse_count == -1 || !sock->reuseaddr)
+        {
+            set_error( sock->reuseaddr || bound_addr->match_any_addr
+                       ? STATUS_ACCESS_DENIED : STATUS_SHARING_VIOLATION );
+            return 1;
+        }
+    }
+    return 0;
+}
+
+static struct bound_addr *register_bound_address( struct sock *sock, const union unix_sockaddr *addr )
+{
+    struct bound_addr *bound_addr, *temp;
+
+    if (!(bound_addr = mem_alloc( sizeof(*bound_addr) )))
+        return NULL;
+
+    bound_addr->addr = *addr;
+    bound_addr->match_any_addr = sock->exclusiveaddruse && is_any_addr( addr );
+
+    if (rb_put( &bound_addresses_tree, bound_addr, &bound_addr->entry ))
+    {
+        temp = bound_addr;
+        bound_addr = WINE_RB_ENTRY_VALUE(rb_get( &bound_addresses_tree, temp ), struct bound_addr, entry);
+        free( temp );
+        if (bound_addr->reuse_count == -1)
+        {
+            if (debug_level)
+                fprintf( stderr, "register_bound_address: address being updated is already exclusively bound\n" );
+            return NULL;
+        }
+        ++bound_addr->reuse_count;
+    }
+    else
+    {
+        bound_addr->reuse_count = sock->reuseaddr ? 1 : -1;
+    }
+    return bound_addr;
+}
+
+static void update_addr_usage( struct sock *sock, const union unix_sockaddr *addr, int v6only )
+{
+    union unix_sockaddr v4addr;
+
+    assert( !sock->bound_addr[0] && !sock->bound_addr[1] );
+
+    if (!should_track_conflicts_for_addr( sock, addr )) return;
+
+    sock->bound_addr[0] = register_bound_address( sock, addr );
+
+    if (sock->family != WS_AF_INET6 || v6only) return;
+
+    if (!ipv4addr_from_v6( &v4addr, &addr->in6, sock->exclusiveaddruse )) return;
+
+    sock->bound_addr[1] = register_bound_address( sock, &v4addr );
+}
+
+static void sock_dump( struct object *obj, int verbose );
+static struct fd *sock_get_fd( struct object *obj );
+static int sock_close_handle( struct object *obj, struct process *process, obj_handle_t handle );
+static void sock_destroy( struct object *obj );
+static struct object *sock_get_ifchange( struct sock *sock );
+static void sock_release_ifchange( struct sock *sock );
+
+static int sock_get_poll_events( struct fd *fd );
+static void sock_poll_event( struct fd *fd, int event );
+static enum server_fd_type sock_get_fd_type( struct fd *fd );
+static void sock_ioctl( struct fd *fd, ioctl_code_t code, struct async *async );
+static void sock_cancel_async( struct fd *fd, struct async *async );
+static void sock_reselect_async( struct fd *fd, struct async_queue *queue );
+
+static int accept_into_socket( struct sock *sock, struct sock *acceptsock );
+static struct sock *accept_socket( struct sock *sock );
+static int sock_get_ntstatus( int err );
+static unsigned int sock_get_error( int err );
+static void poll_socket( struct sock *poll_sock, struct async *async, int exclusive, timeout_t timeout,
+                         unsigned int count, const struct afd_poll_socket_64 *sockets );
+
+static const struct object_ops sock_ops =
+{
+    sizeof(struct sock),          /* size */
+    &file_type,                   /* type */
+    sock_dump,                    /* dump */
+    NULL,                         /* add_queue */
+    NULL,                         /* remove_queue */
+    NULL,                         /* signaled */
+    NULL,                         /* satisfied */
+    no_signal,                    /* signal */
+    sock_get_fd,                  /* get_fd */
+    default_fd_get_sync,          /* get_sync */
+    default_map_access,           /* map_access */
+    default_get_sd,               /* get_sd */
+    default_set_sd,               /* set_sd */
+    no_get_full_name,             /* get_full_name */
+    no_lookup_name,               /* lookup_name */
+    no_link_name,                 /* link_name */
+    NULL,                         /* unlink_name */
+    no_open_file,                 /* open_file */
+    no_kernel_obj_list,           /* get_kernel_obj_list */
+    sock_close_handle,            /* close_handle */
+    sock_destroy                  /* destroy */
+};
+
+static const struct fd_ops sock_fd_ops =
+{
+    sock_get_poll_events,         /* get_poll_events */
+    sock_poll_event,              /* poll_event */
+    sock_get_fd_type,             /* get_fd_type */
+    no_fd_read,                   /* read */
+    no_fd_write,                  /* write */
+    no_fd_flush,                  /* flush */
+    default_fd_get_file_info,     /* get_file_info */
+    no_fd_get_volume_info,        /* get_volume_info */
+    sock_ioctl,                   /* ioctl */
+    sock_cancel_async,            /* cancel_async */
+    no_fd_queue_async,            /* queue_async */
+    sock_reselect_async           /* reselect_async */
+};
+
+static int sockaddr_from_unix( const union unix_sockaddr *uaddr, struct WS_sockaddr *wsaddr, socklen_t wsaddrlen )
+{
+    memset( wsaddr, 0, wsaddrlen );
+
+    switch (uaddr->addr.sa_family)
+    {
+    case AF_INET:
+    {
+        struct WS_sockaddr_in win = {0};
+
+        if (wsaddrlen < sizeof(win)) return -1;
+        win.sin_family = WS_AF_INET;
+        win.sin_port = uaddr->in.sin_port;
+        memcpy( &win.sin_addr, &uaddr->in.sin_addr, sizeof(win.sin_addr) );
+        memcpy( wsaddr, &win, sizeof(win) );
+        return sizeof(win);
+    }
+
+    case AF_INET6:
+    {
+        struct WS_sockaddr_in6 win = {0};
+
+        if (wsaddrlen < sizeof(win)) return -1;
+        win.sin6_family = WS_AF_INET6;
+        win.sin6_port = uaddr->in6.sin6_port;
+        win.sin6_flowinfo = uaddr->in6.sin6_flowinfo;
+        memcpy( &win.sin6_addr, &uaddr->in6.sin6_addr, sizeof(win.sin6_addr) );
+#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID
+        win.sin6_scope_id = uaddr->in6.sin6_scope_id;
+#endif
+        memcpy( wsaddr, &win, sizeof(win) );
+        return sizeof(win);
+    }
+
+#ifdef HAS_IPX
+    case AF_IPX:
+    {
+        struct WS_sockaddr_ipx win = {0};
+
+        if (wsaddrlen < sizeof(win)) return -1;
+        win.sa_family = WS_AF_IPX;
+        memcpy( win.sa_netnum, &uaddr->ipx.sipx_network, sizeof(win.sa_netnum) );
+        memcpy( win.sa_nodenum, &uaddr->ipx.sipx_node, sizeof(win.sa_nodenum) );
+        win.sa_socket = uaddr->ipx.sipx_port;
+        memcpy( wsaddr, &win, sizeof(win) );
+        return sizeof(win);
+    }
+#endif
+
+#ifdef HAS_IRDA
+    case AF_IRDA:
+    {
+        SOCKADDR_IRDA win;
+
+        if (wsaddrlen < sizeof(win)) return -1;
+        win.irdaAddressFamily = WS_AF_IRDA;
+        memcpy( win.irdaDeviceID, &uaddr->irda.sir_addr, sizeof(win.irdaDeviceID) );
+        if (uaddr->irda.sir_lsap_sel != LSAP_ANY)
+            snprintf( win.irdaServiceName, sizeof(win.irdaServiceName), "LSAP-SEL%u", uaddr->irda.sir_lsap_sel );
+        else
+            memcpy( win.irdaServiceName, uaddr->irda.sir_name, sizeof(win.irdaServiceName) );
+        memcpy( wsaddr, &win, sizeof(win) );
+        return sizeof(win);
+    }
+#endif
+
+#ifdef HAS_BLUETOOTH
+    case AF_BLUETOOTH:
+    {
+        SOCKADDR_BTH win = {0};
+        BLUETOOTH_ADDRESS addr = {0};
+
+        if (wsaddrlen < sizeof(win)) return -1;
+        win.addressFamily = WS_AF_BTH;
+
+        memcpy( addr.rgBytes, uaddr->rfcomm.rc_bdaddr.b, sizeof( addr.rgBytes ));
+        win.btAddr = addr.ullLong;
+        win.port = uaddr->rfcomm.rc_channel;
+        return sizeof(win);
+    }
+#endif
+    case AF_UNSPEC:
+        return 0;
+
+    default:
+        return -1;
+
+    }
+}
+
+static socklen_t sockaddr_to_unix( const struct WS_sockaddr *wsaddr, int wsaddrlen, union unix_sockaddr *uaddr )
+{
+    memset( uaddr, 0, sizeof(*uaddr) );
+
+    switch (wsaddr->sa_family)
+    {
+    case WS_AF_INET:
+    {
+        struct WS_sockaddr_in win = {0};
+
+        if (wsaddrlen < sizeof(win)) return 0;
+        memcpy( &win, wsaddr, sizeof(win) );
+        uaddr->in.sin_family = AF_INET;
+        uaddr->in.sin_port = win.sin_port;
+        memcpy( &uaddr->in.sin_addr, &win.sin_addr, sizeof(win.sin_addr) );
+        return sizeof(uaddr->in);
+    }
+
+    case WS_AF_INET6:
+    {
+        struct WS_sockaddr_in6 win = {0};
+
+        if (wsaddrlen < sizeof(win)) return 0;
+        memcpy( &win, wsaddr, sizeof(win) );
+        uaddr->in6.sin6_family = AF_INET6;
+        uaddr->in6.sin6_port = win.sin6_port;
+        uaddr->in6.sin6_flowinfo = win.sin6_flowinfo;
+        memcpy( &uaddr->in6.sin6_addr, &win.sin6_addr, sizeof(win.sin6_addr) );
+#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID
+        uaddr->in6.sin6_scope_id = win.sin6_scope_id;
+#endif
+        return sizeof(uaddr->in6);
+    }
+
+#ifdef HAS_IPX
+    case WS_AF_IPX:
+    {
+        struct WS_sockaddr_ipx win = {0};
+
+        if (wsaddrlen < sizeof(win)) return 0;
+        memcpy( &win, wsaddr, sizeof(win) );
+        uaddr->ipx.sipx_family = AF_IPX;
+        memcpy( &uaddr->ipx.sipx_network, win.sa_netnum, sizeof(win.sa_netnum) );
+        memcpy( &uaddr->ipx.sipx_node, win.sa_nodenum, sizeof(win.sa_nodenum) );
+        uaddr->ipx.sipx_port = win.sa_socket;
+        return sizeof(uaddr->ipx);
+    }
+#endif
+
+#ifdef HAS_IRDA
+    case WS_AF_IRDA:
+    {
+        SOCKADDR_IRDA win = {0};
+        unsigned int lsap_sel;
+
+        if (wsaddrlen < sizeof(win)) return 0;
+        memcpy( &win, wsaddr, sizeof(win) );
+        uaddr->irda.sir_family = AF_IRDA;
+        if (sscanf( win.irdaServiceName, "LSAP-SEL%u", &lsap_sel ) == 1)
+            uaddr->irda.sir_lsap_sel = lsap_sel;
+        else
+        {
+            uaddr->irda.sir_lsap_sel = LSAP_ANY;
+            memcpy( uaddr->irda.sir_name, win.irdaServiceName, sizeof(win.irdaServiceName) );
+        }
+        memcpy( &uaddr->irda.sir_addr, win.irdaDeviceID, sizeof(win.irdaDeviceID) );
+        return sizeof(uaddr->irda);
+    }
+#endif
+
+#ifdef HAS_BLUETOOTH
+    case WS_AF_BTH:
+    {
+        SOCKADDR_BTH win = {0};
+        BLUETOOTH_ADDRESS addr = {0};
+
+        if (wsaddrlen != sizeof(win)) return 0;
+        memcpy( &win, wsaddr, sizeof(win) );
+        addr.ullLong = win.btAddr;
+
+        uaddr->rfcomm.rc_family = AF_BLUETOOTH;
+        memcpy( &uaddr->rfcomm.rc_bdaddr, addr.rgBytes, sizeof( addr.rgBytes ) );
+        /* There can only be a maximum of 30 RFCOMM channels, so UINT8_MAX is safe to use here. */
+        uaddr->rfcomm.rc_channel = win.port == BT_PORT_ANY ? UINT8_MAX : win.port;
+        return sizeof(uaddr->rfcomm);
+    }
+#endif
+
+    case WS_AF_UNSPEC:
+        switch (wsaddrlen)
+        {
+        default: /* likely an ipv4 address */
+        case sizeof(struct WS_sockaddr_in):
+            return sizeof(uaddr->in);
+
+#ifdef HAS_IPX
+        case sizeof(struct WS_sockaddr_ipx):
+            return sizeof(uaddr->ipx);
+#endif
+
+#ifdef HAS_IRDA
+        case sizeof(SOCKADDR_IRDA):
+            return sizeof(uaddr->irda);
+#endif
+
+        case sizeof(struct WS_sockaddr_in6):
+            return sizeof(uaddr->in6);
+        }
+
+    default:
+        return 0;
+    }
+}
+
+static socklen_t get_unix_sockaddr_any( union unix_sockaddr *uaddr, int ws_family )
+{
+    memset( uaddr, 0, sizeof(*uaddr) );
+    switch (ws_family)
+    {
+        case WS_AF_INET:
+            uaddr->in.sin_family = AF_INET;
+            return sizeof(uaddr->in);
+        case WS_AF_INET6:
+            uaddr->in6.sin6_family = AF_INET6;
+            return sizeof(uaddr->in6);
+#ifdef HAS_IPX
+        case WS_AF_IPX:
+            uaddr->ipx.sipx_family = AF_IPX;
+            return sizeof(uaddr->ipx);
+#endif
+#ifdef HAS_IRDA
+        case WS_AF_IRDA:
+            uaddr->irda.sir_family = AF_IRDA;
+            return sizeof(uaddr->irda);
+#endif
+        default:
+            return 0;
+    }
+}
+
+/* some events are generated at the same time but must be sent in a particular
+ * order (e.g. CONNECT must be sent before READ) */
+static const enum afd_poll_bit event_bitorder[] =
+{
+    AFD_POLL_BIT_CONNECT,
+    AFD_POLL_BIT_CONNECT_ERR,
+    AFD_POLL_BIT_ACCEPT,
+    AFD_POLL_BIT_OOB,
+    AFD_POLL_BIT_READ,
+    AFD_POLL_BIT_WRITE,
+    AFD_POLL_BIT_RESET,
+    AFD_POLL_BIT_HUP,
+    AFD_POLL_BIT_CLOSE,
+};
+
+typedef enum {
+    SOCK_SHUTDOWN_ERROR = -1,
+    SOCK_SHUTDOWN_EOF = 0,
+    SOCK_SHUTDOWN_POLLHUP = 1
+} sock_shutdown_t;
+
+static sock_shutdown_t sock_shutdown_type = SOCK_SHUTDOWN_ERROR;
+
+static sock_shutdown_t sock_check_pollhup(void)
+{
+    sock_shutdown_t ret = SOCK_SHUTDOWN_ERROR;
+    int fd[2], n;
+    struct pollfd pfd;
+    char dummy;
+
+    if ( socketpair( AF_UNIX, SOCK_STREAM, 0, fd ) ) return ret;
+    if ( shutdown( fd[0], 1 ) ) goto out;
+
+    pfd.fd = fd[1];
+    pfd.events = POLLIN;
+    pfd.revents = 0;
+
+    /* Solaris' poll() sometimes returns nothing if given a 0ms timeout here */
+    n = poll( &pfd, 1, 1 );
+    if ( n != 1 ) goto out; /* error or timeout */
+    if ( pfd.revents & POLLHUP )
+        ret = SOCK_SHUTDOWN_POLLHUP;
+    else if ( pfd.revents & POLLIN &&
+              read( fd[1], &dummy, 1 ) == 0 )
+        ret = SOCK_SHUTDOWN_EOF;
+
+out:
+    close( fd[0] );
+    close( fd[1] );
+    return ret;
+}
+
+void sock_init(void)
+{
+    sock_shutdown_type = sock_check_pollhup();
+
+    switch ( sock_shutdown_type )
+    {
+    case SOCK_SHUTDOWN_EOF:
+        if (debug_level) fprintf( stderr, "sock_init: shutdown() causes EOF\n" );
+        break;
+    case SOCK_SHUTDOWN_POLLHUP:
+        if (debug_level) fprintf( stderr, "sock_init: shutdown() causes POLLHUP\n" );
+        break;
+    default:
+        fprintf( stderr, "sock_init: ERROR in sock_check_pollhup()\n" );
+        sock_shutdown_type = SOCK_SHUTDOWN_EOF;
+    }
+}
+
+static void sock_reselect( struct sock *sock )
+{
+    int ev = sock_get_poll_events( sock->fd );
+
+    if (debug_level)
+        fprintf(stderr,"sock_reselect(%p): new mask %x\n", sock, ev);
+
+    set_fd_events( sock->fd, ev );
+}
+
+static unsigned int afd_poll_flag_to_win32( unsigned int flags )
+{
+    static const unsigned int map[] =
+    {
+        FD_READ,    /* READ */
+        FD_OOB,     /* OOB */
+        FD_WRITE,   /* WRITE */
+        FD_CLOSE,   /* HUP */
+        FD_CLOSE,   /* RESET */
+        0,          /* CLOSE */
+        FD_CONNECT, /* CONNECT */
+        FD_ACCEPT,  /* ACCEPT */
+        FD_CONNECT, /* CONNECT_ERR */
+    };
+
+    unsigned int i, ret = 0;
+
+    for (i = 0; i < ARRAY_SIZE(map); ++i)
+    {
+        if (flags & (1 << i)) ret |= map[i];
+    }
+
+    return ret;
+}
+
+static void post_sock_messages( struct sock *sock )
+{
+    unsigned int events = sock->pending_events & sock->mask;
+    int i;
+
+    if (sock->window)
+    {
+        if (debug_level) fprintf(stderr, "signalling events %x win %08x\n", events, sock->window );
+        for (i = 0; i < ARRAY_SIZE(event_bitorder); i++)
+        {
+            enum afd_poll_bit event = event_bitorder[i];
+            if (events & (1 << event))
+            {
+                lparam_t lparam;
+                if (event == AFD_POLL_BIT_RESET)
+                    lparam = FD_CLOSE | (WSAECONNABORTED << 16);
+                else
+                    lparam = afd_poll_flag_to_win32(1 << event) | (sock_get_error( sock->errors[event] ) << 16);
+                post_message( sock->window, sock->message, sock->wparam, lparam );
+            }
+        }
+        sock->pending_events = 0;
+        sock_reselect( sock );
+    }
+}
+
+static inline int sock_error( struct sock *sock, int *poll_event )
+{
+    int error = 0;
+    socklen_t len = sizeof(error);
+
+    getsockopt( get_unix_fd(sock->fd), SOL_SOCKET, SO_ERROR, (void *)&error, &len);
+
+    switch (sock->state)
+    {
+    case SOCK_UNCONNECTED:
+        break;
+
+    case SOCK_CONNECTING:
+        if (error)
+            sock->errors[AFD_POLL_BIT_CONNECT_ERR] = error;
+        else
+            error = sock->errors[AFD_POLL_BIT_CONNECT_ERR];
+        break;
+
+    case SOCK_LISTENING:
+        if (error)
+            sock->errors[AFD_POLL_BIT_ACCEPT] = error;
+        else
+            error = sock->errors[AFD_POLL_BIT_ACCEPT];
+        break;
+
+    case SOCK_CONNECTIONLESS:
+        if (error == ENETUNREACH || error == EHOSTUNREACH || error == ECONNRESET)
+        {
+            if (poll_event) *poll_event &= ~POLLERR;
+            return 0;
+        }
+        /* fallthrough */
+    case SOCK_CONNECTED:
+        if (error == ECONNRESET || error == EPIPE)
+        {
+            sock->reset = 1;
+            error = 0;
+        }
+        else if (error)
+            sock->errors[AFD_POLL_BIT_HUP] = error;
+        else
+            error = sock->errors[AFD_POLL_BIT_HUP];
+        break;
+    }
+
+    return error;
+}
+
+static void free_accept_req( void *private )
+{
+    struct accept_req *req = private;
+    list_remove( &req->entry );
+    if (req->acceptsock)
+    {
+        req->acceptsock->accept_recv_req = NULL;
+        release_object( req->acceptsock );
+    }
+    release_object( req->async );
+    release_object( req->iosb );
+    release_object( req->sock );
+    free( req );
+}
+
+static void fill_accept_output( struct accept_req *req )
+{
+    const data_size_t out_size = req->iosb->out_size;
+    struct async *async = req->async;
+    union unix_sockaddr unix_addr;
+    struct WS_sockaddr *win_addr;
+    unsigned int remote_len;
+    socklen_t unix_len;
+    int fd, size = 0;
+    char *out_data;
+    int win_len;
+
+    if (!(out_data = mem_alloc( out_size )))
+    {
+        async_terminate( async, get_error() );
+        return;
+    }
+
+    fd = get_unix_fd( req->acceptsock->fd );
+
+    if (req->recv_len && (size = recv( fd, out_data, req->recv_len, 0 )) < 0)
+    {
+        if (!req->accepted && errno == EWOULDBLOCK)
+        {
+            req->accepted = 1;
+            sock_reselect( req->acceptsock );
+            return;
+        }
+
+        async_terminate( async, sock_get_ntstatus( errno ) );
+        free( out_data );
+        return;
+    }
+
+    if (req->local_len)
+    {
+        if (req->local_len < sizeof(int))
+        {
+            async_terminate( async, STATUS_BUFFER_TOO_SMALL );
+            free( out_data );
+            return;
+        }
+
+        unix_len = sizeof(unix_addr);
+        win_addr = (struct WS_sockaddr *)(out_data + req->recv_len + sizeof(int));
+        if (getsockname( fd, &unix_addr.addr, &unix_len ) < 0 ||
+            (win_len = sockaddr_from_unix( &unix_addr, win_addr, req->local_len - sizeof(int) )) < 0)
+        {
+            async_terminate( async, sock_get_ntstatus( errno ) );
+            free( out_data );
+            return;
+        }
+        memcpy( out_data + req->recv_len, &win_len, sizeof(int) );
+    }
+
+    unix_len = sizeof(unix_addr);
+    win_addr = (struct WS_sockaddr *)(out_data + req->recv_len + req->local_len + sizeof(int));
+    remote_len = out_size - req->recv_len - req->local_len;
+    if (getpeername( fd, &unix_addr.addr, &unix_len ) < 0 ||
+        (win_len = sockaddr_from_unix( &unix_addr, win_addr, remote_len - sizeof(int) )) < 0)
+    {
+        async_terminate( async, sock_get_ntstatus( errno ) );
+        free( out_data );
+        return;
+    }
+    memcpy( out_data + req->recv_len + req->local_len, &win_len, sizeof(int) );
+
+    async_request_complete( req->async, STATUS_SUCCESS, size, out_size, out_data );
+}
+
+static void complete_async_accept( struct sock *sock, struct accept_req *req )
+{
+    struct sock *acceptsock = req->acceptsock;
+    struct async *async = req->async;
+
+    if (debug_level) fprintf( stderr, "completing accept request for socket %p\n", sock );
+
+    if (acceptsock)
+    {
+        if (!accept_into_socket( sock, acceptsock ))
+        {
+            async_terminate( async, get_error() );
+            return;
+        }
+        fill_accept_output( req );
+    }
+    else
+    {
+        obj_handle_t handle;
+
+        if (!(acceptsock = accept_socket( sock )))
+        {
+            async_terminate( async, get_error() );
+            return;
+        }
+        handle = alloc_handle_no_access_check( async_get_thread( async )->process, &acceptsock->obj,
+                                               GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, OBJ_INHERIT );
+        acceptsock->wparam = handle;
+        sock_reselect( acceptsock );
+        release_object( acceptsock );
+        if (!handle)
+        {
+            async_terminate( async, get_error() );
+            return;
+        }
+
+        async_request_complete_alloc( req->async, STATUS_SUCCESS, 0, sizeof(handle), &handle );
+    }
+}
+
+static void complete_async_accept_recv( struct accept_req *req )
+{
+    if (debug_level) fprintf( stderr, "completing accept recv request for socket %p\n", req->acceptsock );
+
+    assert( req->recv_len );
+
+    fill_accept_output( req );
+}
+
+static void free_connect_req( void *private )
+{
+    struct connect_req *req = private;
+
+    req->sock->connect_req = NULL;
+    release_object( req->async );
+    release_object( req->iosb );
+    release_object( req->sock );
+    free( req );
+}
+
+static void complete_async_connect( struct sock *sock )
+{
+    struct connect_req *req = sock->connect_req;
+    const char *in_buffer;
+    size_t len;
+    int ret;
+
+    if (debug_level) fprintf( stderr, "completing connect request for socket %p\n", sock );
+
+    if (!req->send_len)
+    {
+        async_terminate( req->async, STATUS_SUCCESS );
+        return;
+    }
+
+    in_buffer = (const char *)req->iosb->in_data + sizeof(struct afd_connect_params) + req->addr_len;
+    len = req->send_len - req->send_cursor;
+
+    ret = send( get_unix_fd( sock->fd ), in_buffer + req->send_cursor, len, 0 );
+    if (ret < 0 && errno != EWOULDBLOCK)
+        async_terminate( req->async, sock_get_ntstatus( errno ) );
+    else if (ret == len)
+        async_request_complete( req->async, STATUS_SUCCESS, req->send_len, 0, NULL );
+    else
+        req->send_cursor += ret;
+}
+
+static void free_poll_req( void *private )
+{
+    struct poll_req *req = private;
+    unsigned int i;
+
+    if (req->timeout) remove_timeout_user( req->timeout );
+
+    for (i = 0; i < req->count; ++i)
+        release_object( req->sockets[i].sock );
+    release_object( req->async );
+    release_object( req->iosb );
+    list_remove( &req->entry );
+    free( req );
+}
+
+static int is_oobinline( struct sock *sock )
+{
+    int oobinline;
+    socklen_t len = sizeof(oobinline);
+    return !getsockopt( get_unix_fd( sock->fd ), SOL_SOCKET, SO_OOBINLINE, (char *)&oobinline, &len ) && oobinline;
+}
+
+static int get_poll_flags( struct sock *sock, int event )
+{
+    int flags = 0;
+
+    /* A connection-mode socket which has never been connected does not return
+     * write or hangup events, but Linux reports POLLOUT | POLLHUP. */
+    if (sock->state == SOCK_UNCONNECTED)
+        event &= ~(POLLOUT | POLLHUP);
+
+    if (event & POLLIN)
+    {
+        if (sock->state == SOCK_LISTENING)
+            flags |= AFD_POLL_ACCEPT;
+        else
+            flags |= AFD_POLL_READ;
+    }
+    if (event & POLLPRI)
+        flags |= is_oobinline( sock ) ? AFD_POLL_READ : AFD_POLL_OOB;
+    if (event & POLLOUT)
+        flags |= AFD_POLL_WRITE;
+    if (sock->state == SOCK_CONNECTED)
+        flags |= AFD_POLL_CONNECT;
+    if (event & POLLHUP)
+        flags |= AFD_POLL_HUP;
+    if (event & POLLERR)
+        flags |= AFD_POLL_CONNECT_ERR;
+    if (sock->reset)
+        flags |= AFD_POLL_RESET;
+
+    return flags;
+}
+
+static void complete_async_poll( struct poll_req *req, unsigned int status )
+{
+    unsigned int i, signaled_count = 0;
+
+    for (i = 0; i < req->count; ++i)
+    {
+        struct sock *sock = req->sockets[i].sock;
+
+        if (sock->main_poll == req)
+            sock->main_poll = NULL;
+    }
+
+    if (!status)
+    {
+        for (i = 0; i < req->count; ++i)
+        {
+            if (req->sockets[i].flags)
+                ++signaled_count;
+        }
+    }
+
+    if (is_machine_64bit( async_get_thread( req->async )->process->machine ))
+    {
+        size_t output_size = offsetof( struct afd_poll_params_64, sockets[signaled_count] );
+        struct afd_poll_params_64 *output;
+
+        if (!(output = mem_alloc( output_size )))
+        {
+            async_terminate( req->async, get_error() );
+            return;
+        }
+        memset( output, 0, output_size );
+        output->timeout = req->orig_timeout;
+        output->exclusive = req->exclusive;
+        for (i = 0; i < req->count; ++i)
+        {
+            if (!req->sockets[i].flags) continue;
+            output->sockets[output->count].socket = req->sockets[i].handle;
+            output->sockets[output->count].flags = req->sockets[i].flags;
+            output->sockets[output->count].status = req->sockets[i].status;
+            ++output->count;
+        }
+        assert( output->count == signaled_count );
+
+        async_request_complete( req->async, status, output_size, output_size, output );
+    }
+    else
+    {
+        size_t output_size = offsetof( struct afd_poll_params_32, sockets[signaled_count] );
+        struct afd_poll_params_32 *output;
+
+        if (!(output = mem_alloc( output_size )))
+        {
+            async_terminate( req->async, get_error() );
+            return;
+        }
+        memset( output, 0, output_size );
+        output->timeout = req->orig_timeout;
+        output->exclusive = req->exclusive;
+        for (i = 0; i < req->count; ++i)
+        {
+            if (!req->sockets[i].flags) continue;
+            output->sockets[output->count].socket = req->sockets[i].handle;
+            output->sockets[output->count].flags = req->sockets[i].flags;
+            output->sockets[output->count].status = req->sockets[i].status;
+            ++output->count;
+        }
+        assert( output->count == signaled_count );
+
+        async_request_complete( req->async, status, output_size, output_size, output );
+    }
+}
+
+static void complete_async_polls( struct sock *sock, int event, int error )
+{
+    int flags = get_poll_flags( sock, event );
+    struct poll_req *req, *next;
+
+    LIST_FOR_EACH_ENTRY_SAFE( req, next, &poll_list, struct poll_req, entry )
+    {
+        unsigned int i;
+
+        if (req->iosb->status != STATUS_PENDING) continue;
+
+        for (i = 0; i < req->count; ++i)
+        {
+            if (req->sockets[i].sock != sock) continue;
+            if (!(req->sockets[i].mask & flags)) continue;
+
+            if (debug_level)
+                fprintf( stderr, "completing poll for socket %p, wanted %#x got %#x\n",
+                         sock, req->sockets[i].mask, flags );
+
+            req->sockets[i].flags = req->sockets[i].mask & flags;
+            req->sockets[i].status = sock_get_ntstatus( error );
+
+            if (req->pending)
+            {
+                complete_async_poll( req, STATUS_SUCCESS );
+                break;
+            }
+        }
+    }
+}
+
+static void async_poll_timeout( void *private )
+{
+    struct poll_req *req = private;
+
+    req->timeout = NULL;
+
+    if (req->iosb->status != STATUS_PENDING) return;
+
+    complete_async_poll( req, STATUS_TIMEOUT );
+}
+
+static int sock_dispatch_asyncs( struct sock *sock, int event, int error )
+{
+    if (event & (POLLIN | POLLPRI))
+    {
+        struct accept_req *req;
+
+        LIST_FOR_EACH_ENTRY( req, &sock->accept_list, struct accept_req, entry )
+        {
+            if (req->iosb->status == STATUS_PENDING && !req->accepted)
+            {
+                complete_async_accept( sock, req );
+                event &= ~POLLIN;
+                break;
+            }
+        }
+
+        if (sock->accept_recv_req && sock->accept_recv_req->iosb->status == STATUS_PENDING)
+            complete_async_accept_recv( sock->accept_recv_req );
+    }
+
+    if ((event & POLLOUT) && sock->connect_req && sock->connect_req->iosb->status == STATUS_PENDING)
+        complete_async_connect( sock );
+
+    if ((event & (POLLIN | POLLPRI)) && async_queued( &sock->read_q ))
+    {
+        if (async_waiting( &sock->read_q ))
+        {
+            if (debug_level) fprintf( stderr, "activating read queue for socket %p\n", sock );
+            async_wake_up( &sock->read_q, STATUS_ALERTED );
+        }
+        event &= ~(POLLIN | POLLPRI);
+    }
+
+    if ((event & POLLOUT) && async_queue_has_waiting_asyncs( &sock->write_q ))
+    {
+        if (async_waiting( &sock->write_q ))
+        {
+            if (debug_level) fprintf( stderr, "activating write queue for socket %p\n", sock );
+            async_wake_up( &sock->write_q, STATUS_ALERTED );
+        }
+        event &= ~POLLOUT;
+    }
+
+    if (event & (POLLERR | POLLHUP))
+    {
+        int status = sock_get_ntstatus( error );
+        struct accept_req *req, *next;
+
+        async_wake_up( &sock->read_q, status );
+        async_wake_up( &sock->write_q, status );
+
+        LIST_FOR_EACH_ENTRY_SAFE( req, next, &sock->accept_list, struct accept_req, entry )
+        {
+            if (req->iosb->status == STATUS_PENDING)
+                async_terminate( req->async, status );
+        }
+
+        if (sock->accept_recv_req && sock->accept_recv_req->iosb->status == STATUS_PENDING)
+            async_terminate( sock->accept_recv_req->async, status );
+
+        if (sock->connect_req)
+            async_terminate( sock->connect_req->async, status );
+    }
+
+    if (sock->reset)
+    {
+        async_wake_up( &sock->read_q, STATUS_CONNECTION_RESET );
+        async_wake_up( &sock->write_q, STATUS_CONNECTION_RESET );
+
+        if (sock->accept_recv_req && sock->accept_recv_req->iosb->status == STATUS_PENDING)
+            async_terminate( sock->accept_recv_req->async, STATUS_CONNECTION_RESET );
+    }
+
+    return event;
+}
+
+static void post_socket_event( struct sock *sock, enum afd_poll_bit event_bit )
+{
+    unsigned int event = (1 << event_bit);
+
+    if (!(sock->reported_events & event))
+    {
+        sock->pending_events |= event;
+        sock->reported_events |= event;
+
+        if ((sock->mask & event) && sock->event)
+            set_event( sock->event );
+    }
+}
+
+static void sock_dispatch_events( struct sock *sock, enum connection_state prevstate, int event )
+{
+    switch (prevstate)
+    {
+    case SOCK_UNCONNECTED:
+        break;
+
+    case SOCK_CONNECTING:
+        if (event & POLLOUT)
+        {
+            post_socket_event( sock, AFD_POLL_BIT_CONNECT );
+            post_socket_event( sock, AFD_POLL_BIT_WRITE );
+        }
+        if (event & (POLLERR | POLLHUP))
+            post_socket_event( sock, AFD_POLL_BIT_CONNECT_ERR );
+        break;
+
+    case SOCK_LISTENING:
+        if (event & (POLLIN | POLLERR | POLLHUP))
+            post_socket_event( sock, AFD_POLL_BIT_ACCEPT );
+        break;
+
+    case SOCK_CONNECTED:
+    case SOCK_CONNECTIONLESS:
+        if (sock->reset)
+            post_socket_event( sock, AFD_POLL_BIT_RESET );
+
+        if (event & POLLIN)
+            post_socket_event( sock, AFD_POLL_BIT_READ );
+
+        if (event & POLLOUT)
+            post_socket_event( sock, AFD_POLL_BIT_WRITE );
+
+        if (event & POLLPRI)
+            post_socket_event( sock, AFD_POLL_BIT_OOB );
+
+        if (event & (POLLERR | POLLHUP))
+            post_socket_event( sock, AFD_POLL_BIT_HUP );
+        break;
+    }
+
+    post_sock_messages( sock );
+}
+
+static void sock_poll_event( struct fd *fd, int event )
+{
+    struct sock *sock = get_fd_user( fd );
+    int hangup_seen = 0;
+    enum connection_state prevstate = sock->state;
+    int error = 0;
+
+    assert( sock->obj.ops == &sock_ops );
+    grab_object( sock );
+
+    if (debug_level)
+        fprintf(stderr, "socket %p select event: %x\n", sock, event);
+
+    if (event & (POLLERR | POLLHUP))
+        error = sock_error( sock, &event );
+
+    switch (sock->state)
+    {
+    case SOCK_UNCONNECTED:
+        break;
+
+    case SOCK_CONNECTING:
+        if (event & (POLLERR|POLLHUP))
+        {
+            sock->state = SOCK_UNCONNECTED;
+            event &= ~POLLOUT;
+        }
+        else if (event & POLLOUT)
+        {
+            sock->state = SOCK_CONNECTED;
+            sock->connect_time = current_time;
+            sock->errors[AFD_POLL_BIT_CONNECT_ERR] = 0;
+        }
+        break;
+
+    case SOCK_LISTENING:
+        break;
+
+    case SOCK_CONNECTED:
+    case SOCK_CONNECTIONLESS:
+        if (sock->reset)
+            event &= ~(POLLIN | POLLERR | POLLHUP);
+
+        if (sock->type == WS_SOCK_STREAM && (event & POLLIN))
+        {
+            char dummy;
+            int nr;
+
+            /* Linux 2.4 doesn't report POLLHUP if only one side of the socket
+             * has been closed, so we need to check for it explicitly here */
+            nr  = recv( get_unix_fd( fd ), &dummy, 1, MSG_PEEK );
+            if ( nr == 0 )
+            {
+                hangup_seen = 1;
+                event &= ~POLLIN;
+            }
+            else if ( nr < 0 )
+            {
+                event &= ~POLLIN;
+                /* EAGAIN can happen if an async recv() falls between the server's poll()
+                   call and the invocation of this routine */
+                if (errno == ECONNRESET || errno == EPIPE)
+                {
+                    sock->reset = 1;
+                }
+                else if (errno != EAGAIN)
+                {
+                    error = errno;
+                    event |= POLLERR;
+                    sock->errors[AFD_POLL_BIT_HUP] = error;
+                    if ( debug_level )
+                        fprintf( stderr, "recv error on socket %p: %d\n", sock, errno );
+                }
+            }
+        }
+
+        if (hangup_seen || (sock_shutdown_type == SOCK_SHUTDOWN_POLLHUP && (event & POLLHUP)))
+        {
+            sock->hangup = 1;
+        }
+        else if (event & (POLLHUP | POLLERR))
+        {
+            sock->aborted = 1;
+
+            if (debug_level)
+                fprintf( stderr, "socket %p aborted by error %d, event %#x\n", sock, error, event );
+        }
+
+        if (hangup_seen)
+            event |= POLLHUP;
+        break;
+    }
+
+    event = sock_dispatch_asyncs( sock, event, error );
+    sock_dispatch_events( sock, prevstate, event );
+    complete_async_polls( sock, event, error );
+
+    sock_reselect( sock );
+    release_object( sock );
+}
+
+static void sock_dump( struct object *obj, int verbose )
+{
+    struct sock *sock = (struct sock *)obj;
+    assert( obj->ops == &sock_ops );
+    fprintf( stderr, "Socket fd=%p, state=%x, mask=%x, pending=%x, reported=%x\n",
+            sock->fd, sock->state,
+            sock->mask, sock->pending_events, sock->reported_events );
+}
+
+static int poll_flags_from_afd( struct sock *sock, int flags )
+{
+    int ev = 0;
+
+    /* A connection-mode socket which has never been connected does
+     * not return write or hangup events, but Linux returns
+     * POLLOUT | POLLHUP. */
+    if (sock->state == SOCK_UNCONNECTED)
+        return -1;
+
+    if (flags & (AFD_POLL_READ | AFD_POLL_ACCEPT))
+        ev |= POLLIN;
+    if ((flags & AFD_POLL_HUP) && sock->type == WS_SOCK_STREAM)
+        ev |= POLLIN;
+    if (flags & AFD_POLL_OOB)
+        ev |= is_oobinline( sock ) ? POLLIN : POLLPRI;
+    if (flags & AFD_POLL_WRITE)
+        ev |= POLLOUT;
+
+    return ev;
+}
+
+static int sock_get_poll_events( struct fd *fd )
+{
+    struct sock *sock = get_fd_user( fd );
+    unsigned int mask = sock->mask & ~sock->reported_events;
+    struct poll_req *req;
+    int ev = 0;
+
+    assert( sock->obj.ops == &sock_ops );
+
+    if (!sock->type) /* not initialized yet */
+        return -1;
+
+    LIST_FOR_EACH_ENTRY( req, &poll_list, struct poll_req, entry )
+    {
+        unsigned int i;
+
+        if (req->iosb->status != STATUS_PENDING) continue;
+
+        for (i = 0; i < req->count; ++i)
+        {
+            if (req->sockets[i].sock != sock) continue;
+
+            ev |= poll_flags_from_afd( sock, req->sockets[i].mask );
+        }
+    }
+
+    switch (sock->state)
+    {
+    case SOCK_UNCONNECTED:
+        /* A connection-mode Windows socket which has never been connected does
+         * not return any events, but Linux returns POLLOUT | POLLHUP. Hence we
+         * need to return -1 here, to prevent the socket from being polled on at
+         * all. */
+        return -1;
+
+    case SOCK_CONNECTING:
+        return POLLOUT;
+
+    case SOCK_LISTENING:
+        if (!list_empty( &sock->accept_list ) || (mask & AFD_POLL_ACCEPT))
+            ev |= POLLIN;
+        break;
+
+    case SOCK_CONNECTED:
+    case SOCK_CONNECTIONLESS:
+        if (sock->hangup && sock->wr_shutdown && !sock->wr_shutdown_pending)
+        {
+            /* Linux returns POLLHUP if a socket is both SHUT_RD and SHUT_WR, or
+             * if both the socket and its peer are SHUT_WR.
+             *
+             * We don't use SHUT_RD, so we can only encounter this in the latter
+             * case. In that case there can't be any pending read requests (they
+             * would have already been completed with a length of zero), the
+             * above condition ensures that we don't have any pending write
+             * requests, and nothing that can change about the socket state that
+             * would complete a pending poll request. */
+            return -1;
+        }
+
+        if (sock->aborted || sock->reset)
+            return -1;
+
+        if (sock->accept_recv_req)
+        {
+            ev |= POLLIN;
+        }
+        else if (async_queued( &sock->read_q ))
+        {
+            /* Clear POLLIN and POLLPRI if we have an alerted async, even if
+             * we're polling this socket for READ or OOB. We can't signal the
+             * poll if the pending async will read all of the data [cf. the
+             * matching logic in sock_dispatch_asyncs()], but we also don't
+             * want to spin polling for POLLIN if we're not going to use it. */
+            if (async_waiting( &sock->read_q ))
+                ev |= POLLIN | POLLPRI;
+            else
+                ev &= ~(POLLIN | POLLPRI);
+        }
+        else
+        {
+            /* Don't ask for POLLIN if we got a hangup. We won't receive more
+             * data anyway, but we will get POLLIN if SOCK_SHUTDOWN_EOF. */
+            if (!sock->hangup)
+            {
+                if (mask & AFD_POLL_READ)
+                    ev |= POLLIN;
+                if (mask & AFD_POLL_OOB)
+                    ev |= POLLPRI;
+            }
+
+            /* We use POLLIN with 0 bytes recv() as hangup indication for stream sockets. */
+            if (sock->state == SOCK_CONNECTED && (mask & AFD_POLL_HUP) && !(sock->reported_events & AFD_POLL_READ))
+                ev |= POLLIN;
+        }
+
+        if (async_queued( &sock->write_q ))
+        {
+            /* As with read asyncs above, clear POLLOUT if we have an alerted
+             * async. */
+            if (async_waiting( &sock->write_q ))
+                ev |= POLLOUT;
+            else
+                ev &= ~POLLOUT;
+        }
+        else if (!sock->wr_shutdown && (mask & AFD_POLL_WRITE))
+        {
+            ev |= POLLOUT;
+        }
+
+        break;
+    }
+
+    return ev;
+}
+
+static enum server_fd_type sock_get_fd_type( struct fd *fd )
+{
+    return FD_TYPE_SOCKET;
+}
+
+static void sock_cancel_async( struct fd *fd, struct async *async )
+{
+    struct poll_req *req;
+
+    LIST_FOR_EACH_ENTRY( req, &poll_list, struct poll_req, entry )
+    {
+        unsigned int i;
+
+        if (req->async != async)
+            continue;
+
+        for (i = 0; i < req->count; i++)
+        {
+            struct sock *sock = req->sockets[i].sock;
+
+            if (sock->main_poll == req)
+                sock->main_poll = NULL;
+        }
+    }
+
+    async_terminate( async, STATUS_CANCELLED );
+}
+
+static void sock_reselect_async( struct fd *fd, struct async_queue *queue )
+{
+    struct sock *sock = get_fd_user( fd );
+
+    if (sock->wr_shutdown_pending && list_empty( &sock->write_q.queue ))
+    {
+        shutdown( get_unix_fd( sock->fd ), SHUT_WR );
+        sock->wr_shutdown_pending = 0;
+    }
+
+    /* Don't reselect the ifchange queue; we always ask for POLLIN.
+     * Don't reselect an uninitialized socket; we can't call set_fd_events() on
+     * a pseudo-fd. */
+    if (queue != &sock->ifchange_q && sock->type)
+        sock_reselect( sock );
+}
+
+static struct fd *sock_get_fd( struct object *obj )
+{
+    struct sock *sock = (struct sock *)obj;
+    return (struct fd *)grab_object( sock->fd );
+}
+
+static int sock_close_handle( struct object *obj, struct process *process, obj_handle_t handle )
+{
+    struct sock *sock = (struct sock *)obj;
+
+    if (sock->obj.handle_count == 1) /* last handle */
+    {
+        struct accept_req *accept_req, *accept_next;
+        struct poll_req *poll_req, *poll_next;
+
+        if (sock->accept_recv_req)
+            async_terminate( sock->accept_recv_req->async, STATUS_CANCELLED );
+
+        LIST_FOR_EACH_ENTRY_SAFE( accept_req, accept_next, &sock->accept_list, struct accept_req, entry )
+            async_terminate( accept_req->async, STATUS_CANCELLED );
+
+        if (sock->connect_req)
+            async_terminate( sock->connect_req->async, STATUS_CANCELLED );
+
+        LIST_FOR_EACH_ENTRY_SAFE( poll_req, poll_next, &poll_list, struct poll_req, entry )
+        {
+            struct iosb *iosb = poll_req->iosb;
+            BOOL signaled = FALSE;
+            unsigned int i;
+
+            if (iosb->status != STATUS_PENDING) continue;
+
+            for (i = 0; i < poll_req->count; ++i)
+            {
+                if (poll_req->sockets[i].sock == sock)
+                {
+                    signaled = TRUE;
+                    poll_req->sockets[i].flags = AFD_POLL_CLOSE;
+                    poll_req->sockets[i].status = 0;
+                }
+            }
+
+            if (signaled) complete_async_poll( poll_req, STATUS_SUCCESS );
+        }
+    }
+    return async_close_obj_handle( obj, process, handle );
+}
+
+static void sock_destroy( struct object *obj )
+{
+    struct sock *sock = (struct sock *)obj;
+    unsigned int i;
+
+    assert( obj->ops == &sock_ops );
+
+    /* FIXME: special socket shutdown stuff? */
+
+    for (i = 0; i < 2; ++i)
+    {
+        if (sock->bound_addr[i] && --sock->bound_addr[i]->reuse_count <= 0)
+        {
+            rb_remove( &bound_addresses_tree, &sock->bound_addr[i]->entry );
+            free( sock->bound_addr[i] );
+        }
+    }
+
+    if ( sock->deferred )
+        release_object( sock->deferred );
+
+    async_wake_up( &sock->ifchange_q, STATUS_CANCELLED );
+    sock_release_ifchange( sock );
+    free_async_queue( &sock->read_q );
+    free_async_queue( &sock->write_q );
+    free_async_queue( &sock->ifchange_q );
+    free_async_queue( &sock->accept_q );
+    free_async_queue( &sock->connect_q );
+    free_async_queue( &sock->poll_q );
+    if (sock->event) release_object( sock->event );
+    if (sock->fd) release_object( sock->fd );
+}
+
+static struct sock *create_socket(void)
+{
+    struct sock *sock;
+
+    if (!(sock = alloc_object( &sock_ops ))) return NULL;
+    sock->fd      = NULL;
+    sock->state   = SOCK_UNCONNECTED;
+    sock->mask    = 0;
+    sock->pending_events = 0;
+    sock->reported_events = 0;
+    sock->proto   = 0;
+    sock->type    = 0;
+    sock->family  = 0;
+    sock->event   = NULL;
+    sock->window  = 0;
+    sock->message = 0;
+    sock->wparam  = 0;
+    sock->connect_time = 0;
+    sock->deferred = NULL;
+    sock->ifchange_obj = NULL;
+    sock->accept_recv_req = NULL;
+    sock->connect_req = NULL;
+    sock->main_poll = NULL;
+    memset( &sock->addr, 0, sizeof(sock->addr) );
+    sock->addr_len = 0;
+    memset( &sock->peer_addr, 0, sizeof(sock->peer_addr) );
+    sock->peer_addr_len = 0;
+    sock->rd_shutdown = 0;
+    sock->wr_shutdown = 0;
+    sock->wr_shutdown_pending = 0;
+    sock->hangup = 0;
+    sock->aborted = 0;
+    sock->nonblocking = 0;
+    sock->bound = 0;
+    sock->reset = 0;
+    sock->reuseaddr = 0;
+    sock->exclusiveaddruse = 0;
+    sock->rcvbuf = 0;
+    sock->sndbuf = 0;
+    sock->rcvtimeo = 0;
+    sock->sndtimeo = 0;
+    sock->icmp_fixup_data_len = 0;
+    sock->bound_addr[0] = sock->bound_addr[1] = NULL;
+    init_async_queue( &sock->read_q );
+    init_async_queue( &sock->write_q );
+    init_async_queue( &sock->ifchange_q );
+    init_async_queue( &sock->accept_q );
+    init_async_queue( &sock->connect_q );
+    init_async_queue( &sock->poll_q );
+    memset( sock->errors, 0, sizeof(sock->errors) );
+    list_init( &sock->accept_list );
+    return sock;
+}
+
+static int get_unix_family( int family )
+{
+    switch (family)
+    {
+        case WS_AF_INET: return AF_INET;
+        case WS_AF_INET6: return AF_INET6;
+#ifdef HAS_IPX
+        case WS_AF_IPX: return AF_IPX;
+#endif
+#ifdef AF_IRDA
+        case WS_AF_IRDA: return AF_IRDA;
+#endif
+#ifdef AF_BLUETOOTH
+        case WS_AF_BTH: return AF_BLUETOOTH;
+#endif
+        case WS_AF_UNSPEC: return AF_UNSPEC;
+        default: return -1;
+    }
+}
+
+static int get_unix_type( int type )
+{
+    switch (type)
+    {
+        case WS_SOCK_DGRAM: return SOCK_DGRAM;
+        case WS_SOCK_RAW: return SOCK_RAW;
+        case WS_SOCK_STREAM: return SOCK_STREAM;
+        default: return -1;
+    }
+}
+
+static int get_unix_protocol( int family, int protocol )
+{
+    if (protocol >= WS_NSPROTO_IPX && protocol <= WS_NSPROTO_IPX + 255)
+        return protocol;
+
+#ifdef HAS_BLUETOOTH
+    if (family == WS_AF_BTH)
+        return protocol == WS_BTHPROTO_RFCOMM ? BTPROTO_RFCOMM : -1;
+#endif
+
+    switch (protocol)
+    {
+        case WS_IPPROTO_ICMP: return IPPROTO_ICMP;
+        case WS_IPPROTO_ICMPV6: return IPPROTO_ICMPV6;
+        case WS_IPPROTO_IGMP: return IPPROTO_IGMP;
+        case WS_IPPROTO_IP: return IPPROTO_IP;
+        case WS_IPPROTO_IPV4: return IPPROTO_IPIP;
+        case WS_IPPROTO_IPV6: return IPPROTO_IPV6;
+        case WS_IPPROTO_RAW: return IPPROTO_RAW;
+        case WS_IPPROTO_TCP: return IPPROTO_TCP;
+        case WS_IPPROTO_UDP: return IPPROTO_UDP;
+        default: return -1;
+    }
+}
+
+static void set_dont_fragment( int fd, int level, int value )
+{
+    int optname;
+
+    if (level == IPPROTO_IP)
+    {
+#ifdef IP_DONTFRAG
+        optname = IP_DONTFRAG;
+#elif defined(IP_MTU_DISCOVER) && defined(IP_PMTUDISC_DO) && defined(IP_PMTUDISC_DONT)
+        optname = IP_MTU_DISCOVER;
+        value = value ? IP_PMTUDISC_DO : IP_PMTUDISC_DONT;
+#else
+        return;
+#endif
+    }
+    else
+    {
+#ifdef IPV6_DONTFRAG
+        optname = IPV6_DONTFRAG;
+#elif defined(IPV6_MTU_DISCOVER) && defined(IPV6_PMTUDISC_DO) && defined(IPV6_PMTUDISC_DONT)
+        optname = IPV6_MTU_DISCOVER;
+        value = value ? IPV6_PMTUDISC_DO : IPV6_PMTUDISC_DONT;
+#else
+        return;
+#endif
+    }
+
+    setsockopt( fd, level, optname, &value, sizeof(value) );
+}
+
+static int init_socket( struct sock *sock, int family, int type, int protocol )
+{
+    unsigned int options = 0;
+    int sockfd, unix_type, unix_family, unix_protocol, value;
+    socklen_t len;
+
+    unix_family = get_unix_family( family );
+    unix_type = get_unix_type( type );
+    unix_protocol = get_unix_protocol( family, protocol );
+
+    if (unix_protocol < 0)
+    {
+        if (family && unix_family < 0)
+            set_win32_error( WSAEAFNOSUPPORT );
+        else if (type && unix_type < 0)
+            set_win32_error( WSAESOCKTNOSUPPORT );
+        else
+            set_win32_error( WSAEPROTONOSUPPORT );
+        return -1;
+    }
+    if (unix_family < 0)
+    {
+        if (family >= 0 && unix_type < 0)
+            set_win32_error( WSAESOCKTNOSUPPORT );
+        else
+            set_win32_error( WSAEAFNOSUPPORT );
+        return -1;
+    }
+
+    sockfd = socket( unix_family, unix_type, unix_protocol );
+#ifdef linux
+    if (sockfd == -1 && errno == EPERM && unix_type == SOCK_RAW
+        && ((unix_family == AF_INET && unix_protocol == IPPROTO_ICMP)
+            || (unix_family == AF_INET6 && unix_protocol == IPPROTO_ICMPV6)))
+    {
+        sockfd = socket( unix_family, SOCK_DGRAM, unix_protocol );
+        if (sockfd != -1)
+        {
+            const int val = 1;
+
+            if (unix_family == AF_INET6)
+            {
+#ifdef IPV6_RECVPKTINFO
+                setsockopt( sockfd, IPPROTO_IPV6, IPV6_RECVPKTINFO, (const char *)&val, sizeof(val) );
+#endif
+            }
+            else
+            {
+                setsockopt( sockfd, IPPROTO_IP, IP_RECVTTL, (const char *)&val, sizeof(val) );
+                setsockopt( sockfd, IPPROTO_IP, IP_RECVTOS, (const char *)&val, sizeof(val) );
+                setsockopt( sockfd, IPPROTO_IP, IP_PKTINFO, (const char *)&val, sizeof(val) );
+            }
+        }
+    }
+#endif
+
+    if (sockfd == -1)
+    {
+        if (errno == EINVAL) set_win32_error( WSAESOCKTNOSUPPORT );
+#ifdef AF_BLUETOOTH
+        else if (errno == ESOCKTNOSUPPORT && unix_family == AF_BLUETOOTH)
+            set_win32_error( WSAEAFNOSUPPORT );
+#endif
+        else set_win32_error( sock_get_error( errno ));
+        return -1;
+    }
+    fcntl(sockfd, F_SETFL, O_NONBLOCK); /* make socket nonblocking */
+
+    if (family == WS_AF_IPX && protocol >= WS_NSPROTO_IPX && protocol <= WS_NSPROTO_IPX + 255)
+    {
+#ifdef HAS_IPX
+        int ipx_type = protocol - WS_NSPROTO_IPX;
+
+#ifdef SOL_IPX
+        setsockopt( sockfd, SOL_IPX, IPX_TYPE, &ipx_type, sizeof(ipx_type) );
+#else
+        struct ipx val;
+        /* Should we retrieve val using a getsockopt call and then
+         * set the modified one? */
+        val.ipx_pt = ipx_type;
+        setsockopt( sockfd, 0, SO_DEFAULT_HEADERS, &val, sizeof(val) );
+#endif
+#endif
+    }
+
+    if (unix_family == AF_INET || unix_family == AF_INET6)
+    {
+        /* ensure IP_DONTFRAGMENT is disabled for SOCK_DGRAM and SOCK_RAW, enabled for SOCK_STREAM */
+        if (unix_type == SOCK_DGRAM || unix_type == SOCK_RAW) /* in Linux the global default can be enabled */
+            set_dont_fragment( sockfd, unix_family == AF_INET6 ? IPPROTO_IPV6 : IPPROTO_IP, FALSE );
+        else if (unix_type == SOCK_STREAM)
+            set_dont_fragment( sockfd, unix_family == AF_INET6 ? IPPROTO_IPV6 : IPPROTO_IP, TRUE );
+    }
+
+#ifdef IPV6_V6ONLY
+    if (unix_family == AF_INET6)
+    {
+        static const int enable = 1;
+        setsockopt( sockfd, IPPROTO_IPV6, IPV6_V6ONLY, &enable, sizeof(enable) );
+    }
+#endif
+
+    len = sizeof(value);
+    if (!getsockopt( sockfd, SOL_SOCKET, SO_RCVBUF, &value, &len ))
+    {
+        if (value < MIN_RCVBUF)
+        {
+            value = MIN_RCVBUF;
+            setsockopt( sockfd, SOL_SOCKET, SO_RCVBUF, &value, sizeof(value) );
+        }
+        sock->rcvbuf = value;
+    }
+
+    len = sizeof(value);
+    if (!getsockopt( sockfd, SOL_SOCKET, SO_SNDBUF, &value, &len ))
+        sock->sndbuf = value;
+
+    sock->state  = (type == WS_SOCK_STREAM ? SOCK_UNCONNECTED : SOCK_CONNECTIONLESS);
+    sock->proto  = protocol;
+    sock->type   = type;
+    sock->family = family;
+
+    if (is_tcp_socket( sock ))
+    {
+        value = 1;
+        setsockopt( sockfd, SOL_SOCKET, SO_REUSEADDR, &value, sizeof(value) );
+#ifdef TCP_SYNCNT
+        value = 4;
+        setsockopt( sockfd, IPPROTO_TCP, TCP_SYNCNT, &value, sizeof(value) );
+#endif
+    }
+
+    if (sock->fd)
+    {
+        options = get_fd_options( sock->fd );
+        release_object( sock->fd );
+    }
+
+    if (!(sock->fd = create_anonymous_fd( &sock_fd_ops, sockfd, &sock->obj, options )))
+    {
+        return -1;
+    }
+
+    /* We can't immediately allow caching for a connection-mode socket, since it
+     * might be accepted into (changing the underlying fd object.) */
+    if (sock->type != WS_SOCK_STREAM) allow_fd_caching( sock->fd );
+
+    return 0;
+}
+
+/* accepts a socket and inits it */
+static int accept_new_fd( struct sock *sock )
+{
+
+    /* Try to accept(2). We can't be safe that this an already connected socket
+     * or that accept() is allowed on it. In those cases we will get -1/errno
+     * return.
+     */
+    struct sockaddr saddr;
+    socklen_t slen = sizeof(saddr);
+    int acceptfd = accept( get_unix_fd(sock->fd), &saddr, &slen );
+    if (acceptfd != -1)
+        fcntl( acceptfd, F_SETFL, O_NONBLOCK );
+    else
+        set_error( sock_get_ntstatus( errno ));
+    return acceptfd;
+}
+
+/* accept a socket (creates a new fd) */
+static struct sock *accept_socket( struct sock *sock )
+{
+    struct sock *acceptsock;
+    int	acceptfd;
+
+    if (get_unix_fd( sock->fd ) == -1) return NULL;
+
+    if ( sock->deferred )
+    {
+        acceptsock = sock->deferred;
+        sock->deferred = NULL;
+    }
+    else
+    {
+        union unix_sockaddr unix_addr;
+        socklen_t unix_len;
+
+        if ((acceptfd = accept_new_fd( sock )) == -1) return NULL;
+        if (!(acceptsock = create_socket()))
+        {
+            close( acceptfd );
+            return NULL;
+        }
+
+        /* newly created socket gets the same properties of the listening socket */
+        acceptsock->state               = SOCK_CONNECTED;
+        acceptsock->bound               = 1;
+        acceptsock->nonblocking         = sock->nonblocking;
+        acceptsock->mask                = sock->mask;
+        acceptsock->proto               = sock->proto;
+        acceptsock->type                = sock->type;
+        acceptsock->family              = sock->family;
+        acceptsock->window              = sock->window;
+        acceptsock->message             = sock->message;
+        acceptsock->reuseaddr           = sock->reuseaddr;
+        acceptsock->exclusiveaddruse    = sock->exclusiveaddruse;
+        acceptsock->sndbuf              = sock->sndbuf;
+        acceptsock->rcvbuf              = sock->rcvbuf;
+        acceptsock->sndtimeo            = sock->sndtimeo;
+        acceptsock->rcvtimeo            = sock->rcvtimeo;
+        acceptsock->connect_time        = current_time;
+
+        if (sock->event) acceptsock->event = (struct event *)grab_object( sock->event );
+        if (!(acceptsock->fd = create_anonymous_fd( &sock_fd_ops, acceptfd, &acceptsock->obj,
+                                                    get_fd_options( sock->fd ) )))
+        {
+            release_object( acceptsock );
+            return NULL;
+        }
+        allow_fd_caching( acceptsock->fd );
+        unix_len = sizeof(unix_addr);
+        if (!getsockname( acceptfd, &unix_addr.addr, &unix_len ))
+        {
+            acceptsock->addr_len = sockaddr_from_unix( &unix_addr, &acceptsock->addr.addr, sizeof(acceptsock->addr) );
+            if (!getpeername( acceptfd, &unix_addr.addr, &unix_len ))
+                acceptsock->peer_addr_len = sockaddr_from_unix( &unix_addr,
+                                                                &acceptsock->peer_addr.addr,
+                                                                sizeof(acceptsock->peer_addr) );
+        }
+    }
+
+    clear_error();
+    sock->pending_events &= ~AFD_POLL_ACCEPT;
+    sock->reported_events &= ~AFD_POLL_ACCEPT;
+    sock_reselect( sock );
+    return acceptsock;
+}
+
+static int accept_into_socket( struct sock *sock, struct sock *acceptsock )
+{
+    union unix_sockaddr unix_addr;
+    socklen_t unix_len;
+    int acceptfd;
+    struct fd *newfd;
+
+    if (get_unix_fd( sock->fd ) == -1) return FALSE;
+
+    if ( sock->deferred )
+    {
+        newfd = dup_fd_object( sock->deferred->fd, 0, 0,
+                               get_fd_options( acceptsock->fd ) );
+        if ( !newfd )
+            return FALSE;
+
+        set_fd_user( newfd, &sock_fd_ops, &acceptsock->obj );
+
+        release_object( sock->deferred );
+        sock->deferred = NULL;
+    }
+    else
+    {
+        if ((acceptfd = accept_new_fd( sock )) == -1)
+            return FALSE;
+
+        if (!(newfd = create_anonymous_fd( &sock_fd_ops, acceptfd, &acceptsock->obj,
+                                            get_fd_options( acceptsock->fd ) )))
+            return FALSE;
+    }
+    allow_fd_caching( newfd );
+
+    acceptsock->state = SOCK_CONNECTED;
+    acceptsock->bound = 1;
+    acceptsock->pending_events = 0;
+    acceptsock->reported_events = 0;
+    acceptsock->proto   = sock->proto;
+    acceptsock->type    = sock->type;
+    acceptsock->family  = sock->family;
+    acceptsock->wparam  = 0;
+    acceptsock->deferred = NULL;
+    acceptsock->connect_time = current_time;
+    fd_copy_completion( acceptsock->fd, newfd );
+    release_object( acceptsock->fd );
+    acceptsock->fd = newfd;
+
+    unix_len = sizeof(unix_addr);
+    if (!getsockname( get_unix_fd( newfd ), &unix_addr.addr, &unix_len ))
+    {
+        acceptsock->addr_len = sockaddr_from_unix( &unix_addr, &acceptsock->addr.addr, sizeof(acceptsock->addr) );
+        if (!getpeername( get_unix_fd( newfd ), &unix_addr.addr, &unix_len ))
+            acceptsock->peer_addr_len = sockaddr_from_unix( &unix_addr,
+                                                            &acceptsock->peer_addr.addr,
+                                                            sizeof(acceptsock->peer_addr) );
+    }
+
+    clear_error();
+    sock->pending_events &= ~AFD_POLL_ACCEPT;
+    sock->reported_events &= ~AFD_POLL_ACCEPT;
+    sock_reselect( sock );
+
+    return TRUE;
+}
+
+#ifdef IP_BOUND_IF
+
+static int bind_to_iface_name( int fd, in_addr_t bind_addr, const char *name )
+{
+    static const int enable = 1;
+    unsigned int index;
+
+    if (!(index = if_nametoindex( name )))
+        return -1;
+
+    if (setsockopt( fd, IPPROTO_IP, IP_BOUND_IF, &index, sizeof(index) ))
+        return -1;
+
+    return setsockopt( fd, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable) );
+}
+
+#elif defined(IP_UNICAST_IF) && defined(SO_ATTACH_FILTER) && defined(SO_BINDTODEVICE)
+
+struct interface_filter
+{
+    struct sock_filter iface_memaddr;
+    struct sock_filter iface_rule;
+    struct sock_filter ip_memaddr;
+    struct sock_filter ip_rule;
+    struct sock_filter return_keep;
+    struct sock_filter return_dump;
+};
+# define FILTER_JUMP_DUMP(here)  (u_char)(offsetof(struct interface_filter, return_dump) \
+                                 -offsetof(struct interface_filter, here)-sizeof(struct sock_filter)) \
+                                 /sizeof(struct sock_filter)
+# define FILTER_JUMP_KEEP(here)  (u_char)(offsetof(struct interface_filter, return_keep) \
+                                 -offsetof(struct interface_filter, here)-sizeof(struct sock_filter)) \
+                                 /sizeof(struct sock_filter)
+# define FILTER_JUMP_NEXT()      (u_char)(0)
+# define SKF_NET_DESTIP          16 /* offset in the network header to the destination IP */
+static struct interface_filter generic_interface_filter =
+{
+    /* This filter rule allows incoming packets on the specified interface, which works for all
+     * remotely generated packets and for locally generated broadcast packets. */
+    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, SKF_AD_OFF+SKF_AD_IFINDEX),
+    BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0xdeadbeef, FILTER_JUMP_KEEP(iface_rule), FILTER_JUMP_NEXT()),
+    /* This rule allows locally generated packets targeted at the specific IP address of the chosen
+     * adapter (local packets not destined for the broadcast address do not have IFINDEX set) */
+    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, SKF_NET_OFF+SKF_NET_DESTIP),
+    BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0xdeadbeef, FILTER_JUMP_KEEP(ip_rule), FILTER_JUMP_DUMP(ip_rule)),
+    BPF_STMT(BPF_RET+BPF_K, (u_int)-1), /* keep packet */
+    BPF_STMT(BPF_RET+BPF_K, 0)          /* dump packet */
+};
+
+static int bind_to_iface_name( int fd, in_addr_t bind_addr, const char *name )
+{
+    struct interface_filter specific_interface_filter;
+    struct sock_fprog filter_prog;
+    static const int enable = 1;
+    unsigned int index;
+    in_addr_t ifindex;
+
+    if (!setsockopt( fd, SOL_SOCKET, SO_BINDTODEVICE, name, strlen( name ) + 1 ))
+        return 0;
+
+    /* SO_BINDTODEVICE requires NET_CAP_RAW until Linux 5.7. */
+    if (debug_level)
+        fprintf( stderr, "setsockopt SO_BINDTODEVICE fd %d, name %s failed: %s, falling back to SO_REUSE_ADDR\n",
+                 fd, name, strerror( errno ));
+
+    if (!(index = if_nametoindex( name )))
+        return -1;
+
+    ifindex = htonl( index );
+    if (setsockopt( fd, IPPROTO_IP, IP_UNICAST_IF, &ifindex, sizeof(ifindex) ) < 0)
+        return -1;
+
+    specific_interface_filter = generic_interface_filter;
+    specific_interface_filter.iface_rule.k = index;
+    specific_interface_filter.ip_rule.k = htonl( bind_addr );
+    filter_prog.len = sizeof(generic_interface_filter) / sizeof(struct sock_filter);
+    filter_prog.filter = (struct sock_filter *)&specific_interface_filter;
+    if (setsockopt( fd, SOL_SOCKET, SO_ATTACH_FILTER, &filter_prog, sizeof(filter_prog) ))
+        return -1;
+
+    return setsockopt( fd, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable) );
+}
+
+#else
+
+static int bind_to_iface_name( int fd, in_addr_t bind_addr, const char *name )
+{
+    errno = EOPNOTSUPP;
+    return -1;
+}
+
+#endif /* LINUX_BOUND_IF */
+
+/* Take bind() calls on any name corresponding to a local network adapter and
+ * restrict the given socket to operating only on the specified interface. This
+ * restriction consists of two components:
+ *  1) An outgoing packet restriction suggesting the egress interface for all
+ *     packets.
+ *  2) An incoming packet restriction dropping packets not meant for the
+ *     interface.
+ * If the function succeeds in placing these restrictions, then the name for the
+ * bind() may safely be changed to INADDR_ANY, permitting the transmission and
+ * receipt of broadcast packets on the socket. This behavior is only relevant to
+ * UDP sockets and is needed for applications that expect to be able to receive
+ * broadcast packets on a socket that is bound to a specific network interface.
+ */
+static int bind_to_interface( struct sock *sock, const struct sockaddr_in *addr )
+{
+    in_addr_t bind_addr = addr->sin_addr.s_addr;
+    struct ifaddrs *ifaddrs, *ifaddr;
+    int fd = get_unix_fd( sock->fd );
+    int err = -1;
+
+    if (bind_addr == htonl( INADDR_ANY ) || bind_addr == htonl( INADDR_LOOPBACK ))
+        return 0;
+    if (sock->type != WS_SOCK_DGRAM)
+        return 0;
+
+    if (getifaddrs( &ifaddrs ) < 0) return 0;
+
+    for (ifaddr = ifaddrs; ifaddr != NULL; ifaddr = ifaddr->ifa_next)
+    {
+        if (ifaddr->ifa_addr && ifaddr->ifa_addr->sa_family == AF_INET
+                && ((struct sockaddr_in *)ifaddr->ifa_addr)->sin_addr.s_addr == bind_addr)
+        {
+            if ((err = bind_to_iface_name( fd, bind_addr, ifaddr->ifa_name )) < 0)
+            {
+                if (debug_level)
+                    fprintf( stderr, "failed to bind to interface: %s\n", strerror( errno ) );
+            }
+            break;
+        }
+    }
+    freeifaddrs( ifaddrs );
+    return !err;
+}
+
+#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID
+static unsigned int get_ipv6_interface_index( const struct in6_addr *addr )
+{
+    struct ifaddrs *ifaddrs, *ifaddr;
+
+    if (getifaddrs( &ifaddrs ) < 0) return 0;
+
+    for (ifaddr = ifaddrs; ifaddr != NULL; ifaddr = ifaddr->ifa_next)
+    {
+        if (ifaddr->ifa_addr && ifaddr->ifa_addr->sa_family == AF_INET6
+                && !memcmp( &((struct sockaddr_in6 *)ifaddr->ifa_addr)->sin6_addr, addr, sizeof(*addr) ))
+        {
+            unsigned int index = if_nametoindex( ifaddr->ifa_name );
+
+            if (!index)
+            {
+                if (debug_level)
+                    fprintf( stderr, "Unable to look up interface index for %s: %s\n",
+                             ifaddr->ifa_name, strerror( errno ) );
+                continue;
+            }
+
+            freeifaddrs( ifaddrs );
+            return index;
+        }
+    }
+
+    freeifaddrs( ifaddrs );
+    return 0;
+}
+#endif
+
+/* return an errno value mapped to a WSA error */
+static unsigned int sock_get_error( int err )
+{
+    switch (err)
+    {
+        case EINTR:             return WSAEINTR;
+        case EBADF:             return WSAEBADF;
+        case EPERM:
+        case EACCES:            return WSAEACCES;
+        case EFAULT:            return WSAEFAULT;
+        case EINVAL:            return WSAEINVAL;
+        case EMFILE:            return WSAEMFILE;
+        case EINPROGRESS:
+        case EWOULDBLOCK:       return WSAEWOULDBLOCK;
+        case EALREADY:          return WSAEALREADY;
+        case ENOTSOCK:          return WSAENOTSOCK;
+        case EDESTADDRREQ:      return WSAEDESTADDRREQ;
+        case EMSGSIZE:          return WSAEMSGSIZE;
+        case EPROTOTYPE:        return WSAEPROTOTYPE;
+        case ENOPROTOOPT:       return WSAENOPROTOOPT;
+        case EPROTONOSUPPORT:   return WSAEPROTONOSUPPORT;
+        case ESOCKTNOSUPPORT:   return WSAESOCKTNOSUPPORT;
+        case EOPNOTSUPP:        return WSAEOPNOTSUPP;
+        case EPFNOSUPPORT:      return WSAEPFNOSUPPORT;
+        case EAFNOSUPPORT:      return WSAEAFNOSUPPORT;
+        case EADDRINUSE:        return WSAEADDRINUSE;
+        case EADDRNOTAVAIL:     return WSAEADDRNOTAVAIL;
+        case ENETDOWN:          return WSAENETDOWN;
+        case ENETUNREACH:       return WSAENETUNREACH;
+        case ENETRESET:         return WSAENETRESET;
+        case ECONNABORTED:      return WSAECONNABORTED;
+        case EPIPE:
+        case ECONNRESET:        return WSAECONNRESET;
+        case ENOBUFS:           return WSAENOBUFS;
+        case EISCONN:           return WSAEISCONN;
+        case ENOTCONN:          return WSAENOTCONN;
+        case ESHUTDOWN:         return WSAESHUTDOWN;
+        case ETOOMANYREFS:      return WSAETOOMANYREFS;
+        case ETIMEDOUT:         return WSAETIMEDOUT;
+        case ECONNREFUSED:      return WSAECONNREFUSED;
+        case ELOOP:             return WSAELOOP;
+        case ENAMETOOLONG:      return WSAENAMETOOLONG;
+        case EHOSTDOWN:         return WSAEHOSTDOWN;
+        case EHOSTUNREACH:      return WSAEHOSTUNREACH;
+        case ENOTEMPTY:         return WSAENOTEMPTY;
+#ifdef EPROCLIM
+        case EPROCLIM:          return WSAEPROCLIM;
+#endif
+#ifdef EUSERS
+        case EUSERS:            return WSAEUSERS;
+#endif
+#ifdef EDQUOT
+        case EDQUOT:            return WSAEDQUOT;
+#endif
+#ifdef ESTALE
+        case ESTALE:            return WSAESTALE;
+#endif
+#ifdef EREMOTE
+        case EREMOTE:           return WSAEREMOTE;
+#endif
+
+        case 0:                 return 0;
+        default:
+            errno = err;
+            perror("wineserver: sock_get_error() can't map error");
+            return WSAEFAULT;
+    }
+}
+
+static int sock_get_ntstatus( int err )
+{
+    switch ( err )
+    {
+        case EBADF:             return STATUS_INVALID_HANDLE;
+        case EBUSY:             return STATUS_DEVICE_BUSY;
+        case EPERM:
+        case EACCES:            return STATUS_ACCESS_DENIED;
+        case EFAULT:            return STATUS_ACCESS_VIOLATION;
+        case EINVAL:            return STATUS_INVALID_PARAMETER;
+        case ENFILE:
+        case EMFILE:            return STATUS_TOO_MANY_OPENED_FILES;
+        case EINPROGRESS:
+        case EWOULDBLOCK:       return STATUS_DEVICE_NOT_READY;
+        case EALREADY:          return STATUS_NETWORK_BUSY;
+        case ENOTSOCK:          return STATUS_OBJECT_TYPE_MISMATCH;
+        case EDESTADDRREQ:      return STATUS_INVALID_PARAMETER;
+        case EMSGSIZE:          return STATUS_BUFFER_OVERFLOW;
+        case EPROTONOSUPPORT:
+        case ESOCKTNOSUPPORT:
+        case EPFNOSUPPORT:
+        case EAFNOSUPPORT:
+        case EPROTOTYPE:        return STATUS_NOT_SUPPORTED;
+        case ENOPROTOOPT:       return STATUS_INVALID_PARAMETER;
+        case EOPNOTSUPP:        return STATUS_NOT_SUPPORTED;
+        case EADDRINUSE:        return STATUS_SHARING_VIOLATION;
+        /* Linux returns ENODEV when specifying an invalid sin6_scope_id;
+         * Windows returns STATUS_INVALID_ADDRESS_COMPONENT */
+        case ENODEV:
+        case EADDRNOTAVAIL:     return STATUS_INVALID_ADDRESS_COMPONENT;
+        case ECONNREFUSED:      return STATUS_CONNECTION_REFUSED;
+        case ESHUTDOWN:         return STATUS_PIPE_DISCONNECTED;
+        case ENOTCONN:          return STATUS_INVALID_CONNECTION;
+        case ETIMEDOUT:         return STATUS_IO_TIMEOUT;
+        case ENETUNREACH:       return STATUS_NETWORK_UNREACHABLE;
+        case EHOSTUNREACH:      return STATUS_HOST_UNREACHABLE;
+        case ENETDOWN:          return STATUS_NETWORK_BUSY;
+        case EPIPE:
+        case ECONNRESET:        return STATUS_CONNECTION_RESET;
+        case ECONNABORTED:      return STATUS_CONNECTION_ABORTED;
+        case EISCONN:           return STATUS_CONNECTION_ACTIVE;
+
+        case 0:                 return STATUS_SUCCESS;
+        default:
+            errno = err;
+            perror("wineserver: sock_get_ntstatus() can't map error");
+            return STATUS_UNSUCCESSFUL;
+    }
+}
+
+static struct accept_req *alloc_accept_req( struct sock *sock, struct sock *acceptsock, struct async *async,
+                                            const struct afd_accept_into_params *params )
+{
+    struct accept_req *req = mem_alloc( sizeof(*req) );
+
+    if (req)
+    {
+        req->async = (struct async *)grab_object( async );
+        req->iosb = async_get_iosb( async );
+        req->sock = (struct sock *)grab_object( sock );
+        req->acceptsock = acceptsock;
+        if (acceptsock) grab_object( acceptsock );
+        req->accepted = 0;
+        req->recv_len = 0;
+        req->local_len = 0;
+        if (params)
+        {
+            req->recv_len = params->recv_len;
+            req->local_len = params->local_len;
+        }
+    }
+    return req;
+}
+
+static void sock_ioctl( struct fd *fd, ioctl_code_t code, struct async *async )
+{
+    struct sock *sock = get_fd_user( fd );
+    int unix_fd = -1;
+
+    assert( sock->obj.ops == &sock_ops );
+
+    if (code != IOCTL_AFD_WINE_CREATE && code != IOCTL_AFD_POLL && (unix_fd = get_unix_fd( fd )) < 0)
+        return;
+
+    switch(code)
+    {
+    case IOCTL_AFD_WINE_CREATE:
+    {
+        const struct afd_create_params *params = get_req_data();
+
+        if (get_req_data_size() != sizeof(*params))
+        {
+            set_error( STATUS_INVALID_PARAMETER );
+            return;
+        }
+        init_socket( sock, params->family, params->type, params->protocol );
+        return;
+    }
+
+    case IOCTL_AFD_WINE_ACCEPT:
+    {
+        struct sock *acceptsock;
+        obj_handle_t handle;
+
+        if (get_reply_max_size() != sizeof(handle))
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+
+        if (!(acceptsock = accept_socket( sock )))
+        {
+            struct accept_req *req;
+
+            if (sock->nonblocking) return;
+            if (get_error() != STATUS_DEVICE_NOT_READY) return;
+
+            if (!(req = alloc_accept_req( sock, NULL, async, NULL ))) return;
+            list_add_tail( &sock->accept_list, &req->entry );
+
+            async_set_completion_callback( async, free_accept_req, req );
+            queue_async( &sock->accept_q, async );
+            sock_reselect( sock );
+            set_error( STATUS_PENDING );
+            return;
+        }
+        handle = alloc_handle( current->process, &acceptsock->obj,
+                               GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, OBJ_INHERIT );
+        acceptsock->wparam = handle;
+        sock_reselect( acceptsock );
+        release_object( acceptsock );
+        set_reply_data( &handle, sizeof(handle) );
+        return;
+    }
+
+    case IOCTL_AFD_WINE_ACCEPT_INTO:
+    {
+        static const int access = FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | FILE_READ_DATA;
+        const struct afd_accept_into_params *params = get_req_data();
+        struct sock *acceptsock;
+        unsigned int remote_len;
+        struct accept_req *req;
+
+        if (get_req_data_size() != sizeof(*params) ||
+            get_reply_max_size() < params->recv_len ||
+            get_reply_max_size() - params->recv_len < params->local_len)
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+
+        remote_len = get_reply_max_size() - params->recv_len - params->local_len;
+        if (remote_len < sizeof(int))
+        {
+            set_error( STATUS_INVALID_PARAMETER );
+            return;
+        }
+
+        if (!(acceptsock = (struct sock *)get_handle_obj( current->process, params->accept_handle, access, &sock_ops )))
+            return;
+
+        if (acceptsock->accept_recv_req)
+        {
+            release_object( acceptsock );
+            set_error( STATUS_INVALID_PARAMETER );
+            return;
+        }
+
+        if (!(req = alloc_accept_req( sock, acceptsock, async, params )))
+        {
+            release_object( acceptsock );
+            return;
+        }
+        list_add_tail( &sock->accept_list, &req->entry );
+        acceptsock->accept_recv_req = req;
+        release_object( acceptsock );
+
+        acceptsock->wparam = params->accept_handle;
+        async_set_completion_callback( async, free_accept_req, req );
+        queue_async( &sock->accept_q, async );
+        sock_reselect( sock );
+        set_error( STATUS_PENDING );
+        return;
+    }
+
+    case IOCTL_AFD_LISTEN:
+    {
+        const struct afd_listen_params *params = get_req_data();
+
+        if (get_req_data_size() < sizeof(*params))
+        {
+            set_error( STATUS_INVALID_PARAMETER );
+            return;
+        }
+
+        if (sock->type == WS_SOCK_DGRAM)
+        {
+            set_error( STATUS_NOT_SUPPORTED );
+            return;
+        }
+
+        if (!sock->bound)
+        {
+            set_error( STATUS_INVALID_PARAMETER );
+            return;
+        }
+
+        if (listen( unix_fd, params->backlog ) < 0)
+        {
+            set_error( sock_get_ntstatus( errno ) );
+            return;
+        }
+
+        sock->state = SOCK_LISTENING;
+
+        /* a listening socket can no longer be accepted into */
+        allow_fd_caching( sock->fd );
+
+        /* we may already be selecting for AFD_POLL_ACCEPT */
+        sock_reselect( sock );
+        return;
+    }
+
+    case IOCTL_AFD_WINE_CONNECT:
+    {
+        const struct afd_connect_params *params = get_req_data();
+        const struct WS_sockaddr *addr;
+        union unix_sockaddr unix_addr, peer_addr;
+        struct connect_req *req;
+        socklen_t unix_len;
+        int send_len, ret;
+
+        if (get_req_data_size() < sizeof(*params) ||
+            get_req_data_size() - sizeof(*params) < params->addr_len)
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+        send_len = get_req_data_size() - sizeof(*params) - params->addr_len;
+        addr = (const struct WS_sockaddr *)(params + 1);
+
+        if (!params->synchronous && !sock->bound)
+        {
+            set_error( STATUS_INVALID_PARAMETER );
+            return;
+        }
+
+        if (sock->accept_recv_req)
+        {
+            set_error( STATUS_INVALID_PARAMETER );
+            return;
+        }
+
+        if (sock->connect_req)
+        {
+            set_error( STATUS_INVALID_PARAMETER );
+            return;
+        }
+
+        switch (sock->state)
+        {
+            case SOCK_LISTENING:
+                set_error( STATUS_INVALID_PARAMETER );
+                return;
+
+            case SOCK_CONNECTING:
+                /* FIXME: STATUS_ADDRESS_ALREADY_ASSOCIATED probably isn't right,
+                 * but there's no status code that maps to WSAEALREADY... */
+                set_error( params->synchronous ? STATUS_ADDRESS_ALREADY_ASSOCIATED : STATUS_INVALID_PARAMETER );
+                return;
+
+            case SOCK_CONNECTED:
+                set_error( STATUS_CONNECTION_ACTIVE );
+                return;
+
+            case SOCK_UNCONNECTED:
+            case SOCK_CONNECTIONLESS:
+                break;
+        }
+
+        unix_len = sockaddr_to_unix( addr, params->addr_len, &unix_addr );
+        if (!unix_len)
+        {
+            set_error( STATUS_INVALID_ADDRESS );
+            return;
+        }
+        if (unix_addr.addr.sa_family == AF_INET && !memcmp( &unix_addr.in.sin_addr, magic_loopback_addr, 4 ))
+            unix_addr.in.sin_addr.s_addr = htonl( INADDR_LOOPBACK );
+
+        memcpy( &peer_addr, &unix_addr, sizeof(unix_addr) );
+        ret = connect( unix_fd, &unix_addr.addr, unix_len );
+        if (ret < 0 && errno == ECONNABORTED)
+        {
+            /* On Linux with nonblocking socket if the previous connect() failed for any reason (including
+             * timeout), next connect will fail. If the error code was queried by getsockopt( SO_ERROR )
+             * the error code returned now is ECONNABORTED (otherwise that is the actual connect() failure
+             * error code). If we got here after previous connect attempt on the socket that means
+             * we already queried SO_ERROR in sock_error(), so retrying on ECONNABORTED only is
+             * sufficient. */
+            ret = connect( unix_fd, &unix_addr.addr, unix_len );
+        }
+
+        if (ret < 0 && errno == EACCES && sock->state == SOCK_CONNECTIONLESS && unix_addr.addr.sa_family == AF_INET)
+        {
+            int broadcast, saved_errno;
+            socklen_t len = sizeof(broadcast);
+
+            broadcast = 1;
+            getsockopt( unix_fd, SOL_SOCKET, SO_BROADCAST, &broadcast, &len );
+            if (!broadcast)
+            {
+                broadcast = 1;
+                setsockopt( unix_fd, SOL_SOCKET, SO_BROADCAST, &broadcast, sizeof(broadcast) );
+                ret = connect( unix_fd, &unix_addr.addr, unix_len );
+                saved_errno = errno;
+                broadcast = 0;
+                setsockopt( unix_fd, SOL_SOCKET, SO_BROADCAST, &broadcast, sizeof(broadcast) );
+                errno = saved_errno;
+            }
+        }
+
+        if (ret < 0 && errno != EINPROGRESS)
+        {
+            set_error( sock_get_ntstatus( errno ) );
+            return;
+        }
+
+        /* a connected or connecting socket can no longer be accepted into */
+        allow_fd_caching( sock->fd );
+
+        unix_len = sizeof(unix_addr);
+        getsockname( unix_fd, &unix_addr.addr, &unix_len );
+        sock->addr_len = sockaddr_from_unix( &unix_addr, &sock->addr.addr, sizeof(sock->addr) );
+        sock->peer_addr_len = sockaddr_from_unix( &peer_addr, &sock->peer_addr.addr, sizeof(sock->peer_addr));
+
+        sock->bound = 1;
+
+        if (!ret)
+        {
+            if (sock->type != WS_SOCK_DGRAM)
+            {
+                sock->state = SOCK_CONNECTED;
+                sock->connect_time = current_time;
+            }
+
+            if (!send_len) return;
+        }
+
+        if (sock->type != WS_SOCK_DGRAM)
+            sock->state = SOCK_CONNECTING;
+
+        if (params->synchronous && sock->nonblocking)
+        {
+            sock_reselect( sock );
+            set_error( STATUS_DEVICE_NOT_READY );
+            return;
+        }
+
+        if (!(req = mem_alloc( sizeof(*req) )))
+            return;
+
+        req->async = (struct async *)grab_object( async );
+        req->iosb = async_get_iosb( async );
+        req->sock = (struct sock *)grab_object( sock );
+        req->addr_len = params->addr_len;
+        req->send_len = send_len;
+        req->send_cursor = 0;
+
+        async_set_completion_callback( async, free_connect_req, req );
+        sock->connect_req = req;
+        queue_async( &sock->connect_q, async );
+        sock_reselect( sock );
+        set_error( STATUS_PENDING );
+        return;
+    }
+
+    case IOCTL_AFD_WINE_SHUTDOWN:
+    {
+        unsigned int how;
+
+        if (get_req_data_size() < sizeof(int))
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+        how = *(int *)get_req_data();
+
+        if (how > SD_BOTH)
+        {
+            set_error( STATUS_INVALID_PARAMETER );
+            return;
+        }
+
+        if (sock->state != SOCK_CONNECTED && sock->state != SOCK_CONNECTIONLESS)
+        {
+            set_error( STATUS_INVALID_CONNECTION );
+            return;
+        }
+
+        if (how != SD_SEND)
+        {
+            sock->rd_shutdown = 1;
+        }
+        if (how != SD_RECEIVE)
+        {
+            sock->wr_shutdown = 1;
+            if (list_empty( &sock->write_q.queue ))
+                shutdown( unix_fd, SHUT_WR );
+            else
+                sock->wr_shutdown_pending = 1;
+        }
+
+        if (how == SD_BOTH)
+        {
+            if (sock->event) release_object( sock->event );
+            sock->event = NULL;
+            sock->window = 0;
+            sock->mask = 0;
+            sock->nonblocking = 1;
+        }
+
+        sock_reselect( sock );
+        return;
+    }
+
+    case IOCTL_AFD_WINE_ADDRESS_LIST_CHANGE:
+    {
+        int force_async;
+
+        if (get_req_data_size() < sizeof(int))
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+        force_async = *(int *)get_req_data();
+
+        if (sock->nonblocking && !force_async)
+        {
+            set_error( STATUS_DEVICE_NOT_READY );
+            return;
+        }
+        if (!sock_get_ifchange( sock )) return;
+        queue_async( &sock->ifchange_q, async );
+        set_error( STATUS_PENDING );
+        return;
+    }
+
+    case IOCTL_AFD_WINE_FIONBIO:
+        if (get_req_data_size() < sizeof(int))
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+        if (*(int *)get_req_data())
+        {
+            sock->nonblocking = 1;
+        }
+        else
+        {
+            if (sock->mask)
+            {
+                set_error( STATUS_INVALID_PARAMETER );
+                return;
+            }
+            sock->nonblocking = 0;
+        }
+        return;
+
+    case IOCTL_AFD_EVENT_SELECT:
+    {
+        struct event *event = NULL;
+        obj_handle_t event_handle;
+        int mask;
+
+        set_async_pending( async );
+
+        if (is_machine_64bit( current->process->machine ))
+        {
+            const struct afd_event_select_params_64 *params = get_req_data();
+
+            if (get_req_data_size() < sizeof(*params))
+            {
+                set_error( STATUS_INVALID_PARAMETER );
+                return;
+            }
+
+            event_handle = params->event;
+            mask = params->mask;
+        }
+        else
+        {
+            const struct afd_event_select_params_32 *params = get_req_data();
+
+            if (get_req_data_size() < sizeof(*params))
+            {
+                set_error( STATUS_INVALID_PARAMETER );
+                return;
+            }
+
+            event_handle = params->event;
+            mask = params->mask;
+        }
+
+        if ((event_handle || mask) &&
+            !(event = get_event_obj( current->process, event_handle, EVENT_MODIFY_STATE )))
+        {
+            set_error( STATUS_INVALID_PARAMETER );
+            return;
+        }
+
+        if (sock->event) release_object( sock->event );
+        sock->event = event;
+        sock->mask = mask;
+        sock->window = 0;
+        sock->message = 0;
+        sock->wparam = 0;
+        sock->nonblocking = 1;
+
+        sock_reselect( sock );
+
+        /* Explicitly wake the socket up if the mask matches pending_events.
+         *
+         * The logic here is a bit surprising. We always set the event if the
+         * socket has events that haven't been consumed by
+         * WSAEnumNetworkEvents() yet, including if WSAEventSelect() is called
+         * multiple times without consuming the events.
+         * However, once the events are consumed by WSAEnumNetworkEvents(), we
+         * don't set the event again (even though e.g. data is still available)
+         * until a "reset" call (i.e. that clears reported_events). */
+
+        if (event && (sock->pending_events & mask))
+        {
+            if (debug_level) fprintf( stderr, "signalling pending events %#x due to event select\n",
+                                      sock->pending_events & mask );
+            set_event( event );
+        }
+
+        return;
+    }
+
+    case IOCTL_AFD_WINE_MESSAGE_SELECT:
+    {
+        const struct afd_message_select_params *params = get_req_data();
+
+        if (get_req_data_size() < sizeof(params))
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+
+        if (sock->event) release_object( sock->event );
+
+        if (params->window)
+        {
+            sock->pending_events = 0;
+            sock->reported_events = 0;
+        }
+        sock->event = NULL;
+        sock->mask = params->mask;
+        sock->window = params->window;
+        sock->message = params->message;
+        sock->wparam = params->handle;
+        sock->nonblocking = 1;
+
+        sock_reselect( sock );
+
+        return;
+    }
+
+    case IOCTL_AFD_BIND:
+    {
+        const struct afd_bind_params *params = get_req_data();
+        union unix_sockaddr unix_addr, bind_addr;
+        data_size_t in_size;
+        socklen_t unix_len;
+        int v6only = 1;
+
+        /* the ioctl is METHOD_NEITHER, so ntdll gives us the output buffer as
+         * input */
+        if (get_req_data_size() < get_reply_max_size())
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+        in_size = get_req_data_size() - get_reply_max_size();
+        if (in_size < offsetof(struct afd_bind_params, addr.sa_data)
+                || get_reply_max_size() < in_size - sizeof(int))
+        {
+            set_error( STATUS_INVALID_PARAMETER );
+            return;
+        }
+
+        if (sock->bound)
+        {
+            set_error( STATUS_ADDRESS_ALREADY_ASSOCIATED );
+            return;
+        }
+
+        unix_len = sockaddr_to_unix( &params->addr, in_size - sizeof(int), &unix_addr );
+        if (!unix_len)
+        {
+            set_error( STATUS_INVALID_ADDRESS );
+            return;
+        }
+        bind_addr = unix_addr;
+
+        if (unix_addr.addr.sa_family == AF_INET)
+        {
+            if (!memcmp( &unix_addr.in.sin_addr, magic_loopback_addr, 4 )
+                    || bind_to_interface( sock, &unix_addr.in ))
+                bind_addr.in.sin_addr.s_addr = htonl( INADDR_ANY );
+        }
+        else if (unix_addr.addr.sa_family == AF_INET6)
+        {
+#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID
+            /* Windows allows specifying zero to use the default scope. Linux
+             * interprets it as an interface index and requires that it be
+             * nonzero. */
+            if (!unix_addr.in6.sin6_scope_id)
+                bind_addr.in6.sin6_scope_id = get_ipv6_interface_index( &unix_addr.in6.sin6_addr );
+#endif
+        }
+
+        set_async_pending( async );
+
+#ifdef IPV6_V6ONLY
+    if (sock->family == WS_AF_INET6)
+    {
+        socklen_t len = sizeof(v6only);
+
+        getsockopt( get_unix_fd(sock->fd), IPPROTO_IPV6, IPV6_V6ONLY, &v6only, &len );
+    }
+#endif
+
+        if (check_addr_usage( sock, &bind_addr, v6only ))
+            return;
+
+#ifdef HAS_BLUETOOTH
+        if (unix_addr.rfcomm.rc_family == AF_BLUETOOTH
+            && !(unix_addr.rfcomm.rc_channel >= 1 && unix_addr.rfcomm.rc_channel <= 30))
+        {
+            int i;
+            if (unix_addr.rfcomm.rc_channel != UINT8_MAX)
+            {
+                set_error( sock_get_ntstatus( EADDRNOTAVAIL ) );
+                return;
+            }
+            /* If the RFCOMM channel was set to BT_PORT_ANY, we need to find an available RFCOMM
+             *  channel. The Linux kernel has a similar mechanism, but the channel is only assigned
+             *  on listen(), which we cannot call yet. The other, albeit hacky/race-y way to find an available
+             *  channel is to loop through all valid channel values (1 to 30) until bind() succeeds.
+             */
+            for (i = 1; i <= 30; i++)
+            {
+                bind_addr.rfcomm.rc_channel = i;
+                if (!bind( unix_fd, &bind_addr.addr, unix_len ))
+                    break;
+                if (errno != EADDRINUSE)
+                {
+                    set_error( sock_get_ntstatus( errno ) );
+                    return;
+                }
+            }
+            if (i > 30)
+            {
+                set_error( sock_get_ntstatus( EADDRINUSE ) );
+                return;
+            }
+        }
+        else
+#endif
+        if (bind( unix_fd, &bind_addr.addr, unix_len ) < 0)
+        {
+            if (errno == EADDRINUSE && sock->reuseaddr)
+                errno = EACCES;
+
+            set_error( sock_get_ntstatus( errno ) );
+            return;
+        }
+
+        sock->bound = 1;
+
+        unix_len = sizeof(bind_addr);
+        if (!getsockname( unix_fd, &bind_addr.addr, &unix_len ))
+        {
+            /* store the interface or magic loopback address instead of the
+             * actual unix address */
+            if (bind_addr.addr.sa_family == AF_INET)
+                bind_addr.in.sin_addr = unix_addr.in.sin_addr;
+            sock->addr_len = sockaddr_from_unix( &bind_addr, &sock->addr.addr, sizeof(sock->addr) );
+        }
+
+        update_addr_usage( sock, &bind_addr, v6only );
+
+        if (get_reply_max_size() >= sock->addr_len)
+            set_reply_data( &sock->addr, sock->addr_len );
+        return;
+    }
+
+    case IOCTL_AFD_GETSOCKNAME:
+        if (!sock->bound)
+        {
+            set_error( STATUS_INVALID_PARAMETER );
+            return;
+        }
+
+        if (get_reply_max_size() < sock->addr_len)
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+
+        set_reply_data( &sock->addr, sock->addr_len );
+        return;
+
+    case IOCTL_AFD_WINE_GETPEERNAME:
+        if (sock->state != SOCK_CONNECTED &&
+            sock->state != SOCK_CONNECTING &&
+            sock->state != SOCK_CONNECTIONLESS)
+        {
+            set_error( STATUS_INVALID_CONNECTION );
+            return;
+        }
+
+        /* If ConnectEx() hasn't finished connecting (or failing to connect) the provided
+         * socket, getpeername() can't be called on it. This seems to be undocumented
+         * and is *not* the case for connect(), but we do test for it in ws2_32.
+         * connect_req is non-NULL iff ConnectEx() was used and has not finished,
+         * so we can use it as a check for ConnectEx() usage here. */
+        if (sock->connect_req)
+        {
+            set_error( STATUS_INVALID_CONNECTION );
+            return;
+        }
+
+        if (!sock->peer_addr_len && sock->type == WS_SOCK_DGRAM)
+        {
+            set_error( STATUS_INVALID_CONNECTION );
+            return;
+        }
+
+        if (get_reply_max_size() < sock->peer_addr_len)
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+
+        set_reply_data( &sock->peer_addr, sock->peer_addr_len );
+        return;
+
+    case IOCTL_AFD_WINE_DEFER:
+    {
+        const obj_handle_t *handle = get_req_data();
+        struct sock *acceptsock;
+
+        if (get_req_data_size() < sizeof(*handle))
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+
+        acceptsock = (struct sock *)get_handle_obj( current->process, *handle, 0, &sock_ops );
+        if (!acceptsock) return;
+
+        sock->deferred = acceptsock;
+        return;
+    }
+
+    case IOCTL_AFD_WINE_GET_INFO:
+    {
+        struct afd_get_info_params params;
+
+        if (get_reply_max_size() < sizeof(params))
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+
+        params.family = sock->family;
+        params.type = sock->type;
+        params.protocol = sock->proto;
+        set_reply_data( &params, sizeof(params) );
+        return;
+    }
+
+    case IOCTL_AFD_WINE_GET_SO_ACCEPTCONN:
+    {
+        int listening = (sock->state == SOCK_LISTENING);
+
+        if (get_reply_max_size() < sizeof(listening))
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+
+        set_reply_data( &listening, sizeof(listening) );
+        return;
+    }
+
+    case IOCTL_AFD_WINE_GET_SO_ERROR:
+    {
+        int error;
+        unsigned int i;
+
+        if (get_reply_max_size() < sizeof(error))
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+
+        error = sock_error( sock, NULL );
+        if (!error)
+        {
+            for (i = 0; i < ARRAY_SIZE( sock->errors ); ++i)
+            {
+                if (sock->errors[i])
+                {
+                    error = sock->errors[i];
+                    break;
+                }
+            }
+        }
+
+        error = sock_get_error( error );
+        set_reply_data( &error, sizeof(error) );
+        return;
+    }
+
+    case IOCTL_AFD_WINE_GET_SO_RCVBUF:
+    {
+        int rcvbuf = sock->rcvbuf;
+
+        if (get_reply_max_size() < sizeof(rcvbuf))
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+
+        set_reply_data( &rcvbuf, sizeof(rcvbuf) );
+        return;
+    }
+
+    case IOCTL_AFD_WINE_SET_SO_RCVBUF:
+    {
+        DWORD rcvbuf, set_rcvbuf;
+
+        if (get_req_data_size() < sizeof(rcvbuf))
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+        rcvbuf = *(DWORD *)get_req_data();
+        set_rcvbuf = max( rcvbuf, MIN_RCVBUF );
+
+        if (!setsockopt( unix_fd, SOL_SOCKET, SO_RCVBUF, (char *)&set_rcvbuf, sizeof(set_rcvbuf) ))
+            sock->rcvbuf = rcvbuf;
+        else
+            set_error( sock_get_ntstatus( errno ) );
+        return;
+    }
+
+    case IOCTL_AFD_WINE_GET_SO_RCVTIMEO:
+    {
+        DWORD rcvtimeo = sock->rcvtimeo;
+
+        if (get_reply_max_size() < sizeof(rcvtimeo))
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+
+        set_reply_data( &rcvtimeo, sizeof(rcvtimeo) );
+        return;
+    }
+
+    case IOCTL_AFD_WINE_SET_SO_RCVTIMEO:
+    {
+        DWORD rcvtimeo;
+
+        if (get_req_data_size() < sizeof(rcvtimeo))
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+        rcvtimeo = *(DWORD *)get_req_data();
+
+        sock->rcvtimeo = rcvtimeo;
+        return;
+    }
+
+    /* BSD socket SO_REUSEADDR is not compatible with winsock semantics. */
+    case IOCTL_AFD_WINE_SET_SO_REUSEADDR:
+    {
+        int reuse, ret;
+
+        if (get_req_data_size() < sizeof(reuse))
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+
+        reuse = *(int *)get_req_data();
+
+        if (reuse && sock->exclusiveaddruse)
+        {
+            set_error( STATUS_INVALID_PARAMETER );
+            return;
+        }
+
+        if (is_tcp_socket( sock ))
+            ret = 0;
+        else
+            ret = setsockopt( unix_fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse) );
+#ifdef __APPLE__
+        if (!ret) ret = setsockopt( unix_fd, SOL_SOCKET, SO_REUSEPORT, &reuse, sizeof(reuse) );
+#endif
+        if (ret)
+            set_error( sock_get_ntstatus( errno ) );
+        else
+            sock->reuseaddr = !!reuse;
+        return;
+    }
+
+    case IOCTL_AFD_WINE_SET_SO_EXCLUSIVEADDRUSE:
+    {
+        int exclusive;
+
+        if (get_req_data_size() < sizeof(exclusive))
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+
+        exclusive = *(int *)get_req_data();
+        if (exclusive && sock->reuseaddr)
+        {
+            set_error( STATUS_INVALID_PARAMETER );
+            return;
+        }
+        sock->exclusiveaddruse = !!exclusive;
+        return;
+    }
+
+    case IOCTL_AFD_WINE_GET_SO_SNDBUF:
+    {
+        int sndbuf = sock->sndbuf;
+
+        if (get_reply_max_size() < sizeof(sndbuf))
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+
+        set_reply_data( &sndbuf, sizeof(sndbuf) );
+        return;
+    }
+
+    case IOCTL_AFD_WINE_SET_SO_SNDBUF:
+    {
+        DWORD sndbuf;
+
+        if (get_req_data_size() < sizeof(sndbuf))
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+        sndbuf = *(DWORD *)get_req_data();
+
+#ifdef __APPLE__
+        if (!sndbuf)
+        {
+            /* setsockopt fails if a zero value is passed */
+            sock->sndbuf = sndbuf;
+            return;
+        }
+#endif
+
+        if (!setsockopt( unix_fd, SOL_SOCKET, SO_SNDBUF, (char *)&sndbuf, sizeof(sndbuf) ))
+            sock->sndbuf = sndbuf;
+        else
+            set_error( sock_get_ntstatus( errno ) );
+        return;
+    }
+
+    case IOCTL_AFD_WINE_GET_SO_SNDTIMEO:
+    {
+        DWORD sndtimeo = sock->sndtimeo;
+
+        if (get_reply_max_size() < sizeof(sndtimeo))
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+
+        set_reply_data( &sndtimeo, sizeof(sndtimeo) );
+        return;
+    }
+
+    case IOCTL_AFD_WINE_SET_SO_SNDTIMEO:
+    {
+        DWORD sndtimeo;
+
+        if (get_req_data_size() < sizeof(sndtimeo))
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+        sndtimeo = *(DWORD *)get_req_data();
+
+        sock->sndtimeo = sndtimeo;
+        return;
+    }
+
+    case IOCTL_AFD_WINE_GET_SO_CONNECT_TIME:
+    {
+        DWORD time = ~0u;
+
+        if (get_reply_max_size() < sizeof(time))
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+
+        if (sock->state == SOCK_CONNECTED)
+            time = (current_time - sock->connect_time) / 10000000;
+
+        set_reply_data( &time, sizeof(time) );
+        return;
+    }
+
+    case IOCTL_AFD_WINE_GET_SO_REUSEADDR:
+    {
+        int reuse;
+
+        if (!get_reply_max_size())
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+
+        reuse = sock->reuseaddr;
+        set_reply_data( &reuse, min( sizeof(reuse), get_reply_max_size() ));
+        return;
+    }
+
+    case IOCTL_AFD_WINE_GET_SO_EXCLUSIVEADDRUSE:
+    {
+        int exclusive;
+
+        if (!get_reply_max_size())
+        {
+            set_error( STATUS_BUFFER_TOO_SMALL );
+            return;
+        }
+
+        exclusive = sock->exclusiveaddruse;
+        set_reply_data( &exclusive, min( sizeof(exclusive), get_reply_max_size() ));
+        return;
+    }
+
+    case IOCTL_AFD_POLL:
+    {
+        if (get_reply_max_size() < get_req_data_size())
+        {
+            set_error( STATUS_INVALID_PARAMETER );
+            return;
+        }
+
+        if (is_machine_64bit( current->process->machine ))
+        {
+            const struct afd_poll_params_64 *params = get_req_data();
+
+            if (get_req_data_size() < sizeof(struct afd_poll_params_64) ||
+                get_req_data_size() < offsetof( struct afd_poll_params_64, sockets[params->count] ))
+            {
+                set_error( STATUS_INVALID_PARAMETER );
+                return;
+            }
+
+            poll_socket( sock, async, params->exclusive, params->timeout, params->count, params->sockets );
+        }
+        else
+        {
+            const struct afd_poll_params_32 *params = get_req_data();
+            struct afd_poll_socket_64 *sockets;
+            unsigned int i;
+
+            if (get_req_data_size() < sizeof(struct afd_poll_params_32) ||
+                get_req_data_size() < offsetof( struct afd_poll_params_32, sockets[params->count] ))
+            {
+                set_error( STATUS_INVALID_PARAMETER );
+                return;
+            }
+
+            if (!(sockets = mem_alloc( params->count * sizeof(*sockets) ))) return;
+            for (i = 0; i < params->count; ++i)
+            {
+                sockets[i].socket = params->sockets[i].socket;
+                sockets[i].flags = params->sockets[i].flags;
+                sockets[i].status = params->sockets[i].status;
+            }
+
+            poll_socket( sock, async, params->exclusive, params->timeout, params->count, sockets );
+            free( sockets );
+        }
+
+        return;
+    }
+
+    default:
+        set_error( STATUS_NOT_SUPPORTED );
+        return;
+    }
+}
+
+static void handle_exclusive_poll(struct poll_req *req)
+{
+    unsigned int i;
+
+    for (i = 0; i < req->count; ++i)
+    {
+        struct sock *sock = req->sockets[i].sock;
+        struct poll_req *main_poll = sock->main_poll;
+
+        if (main_poll && main_poll->exclusive && req->exclusive)
+        {
+            complete_async_poll( main_poll, STATUS_SUCCESS );
+            main_poll = NULL;
+        }
+
+        if (!main_poll)
+            sock->main_poll = req;
+    }
+}
+
+static void poll_socket( struct sock *poll_sock, struct async *async, int exclusive, timeout_t timeout,
+                         unsigned int count, const struct afd_poll_socket_64 *sockets )
+{
+    BOOL signaled = FALSE;
+    struct poll_req *req;
+    unsigned int i, j;
+
+    if (!count)
+    {
+        set_error( STATUS_INVALID_PARAMETER );
+        return;
+    }
+
+    if (!(req = mem_alloc( offsetof( struct poll_req, sockets[count] ) )))
+        return;
+
+    req->timeout = NULL;
+    req->pending = 0;
+    if (timeout && timeout != TIMEOUT_INFINITE &&
+        !(req->timeout = add_timeout_user( timeout, async_poll_timeout, req )))
+    {
+        free( req );
+        return;
+    }
+    req->orig_timeout = timeout;
+
+    for (i = 0; i < count; ++i)
+    {
+        req->sockets[i].sock = (struct sock *)get_handle_obj( current->process, sockets[i].socket, 0, &sock_ops );
+        if (!req->sockets[i].sock)
+        {
+            for (j = 0; j < i; ++j) release_object( req->sockets[j].sock );
+            if (req->timeout) remove_timeout_user( req->timeout );
+            free( req );
+            return;
+        }
+        req->sockets[i].handle = sockets[i].socket;
+        req->sockets[i].mask = sockets[i].flags;
+        req->sockets[i].flags = 0;
+    }
+
+    req->exclusive = exclusive;
+    req->count = count;
+    req->async = (struct async *)grab_object( async );
+    req->iosb = async_get_iosb( async );
+
+    handle_exclusive_poll(req);
+
+    list_add_tail( &poll_list, &req->entry );
+    async_set_completion_callback( async, free_poll_req, req );
+    queue_async( &poll_sock->poll_q, async );
+
+    for (i = 0; i < count; ++i)
+    {
+        struct sock *sock = req->sockets[i].sock;
+        int mask = req->sockets[i].mask;
+        struct pollfd pollfd;
+
+        pollfd.fd = get_unix_fd( sock->fd );
+        pollfd.events = poll_flags_from_afd( sock, mask );
+        if (pollfd.events >= 0 && poll( &pollfd, 1, 0 ) >= 0)
+            sock_poll_event( sock->fd, pollfd.revents );
+
+        /* FIXME: do other error conditions deserve a similar treatment? */
+        if (sock->state != SOCK_CONNECTING && sock->errors[AFD_POLL_BIT_CONNECT_ERR] && (mask & AFD_POLL_CONNECT_ERR))
+        {
+            req->sockets[i].flags |= AFD_POLL_CONNECT_ERR;
+            req->sockets[i].status = sock_get_ntstatus( sock->errors[AFD_POLL_BIT_CONNECT_ERR] );
+        }
+    }
+
+    for (i = 0; i < count; ++i)
+    {
+        if (req->sockets[i].flags)
+            signaled = TRUE;
+    }
+
+    if (!timeout || signaled)
+        complete_async_poll( req, STATUS_SUCCESS );
+    else
+        req->pending = 1;
+
+    for (i = 0; i < req->count; ++i)
+        sock_reselect( req->sockets[i].sock );
+    set_error( STATUS_PENDING );
+}
+
+#ifdef HAVE_LINUX_RTNETLINK_H
+
+/* only keep one ifchange object around, all sockets waiting for wakeups will look to it */
+static struct object *ifchange_object;
+
+static void ifchange_dump( struct object *obj, int verbose );
+static struct fd *ifchange_get_fd( struct object *obj );
+static void ifchange_destroy( struct object *obj );
+
+static int ifchange_get_poll_events( struct fd *fd );
+static void ifchange_poll_event( struct fd *fd, int event );
+
+struct ifchange
+{
+    struct object       obj;     /* object header */
+    struct fd          *fd;      /* interface change file descriptor */
+    struct list         sockets; /* list of sockets to send interface change notifications */
+};
+
+static const struct object_ops ifchange_ops =
+{
+    sizeof(struct ifchange), /* size */
+    &no_type,                /* type */
+    ifchange_dump,           /* dump */
+    no_add_queue,            /* add_queue */
+    NULL,                    /* remove_queue */
+    NULL,                    /* signaled */
+    no_satisfied,            /* satisfied */
+    no_signal,               /* signal */
+    ifchange_get_fd,         /* get_fd */
+    default_get_sync,        /* get_sync */
+    default_map_access,      /* map_access */
+    default_get_sd,          /* get_sd */
+    default_set_sd,          /* set_sd */
+    no_get_full_name,        /* get_full_name */
+    no_lookup_name,          /* lookup_name */
+    no_link_name,            /* link_name */
+    NULL,                    /* unlink_name */
+    no_open_file,            /* open_file */
+    no_kernel_obj_list,      /* get_kernel_obj_list */
+    no_close_handle,         /* close_handle */
+    ifchange_destroy         /* destroy */
+};
+
+static const struct fd_ops ifchange_fd_ops =
+{
+    ifchange_get_poll_events, /* get_poll_events */
+    ifchange_poll_event,      /* poll_event */
+    NULL,                     /* get_fd_type */
+    no_fd_read,               /* read */
+    no_fd_write,              /* write */
+    no_fd_flush,              /* flush */
+    no_fd_get_file_info,      /* get_file_info */
+    no_fd_get_volume_info,    /* get_volume_info */
+    no_fd_ioctl,              /* ioctl */
+    NULL,                     /* cancel_async */
+    NULL,                     /* queue_async */
+    NULL                      /* reselect_async */
+};
+
+static void ifchange_dump( struct object *obj, int verbose )
+{
+    assert( obj->ops == &ifchange_ops );
+    fprintf( stderr, "Interface change\n" );
+}
+
+static struct fd *ifchange_get_fd( struct object *obj )
+{
+    struct ifchange *ifchange = (struct ifchange *)obj;
+    return (struct fd *)grab_object( ifchange->fd );
+}
+
+static void ifchange_destroy( struct object *obj )
+{
+    struct ifchange *ifchange = (struct ifchange *)obj;
+    assert( obj->ops == &ifchange_ops );
+
+    release_object( ifchange->fd );
+
+    /* reset the global ifchange object so that it will be recreated if it is needed again */
+    assert( obj == ifchange_object );
+    ifchange_object = NULL;
+}
+
+static int ifchange_get_poll_events( struct fd *fd )
+{
+    return POLLIN;
+}
+
+/* wake up all the sockets waiting for a change notification event */
+static void ifchange_wake_up( struct object *obj, unsigned int status )
+{
+    struct ifchange *ifchange = (struct ifchange *)obj;
+    struct list *ptr, *next;
+    assert( obj->ops == &ifchange_ops );
+    assert( obj == ifchange_object );
+
+    LIST_FOR_EACH_SAFE( ptr, next, &ifchange->sockets )
+    {
+        struct sock *sock = LIST_ENTRY( ptr, struct sock, ifchange_entry );
+
+        assert( sock->ifchange_obj );
+        async_wake_up( &sock->ifchange_q, status ); /* issue ifchange notification for the socket */
+        sock_release_ifchange( sock ); /* remove socket from list and decrement ifchange refcount */
+    }
+}
+
+static void ifchange_poll_event( struct fd *fd, int event )
+{
+    struct object *ifchange = get_fd_user( fd );
+    unsigned int status = STATUS_PENDING;
+    char buffer[PIPE_BUF];
+    int r;
+
+    r = recv( get_unix_fd(fd), buffer, sizeof(buffer), MSG_DONTWAIT );
+    if (r < 0)
+    {
+        if (errno == EWOULDBLOCK || (EWOULDBLOCK != EAGAIN && errno == EAGAIN))
+            return;  /* retry when poll() says the socket is ready */
+        status = sock_get_ntstatus( errno );
+    }
+    else if (r > 0)
+    {
+        struct nlmsghdr *nlh;
+
+        for (nlh = (struct nlmsghdr *)buffer; NLMSG_OK(nlh, r); nlh = NLMSG_NEXT(nlh, r))
+        {
+            if (nlh->nlmsg_type == NLMSG_DONE)
+                break;
+            if (nlh->nlmsg_type == RTM_NEWADDR || nlh->nlmsg_type == RTM_DELADDR)
+                status = STATUS_SUCCESS;
+        }
+    }
+    else status = STATUS_CANCELLED;
+
+    if (status != STATUS_PENDING) ifchange_wake_up( ifchange, status );
+}
+
+#endif
+
+/* we only need one of these interface notification objects, all of the sockets dependent upon
+ * it will wake up when a notification event occurs */
+ static struct object *get_ifchange( void )
+ {
+#ifdef HAVE_LINUX_RTNETLINK_H
+    struct ifchange *ifchange;
+    struct sockaddr_nl addr;
+    int unix_fd;
+
+    if (ifchange_object)
+    {
+        /* increment the refcount for each socket that uses the ifchange object */
+        return grab_object( ifchange_object );
+    }
+
+    /* create the socket we need for processing interface change notifications */
+    unix_fd = socket( PF_NETLINK, SOCK_RAW, NETLINK_ROUTE );
+    if (unix_fd == -1)
+    {
+        set_error( sock_get_ntstatus( errno ));
+        return NULL;
+    }
+    fcntl( unix_fd, F_SETFL, O_NONBLOCK ); /* make socket nonblocking */
+    memset( &addr, 0, sizeof(addr) );
+    addr.nl_family = AF_NETLINK;
+    addr.nl_groups = RTMGRP_IPV4_IFADDR;
+    /* bind the socket to the special netlink kernel interface */
+    if (bind( unix_fd, (struct sockaddr *)&addr, sizeof(addr) ) == -1)
+    {
+        close( unix_fd );
+        set_error( sock_get_ntstatus( errno ));
+        return NULL;
+    }
+    if (!(ifchange = alloc_object( &ifchange_ops )))
+    {
+        close( unix_fd );
+        set_error( STATUS_NO_MEMORY );
+        return NULL;
+    }
+    list_init( &ifchange->sockets );
+    if (!(ifchange->fd = create_anonymous_fd( &ifchange_fd_ops, unix_fd, &ifchange->obj, 0 )))
+    {
+        release_object( ifchange );
+        set_error( STATUS_NO_MEMORY );
+        return NULL;
+    }
+    set_fd_events( ifchange->fd, POLLIN ); /* enable read wakeup on the file descriptor */
+
+    /* the ifchange object is now successfully configured */
+    ifchange_object = &ifchange->obj;
+    return &ifchange->obj;
+#else
+    set_error( STATUS_NOT_SUPPORTED );
+    return NULL;
+#endif
+}
+
+/* add the socket to the interface change notification list */
+static void ifchange_add_sock( struct object *obj, struct sock *sock )
+{
+#ifdef HAVE_LINUX_RTNETLINK_H
+    struct ifchange *ifchange = (struct ifchange *)obj;
+
+    list_add_tail( &ifchange->sockets, &sock->ifchange_entry );
+#endif
+}
+
+/* create a new ifchange queue for a specific socket or, if one already exists, reuse the existing one */
+static struct object *sock_get_ifchange( struct sock *sock )
+{
+    struct object *ifchange;
+
+    if (sock->ifchange_obj) /* reuse existing ifchange_obj for this socket */
+        return sock->ifchange_obj;
+
+    if (!(ifchange = get_ifchange()))
+        return NULL;
+
+    /* add the socket to the ifchange notification list */
+    ifchange_add_sock( ifchange, sock );
+    sock->ifchange_obj = ifchange;
+    return ifchange;
+}
+
+/* destroy an existing ifchange queue for a specific socket */
+static void sock_release_ifchange( struct sock *sock )
+{
+    if (sock->ifchange_obj)
+    {
+        list_remove( &sock->ifchange_entry );
+        release_object( sock->ifchange_obj );
+        sock->ifchange_obj = NULL;
+    }
+}
+
+static void socket_device_dump( struct object *obj, int verbose );
+static struct object *socket_device_lookup_name( struct object *obj, struct unicode_str *name,
+                                                 unsigned int attr, struct object *root );
+static struct object *socket_device_open_file( struct object *obj, unsigned int access,
+                                               unsigned int sharing, unsigned int options );
+
+static const struct object_ops socket_device_ops =
+{
+    sizeof(struct object),      /* size */
+    &device_type,               /* type */
+    socket_device_dump,         /* dump */
+    no_add_queue,               /* add_queue */
+    NULL,                       /* remove_queue */
+    NULL,                       /* signaled */
+    no_satisfied,               /* satisfied */
+    no_signal,                  /* signal */
+    no_get_fd,                  /* get_fd */
+    default_get_sync,           /* get_sync */
+    default_map_access,         /* map_access */
+    default_get_sd,             /* get_sd */
+    default_set_sd,             /* set_sd */
+    default_get_full_name,      /* get_full_name */
+    socket_device_lookup_name,  /* lookup_name */
+    directory_link_name,        /* link_name */
+    default_unlink_name,        /* unlink_name */
+    socket_device_open_file,    /* open_file */
+    no_kernel_obj_list,         /* get_kernel_obj_list */
+    no_close_handle,            /* close_handle */
+    no_destroy                  /* destroy */
+};
+
+static void socket_device_dump( struct object *obj, int verbose )
+{
+    fputs( "Socket device\n", stderr );
+}
+
+static struct object *socket_device_lookup_name( struct object *obj, struct unicode_str *name,
+                                                 unsigned int attr, struct object *root )
+{
+    if (name) name->len = 0;
+    return NULL;
+}
+
+static struct object *socket_device_open_file( struct object *obj, unsigned int access,
+                                               unsigned int sharing, unsigned int options )
+{
+    struct sock *sock;
+
+    if (!(sock = create_socket())) return NULL;
+    if (!(sock->fd = alloc_pseudo_fd( &sock_fd_ops, &sock->obj, options )))
+    {
+        release_object( sock );
+        return NULL;
+    }
+    return &sock->obj;
+}
+
+struct object *create_socket_device( struct object *root, const struct unicode_str *name,
+                                     unsigned int attr, const struct security_descriptor *sd )
+{
+    return create_named_object( root, &socket_device_ops, name, attr, sd );
+}
+
+DECL_HANDLER(recv_socket)
+{
+    struct sock *sock = (struct sock *)get_handle_obj( current->process, req->async.handle, 0, &sock_ops );
+    unsigned int status = STATUS_PENDING;
+    timeout_t timeout = 0;
+    struct async *async;
+    struct fd *fd;
+
+    if (!sock) return;
+    fd = sock->fd;
+
+    if (!req->force_async && !sock->nonblocking && is_fd_overlapped( fd ))
+        timeout = (timeout_t)sock->rcvtimeo * -10000;
+
+    if (sock->rd_shutdown)
+        status = STATUS_PIPE_DISCONNECTED;
+    else if (sock->reset)
+        status = STATUS_CONNECTION_RESET;
+    else if (!async_queued( &sock->read_q ))
+    {
+        /* If read_q is not empty, we cannot really tell if the already queued
+         * asyncs will not consume all available data; if there's no data
+         * available, the current request won't be immediately satiable.
+         */
+        if ((!req->force_async && sock->nonblocking) ||
+            check_fd_events( sock->fd, req->oob && !is_oobinline( sock ) ? POLLPRI : POLLIN ))
+        {
+            /* Give the client opportunity to complete synchronously.
+             * If it turns out that the I/O request is not actually immediately satiable,
+             * the client may then choose to re-queue the async (with STATUS_PENDING).
+             *
+             * Note: If the nonblocking flag is set, we don't poll the socket
+             * here and always opt for synchronous completion first.  This is
+             * because the application has probably seen POLLIN already from a
+             * preceding select()/poll() call before it requested to receive
+             * data.
+             */
+            status = STATUS_ALERTED;
+        }
+    }
+
+    if (status == STATUS_PENDING && !req->force_async && sock->nonblocking)
+        status = STATUS_DEVICE_NOT_READY;
+
+    sock->pending_events &= ~(req->oob ? AFD_POLL_OOB : AFD_POLL_READ);
+    sock->reported_events &= ~(req->oob ? AFD_POLL_OOB : AFD_POLL_READ);
+
+    if ((async = create_request_async( fd, get_fd_comp_flags( fd ), &req->async, 0 )))
+    {
+        set_error( status );
+
+        if (timeout)
+            async_set_timeout( async, timeout, STATUS_IO_TIMEOUT );
+
+        if (status == STATUS_PENDING || status == STATUS_ALERTED)
+            queue_async( &sock->read_q, async );
+
+        /* always reselect; we changed reported_events above */
+        sock_reselect( sock );
+
+        reply->wait = async_handoff( async, NULL, 0 );
+        reply->options = get_fd_options( fd );
+        reply->nonblocking = sock->nonblocking;
+        release_object( async );
+    }
+    release_object( sock );
+}
+
+static void send_socket_completion_callback( void *private )
+{
+    struct send_req *send_req = private;
+    struct iosb *iosb = send_req->iosb;
+    struct sock *sock = send_req->sock;
+
+    if (iosb->status != STATUS_SUCCESS)
+    {
+        /* send() calls only clear and reselect events if unsuccessful. */
+        sock->pending_events &= ~AFD_POLL_WRITE;
+        sock->reported_events &= ~AFD_POLL_WRITE;
+        sock_reselect( sock );
+    }
+
+    release_object( iosb );
+    release_object( sock );
+    free( send_req );
+}
+
+DECL_HANDLER(send_socket)
+{
+    struct sock *sock = (struct sock *)get_handle_obj( current->process, req->async.handle, 0, &sock_ops );
+    unsigned int status = STATUS_PENDING;
+    timeout_t timeout = 0;
+    struct async *async;
+    struct fd *fd;
+    int bind_errno = 0;
+    BOOL force_async = req->flags & SERVER_SOCKET_IO_FORCE_ASYNC;
+
+    if (!sock) return;
+    fd = sock->fd;
+
+    if (sock->type == WS_SOCK_DGRAM && !sock->bound)
+    {
+        union unix_sockaddr unix_addr;
+        socklen_t unix_len;
+        int unix_fd = get_unix_fd( fd );
+
+        unix_len = get_unix_sockaddr_any( &unix_addr, sock->family );
+        if (bind( unix_fd, &unix_addr.addr, unix_len ) < 0)
+            bind_errno = errno;
+
+        if (getsockname( unix_fd, &unix_addr.addr, &unix_len ) >= 0)
+        {
+            sock->addr_len = sockaddr_from_unix( &unix_addr, &sock->addr.addr, sizeof(sock->addr) );
+            sock->bound = 1;
+        }
+        else if (!bind_errno) bind_errno = errno;
+    }
+
+    if (!force_async && !sock->nonblocking && is_fd_overlapped( fd ))
+        timeout = (timeout_t)sock->sndtimeo * -10000;
+
+    if (bind_errno) status = sock_get_ntstatus( bind_errno );
+    else if (sock->wr_shutdown) status = STATUS_PIPE_DISCONNECTED;
+    else if (!async_queue_has_waiting_asyncs( &sock->write_q ))
+    {
+        /* If write_q is not empty, we cannot really tell if the already queued
+         * asyncs will not consume all available space; if there's no space
+         * available, the current request won't be immediately satiable.
+         */
+        if ((!force_async && sock->nonblocking) || check_fd_events( sock->fd, POLLOUT ))
+        {
+            /* Give the client opportunity to complete synchronously.
+             * If it turns out that the I/O request is not actually immediately satiable,
+             * the client may then choose to re-queue the async (with STATUS_PENDING).
+             *
+             * Note: If the nonblocking flag is set, we don't poll the socket
+             * here and always opt for synchronous completion first.  This is
+             * because the application has probably seen POLLOUT already from a
+             * preceding select()/poll() call before it requested to send data.
+             *
+             * Furthermore, some applications expect that any send() call on a
+             * socket that has indicated POLLOUT beforehand never fails with
+             * WSAEWOULDBLOCK.  It's possible that Linux poll() may yield
+             * POLLOUT on the first call but not the second, even if no send()
+             * call has been made in the meanwhile.  This can happen for a
+             * number of reasons; for example, TCP fragmentation may consume
+             * extra buffer space for each packet that has been split out, or
+             * the TCP/IP networking stack may decide to shrink the send buffer
+             * due to memory pressure.
+             */
+            status = STATUS_ALERTED;
+        }
+    }
+
+    if (status == STATUS_PENDING && !force_async && sock->nonblocking)
+        status = STATUS_DEVICE_NOT_READY;
+
+    if ((async = create_request_async( fd, get_fd_comp_flags( fd ), &req->async,
+                                       req->flags & SERVER_SOCKET_IO_SYSTEM )))
+    {
+        struct send_req *send_req;
+        struct iosb *iosb = async_get_iosb( async );
+
+        if ((send_req = mem_alloc( sizeof(*send_req) )))
+        {
+            send_req->iosb = (struct iosb *)grab_object( iosb );
+            send_req->sock = (struct sock *)grab_object( sock );
+            async_set_completion_callback( async, send_socket_completion_callback, send_req );
+        }
+        else if (status == STATUS_PENDING || status == STATUS_DEVICE_NOT_READY)
+            status = STATUS_NO_MEMORY;
+
+        release_object( iosb );
+
+        set_error( status );
+
+        if (timeout)
+            async_set_timeout( async, timeout, STATUS_IO_TIMEOUT );
+
+        if (status == STATUS_PENDING || status == STATUS_ALERTED)
+        {
+            queue_async( &sock->write_q, async );
+            sock_reselect( sock );
+        }
+
+        reply->wait = async_handoff( async, NULL, 0 );
+        reply->options = get_fd_options( fd );
+        reply->nonblocking = sock->nonblocking;
+        release_object( async );
+    }
+    release_object( sock );
+}
+
+DECL_HANDLER(socket_get_events)
+{
+    struct sock *sock = (struct sock *)get_handle_obj( current->process, req->handle, 0, &sock_ops );
+    unsigned int status[13];
+    struct event *event = NULL;
+    unsigned int i;
+
+    if (get_reply_max_size() < sizeof(status))
+    {
+        set_error( STATUS_INVALID_PARAMETER );
+        return;
+    }
+
+    if (!sock) return;
+
+    if (req->event)
+    {
+        if (!(event = get_event_obj( current->process, req->event, EVENT_MODIFY_STATE )))
+        {
+            release_object( sock );
+            return;
+        }
+    }
+
+    reply->flags = sock->pending_events & sock->mask;
+    for (i = 0; i < ARRAY_SIZE( status ); ++i)
+        status[i] = sock_get_ntstatus( sock->errors[i] );
+
+    sock->pending_events &= ~sock->mask;
+    sock_reselect( sock );
+
+    if (event)
+    {
+        reset_event( event );
+        release_object( event );
+    }
+
+    set_reply_data( status, sizeof(status) );
+
+    release_object( sock );
+}
+
+DECL_HANDLER(socket_send_icmp_id)
+{
+    struct sock *sock = (struct sock *)get_handle_obj( current->process, req->handle, 0, &sock_ops );
+
+    if (!sock) return;
+
+    if (sock->icmp_fixup_data_len == MAX_ICMP_HISTORY_LENGTH)
+    {
+        memmove( sock->icmp_fixup_data, sock->icmp_fixup_data + 1,
+                 sizeof(*sock->icmp_fixup_data) * (MAX_ICMP_HISTORY_LENGTH - 1) );
+        --sock->icmp_fixup_data_len;
+    }
+
+    sock->icmp_fixup_data[sock->icmp_fixup_data_len].icmp_id = req->icmp_id;
+    sock->icmp_fixup_data[sock->icmp_fixup_data_len].icmp_seq = req->icmp_seq;
+    ++sock->icmp_fixup_data_len;
+
+    release_object( sock );
+}
+
+DECL_HANDLER(socket_get_icmp_id)
+{
+    struct sock *sock = (struct sock *)get_handle_obj( current->process, req->handle, 0, &sock_ops );
+    unsigned int i;
+
+    if (!sock) return;
+
+    for (i = 0; i < sock->icmp_fixup_data_len; ++i)
+    {
+        if (sock->icmp_fixup_data[i].icmp_seq == req->icmp_seq)
+        {
+            reply->icmp_id = sock->icmp_fixup_data[i].icmp_id;
+            --sock->icmp_fixup_data_len;
+            memmove( &sock->icmp_fixup_data[i], &sock->icmp_fixup_data[i + 1],
+                     (sock->icmp_fixup_data_len - i) * sizeof(*sock->icmp_fixup_data) );
+            release_object( sock );
+            return;
+        }
+    }
+
+    set_error( STATUS_NOT_FOUND );
+    release_object( sock );
+}
+
+static inline MIB_TCP_STATE tcp_state_to_mib_state( int state )
+{
+   switch (state)
+   {
+      case TCPS_ESTABLISHED: return MIB_TCP_STATE_ESTAB;
+      case TCPS_SYN_SENT: return MIB_TCP_STATE_SYN_SENT;
+      case TCPS_SYN_RECEIVED: return MIB_TCP_STATE_SYN_RCVD;
+      case TCPS_FIN_WAIT_1: return MIB_TCP_STATE_FIN_WAIT1;
+      case TCPS_FIN_WAIT_2: return MIB_TCP_STATE_FIN_WAIT2;
+      case TCPS_TIME_WAIT: return MIB_TCP_STATE_TIME_WAIT;
+      case TCPS_CLOSE_WAIT: return MIB_TCP_STATE_CLOSE_WAIT;
+      case TCPS_LAST_ACK: return MIB_TCP_STATE_LAST_ACK;
+      case TCPS_LISTEN: return MIB_TCP_STATE_LISTEN;
+      case TCPS_CLOSING: return MIB_TCP_STATE_CLOSING;
+      default:
+      case TCPS_CLOSED: return MIB_TCP_STATE_CLOSED;
+   }
+}
+
+static MIB_TCP_STATE get_tcp_socket_state( int fd )
+{
+#ifdef __APPLE__
+    /* The macOS getsockopt name and struct are compatible with those on Linux
+       and FreeBSD, just named differently. */
+    #define TCP_INFO TCP_CONNECTION_INFO
+    #define tcp_info tcp_connection_info
+#endif
+
+    struct tcp_info info;
+    socklen_t info_len = sizeof(info);
+    if (getsockopt( fd, IPPROTO_TCP, TCP_INFO, &info, &info_len ) == 0)
+        return tcp_state_to_mib_state( info.tcpi_state );
+
+    if (debug_level)
+        fprintf( stderr, "getsockopt TCP_INFO failed: %s\n", strerror( errno ) );
+
+    return MIB_TCP_STATE_ESTAB;
+}
+
+struct enum_tcp_connection_info
+{
+    MIB_TCP_STATE state_filter;
+    unsigned int count;
+    union tcp_connection *conn;
+};
+
+static int enum_tcp_connections( struct process *process, struct object *obj, void *user )
+{
+    struct sock *sock = (struct sock *)obj;
+    struct enum_tcp_connection_info *info = user;
+    MIB_TCP_STATE socket_state;
+    union tcp_connection *conn;
+
+    assert( obj->ops == &sock_ops );
+
+    if (sock->type != WS_SOCK_STREAM || !(sock->family == WS_AF_INET || sock->family == WS_AF_INET6))
+        return 0;
+
+    socket_state = get_tcp_socket_state( get_unix_fd(sock->fd) );
+    if (info->state_filter && socket_state != info->state_filter)
+        return 0;
+
+    if (!info->conn)
+    {
+        info->count++;
+        return 0;
+    }
+
+    assert( info->count );
+    conn = info->conn++;
+    memset( conn, 0, sizeof(*conn) );
+
+    conn->common.family = sock->family;
+    conn->common.state = socket_state;
+    conn->common.owner = process->id;
+
+    if (sock->family == WS_AF_INET)
+    {
+        conn->ipv4.local_addr = sock->addr.in.sin_addr.WS_s_addr;
+        conn->ipv4.local_port = sock->addr.in.sin_port;
+        if (sock->peer_addr_len)
+        {
+            conn->ipv4.remote_addr = sock->peer_addr.in.sin_addr.WS_s_addr;
+            conn->ipv4.remote_port = sock->peer_addr.in.sin_port;
+        }
+    }
+    else
+    {
+        memcpy( &conn->ipv6.local_addr, &sock->addr.in6.sin6_addr, 16 );
+        conn->ipv6.local_scope_id = sock->addr.in6.sin6_scope_id;
+        conn->ipv6.local_port = sock->addr.in6.sin6_port;
+        if (sock->peer_addr_len)
+        {
+            memcpy( &conn->ipv6.remote_addr, &sock->peer_addr.in6.sin6_addr, 16 );
+            conn->ipv6.remote_scope_id = sock->peer_addr.in6.sin6_scope_id;
+            conn->ipv6.remote_port = sock->peer_addr.in6.sin6_port;
+        }
+    }
+
+    info->count--;
+
+    return 0;
+}
+
+DECL_HANDLER(get_tcp_connections)
+{
+    struct enum_tcp_connection_info info;
+    union tcp_connection *conn;
+    data_size_t max_conns = get_reply_max_size() / sizeof(*conn);
+
+    info.state_filter = req->state_filter;
+    info.conn = NULL;
+    info.count = 0;
+    enum_handles_of_type( &sock_ops, enum_tcp_connections, &info );
+    reply->count = info.count;
+
+    if (max_conns < info.count)
+        set_error( STATUS_BUFFER_TOO_SMALL );
+    else if ((conn = set_reply_data_size( info.count * sizeof(*conn) )))
+    {
+        info.conn = conn;
+        enum_handles_of_type( &sock_ops, enum_tcp_connections, &info );
+    }
+}
+
+struct enum_udp_endpoint_info
+{
+    unsigned int count;
+    union udp_endpoint *endpt;
+};
+
+static int enum_udp_endpoints( struct process *process, struct object *obj, void *user )
+{
+    struct sock *sock = (struct sock *)obj;
+    struct enum_udp_endpoint_info *info = user;
+    union udp_endpoint *endpt;
+
+    assert( obj->ops == &sock_ops );
+
+    if (sock->type != WS_SOCK_DGRAM || !(sock->family == WS_AF_INET || sock->family == WS_AF_INET6))
+        return 0;
+
+    if (!info->endpt)
+    {
+        info->count++;
+        return 0;
+    }
+
+    assert( info->count );
+    endpt = info->endpt++;
+    memset( endpt, 0, sizeof(*endpt) );
+
+    endpt->common.family = sock->family;
+    endpt->common.owner = process->id;
+
+    if (sock->family == WS_AF_INET)
+    {
+        endpt->ipv4.addr = sock->addr.in.sin_addr.WS_s_addr;
+        endpt->ipv4.port = sock->addr.in.sin_port;
+    }
+    else
+    {
+        memcpy( &endpt->ipv6.addr, &sock->addr.in6.sin6_addr, 16 );
+        endpt->ipv6.scope_id = sock->addr.in6.sin6_scope_id;
+        endpt->ipv6.port = sock->addr.in6.sin6_port;
+    }
+
+    info->count--;
+
+    return 0;
+}
+
+DECL_HANDLER(get_udp_endpoints)
+{
+    struct enum_udp_endpoint_info info;
+    union udp_endpoint *endpt;
+    data_size_t max_endpts = get_reply_max_size() / sizeof(*endpt);
+
+    info.endpt = NULL;
+    info.count = 0;
+    enum_handles_of_type( &sock_ops, enum_udp_endpoints, &info );
+    reply->count = info.count;
+
+    if (max_endpts < info.count)
+        set_error( STATUS_BUFFER_TOO_SMALL );
+    else if ((endpt = set_reply_data_size( info.count * sizeof(*endpt) )))
+    {
+        info.endpt = endpt;
+        enum_handles_of_type( &sock_ops, enum_udp_endpoints, &info );
+    }
+}
diff -ruN --show-c-function server/symlink.c server/symlink.c
--- server/symlink.c	2025-10-10 10:17:47.804758763 -0700
+++ server/symlink.c	2025-10-10 10:22:17.154320711 -0700
@@ -71,10 +71,10 @@ static const struct object_ops symlink_o
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
-    default_get_sync,             /* get_sync */
     default_map_access,           /* map_access */
     default_get_sd,               /* get_sd */
     default_set_sd,               /* set_sd */
diff -ruN --show-c-function server/thread.c server/thread.c
--- server/thread.c	2025-10-10 10:17:48.600775782 -0700
+++ server/thread.c	2025-10-10 10:22:17.173594698 -0700
@@ -60,6 +60,7 @@
 #include "request.h"
 #include "user.h"
 #include "security.h"
+#include "esync.h"
 
 
 /* thread queues */
@@ -85,7 +86,6 @@ struct thread_wait
 struct thread_apc
 {
     struct object       obj;      /* object header */
-    struct object      *sync;     /* sync object for wait/signal */
     struct list         entry;    /* queue linked list */
     struct thread      *caller;   /* thread that queued this apc */
     struct object      *owner;    /* object that queued this apc */
@@ -96,7 +96,7 @@ struct thread_apc
 };
 
 static void dump_thread_apc( struct object *obj, int verbose );
-static struct object *thread_apc_get_sync( struct object *obj );
+static int thread_apc_signaled( struct object *obj, struct wait_queue_entry *entry );
 static void thread_apc_destroy( struct object *obj );
 static void clear_apc_queue( struct list *queue );
 
@@ -105,13 +105,13 @@ static const struct object_ops thread_ap
     sizeof(struct thread_apc),  /* size */
     &no_type,                   /* type */
     dump_thread_apc,            /* dump */
-    NULL,                       /* add_queue */
-    NULL,                       /* remove_queue */
-    NULL,                       /* signaled */
-    NULL,                       /* satisfied */
+    add_queue,                  /* add_queue */
+    remove_queue,               /* remove_queue */
+    thread_apc_signaled,        /* signaled */
+    NULL,                       /* get_esync_fd */
+    no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
-    thread_apc_get_sync,        /* get_sync */
     default_map_access,         /* map_access */
     default_get_sd,             /* get_sd */
     default_set_sd,             /* set_sd */
@@ -130,10 +130,9 @@ static const struct object_ops thread_ap
 
 struct context
 {
-    struct object           obj;        /* object header */
-    struct object          *sync;       /* sync object for wait/signal */
-    unsigned int            status;     /* status of the context */
-    struct context_data     regs[2];    /* context data */
+    struct object   obj;        /* object header */
+    unsigned int    status;     /* status of the context */
+    struct context_data regs[2];/* context data */
 };
 #define CTX_NATIVE  0  /* context for native machine */
 #define CTX_WOW     1  /* context if thread is inside WoW */
@@ -142,21 +141,20 @@ struct context
 static const unsigned int system_flags = SERVER_CTX_DEBUG_REGISTERS;
 
 static void dump_context( struct object *obj, int verbose );
-static struct object *context_get_sync( struct object *obj );
-static void context_destroy( struct object *obj );
+static int context_signaled( struct object *obj, struct wait_queue_entry *entry );
 
 static const struct object_ops context_ops =
 {
     sizeof(struct context),     /* size */
     &no_type,                   /* type */
     dump_context,               /* dump */
-    NULL,                       /* add_queue */
-    NULL,                       /* remove_queue */
-    NULL,                       /* signaled */
-    NULL,                       /* satisfied */
+    add_queue,                  /* add_queue */
+    remove_queue,               /* remove_queue */
+    context_signaled,           /* signaled */
+    NULL,                       /* get_esync_fd */
+    no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
-    context_get_sync,           /* get_sync */
     default_map_access,         /* map_access */
     default_get_sd,             /* get_sd */
     default_set_sd,             /* set_sd */
@@ -167,7 +165,7 @@ static const struct object_ops context_o
     no_open_file,               /* open_file */
     no_kernel_obj_list,         /* get_kernel_obj_list */
     no_close_handle,            /* close_handle */
-    context_destroy,            /* destroy */
+    no_destroy                  /* destroy */
 };
 
 
@@ -189,7 +187,8 @@ struct type_descr thread_type =
 };
 
 static void dump_thread( struct object *obj, int verbose );
-static struct object *thread_get_sync( struct object *obj );
+static int thread_signaled( struct object *obj, struct wait_queue_entry *entry );
+static int thread_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int thread_map_access( struct object *obj, unsigned int access );
 static void thread_poll_event( struct fd *fd, int event );
 static struct list *thread_get_kernel_obj_list( struct object *obj );
@@ -200,13 +199,13 @@ static const struct object_ops thread_op
     sizeof(struct thread),      /* size */
     &thread_type,               /* type */
     dump_thread,                /* dump */
-    NULL,                       /* add_queue */
-    NULL,                       /* remove_queue */
-    NULL,                       /* signaled */
-    NULL,                       /* satisfied */
+    add_queue,                  /* add_queue */
+    remove_queue,               /* remove_queue */
+    thread_signaled,            /* signaled */
+    thread_get_esync_fd,        /* get_esync_fd */
+    no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
-    thread_get_sync,            /* get_sync */
     thread_map_access,          /* map_access */
     default_get_sd,             /* get_sd */
     default_set_sd,             /* set_sd */
@@ -396,13 +395,13 @@ static inline void init_thread_structure
 {
     int i;
 
-    thread->sync            = NULL;
-    thread->alert_sync      = NULL;
     thread->unix_pid        = -1;  /* not known yet */
     thread->unix_tid        = -1;  /* not known yet */
     thread->context         = NULL;
     thread->teb             = 0;
     thread->entry_point     = 0;
+    thread->esync_fd        = -1;
+    thread->esync_apc_fd    = -1;
     thread->system_regs     = 0;
     thread->queue           = NULL;
     thread->wait            = NULL;
@@ -464,35 +463,20 @@ static void dump_context( struct object
 }
 
 
-static struct object *context_get_sync( struct object *obj )
+static int context_signaled( struct object *obj, struct wait_queue_entry *entry )
 {
     struct context *context = (struct context *)obj;
-    assert( obj->ops == &context_ops );
-    return grab_object( context->sync );
+    return context->status != STATUS_PENDING;
 }
 
-static void context_destroy( struct object *obj )
-{
-    struct context *context = (struct context *)obj;
-    assert( obj->ops == &context_ops );
-    if (context->sync) release_object( context->sync );
-}
 
 static struct context *create_thread_context( struct thread *thread )
 {
     struct context *context;
     if (!(context = alloc_object( &context_ops ))) return NULL;
-    context->sync   = NULL;
     context->status = STATUS_PENDING;
     memset( &context->regs, 0, sizeof(context->regs) );
     context->regs[CTX_NATIVE].machine = native_machine;
-
-    if (!(context->sync = create_internal_sync( 1, 0 )))
-    {
-        release_object( context );
-        return NULL;
-    }
-
     return context;
 }
 
@@ -559,9 +543,11 @@ struct thread *create_thread( int fd, st
         release_object( thread );
         return NULL;
     }
-    if (!(thread->request_fd = create_anonymous_fd( &thread_fd_ops, fd, &thread->obj, 0 ))) goto error;
-    if (!(thread->sync = create_internal_sync( 1, 0 ))) goto error;
-    if (get_inproc_device_fd() >= 0 && !(thread->alert_sync = create_inproc_internal_sync( 1, 0 ))) goto error;
+    if (!(thread->request_fd = create_anonymous_fd( &thread_fd_ops, fd, &thread->obj, 0 )))
+    {
+        release_object( thread );
+        return NULL;
+    }
 
     if (process->desktop)
     {
@@ -573,13 +559,15 @@ struct thread *create_thread( int fd, st
         }
     }
 
+    if (do_esync())
+    {
+        thread->esync_fd = esync_create_fd( 0, 0 );
+        thread->esync_apc_fd = esync_create_fd( 0, 0 );
+    }
+
     set_fd_events( thread->request_fd, POLLIN );  /* start listening to events */
     add_process_thread( thread->process, thread );
     return thread;
-
-error:
-    release_object( thread );
-    return NULL;
 }
 
 /* handle a client event */
@@ -611,7 +599,7 @@ static void cleanup_thread( struct threa
     if (thread->context)
     {
         thread->context->status = STATUS_ACCESS_DENIED;
-        signal_sync( thread->context->sync );
+        wake_up( &thread->context->obj, 0 );
         release_object( thread->context );
         thread->context = NULL;
     }
@@ -656,8 +644,9 @@ static void destroy_thread( struct objec
     release_object( thread->process );
     if (thread->id) free_ptid( thread->id );
     if (thread->token) release_object( thread->token );
-    if (thread->alert_sync) release_object( thread->alert_sync );
-    if (thread->sync) release_object( thread->sync );
+
+    if (do_esync())
+        close( thread->esync_fd );
 }
 
 /* dump a thread on stdout for debugging purposes */
@@ -670,11 +659,17 @@ static void dump_thread( struct object *
              thread->id, thread->unix_pid, thread->unix_tid, thread->state );
 }
 
-static struct object *thread_get_sync( struct object *obj )
+static int thread_signaled( struct object *obj, struct wait_queue_entry *entry )
+{
+    struct thread *mythread = (struct thread *)obj;
+    return (mythread->state == TERMINATED);
+}
+
+static int thread_get_esync_fd( struct object *obj, enum esync_type *type )
 {
     struct thread *thread = (struct thread *)obj;
-    assert( obj->ops == &thread_ops );
-    return grab_object( thread->sync );
+    *type = ESYNC_MANUAL_SERVER;
+    return thread->esync_fd;
 }
 
 static unsigned int thread_map_access( struct object *obj, unsigned int access )
@@ -693,11 +688,10 @@ static void dump_thread_apc( struct obje
     fprintf( stderr, "APC owner=%p type=%u\n", apc->owner, apc->call.type );
 }
 
-static struct object *thread_apc_get_sync( struct object *obj )
+static int thread_apc_signaled( struct object *obj, struct wait_queue_entry *entry )
 {
     struct thread_apc *apc = (struct thread_apc *)obj;
-    assert( obj->ops == &thread_apc_ops );
-    return grab_object( apc->sync );
+    return apc->executed;
 }
 
 static void thread_apc_destroy( struct object *obj )
@@ -713,7 +707,6 @@ static void thread_apc_destroy( struct o
             async_set_result( apc->owner, apc->call.async_io.status, 0 );
         release_object( apc->owner );
     }
-    if (apc->sync) release_object( apc->sync );
     reserve_obj_unbind( apc->reserve );
 }
 
@@ -724,7 +717,6 @@ static struct thread_apc *create_apc( st
 
     if ((apc = alloc_object( &thread_apc_ops )))
     {
-        apc->sync        = NULL;
         if (call_data) apc->call = *call_data;
         else apc->call.type = APC_NONE;
         apc->caller      = NULL;
@@ -733,12 +725,6 @@ static struct thread_apc *create_apc( st
         apc->executed    = 0;
         apc->result.type = APC_NONE;
         if (owner) grab_object( owner );
-
-        if (!(apc->sync = create_internal_sync( 1, 0 )))
-        {
-            release_object( apc );
-            return NULL;
-        }
     }
     return apc;
 }
@@ -966,6 +952,8 @@ int resume_thread( struct thread *thread
 /* add a thread to an object wait queue; return 1 if OK, 0 on error */
 int add_queue( struct object *obj, struct wait_queue_entry *entry )
 {
+    grab_object( obj );
+    entry->obj = obj;
     list_add_tail( &obj->wait_queue, &entry->entry );
     return 1;
 }
@@ -974,6 +962,7 @@ int add_queue( struct object *obj, struc
 void remove_queue( struct object *obj, struct wait_queue_entry *entry )
 {
     list_remove( &entry->entry );
+    release_object( obj );
 }
 
 struct thread *get_wait_queue_thread( struct wait_queue_entry *entry )
@@ -1001,46 +990,6 @@ void set_wait_status( struct wait_queue_
     entry->wait->status = status;
 }
 
-static void object_sync_satisfied( struct object *obj, struct wait_queue_entry *entry )
-{
-    struct object *sync = get_obj_sync( obj );
-    sync->ops->satisfied( sync, entry );
-    release_object( sync );
-}
-
-static void object_sync_remove_queue( struct object *obj, struct wait_queue_entry *entry )
-{
-    struct object *sync = get_obj_sync( obj );
-    sync->ops->remove_queue( sync, entry );
-    release_object( sync );
-}
-
-static int object_sync_add_queue( struct object *obj, struct wait_queue_entry *entry )
-{
-    struct object *sync = get_obj_sync( obj );
-    int ret = sync->ops->add_queue( sync, entry );
-    release_object( sync );
-    return ret;
-}
-
-static int object_sync_signaled( struct object *obj, struct wait_queue_entry *entry )
-{
-    struct object *sync = get_obj_sync( obj );
-    int ret = sync->ops->signaled( sync, entry );
-    release_object( sync );
-    return ret;
-}
-
-void signal_sync( struct object *obj )
-{
-    obj->ops->signal( obj, 0, 1 );
-}
-
-void reset_sync( struct object *obj )
-{
-    obj->ops->signal( obj, 0, 0 );
-}
-
 /* finish waiting */
 static unsigned int end_wait( struct thread *thread, unsigned int status )
 {
@@ -1057,22 +1006,18 @@ static unsigned int end_wait( struct thr
         if (wait->select == SELECT_WAIT_ALL)
         {
             for (i = 0, entry = wait->queues; i < wait->count; i++, entry++)
-                object_sync_satisfied( entry->obj, entry );
+                entry->obj->ops->satisfied( entry->obj, entry );
         }
         else
         {
             entry = wait->queues + status;
-            object_sync_satisfied( entry->obj, entry );
+            entry->obj->ops->satisfied( entry->obj, entry );
         }
         status = wait->status;
         if (wait->abandoned) status += STATUS_ABANDONED_WAIT_0;
     }
     for (i = 0, entry = wait->queues; i < wait->count; i++, entry++)
-    {
-        object_sync_remove_queue( entry->obj, entry );
-        release_object( entry->obj );
-        entry->obj = NULL;
-    }
+        entry->obj->ops->remove_queue( entry->obj, entry );
     if (wait->user) remove_timeout_user( wait->user );
     free( wait );
     return status;
@@ -1102,14 +1047,13 @@ static int wait_on( const union select_o
     {
         struct object *obj = objects[i];
         entry->wait = wait;
-        if (!object_sync_add_queue( obj, entry ))
+        if (!obj->ops->add_queue( obj, entry ))
         {
             wait->count = i;
             end_wait( current, get_error() );
             return 0;
         }
 
-        entry->obj = grab_object( obj );
         if (obj == (struct object *)current->queue) idle = 1;
     }
 
@@ -1157,13 +1101,13 @@ static int check_wait( struct thread *th
         /* Note: we must check them all anyway, as some objects may
          * want to do something when signaled, even if others are not */
         for (i = 0, entry = wait->queues; i < wait->count; i++, entry++)
-            not_ok |= !object_sync_signaled( entry->obj, entry );
+            not_ok |= !entry->obj->ops->signaled( entry->obj, entry );
         if (!not_ok) return STATUS_WAIT_0;
     }
     else
     {
         for (i = 0, entry = wait->queues; i < wait->count; i++, entry++)
-            if (object_sync_signaled( entry->obj, entry )) return i;
+            if (entry->obj->ops->signaled( entry->obj, entry )) return i;
     }
 
     if ((wait->flags & SELECT_ALERTABLE) && !list_empty(&thread->user_apc)) return STATUS_USER_APC;
@@ -1279,7 +1223,7 @@ static int signal_object( obj_handle_t h
     obj = get_handle_obj( current->process, handle, 0, NULL );
     if (obj)
     {
-        ret = obj->ops->signal( obj, get_handle_access( current->process, handle ), -1 );
+        ret = obj->ops->signal( obj, get_handle_access( current->process, handle ));
         release_object( obj );
     }
     return ret;
@@ -1370,6 +1314,9 @@ void wake_up( struct object *obj, int ma
     struct list *ptr;
     int ret;
 
+    if (do_esync())
+        esync_wake_up( obj );
+
     LIST_FOR_EACH( ptr, &obj->wait_queue )
     {
         struct wait_queue_entry *entry = LIST_ENTRY( ptr, struct wait_queue_entry, entry );
@@ -1454,9 +1401,10 @@ static int queue_apc( struct process *pr
     list_add_tail( queue, &apc->entry );
     if (!list_prev( queue, &apc->entry ))  /* first one */
     {
-        if (apc->call.type == APC_USER && thread->alert_sync)
-            signal_inproc_sync( thread->alert_sync );
         wake_thread( thread );
+
+        if (do_esync() && queue == &thread->user_apc)
+            esync_wake_fd( thread->esync_apc_fd );
     }
 
     return 1;
@@ -1487,10 +1435,8 @@ void thread_cancel_apc( struct thread *t
         if (apc->owner != owner) continue;
         list_remove( &apc->entry );
         apc->executed = 1;
-        signal_sync( apc->sync );
+        wake_up( &apc->obj, 0 );
         release_object( apc );
-        if (list_empty( &thread->user_apc ) && thread->alert_sync)
-            reset_inproc_sync( thread->alert_sync );
         return;
     }
 }
@@ -1505,9 +1451,11 @@ static struct thread_apc *thread_dequeue
     {
         apc = LIST_ENTRY( ptr, struct thread_apc, entry );
         list_remove( ptr );
-        if (list_empty( &thread->user_apc ) && thread->alert_sync)
-            reset_inproc_sync( thread->alert_sync );
     }
+
+    if (do_esync() && list_empty( &thread->system_apc ) && list_empty( &thread->user_apc ))
+        esync_clear( thread->esync_apc_fd );
+
     return apc;
 }
 
@@ -1521,7 +1469,7 @@ static void clear_apc_queue( struct list
         struct thread_apc *apc = LIST_ENTRY( ptr, struct thread_apc, entry );
         list_remove( &apc->entry );
         apc->executed = 1;
-        signal_sync( apc->sync );
+        wake_up( &apc->obj, 0 );
         release_object( apc );
     }
 }
@@ -1603,7 +1551,9 @@ void kill_thread( struct thread *thread,
     }
     kill_console_processes( thread, 0 );
     abandon_mutexes( thread );
-    signal_sync( thread->sync );
+    wake_up( &thread->obj, 0 );
+    if (do_esync())
+        esync_abandon_mutexes( thread );
     if (violent_death) send_thread_signal( thread, SIGQUIT );
     cleanup_thread( thread );
     remove_process_thread( thread->process, thread );
@@ -1730,7 +1680,6 @@ static int init_thread( struct thread *t
 DECL_HANDLER(init_first_thread)
 {
     struct process *process = current->process;
-    int fd;
 
     if (!init_thread( current, req->reply_fd, req->wait_fd )) return;
 
@@ -1753,12 +1702,6 @@ DECL_HANDLER(init_first_thread)
     reply->server_start = server_start_time;
     set_reply_data( supported_machines,
                     min( supported_machines_count * sizeof(unsigned short), get_reply_max_size() ));
-
-    if ((fd = get_inproc_device_fd()) >= 0)
-    {
-        reply->inproc_device = get_process_id( process ) | 1;
-        send_client_fd( process, fd, reply->inproc_device );
-    }
 }
 
 /* initialize a new thread */
@@ -1967,7 +1910,7 @@ DECL_HANDLER(select)
         }
         ctx->status = STATUS_SUCCESS;
         current->suspend_cookie = req->cookie;
-        signal_sync( ctx->sync );
+        wake_up( &ctx->obj, 0 );
     }
 
     if (!req->cookie) goto invalid_param;
@@ -1991,7 +1934,7 @@ DECL_HANDLER(select)
             apc->result.create_thread.handle = handle;
             clear_error();  /* ignore errors from the above calls */
         }
-        signal_sync( apc->sync );
+        wake_up( &apc->obj, 0 );
         close_handle( current->process, req->prev_apc );
         release_object( apc );
     }
@@ -2014,7 +1957,7 @@ DECL_HANDLER(select)
         else
         {
             apc->executed = 1;
-            signal_sync( apc->sync );
+            wake_up( &apc->obj, 0 );
         }
         release_object( apc );
     }
@@ -2370,17 +2313,3 @@ DECL_HANDLER(get_next_thread)
     set_error( STATUS_NO_MORE_ENTRIES );
     release_object( process );
 }
-
-
-/* Get the in-process synchronization fd for the current thread user APC alerts */
-DECL_HANDLER(get_inproc_alert_fd)
-{
-    int fd;
-
-    if ((fd = get_inproc_sync_fd( current->alert_sync )) < 0) set_error( STATUS_INVALID_PARAMETER );
-    else
-    {
-        reply->handle = get_thread_id( current ) | 1; /* arbitrary token */
-        send_client_fd( current->process, fd, reply->handle );
-    }
-}
diff -ruN --show-c-function server/thread.h server/thread.h
--- server/thread.h	2025-10-10 10:17:48.600775782 -0700
+++ server/thread.h	2025-10-10 10:22:17.166820302 -0700
@@ -50,14 +50,14 @@ struct inflight_fd
 struct thread
 {
     struct object          obj;           /* object header */
-    struct object         *sync;          /* sync object for wait/signal */
-    struct inproc_sync    *alert_sync;    /* inproc sync for user apc alerts */
     struct list            entry;         /* entry in system-wide thread list */
     struct list            proc_entry;    /* entry in per-process thread list */
     struct list            desktop_entry; /* entry in per-desktop thread list */
     struct process        *process;
     thread_id_t            id;            /* thread id */
     struct list            mutex_list;    /* list of currently owned mutexes */
+    int                    esync_fd;      /* esync file descriptor (signalled on exit) */
+    int                    esync_apc_fd;  /* esync apc fd (signalled when APCs are present) */
     unsigned int           system_regs;   /* which system regs have been set */
     struct msg_queue      *queue;         /* message queue */
     struct thread_wait    *wait;          /* current wait condition if sleeping */
diff -ruN --show-c-function server/timer.c server/timer.c
--- server/timer.c	2025-10-10 10:17:47.804758763 -0700
+++ server/timer.c	2025-10-10 10:22:17.164848754 -0700
@@ -35,6 +35,7 @@
 #include "file.h"
 #include "handle.h"
 #include "request.h"
+#include "esync.h"
 
 static const WCHAR timer_name[] = {'T','i','m','e','r'};
 
@@ -53,7 +54,6 @@ struct type_descr timer_type =
 struct timer
 {
     struct object        obj;       /* object header */
-    struct object       *sync;      /* sync object for wait/signal */
     int                  manual;    /* manual reset */
     int                  signaled;  /* current signaled state */
     unsigned int         period;    /* timer period in ms */
@@ -62,10 +62,13 @@ struct timer
     struct thread       *thread;    /* thread that set the APC function */
     client_ptr_t         callback;  /* callback APC function */
     client_ptr_t         arg;       /* callback argument */
+    int                  esync_fd;  /* esync file descriptor */
 };
 
 static void timer_dump( struct object *obj, int verbose );
-static struct object *timer_get_sync( struct object *obj );
+static int timer_signaled( struct object *obj, struct wait_queue_entry *entry );
+static int timer_get_esync_fd( struct object *obj, enum esync_type *type );
+static void timer_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static void timer_destroy( struct object *obj );
 
 static const struct object_ops timer_ops =
@@ -73,13 +76,13 @@ static const struct object_ops timer_ops
     sizeof(struct timer),      /* size */
     &timer_type,               /* type */
     timer_dump,                /* dump */
-    NULL,                      /* add_queue */
-    NULL,                      /* remove_queue */
-    NULL,                      /* signaled */
-    NULL,                      /* satisfied */
+    add_queue,                 /* add_queue */
+    remove_queue,              /* remove_queue */
+    timer_signaled,            /* signaled */
+    timer_get_esync_fd,        /* get_esync_fd */
+    timer_satisfied,           /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
-    timer_get_sync,            /* get_sync */
     default_map_access,        /* map_access */
     default_get_sd,            /* get_sd */
     default_set_sd,            /* set_sd */
@@ -105,19 +108,16 @@ static struct timer *create_timer( struc
         if (get_error() != STATUS_OBJECT_NAME_EXISTS)
         {
             /* initialize it if it didn't already exist */
-            timer->sync     = NULL;
             timer->manual   = manual;
             timer->signaled = 0;
             timer->when     = 0;
             timer->period   = 0;
             timer->timeout  = NULL;
             timer->thread   = NULL;
+            timer->esync_fd = -1;
 
-            if (!(timer->sync = create_internal_sync( manual, 0 )))
-            {
-                release_object( timer );
-                return NULL;
-            }
+            if (do_esync())
+                timer->esync_fd = esync_create_fd( 0, 0 );
         }
     }
     return timer;
@@ -157,8 +157,9 @@ static void timer_callback( void *privat
     }
     else timer->timeout = NULL;
 
+    /* wake up waiters */
     timer->signaled = 1;
-    signal_sync( timer->sync );
+    wake_up( &timer->obj, 0 );
 }
 
 /* cancel a running timer */
@@ -189,7 +190,9 @@ static int set_timer( struct timer *time
     {
         period = 0;  /* period doesn't make any sense for a manual timer */
         timer->signaled = 0;
-        reset_sync( timer->sync );
+
+        if (do_esync())
+            esync_clear( timer->esync_fd );
     }
     timer->when     = (expire <= 0) ? expire - monotonic_time : max( expire, current_time );
     timer->period   = period;
@@ -210,11 +213,25 @@ static void timer_dump( struct object *o
              timer->manual, get_timeout_str(timeout), timer->period );
 }
 
-static struct object *timer_get_sync( struct object *obj )
+static int timer_signaled( struct object *obj, struct wait_queue_entry *entry )
+{
+    struct timer *timer = (struct timer *)obj;
+    assert( obj->ops == &timer_ops );
+    return timer->signaled;
+}
+
+static int timer_get_esync_fd( struct object *obj, enum esync_type *type )
+{
+    struct timer *timer = (struct timer *)obj;
+    *type = timer->manual ? ESYNC_MANUAL_SERVER : ESYNC_AUTO_SERVER;
+    return timer->esync_fd;
+}
+
+static void timer_satisfied( struct object *obj, struct wait_queue_entry *entry )
 {
     struct timer *timer = (struct timer *)obj;
     assert( obj->ops == &timer_ops );
-    return grab_object( timer->sync );
+    if (!timer->manual) timer->signaled = 0;
 }
 
 static void timer_destroy( struct object *obj )
@@ -224,7 +241,7 @@ static void timer_destroy( struct object
 
     if (timer->timeout) remove_timeout_user( timer->timeout );
     if (timer->thread) release_object( timer->thread );
-    if (timer->sync) release_object( timer->sync );
+    if (do_esync()) close( timer->esync_fd );
 }
 
 /* create a timer */
diff -ruN --show-c-function server/token.c server/token.c
--- server/token.c	2025-10-10 10:17:47.804758763 -0700
+++ server/token.c	2025-10-10 10:22:17.154837401 -0700
@@ -145,10 +145,10 @@ static const struct object_ops token_ops
     no_add_queue,              /* add_queue */
     NULL,                      /* remove_queue */
     NULL,                      /* signaled */
+    NULL,                      /* get_esync_fd */
     NULL,                      /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
-    default_get_sync,          /* get_sync */
     default_map_access,        /* map_access */
     default_get_sd,            /* get_sd */
     token_set_sd,              /* set_sd */
diff -ruN --show-c-function server/window.c server/window.c
--- server/window.c	2025-10-10 10:17:48.600775782 -0700
+++ server/window.c	2025-10-10 10:22:17.155062488 -0700
@@ -108,10 +108,10 @@ static const struct object_ops window_op
     no_add_queue,             /* add_queue */
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
+    NULL,                     /* get_esync_fd */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
-    default_get_sync,         /* get_sync */
     default_map_access,       /* map_access */
     default_get_sd,           /* get_sd */
     default_set_sd,           /* set_sd */
diff -ruN --show-c-function server/winstation.c server/winstation.c
--- server/winstation.c	2025-10-10 10:17:48.600775782 -0700
+++ server/winstation.c	2025-10-10 10:22:17.155372576 -0700
@@ -76,10 +76,10 @@ static const struct object_ops winstatio
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
-    default_get_sync,             /* get_sync */
     default_map_access,           /* map_access */
     default_get_sd,               /* get_sd */
     default_set_sd,               /* set_sd */
@@ -117,10 +117,10 @@ static const struct object_ops desktop_o
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
-    default_get_sync,             /* get_sync */
     default_map_access,           /* map_access */
     default_get_sd,               /* get_sd */
     default_set_sd,               /* set_sd */
